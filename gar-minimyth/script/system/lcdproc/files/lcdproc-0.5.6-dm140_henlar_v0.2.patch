diff -Naur lcdproc-0.5.6-old/acinclude.m4 lcdproc-0.5.6-new/acinclude.m4
--- lcdproc-0.5.6-old/acinclude.m4	2012-09-01 14:34:24.000000000 -0700
+++ lcdproc-0.5.6-new/acinclude.m4	2012-11-14 12:06:48.000000000 -0800
@@ -9,7 +9,7 @@
 	[                  which is a comma-separated list of drivers.]
 	[                  Possible drivers are:]
 	[                    bayrad,CFontz,CFontzPacket,curses,CwLnx,]
-	[                    ea65,EyeboxOne,g15,glcd,glcdlib,glk,hd44780,i2500vfd,]
+	[                    dm140,ea65,EyeboxOne,g15,glcd,glcdlib,glk,hd44780,i2500vfd,]
 	[                    icp_a106,imon,imonlcd,IOWarrior,irman,irtrans,]
 	[                    joy,lb216,lcdm001,lcterm,lirc,lis,MD8800,mdm166a,]
 	[                    ms6931,mtc_s16209x,MtxOrb,mx5000,NoritakeVFD,]
@@ -22,7 +22,7 @@
 	drivers="$enableval",
 	drivers=[bayrad,CFontz,CFontzPacket,curses,CwLnx,glk,lb216,lcdm001,MtxOrb,pyramid,text])
 
-allDrivers=[bayrad,CFontz,CFontzPacket,curses,CwLnx,ea65,EyeboxOne,g15,glcd,glcdlib,glk,hd44780,i2500vfd,icp_a106,imon,imonlcd,IOWarrior,irman,irtrans,joy,lb216,lcdm001,lcterm,lirc,lis,MD8800,mdm166a,ms6931,mtc_s16209x,MtxOrb,mx5000,NoritakeVFD,picolcd,pyramid,sdeclcd,sed1330,sed1520,serialPOS,serialVFD,shuttleVFD,sli,stv5730,SureElec,svga,t6963,text,tyan,ula200,vlsys_m428,xosd]
+allDrivers=[bayrad,CFontz,CFontzPacket,curses,CwLnx,dm140,ea65,EyeboxOne,g15,glcd,glcdlib,glk,hd44780,i2500vfd,icp_a106,imon,imonlcd,IOWarrior,irman,irtrans,joy,lb216,lcdm001,lcterm,lirc,lis,MD8800,mdm166a,ms6931,mtc_s16209x,MtxOrb,mx5000,NoritakeVFD,picolcd,pyramid,sdeclcd,sed1330,sed1520,serialPOS,serialVFD,shuttleVFD,sli,stv5730,SureElec,svga,t6963,text,tyan,ula200,vlsys_m428,xosd]
 if test "$debug" = yes; then
 	allDrivers=["${allDrivers},debug"]
 fi
@@ -127,6 +127,10 @@
 			DRIVERS="$DRIVERS debug${SO}"
 			actdrivers=["$actdrivers debug"]
 			;;
+		dm140)
+                        DRIVERS="$DRIVERS dm140${SO}"
+                        actdrivers=["$actdrivers dm140"]
+                        ;;
 		ea65)
 			DRIVERS="$DRIVERS ea65${SO}"
 			actdrivers=["$actdrivers ea65"]
diff -Naur lcdproc-0.5.6-old/LCDd.conf lcdproc-0.5.6-new/LCDd.conf
--- lcdproc-0.5.6-old/LCDd.conf	2012-08-19 07:29:07.000000000 -0700
+++ lcdproc-0.5.6-new/LCDd.conf	2012-11-14 12:06:25.000000000 -0800
@@ -290,6 +290,10 @@
 
 
 
+## DM140 VFD
+[dm140]
+
+
 ## ea65 driver for the display in AOpen XC Cube AV EA65 media barebones ##
 [ea65]
 
diff -Naur lcdproc-0.5.6-old/LCDd.conf.orig lcdproc-0.5.6-new/LCDd.conf.orig
--- lcdproc-0.5.6-old/LCDd.conf.orig	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.6-new/LCDd.conf.orig	2012-11-14 12:06:17.000000000 -0800
@@ -0,0 +1,1293 @@
+# LCDd.conf -- configuration file for the LCDproc server daemon LCDd
+#
+# This file contains the configuration for the LCDd server.
+#
+# The format is ini-file-like. It is divided into sections that start at
+# markers that look like [section]. Comments are all line-based comments,
+# and are lines that start with '#' or ';'.
+#
+# The server has a 'central' section named [server]. For the menu there is
+# a section called [menu]. Further each driver has a section which
+# defines how the driver acts.
+#
+# The drivers are activated by specifying them in a driver= line in the
+# server section, like:
+#
+#   Driver=curses
+#
+# This tells LCDd to use the curses driver.
+# The first driver that is loaded and is capable of output defines the
+# size of the display. The default driver to use is curses.
+# If the driver is specified using the -d <driver> command line option,
+# the Driver= options in the config file are ignored.
+#
+# The drivers read their own options from the respective sections.
+
+
+
+## Server section with all kinds of settings for the LCDd server ##
+[server]
+
+# Where can we find the driver modules ?
+# IMPORTANT: Make sure to change this setting to reflect your
+#            specific setup! Otherwise LCDd won't be able to find
+#            the driver modules and will thus not be able to
+#            function properly.
+# NOTE: Always place a slash as last character !
+DriverPath=server/drivers/
+
+# Tells the server to load the given drivers. Multiple lines can be given.
+# The name of the driver is case sensitive and determines the section
+# where to look for further configuration options of the specific driver
+# as well as the name of the dynamic driver module to load at runtime.
+# The latter one can be changed by giving a File= directive in the
+# driver specific section.
+#
+# The following drivers are supported:
+#   bayrad, CFontz, CFontzPacket, curses, CwLnx, ea65,
+#   EyeboxOne, g15, glcd, glcdlib, glk, hd44780, icp_a106, imon, imonlcd,
+#   IOWarrior, irman, joy, lb216, lcdm001, lcterm, lirc, lis, MD8800,
+#   mdm166a, ms6931, mtc_s16209x, MtxOrb, mx5000, NoritakeVFD, picolcd,
+#   pyramid, sdeclcd, sed1330, sed1520, serialPOS, serialVFD, shuttleVFD, sli,
+#   stv5730, svga, t6963, text, tyan, ula200, vlsys_m428, xosd
+Driver=curses
+
+# Tells the driver to bind to the given interface
+Bind=127.0.0.1
+
+# Listen on this specified port; defaults to 13666.
+Port=13666
+
+# Sets the reporting level; defaults to 2 (warnings and errors only).
+#ReportLevel=3
+
+# Should we report to syslog instead of stderr ? [default: no; legal: yes, no]
+#ReportToSyslog=yes
+
+# User to run as.  LCDd will drop its root privileges, if any,
+# and run as this user instead.
+User=nobody
+
+# The server will stay in the foreground if set to true.
+#Foreground=no
+
+# Hello message: each entry represents a display line; default: builtin
+#Hello="  Welcome to"
+#Hello="   LCDproc!"
+
+# GoodBye message: each entry represents a display line; default: builtin
+#GoodBye="Thanks for using"
+#GoodBye="   LCDproc!"
+
+# Sets the default time in seconds to displays a screen.
+WaitTime=5
+
+# If set to no, LCDd will start with screen rotation disabled. This has the
+# same effect as if the ToggleRotateKey had been pressed. Rotation will start
+# if the ToggleRotateKey is pressed. Note that this setting does not turn off
+# priority sorting of screens. [default: on; legal: on, off]
+#AutoRotate=no
+
+# If yes, the the serverscreen will be rotated as a usual info screen. If no,
+# it will be a background screen, only visible when no other screens are
+# active. The special value 'blank' is similar to no, but only a blank screen
+# is displayed. [default: on; legal: on, off, blank]
+#ServerScreen=no
+
+# Set master backlight setting. If set to 'open' a client may control the
+# backlight for its own screens (only). [default: open; legal: off, open, on]
+#Backlight=open
+
+# Set master heartbeat setting. If set to 'open' a client may control the
+# heartbeat for its own screens (only). [default: open; legal: off, open, on]
+#Heartbeat=open
+
+# set title scrolling speed [default: 10; legal: 0-10]
+#TitleSpeed=10
+
+# The "...Key=" lines define what the server does with keypresses that
+# don't go to any client. The ToggleRotateKey stops rotation of screens, while
+# the PrevScreenKey and NextScreenKey go back / forward one screen (even if
+# rotation is disabled.
+# Assign the key string returned by the driver to the ...Key setting. These
+# are the defaults:
+ToggleRotateKey=Enter
+PrevScreenKey=Left
+NextScreenKey=Right
+#ScrollUpKey=Up
+#ScrollDownKey=Down
+
+
+## The menu section. The menu is an internal LCDproc client. ##
+[menu]
+# You can configure what keys the menu should use. Note that the MenuKey
+# will be reserved exclusively, the others work in shared mode.
+
+# Up to six keys are supported. The MenuKey (to enter and exit the menu), the
+# EnterKey (to select values) and at least one movement keys are required.
+# These are the default key assignments:
+MenuKey=Escape
+EnterKey=Enter
+UpKey=Up
+DownKey=Down
+#LeftKey=Left
+#RightKey=Right
+
+
+### Driver sections are below this line, in alphabetical order  ###
+
+
+## EMAC BayRAD driver ##
+[bayrad]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# Set the communication speed [default: 9600; legal:  1200, 2400, 9600, 19200]
+Speed=9600
+
+
+
+## CrystalFontz driver (for CF632 & CF634) ##
+[CFontz]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/ttyS0
+# Select the LCD size [default: 20x4]
+Size=20x4
+# Set the initial contrast [default: 560; legal: 0 - 1000]
+Contrast=350
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=0
+# Set the communication speed [default: 9600; legal: 1200, 2400, 9600, 19200,
+# 115200]
+Speed=9600
+# Set the firmware version (New means >= 2.0) [default: no; legal: yes, no]
+NewFirmware=no
+# Reinitialize the LCD's BIOS [default: no; legal: yes, no]
+# normally you shouldn't need this
+Reboot=no
+
+
+
+## CrystalFontz packet driver (for CFA533, CFA631, CFA633 & CFA635) ##
+[CFontzPacket]
+
+# Select the LCD model [default: 633; legal: 533, 631, 633, 635]
+Model=633
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/ttyUSB0
+
+# Set the initial contrast [default: 560; legal: 0 - 1000]
+Contrast=350
+
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+Brightness=1000
+
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=50
+
+# Reinitialize the LCD's BIOS on driver start. [default: no; legal: yes, no]
+Reboot=yes
+
+# Enable the USB flag if the device is connected to an USB port. For
+# serial ports leave it disabled. [default: no; legal: yes, no]
+#USB=yes
+
+# Very old 633 firmware versions do not support partial screen updates using
+# 'Send Data to LCD' command (31). For those devices it may be necessary to
+# enable this flag. [default: no; legal: yes, no]
+#OldFirmware=yes
+
+# Override the LCD size known for the selected model. Usually setting this
+# value should not be necessary.
+#Size=20x4
+
+# Override the default communication speed known for the selected model.
+# Default value depends on model [legal: 19200, 115200]
+#Speed=115200
+
+
+
+## Curses driver ##
+[curses]
+
+# color settings
+# foreground color [default: blue]
+Foreground=blue
+# background color when "backlight" is off [default: cyan]
+Background=cyan
+# background color when "backlight" is on [default: red]
+Backlight=red
+
+# display size [default: 20x4]
+Size=20x4
+
+# What position (X,Y) to start the left top corner at...
+# Default: (7,7)
+TopLeftX=7
+TopLeftY=7
+
+# use ASC symbols for icons & bars [default: no; legal: yes, no]
+UseACS=no
+
+# draw Border [default: yes; legal: yes, no]
+DrawBorder=yes
+
+
+
+## Cwlinux driver ##
+[CwLnx]
+
+# Select the LCD model [default: 12232; legal: 12232, 12832, 1602]
+Model=12232
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/ttyUSB0
+
+# Select the LCD size. Default depends on model:
+# 12232: 20x4
+# 12832: 21x4
+# 1602: 16x2
+Size=20x4
+
+# Set the communication speed [default: 19200; legal: 9600, 19200]
+Speed=19200
+
+# Reinitialize the LCD's BIOS [default: no; legal: yes, no]
+# normally you shouldn't need this
+Reboot=no
+
+# If you have a keypad connected. Keypad layout is currently not
+# configureable from the config file.
+Keypad=yes
+
+# If you have a non-standard keypad you can associate any keystrings to keys.
+# There are 6 input keys in the CwLnx hardware that generate characters
+# from 'A' to 'F'.
+#
+# The following is the built-in default mapping hardcoded in the driver.
+# You can leave those unchanged if you have a standard keypad.
+# You can change it if you want to report other keystrings or have a non
+# standard keypad.
+# KeyMap_A=Up
+# KeyMap_B=Down
+# KeyMap_C=Left
+# KeyMap_D=Right
+# KeyMap_E=Enter
+# KeyMap_F=Escape
+
+# keypad_test_mode permits one to test keypad assignment
+# Default value is no
+#keypad_test_mode=yes
+
+
+
+## ea65 driver for the display in AOpen XC Cube AV EA65 media barebones ##
+[ea65]
+
+# Device is fixed /dev/ttyS1
+# Width and Height are fixed 9x1
+
+# As the VFD is self luminescent we don't have a backlight
+# But we can use the backlight functions to control the front LEDs
+# Brightness 0 to 299 -> LEDs off
+# Brightness 300 to 699 -> LEDs half bright
+# Brightness 700 to 1000 -> LEDs full bright
+Brightness=500
+# OffBrightness is the the value used for the 'backlight off' state
+OffBrightness=0
+
+
+
+## EyeboxOne driver ##
+[EyeboxOne]
+
+# Select the output device to use [default: /dev/ttyS1]
+#Device=/dev/cua01
+Device=/dev/ttyS1
+
+# Set the display size [default: 20x4]
+Size=20x4
+
+# Switch on the backlight? [default: yes]
+Backlight=yes
+
+# Switch on the cursor? [default: no]
+Cursor=no
+
+# Set the communication speed [default: 19200; legal: 1200, 2400, 9600, 19200]
+Speed=19200
+
+# Enter Key is a \r character, so it's hardcoded in the driver
+LeftKey=D
+RightKey=C
+UpKey=A
+DownKey=B
+EscapeKey=P
+
+# You can find out which key of your display sends which
+# character by setting keypad_test_mode to yes and running
+# LCDd. LCDd will output all characters it receives.
+# Afterwards you can modify the settings above and set
+# keypad_set_mode to no again.
+keypad_test_mode=no
+
+
+
+## g15 driver for Logitech G15 Keyboard LCDs ##
+[g15]
+
+# Display size (currently unused)
+size=20x5
+
+
+
+## glcd generic graphical display driver
+[glcd]
+# Select what type of connection. See documentation for types.
+ConnectionType=t6963
+
+# Width and height of the display in pixel. The supported sizes may depend on
+# the ConnectionType. [default: 128x64; legal: 1x1 - 640x480]
+#Size=128x64
+
+# Width and height of a character cell in pixels. This value is only used if
+# the driver has been compiled with FreeType and it is enabled. Otherwise the
+# default 6x8 cell is used.
+#CellSize=12x16
+
+# If LCDproc has been compiled with FreeType 2 support this option can be used
+# to turn if off intentionally. [default: yes; legal: yes, no]
+#useFT2=no
+
+# Path to font file to use for FreeType rendering. This font must be monospace
+# and should contain some special Unicode characters like arrows (Andale Mono
+# is recommended and can be fetched at http://corefonts.sf.net).
+#normal_font=/usr/local/lib/X11/fonts/TTF/andalemo.ttf
+
+# Some fonts miss the Unicode characters used to represent icons. In this case
+# the built-in 5x8 font can used if this option is turned off. [default: yes;
+# legal: yes, no]
+#fontHasIcons=no
+
+# Set the initial contrast if supported by connection type.
+# [default: 600; legal: 0 - 1000]
+#Contrast=600
+
+# Set brightness of the backlight if the backlight is switched 'on'.
+# [default: 800; legal: 0 - 1000]
+#Brightness=1000
+
+# Set brightness of the backlight if the backlight is switched 'off'. Set this
+# to zero to completely turn off the backlight. [default: 100; legal: 0 - 1000]
+#OffBrightness=0
+
+# Time (ms) from first key report to first repeat. Set to 0 to disable repeated
+# key reports. [default: 500; legal: 0 - 3000]
+#KeyRepeatDelay=500
+
+# Time (ms) between repeated key reports. Ignored if KeyRepeatDelay is disabled
+# (set to zero). [default: 300; legal: 0 - 3000]
+#KeyRepeatInterval=300
+
+# Assign key strings to keys. There may be up to 16 keys numbered 'A' to 'Z'.
+# By default keys 'A' to 'F' are assigned Up, Down, Left, Right, Enter, Escape.
+KeyMap_A=Up
+KeyMap_B=Down
+KeyMap_C=Enter
+KeyMap_D=Escape
+
+# t6963: Parallel port to use [default: 0x378; legal: 0x200 - 0x400]
+#Port=0x378
+
+# t6963: Use LPT port in bi-directional mode. This should work on most LPT port
+# and is required for proper timing! [default: yes; legal: yes, no]
+#bidirectional=yes
+
+# t6963: Insert additional delays into reads / writes. [default: no;
+# legal: yes, no]
+#delayBus=no
+
+# serdisplib: Name of the underlying serdisplib driver, e.g. ctinclud. See
+# serdisplib documentation for details.
+serdisp_name=t6963
+
+# serdisplib: The display device to use, e.g. serraw:/dev/ttyS0,
+# parport:/dev/parport0 or USB:07c0/1501.
+serdisp_device=/dev/ppi0
+
+# serdisplib: Options string to pass to serdisplib during initialization. Use
+# this to set any display related options (e.g. wiring). The display size is
+# always set based on the Size configured above! By default, no options are
+# set.
+# Important: The value must be quoted as it contains equal signs!
+#serdisp_options="INVERT=1"
+
+
+
+## glcdlib meta driver for graphical LCDs ##
+[glcdlib]
+
+## mandatory:
+
+# which graphical display supported by graphlcd-base to use [default: image]
+# (see /etc/graphlcd.conf for possible drivers)
+Driver=noritake800
+
+# no=use graphlcd bitmap fonts (they have only one size / font file)
+# yes=use fonts supported by FreeType2 (needs Freetype2 support in
+# libglcdprocdriver and its dependants)
+UseFT2=yes
+
+# text resolution in fixed width characters [default: 16x4]
+# (if it won't fit according to available physical pixel resolution
+# and the minimum available font face size in pixels, then
+# 'DebugBorder' will automatically be turned on)
+TextResolution=20x4
+
+# path to font file to use
+FontFile=/usr/share/fonts/corefonts/courbd.ttf
+
+## these only apply if UseFT2=yes:
+
+# character encoding to use
+CharEncoding=iso8859-2
+
+# minimum size in pixels in which fonts should be rendered
+MinFontFaceSize=7x12
+
+## optional:
+Brightness=50                   # Brightness (in %) if applicable
+Contrast=50                     # Contrast (in %) if applicable
+Backlight=no                    # Backlight if applicable
+UpsideDown=no                   # flip image upside down
+Invert=no                       # invert light/dark pixels
+ShowDebugFrame=no               # turns on/off 1 pixel thick debugging
+                                # border within the usable text area,
+                                # for setting up TextResolution and
+                                # MinFontFaceSize (if using FT2);
+ShowBigBorder=no                # border around the unused area
+ShowThinBorder=yes              # border around the unused area
+PixelShiftX=0
+PixelShiftY=2
+
+
+
+## Matrix Orbital GLK driver ##
+[glk]
+
+# select the serial device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# set the initial contrast value [default: 560; legal: 0 - 1000]
+Contrast=560
+
+# set the serial port speed [default: 19200; legal: 9600, 19200, 38400]
+Speed=19200
+
+
+
+## Hitachi HD44780 driver ##
+[hd44780]
+
+# Select what type of connection. See documentation for types.
+ConnectionType=4bit
+
+# Port where the LPT is. Usual value are: 0x278, 0x378 and 0x3BC
+Port=0x378
+
+# Device of the serial interface [default: /dev/lcd]
+Device=/dev/ttyS0
+
+# Bitrate of the serial port (0 for interface default)
+Speed=0
+
+# If you have a keypad connected.
+# You may also need to configure the keypad layout further on in this file.
+Keypad=no
+
+# Set the initial contrast (bwctusb, lcd2usb, and usb4all)
+# [default: 800; legal: 0 - 1000]
+#Contrast=0
+
+# Set brightness of the backlight (lcd2usb and usb4all):
+# Brightness is the brightness while the backlight is set to 'on'.
+# [default: 800; legal: 0 - 1000]
+#Brightness=1000
+
+# OffBrightness is the brightness while the backlight is set to 'off'.
+# [default: 300; legal: 0 - 1000]
+#OffBrightness=0
+
+# If you have a switchable backlight.
+Backlight=no
+
+# If you have the additional output port ("bargraph") and you want to
+# be able to control it with the lcdproc OUTPUT command
+OutputPort=no
+
+# Specifies if the last line is pixel addressable (yes) or it controls an
+# underline effect (no). [default: yes; legal: yes, no]
+#Lastline=yes
+
+# Specifies the size of the LCD.
+# In case of multiple combined displays, this should be the total size.
+Size=20x4
+
+# For multiple combined displays: how many lines does each display have.
+# Vspan=2,2 means both displays have 2 lines.
+#vspan=2,2
+
+# If you have an HD66712, a KS0073 or another 'almost HD44780-compatible',
+# set this flag to get into extended mode (4-line linear).
+#ExtendedMode=yes
+
+# In extended mode, on some controllers like the ST7036 (in 3 line mode)
+# the next line in DDRAM won't start 0x20 higher. [default: 0x20]
+#LineAddress=0x10
+
+# Character map to to map ISO-8859-1 to the LCD's character set
+# [default: hd44780_default; legal: hd44780_default, hd44780_euro, ea_ks0073,
+# sed1278f_0b, hd44780_koi8_r, hd44780_cp1251, hd44780_8859_5, upd16314 ]
+# (hd44780_koi8_r, hd44780_cp1251, hd44780_8859_5 and upd16314 are possible if
+# compiled with additional charmaps)
+CharMap=hd44780_default
+
+# If your display is slow and cannot keep up with the flow of data from
+# LCDd, garbage can appear on the LCDd. Set this delay factor to 2 or 4
+# to increase the delays. Default: 1.
+#DelayMult=2
+
+# Some displays (e.g. vdr-wakeup) need a message from the driver to that it
+# is still alive. When set to a value bigger then null the character in the
+# upper left corner is updated every <KeepAliveDisplay> seconds. Default: 0.
+#KeepAliveDisplay=0
+
+# If you experience occasional garbage on your display you can use this
+# option as workaround. If set to a value bigger than null it forces a
+# full screen refresh <RefreshDiplay> seconds. Default: 0.
+#RefreshDisplay=5
+
+# You can reduce the inserted delays by setting this to false.
+# On fast PCs it is possible your LCD does not respond correctly.
+# Default: true.
+DelayBus=true
+
+# If you have a keypad you can assign keystrings to the keys.
+# See documentation for used terms and how to wire it.
+# For example to give directly connected key 4 the string "Enter", use:
+#   KeyDirect_4=Enter
+# For matrix keys use the X and Y coordinates of the key:
+#   KeyMatrix_1_3=Enter
+KeyMatrix_4_1=Enter
+KeyMatrix_4_2=Up
+KeyMatrix_4_3=Down
+KeyMatrix_4_4=Escape
+
+
+
+## ICP A106 driver ##
+[icp_a106]
+Device=/dev/ttyS1
+
+
+
+## Code Mercenaries IO-Warrior driver ##
+[IOWarrior]
+
+# display dimensions
+Size=20x4
+
+# serial number. Must be exactly as listed by usbview
+# (if not given, the 1st IOWarrior found gets used)
+#SerialNumber=00000674
+
+# If you have an HD66712, a KS0073 or another 'almost HD44780-compatible',
+# set this flag to get into extended mode (4-line linear).
+#ExtendedMode=yes
+
+# Specifies if the last line is pixel addressable (yes) or it controls an
+# underline effect (no). [default: yes; legal: yes, no]
+#Lastline=yes
+
+
+
+## Soundgraph/Ahanix/Silverstone/Uneed/Accent iMON driver ##
+[imon]
+
+# select the device to use
+Device=/dev/lcd0
+
+# display dimensions
+Size=16x2
+
+# Character map to to map ISO-8859-1 to the displays character set.
+# [default: none; legal: none, hd44780_euro, upd16314, hd44780_koi8_r,
+# hd44780_cp1251, hd44780_8859_5 ] (upd16314, hd44780_koi8_r,
+# hd44780_cp1251, hd44780_8859_5 are possible if compiled with additional
+# charmaps)
+CharMap=hd44780_euro
+
+## Soundgraph iMON LCD ##
+[imonlcd]
+# Specify which iMon protocol should be used
+# [legal: 0, 1; default: 0]
+# Choose 0 for 15c2:ffdc device,
+# Choose 1 for 15c2:0038 device
+Protocol=0
+
+# Set the exit behavior [legal: 0-2; default: 1]
+# 0 means leave shutdown message,
+# 1 means show the big clock,
+# 2 means blank device
+#OnExit=2
+
+# Select the output device to use [default: /dev/lcd0]
+Device=/dev/lcd0
+
+# Select the displays contrast [default: 200; legal: 0-1000]
+Contrast=200
+
+# Specify the size of the display in pixels [default: 96x16]
+#Size=96x16
+
+# Set the backlight state [default: on; legal: on, off]
+#Backlight=on
+
+# Set the disc mode [legal: 0,1; default: 0]
+# 0 => spin the "slim" disc - two disc segments,
+# 1 => their complement spinning;
+#DiscMode=0
+
+
+
+## IrMan driver ##
+[IrMan]
+# in case of trouble with IrMan, try the Lirc emulator for IrMan
+
+# Select the input device to use
+#Device=/dev/irman
+
+# Select the configuration file to use
+#Config=/etc/irman.cfg
+
+
+
+## IRtrans driver ##
+[irtrans]
+
+# Does the device have a backlight? [default: no; legal: yes, no]
+#Backlight=no
+
+# IRTrans device to connect to [default: localhost]
+#Hostname=localhost
+
+# display dimensions
+Size=16x2
+
+
+
+## Joystick driver ##
+[joy]
+
+# Select the input device to use [default: /dev/js0]
+Device=/dev/js0
+
+# set the axis map
+Map_Axis1neg=Left
+Map_Axis1pos=Right
+Map_Axis2neg=Up
+Map_Axis2pos=Down
+
+# set the button map
+Map_Button1=Enter
+Map_Button2=Escape
+
+
+
+## LB216 driver ##
+[lb216]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# Set the initial brightness [default: 255; legal: 0 - 255]
+Brightness=255
+
+# Set the communication speed [default: 9600; legal: 2400, 9600]
+Speed=9600
+
+# Reinitialize the LCD's BIOS [default: no; legal: yes, no]
+Reboot=no
+
+
+
+## LCDM001 driver ##
+[lcdm001]
+
+Device=/dev/ttyS1
+
+# keypad settings
+# Keyname      Function
+#              Normal context              Menu context
+# -------      --------------              ------------
+# PauseKey     Pause/Continue              Enter/select
+# BackKey      Back(Go to previous screen) Up/Left
+# ForwardKey   Forward(Go to next screen)  Down/Right
+# MainMenuKey  Open main menu              Exit/Cancel
+PauseKey=LeftKey
+BackKey=UpKey
+ForwardKey=DownKey
+MainMenuKey=RightKey
+
+# You can rearrange the settings here.
+# If your device is broken, have a look at server/drivers/lcdm001.h
+
+
+
+## HNE LCTerm driver ##
+[lcterm]
+Device=/dev/ttyS1
+Size=16x2
+
+
+
+## LIRC input driver ##
+[lirc]
+
+# Specify an alternative location of the lircrc file [default: ~/.lircrc]
+#lircrc=/etc/lircrc.lcdproc
+
+# Must be the same as in your lircrc
+#prog=lcdd
+
+
+
+## LIS MCE 2005 driver ##
+[lis]
+
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+# 0-250 = 25%, 251-500 = 50%, 501-750 = 75%, 751-1000 = 100%
+#Brightness=1000
+
+# Columns by lines [default: 20x2]
+#Size=20x2
+
+# USB Vendor ID [default: 0x0403]
+# Change only if testing a compatible device.
+#VendorID=0x0403
+
+# USB Product ID [default: 0x6001]
+# Change only if testing a compatible device.
+#ProductID=0x6001
+
+# Specifies if the last line is pixel addressable (yes) or it only controls an
+# underline effect (no). [default: yes; legal: yes, no]
+#Lastline=yes
+
+
+
+##The driver for the VFD of the Medion MD8800 PC ##
+[MD8800]
+# device to use [default: /dev/ttyS1]
+#Device=/dev/ttyS1
+
+# display size [default: 16x2]
+#Size=16x2
+
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=50
+
+
+
+## Futuba MDM166A Display
+[mdm166a]
+# Show self-running clock after LCDd shutdown
+# Possible values: [default: no; legal: no, small, big]
+Clock=big
+# Dim display, no dimming gives full brightness [default: no, legal: yes, no]
+Dimming=no
+# Dim display in case LCDd is inactive [default: no, legal: yes, no]
+OffDimming=yes
+
+
+
+## MSI MS-6931 driver for displays in 1HU servers ##
+[ms6931]
+
+# device to use [default: /dev/ttyS1]
+Device=/dev/ttyS1
+
+# display size [default: 16x2]
+#Size=16x2
+
+
+
+## MTC-S16209x driver ##
+[mtc_s16209x]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# Set the initial brightness [default: 255; legal: 0 - 255]
+Brightness=255
+
+# Reinitialize the LCD's BIOS [default: no; legal: yes, no]
+Reboot=no
+
+
+
+## Matrix Orbital driver ##
+[MtxOrb]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/ttyS0
+
+# Set the display size [default: 20x4]
+Size=20x4
+
+# Set the display type [default: lcd; legal: lcd, lkd, vfd, vkd]
+Type=lkd
+
+# Set the initial contrast [default: 480]
+# NOTE: The driver will ignore this if the display
+#       is a vfd or vkd as they don't have this feature
+Contrast=480
+
+# Some old displays do not have an adjustable backlight but only can
+# switch the backlight on/off. If you experience randomly appearing block
+# characters, try setting this to false. [default: yes; legal: yes, no]
+hasAdjustableBacklight=no
+
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=0
+
+# Set the communication speed [default: 19200; legal: 1200, 2400, 9600, 19200]
+Speed=19200
+
+# The following table translates from MtxOrb key letters to logical key names.
+# By default no keys are mapped, meaning the keypad is not used at all.
+#KeyMap_A=Left
+#KeyMap_B=Right
+#KeyMap_C=Up
+#KeyMap_D=Down
+#KeyMap_E=Enter
+#KeyMap_F=Escape
+# See the [menu] section for an explanation of the key mappings
+
+# You can find out which key of your display sends which
+# character by setting keypad_test_mode to yes and running
+# LCDd. LCDd will output all characters it receives.
+# Afterwards you can modify the settings above and set
+# keypad_set_mode to no again.
+keypad_test_mode=no
+
+
+
+## mx5000 driver for LCD display on the Logitech MX5000 keyboard ##
+[mx5000]
+
+# Select the output device to use [default: /dev/hiddev0]
+Device = /dev/hiddev0
+# Time to wait in ms after the refresh screen has been sent [default: 1000]
+WaitAfterRefresh = 1000
+
+
+
+## Noritake VFD driver ##
+[NoritakeVFD]
+# device where the VFD is. Usual values are /dev/ttyS0 and /dev/ttyS1
+# [default: /dev/lcd]
+Device=/dev/ttyS0
+# Specifies the size of the LCD.
+Size=20x4
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=50
+# set the serial port speed [default: 9600, legal: 1200, 2400, 9600, 19200, 115200]
+Speed=9600
+# Set serial data parity [default: 0; legal: 0-2 ]
+# Meaning: 0(=none), 1(=odd), 2(=even)
+Parity=0
+# re-initialize the VFD [default: no; legal: yes, no]
+Reboot=no
+
+
+
+## Mini-box.com picoLCD (usblcd) driver ##
+[picolcd]
+
+# KeyTimeout is only used if the picoLCD driver is built with libusb-0.1. When
+# built with libusb-1.0 key and IR data is input asynchronously so there is no
+# need to wait for the USB data.
+# KeyTimeout is the time in ms that LCDd spends waiting for a key press before
+# cycling through other duties.  Higher values make LCDd use less CPU time and
+# make key presses more detectable.  Lower values make LCDd more responsive
+# but a little prone to missing key presses.  500 (.5 second) is the default
+# and a balanced value. [default: 500; legal: 0 - 1000]
+KeyTimeout=500
+
+# Key auto repeat is only available if the picoLCD driver is built with
+# libusb-1.0. Use KeyRepeatDelay and KeyRepeatInterval to configure key auto
+# repeat.
+#
+# Key auto repeat delay (time in ms from first key report to first repeat). Use
+# zero to disable auto repeat. [default: 300; legal: 0 - 3000]
+KeyRepeatDelay=300
+
+# Key auto repeat interval (time in ms between repeat reports). Only used if
+# KeyRepeatDelay is not zero. [default: 200; legal: 0 - 3000]
+KeyRepeatInterval=200
+
+# Sets the initial state of the backlight upon start-up.
+# [default: on; legal: on, off]
+#Backlight=on
+
+# Set the initial brightness [default: 1000; legal: 0 - 1000]. Works only
+# with the 20x4 device
+Brightness=1000
+
+# Set the brightness while the backlight is 'off' [default: 0; legal: 0 - 1000].
+# Works only with the 20x4 device.
+#OffBrightness=0
+
+# Set the initial contrast [default: 1000; legal: 0 - 1000]
+Contrast=1000
+
+# Link the key lights to the backlight? [default: on; legal: on, off]
+#LinkLights=off
+
+# Light the keys? [default: on; legal: on, off]
+Keylights=on
+
+# If Keylights is on, the you can unlight specific keys below:
+# Key0 is the directional pad.  Key1 - Key5 correspond to the F1 - F5 keys.
+# There is no LED for the +/- keys.  This is a handy way to indicate to users
+# which keys are disabled.  [default: on; legal: on, off]
+Key0Light=on
+Key1Light=on
+Key2Light=on
+Key3Light=on
+Key4Light=on
+Key5Light=on
+
+# Host name or IP address of the LIRC instance that is to receive IR codes
+# If not set, or set to an empty value, IR support is disabled.
+#LircHost=127.0.0.1
+
+# UDP port on which LIRC is listening [default: 8765; legal: 1 - 65535]
+LircPort=8765
+
+# Threshold in jiffies of synthesized gap that triggers flushing the IR data
+# to lirc [default: 100 ; max: 32767 ]
+# 100 means 6.1ms. legal: 16 - 32767; Use 0 to disable.
+LircFlushThreshold=100
+
+
+
+## Pyramid LCD driver ##
+[pyramid]
+
+# device to connect to [default: /dev/lcd]
+Device=/dev/ttyUSB0
+
+
+
+## SDEC driver for Watchguard Firebox ##
+[sdeclcd]
+# No options
+
+
+
+## Seiko Epson 1330 driver ##
+[sed1330]
+
+# Port where the LPT is. Common values are 0x278, 0x378 and 0x3BC
+Port=0x378
+
+# Type of LCD module (legal: G321D, G121C, G242C, G191D, G2446, SP14Q002)
+# Note: Currently only tested with G321D & SP14Q002.
+Type=G321D
+
+# Width x Height of a character cell in pixels [legal: 6x7 - 8x16; default: 6x10]
+CellSize=6x10
+
+# Select what type of connection [legal: classic, bitshaker; default: classic]
+ConnectionType=classic
+
+
+
+## Seiko Epson 1520 driver ##
+[sed1520]
+
+# Port where the LPT is. Usual values are 0x278, 0x378 and 0x3BC
+Port=0x378
+
+# Select the interface type (wiring) for the display. Supported values are
+# 68 for 68-style connection (RESET level high) and 80 for 80-style connection
+# (RESET level low). [legal: 68, 80; default: 80]
+InterfaceType=80
+
+# On fast machines it may be necessary to slow down transfer to the display.
+# If this value is set to zero, delay is disabled. Any value greater than
+# zero slows down each write by one microsecond. [legal: 0-1000; default: 1]
+DelayMult=0
+
+# The original wiring used an inverter to drive the control lines. If you do
+# not use an inverter set haveInverter to no. [default: yes; legal: yes, no]
+haveInverter=no
+
+
+
+## serial POS display driver ##
+[serialPOS]
+
+# Device to use in serial mode [default: /dev/lcd]
+Device=/dev/lcd
+
+# Specifies the size of the display in characters. [default: 16x2]
+Size=16x2
+
+# Set the communication protocol to use with the POS display.
+# [default: AEDEX; legal: IEE, Epson, Emax, IBM, LogicControls, Ultimate]
+Type=AEDEX
+
+# communication baud rate with the display [default: 9600; legal: 1200, 2400,
+# 19200, 115200]
+Speed=9600
+
+
+
+## Serial VFD driver ##
+## Drives various (see below) serial 5x7dot VFD's.  ##
+[serialVFD]
+
+# Specifies the displaytype.[default: 0]
+# 0 NEC (FIPC8367 based) VFDs.
+# 1 KD Rev 2.1.
+# 2 Noritake VFDs (*).
+# 3 Futaba VFDs
+# 4 IEE S03601-95B
+# 5 IEE S03601-96-080 (*)
+# 6 Futaba NA202SD08FA (allmost IEE compatible)
+# 7 Samsung 20S207DA4 and 20S207DA6
+# 8 Nixdorf BA6x / VT100
+# (* most should work, not tested yet.)
+Type=0
+
+# "no" if display connected serial, "yes" if connected parallel. [default: no]
+# I.e. serial by default
+use_parallel=no
+
+# Number of Custom-Characters. default is display type dependent
+#Custom-Characters=0
+
+# Portaddress where the LPT is. Used in parallel mode only. Usual values are
+# 0x278, 0x378 and 0x3BC.
+Port=0x378
+
+# Set parallel port timing delay (us). Used in parallel mode only.
+# [default: 2; legal: 0 - 255]
+#PortWait=2
+
+# Device to use in serial mode. Usual values are /dev/ttyS0 and /dev/ttyS1
+Device=/dev/ttyS1
+
+# Specifies the size of the VFD.
+Size=20x2
+
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+# (4 steps 0-250, 251-500, 501-750, 751-1000)
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+# (4 steps 0-250, 251-500, 501-750, 751-1000)
+OffBrightness=0
+
+# set the serial port speed [default: 9600; legal: 1200, 2400, 9600, 19200, 115200]
+Speed=9600
+
+# enable ISO 8859 1 compatibility [default: yes; legal: yes, no]
+#ISO_8859_1=yes
+
+
+
+## shuttleVFD driver ##
+[shuttleVFD]
+# No options
+
+
+
+## stv5730 driver ##
+[stv5730]
+
+# Port the device is connected to [default: 0x378]
+Port=0x378
+
+
+[SureElec]
+
+# Port the device is connected to  (by default first USB serial port)
+Device=/dev/ttyUSB0
+
+# Edition level of the device (can be 1, 2 or 3) [default: 2]
+#Edition=1
+
+# set display size
+# Note: The size can be obtained directly from device for edition 2 & 3.
+#Size=16x2
+
+# Set the initial contrast [default: 480; legal: 0 - 1000]
+#Contrast=200
+
+# Set the initial brightness [default: 480; legal: 1 - 1000]
+#Brightness=480
+
+# Set the initial off-brightness [default: 100; legal: 1 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+#OffBrightness=100
+
+
+## SVGAlib driver ##
+[svga]
+
+# svgalib mode to use [default: G320x240x256 ]
+# legal values are supported svgalib modes
+#Mode=G640x480x256
+
+# set display size [default: 20x4]
+Size=20x4
+
+# Set the initial contrast [default: 500; legal: 0 - 1000]
+# Can be set but does not change anything internally
+Contrast=500
+
+# Set the initial brightness [default: 1000; legal: 1 - 1000]
+Brightness=1000
+
+# Set the initial off-brightness [default: 500; legal: 1 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=500
+
+
+
+## Text driver ##
+[text]
+# Set the display size [default: 20x4]
+Size=20x4
+
+
+
+## Toshiba T6963 driver ##
+[t6963]
+
+# set display size in pixels [default: 128x64]
+Size=128x64
+
+# port to use [default: 0x378; legal: 0x200 - 0x400]
+Port=0x378
+
+# Use LPT port in bi-directional mode. This should work on most LPT port and
+# is required for proper timing! [default: yes; legal: yes, no]
+#bidirectional=yes
+
+# Insert additional delays into reads / writes. [default: no; legal: yes, no]
+#delayBus=no
+
+# Clear graphic memory on start-up. [default: no; legal: yes, no]
+#ClearGraphic=no
+
+
+
+## Tyan Barebones LCD driver (GS10 & GS12 series) ##
+[tyan]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# Set the communication speed [default: 9600; legal: 4800, 9600]
+Speed=9600
+
+# set display size [default: 16x2]
+Size=16x2
+
+
+
+## ELV ula200 driver ##
+[ula200]
+
+# Select the LCD size [default: 20x4]
+Size=20x4
+
+# If you have a non standard keypad you can associate any keystrings to keys.
+# There are 6 input key in the CwLnx hardware that generate characters
+# from 'A' to 'F'.
+#
+# The following it the built-in default mapping hardcoded in the driver.
+# You can leave those unchanged if you have a standard keypad.
+# You can change it if you want to report other keystrings or have a non
+# standard keypad.
+# KeyMap_A=Up
+# KeyMap_B=Down
+# KeyMap_C=Left
+# KeyMap_D=Right
+# KeyMap_E=Enter
+# KeyMap_F=Escape
+
+
+
+## Wirz SLI LCD driver ##
+[sli]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# Set the communication speed [default: 19200; legal: 1200, 2400, 9600, 19200,
+# 38400, 57600, 115200]
+Speed=19200
+
+
+
+## vlsys_m428 for VFD/IR combination in Moneual MonCaso 320 ##
+[vlsys_m428]
+
+# Select the output device to use [default: /dev/ttyUSB0]
+#Device=/dev/ttyUSB0
+
+
+
+## OnScreen Display using libxosd ##
+[xosd]
+
+# set display size [default: 20x4]
+Size=20x4
+
+# Offset in pixels from the top-left corner of the monitor [default: 0x0]
+Offset=200x200
+
+# X font to use, in XLFD format, as given by "xfontsel"
+Font=-*-terminus-*-r-*-*-*-320-*-*-*-*-*
+
+# EOF
diff -Naur lcdproc-0.5.6-old/server/drivers/dm140.c lcdproc-0.5.6-new/server/drivers/dm140.c
--- lcdproc-0.5.6-old/server/drivers/dm140.c	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.6-new/server/drivers/dm140.c	2012-11-14 12:06:25.000000000 -0800
@@ -0,0 +1,241 @@
+/*  
+ *  dm1400 vfd driver (c)2007 Henrik Larsson 
+ */
+
+#include <stdio.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <asm/types.h>
+#include <linux/hiddev.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "lcd.h"
+#include "dm140.h"
+
+#include "report.h"
+#include "lcd_lib.h"
+#include "libvfd.h"
+#include "led.h"
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+
+/* Vars for the server core */
+MODULE_EXPORT char *api_version = API_VERSION;
+MODULE_EXPORT int stay_in_foreground = 0;
+MODULE_EXPORT int supports_multiple = 0;
+MODULE_EXPORT char *symbol_prefix = "dm140_";
+
+
+MODULE_EXPORT int
+dm140_init (Driver *drvthis)
+{
+	PrivateData *p;
+	int i;
+
+        /* Allocate and store private data */
+        p = (PrivateData *) calloc(1, sizeof(PrivateData));
+        if (p == NULL)
+        {
+                report(RPT_CRIT, "Failed to allocate memory for PrivateData\n");
+                return -1;
+        }
+        
+        if (drvthis->store_private_ptr(drvthis, p))
+        {
+                report(RPT_CRIT, "Failed to store Private Ptr!");
+                return -1;
+        }
+
+        /* initialize private data */
+	p->width = 18;
+	p->height = 2;
+	p->pszVendor = "040b";
+	p->pszProduct = "7001";
+
+	p->gIconMask = 0; 
+	p->gLayout = VFD_STR_LAYOUT_1;
+	p->gScrollTime = 1;
+	p->gFlags = 0;
+	p->gDisplayMode = VFD_MODE_NONE;
+	
+	if ((p->framebuf = (char *) calloc(1, p->height)) == NULL)
+	{
+	  report(RPT_CRIT, "Allocating memory for framebuffer Failed\n");
+	  return -1;
+	}
+
+	for (i=0; i<p->height; i++)
+	{
+	  p->framebuf[i] = (char *) calloc(1, p->width+1);
+	  report(RPT_INFO, "Allocating memory for framebuffer[%d]\n", i); 
+	  if (p->framebuf == NULL)
+	    return -1;
+        }
+	
+	if((p->fd = OpenHID(drvthis))< 0)
+	{
+		report(RPT_INFO, "Device for Vendor[%s] Product[%s] was not found, exiting\n", p->pszVendor, p->pszProduct);
+		return -1;
+	}
+
+	//******************************************************
+	// Initialize the internal report structures
+	//******************************************************
+	if(ioctl(p->fd, HIDIOCINITREPORT,0)<0)
+		return -1;
+
+	//******************************************************
+	// Find out what type of reports this device accepts
+	//******************************************************
+	//FindReports(fd);
+
+	//******************************************************
+	// Set up the display to show graphics
+	//******************************************************
+	VFDTurnOffIcons(drvthis);
+	VFDSetDisplay(drvthis, VFD_MODE_NONE, 0, 0, 0);
+	VFDGraphicsClearBuffer(drvthis, VFD_GR_PAGE_3);
+        
+        //******************************************************
+        // Set up the display, scrolling region, scroll rate etc.
+        //******************************************************
+        VFDDisableDisplay(drvthis);
+        VFDClearString(drvthis, VFD_STR_REGION_1);
+        VFDClearString(drvthis, VFD_STR_REGION_3);
+        VFDEnableString(drvthis, VFD_STR_LAYOUT_2);
+//        VFDSetScrollRegion(drvthis, 0);
+//        VFDSetScrollTime(drvthis, 500);
+	
+	VFDSetString(drvthis, VFD_STR_REGION_1, 0, "DM140 online!!!");
+
+	return 0;
+
+}
+
+MODULE_EXPORT void
+dm140_close (Driver *drvthis)
+{
+        PrivateData *p = drvthis->private_data;
+
+
+        VFDClearString(drvthis, VFD_STR_REGION_1);
+        VFDClearString(drvthis, VFD_STR_REGION_2);
+        VFDClearString(drvthis, VFD_STR_REGION_3);
+        VFDClearString(drvthis, VFD_STR_REGION_4);
+
+        if (p != NULL) {
+                if (p->fd >= 0)
+                        close(p->fd);
+
+                free(p);
+        }
+        drvthis->store_private_ptr(drvthis, NULL);
+}
+
+MODULE_EXPORT int
+dm140_width (Driver *drvthis)
+{
+	PrivateData *p = drvthis->private_data;
+	return p->width;
+}
+
+MODULE_EXPORT int
+dm140_height (Driver *drvthis)
+{
+	PrivateData *p = drvthis->private_data;
+	return p->height;
+}
+
+MODULE_EXPORT int
+dm140_string (Driver *drvthis, int x, int y, char *buffer)
+{
+  PrivateData *p = drvthis->private_data;
+  int i;
+    
+  report(RPT_INFO, "%s called with values(x,y,c): %d, %d, %s", __FUNCTION__, x, y, buffer);
+
+  for (i=0; i<strlen(buffer); i++)
+  {
+    p->framebuf[y-1][x+i]=buffer[i];
+  }
+
+/*
+  if (y > p->height)
+    y = p->height;
+    
+  if (y == 2)
+    y = VFD_STR_REGION_3;
+  
+  return VFDSetString(drvthis, y, x, buffer);
+*/
+
+  return 0;
+}
+
+MODULE_EXPORT int
+dm140_char (Driver *drvthis, int x, int y, char c)
+{
+  PrivateData *p = drvthis->private_data;
+  
+  report(RPT_INFO, "%s called with values(x,y,c): %d, %d, %c", __FUNCTION__, x, y, c);
+
+  p->framebuf[y][x] = c;
+  
+  return 0;
+}
+
+MODULE_EXPORT int
+dm140_clear (Driver *drvthis)
+{
+  PrivateData *p = drvthis->private_data;
+  int i;
+  
+  report(RPT_INFO, "%s called with values()", __FUNCTION__);
+
+  for (i=0; i<p->height; i++)
+  {
+    memset(p->framebuf[i], 0x20, p->width);
+    p->framebuf[i][p->width] = 0x00;
+  }
+
+//        VFDClearString(drvthis, VFD_STR_REGION_1);
+//        VFDClearString(drvthis, VFD_STR_REGION_2);
+//        VFDClearString(drvthis, VFD_STR_REGION_3);
+//        VFDClearString(drvthis, VFD_STR_REGION_4);
+
+  return 0;
+}
+
+MODULE_EXPORT int
+dm140_flush (Driver *drvthis)
+{
+  PrivateData *p = drvthis->private_data;
+  int i;
+  int y;
+  
+  report(RPT_INFO, "%s called with values()", __FUNCTION__);
+
+  for (i=0; i<p->height; i++)
+  {
+    y = VFD_STR_REGION_1;
+    if(i==0) y = VFD_STR_REGION_1; 
+    if(i==1) y = VFD_STR_REGION_3;
+    // Do switch depening on VFD_LAYOUT
+    VFDSetString(drvthis, y, 1, p->framebuf[i]);
+  }
+  
+  // Don't know what to do
+ 
+  return 0;
+}
+
+
diff -Naur lcdproc-0.5.6-old/server/drivers/dm140.h lcdproc-0.5.6-new/server/drivers/dm140.h
--- lcdproc-0.5.6-old/server/drivers/dm140.h	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.6-new/server/drivers/dm140.h	2012-11-14 12:06:25.000000000 -0800
@@ -0,0 +1,38 @@
+#ifndef DM140_H
+#define DM140_H
+
+#include "libvfd.h"
+
+typedef struct driver_private_data {
+        char device[256];
+        int fd;
+
+        int width;
+        int height;
+
+        char *pszVendor;
+        char *pszProduct;
+
+        int gIconMask;
+        char gLayout;
+        char gScrollTime;
+        char gFlags;
+        int gDisplayMode;
+        char gPages[VFD_PAGE_SIZE][VFD_PAGE_COUNT];
+
+        char **framebuf;
+
+} PrivateData;
+
+
+/* dm140 */
+MODULE_EXPORT int  dm140_init (Driver *drvthis);
+MODULE_EXPORT void dm140_close (Driver *drvthis);
+MODULE_EXPORT int  dm140_width (Driver *drvthis);
+MODULE_EXPORT int  dm140_height (Driver *drvthis);
+MODULE_EXPORT int  dm140_string (Driver *drvthis, int y, int x, char *buffer);
+MODULE_EXPORT int  dm140_char (Driver *drvthis, int y, int x, char c);
+MODULE_EXPORT int  dm140_clear (Driver *drvthis);
+MODULE_EXPORT int  dm140_flush (Driver *drvthis);
+
+#endif
diff -Naur lcdproc-0.5.6-old/server/drivers/led.c lcdproc-0.5.6-new/server/drivers/led.c
--- lcdproc-0.5.6-old/server/drivers/led.c	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.6-new/server/drivers/led.c	2012-11-14 12:06:25.000000000 -0800
@@ -0,0 +1,1065 @@
+/* File modified by Henrik Larsson 2007 to interface with LCDproc API
+ */
+
+/* vfd demo application
+ * Copyright (C) 2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/* This is an example application that turns on the icons on the front panel
+ * and also displays text on the VFD screen
+ */
+ 
+#include <stdio.h>
+#include <sys/select.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <asm/types.h>
+#include <linux/hiddev.h>
+#include <string.h>
+#include "lcd.h"
+#include "libvfd.h"
+#include "report.h"
+#include "dm140.h"
+
+
+//**************************************************************
+//  HID devices exchange data with the host computer using data bundles called 
+//  reports.  Each report is divided into "fields", each of which can have one
+//  or more "usages".  In the hid-core each one of these usages has a single
+//  signed 32 bit value.
+//
+//  read():
+//  This is the event interface.  When the HID device's state changes, it
+//  performs an interrupt transfer containing a report which contains the 
+//  changed value.  The hid-core.c module parses the report, and returns to
+//  hiddev.c the individual usages that have changed within the report.  In
+//  its basic mode, the hiddev will make these individual usage changes
+//  available to the reader using a struct hiddev_event:
+//    struct hiddev_event { unsigned hid;
+//  containing the HID usage identifier for the status that changed, and the
+//  value that it was changed to.  Note that the structure is defined within
+//  <linux/hiddev.h>, along with some other useful #defines and structures.  
+//  The HID usage identifier is a composite of the HID usage page shifed to 
+//  the 16 high order bits ORed with the usage code.  The behavior of the read()
+//  function can be modified using the HIDIOCSFLAG ioctl described below.
+//
+//  ioctl():
+//  Instructs the kernel to retrieve all input and feature report values from
+//  the device.  At this point, all the usage structures will contain current
+//  values for the device, and will maintain it as the device changes.  Note 
+//  that the use of this ioctl is unnecessary in general, since later kernels
+//  automatically initialize the reports from the device at attach time.
+//**************************************************************
+
+/* hack - fix improper signed char handling - it's seeing 0x80 as a negative value*/
+#define VALUE_FILTER(_value)  (_value>0x7F)?(__s32)(0xFFFFFF00 | _value):(_value)
+
+#define VFD_PACKET_SIZE(s) (s*8)
+
+unsigned char amd_logo[VFD_PAGE_SIZE] = {
+  0x7f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x3f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x1f,0xfe,0x07,0x83,0xc0,0xe3,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x0f,0xfe,0x07,0x83,0xe1,0xe3,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x07,0xfe,0x07,0xc3,0xe1,0xe3,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x10,0x1e,0x0f,0xc3,0xf3,0xe3,0x87,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x30,0x1e,0x0e,0xe3,0xb3,0x63,0x83,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x30,0x1e,0x1c,0xe3,0xb7,0x63,0x83,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
+  0xf0,0x1e,0x1c,0xe3,0x9e,0x63,0x83,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
+  0xf0,0x1e,0x1c,0x73,0x9e,0x63,0x83,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
+  0xf0,0x1e,0x3f,0xf3,0x9c,0x63,0x83,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
+  0xff,0xce,0x3f,0xf3,0x8c,0x63,0x8f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
+  0xff,0x86,0x38,0x3b,0x80,0x63,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0xff,0x02,0x70,0x3b,0x80,0x63,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+};
+
+
+char icon_bits[] = 
+{
+  15, 14, 13, 12, 11, 10,  9,  8,
+  18, 17, 16, 19, 23, 27, 31, 35,
+  39, 43, 47, 51, 55, 59, 63
+};
+
+//**************************************************************
+// FUNCTION: Compare
+//
+// INPUT: 
+//  const char *pszValue - string to compare
+//  short sValue - numberic value to compare
+//
+// OUTPUT:
+//   int - Boolean value, 0 on non match, 1 on success.
+//
+// DESCRIPTION: Compare a character value to a numeric value.
+//**************************************************************
+int Compare(const char *pszValue, short sValue)
+{
+  int iValue;
+  // convert the pszValue to a number
+  sscanf( pszValue, "%4x", &iValue);
+  return( iValue == sValue );
+}
+
+
+//**************************************************************
+// FUNCTION: OpenHID
+//
+// INPUT: 
+//  const char *pszVendor - Vendor ID of device to open
+//  const char *pszProduct - Product ID of device to open
+//
+// OUTPUT:
+//   int fd - file descriptor to the opened HID device or -1 if err.
+//
+// DESCRIPTION: This function will open all the HID's on the
+//  system until we find a match or we've exhausted our search.
+//**************************************************************
+int OpenHID(Driver *drvthis)
+{
+  int i, fd=-1;
+  char port[32];
+  char name[256];
+  const char *hiddev_prefix = "/dev/usb/hiddev"; /* in devfs */
+  int version;
+  struct hiddev_devinfo device_info;
+  PrivateData *p = drvthis->private_data;
+      
+
+  //******************************************************
+  // Loop through all the 16 HID ports/devices looking for 
+  // one that matches our device.
+  //******************************************************
+  for(i=0; i<16;i++)
+  {
+    sprintf(port, "%s%d", hiddev_prefix, i);
+    if((fd = open(port,O_WRONLY))>=0)
+    {
+      ioctl(fd, HIDIOCGDEVINFO, &device_info);
+      ioctl(fd, HIDIOCGNAME(sizeof(name)), name);
+
+      // If we've found our device, no need to look further, time to stop searching
+      if( Compare(p->pszVendor, device_info.vendor) && Compare(p->pszProduct, device_info.product))
+      {
+        break; // stop the for loop
+      }
+      close(fd); // Added by HL
+    }
+  }
+
+  //******************************************************
+  // If we've found our device, print out some information about it.
+  //******************************************************
+  if(fd != -1)
+  {
+    int appl; 
+    report(RPT_INFO, "Found Device - Name is %s\n", name);
+    report(RPT_INFO, "Vendor[0x%04hx] Product[0x%04hx] Version[0x%04hx]\n\t",
+          device_info.vendor, device_info.product, device_info.version);
+    switch(device_info.bustype)
+    {
+      default: 
+    	  report(RPT_INFO, " an unknown bus type: 0x%04hx ", device_info.bustype);
+    	  report(RPT_INFO, "bus[%d], devnum[%d] ifnum[%d]\n", device_info.busnum,
+    		  device_info.devnum, device_info.ifnum); 
+	      break;
+    }
+    //******************************************************
+    // Read the version - it's a packed 32 field, so 
+    // unpack it in order to display
+    //******************************************************
+    ioctl(fd, HIDIOCGVERSION, &version);
+    report(RPT_INFO, "HIDdev Driver Version is %d.%d.%d\n", 
+    	  version >>16, (version>>8)&0xff,version &0xff);
+
+    report(RPT_INFO, "There are %d applications for this device\n", device_info.num_applications);
+
+    for(i=0;i<device_info.num_applications; i++)
+    {
+			appl = ioctl(fd, HIDIOCAPPLICATION,	i);
+			report(RPT_INFO, "Application[%i]	is 0x%x	", i,	appl);
+      //******************************************************
+			// The magic values	come from	various	usage	table	specs	
+      //******************************************************
+			switch(appl	>> 16)
+			{
+				case 0x01: report(RPT_INFO, "(Generic	Desktop	Page)\n");break;
+				case 0x02: report(RPT_INFO, "(Simulation Controls)\n");	break;
+				case 0x03: report(RPT_INFO, "(VR Controls)\n");					break;
+				case 0x04: report(RPT_INFO, "(Sport	Controls)\n");			break;
+				case 0x05: report(RPT_INFO, "(Game Controls)\n");				break;
+				case 0x06: report(RPT_INFO, "(Generic	Device Controls)\n");break;
+				case 0x07: report(RPT_INFO, "(Keyboard/Keypad)\n");			break;
+				case 0x08: report(RPT_INFO, "(LEDs)\n");								break;
+				case 0x09: report(RPT_INFO, "(Button)\n");							break;
+				case 0x0A: report(RPT_INFO, "(Ordinal)\n");							break;
+				case 0x0B: report(RPT_INFO, "(Telphony)\n");						break;
+				case 0x0C: report(RPT_INFO, "(Consumer Product Page)\n");	break;
+				case 0x0D: report(RPT_INFO, "(Digitizer)\n");						break;
+				case 0x0E: report(RPT_INFO, "(Reserved)\n");						break;
+				case 0x0F: report(RPT_INFO, "(PID	Page)\n");						break;
+				case 0x14: report(RPT_INFO, "(Alphanumeric Display)\n"); break;
+				case 0x15:
+				case 0x3f: report(RPT_INFO, "(Reserved)\n");						break;
+				case 0x40: report(RPT_INFO, "(Medical	Instruments)\n");	break;
+				case 0x80: report(RPT_INFO, "(USB	Monitor	Page)\n");		break;
+				case 0x81: report(RPT_INFO, "(USB	Enumerated Values	Page)\n"); break;
+				case 0x82: report(RPT_INFO, "(VESA Virtual Controls	Page)\n"); break;
+				case 0x83: report(RPT_INFO, "(Reserved Monitor Page)\n");	break;
+				case 0x84: report(RPT_INFO, "(Power	Device Page)\n");		break;
+				case 0x85: report(RPT_INFO, "(Battery	System Page)\n");	break;
+				case 0x86: 
+				case 0x87: report(RPT_INFO, "(Reserved Power Device	Page)\n"); break;
+				case 0x8C: report(RPT_INFO, "(Bar	Code Scanner Page)\n");	break;
+				case 0x8D: report(RPT_INFO, "(Scale	Page)\n");					break;
+				case 0x8E: report(RPT_INFO, "(Magnetic Stripe	Reading	Device)\n"); break;
+				case 0x8F: report(RPT_INFO, "(Point	of Sale	pages)\n");	break;
+				case 0x90: report(RPT_INFO, "(Camera Control Page)\n");	break;
+				case 0x91: report(RPT_INFO, "(Arcade Page)\n");					break;
+				default: 
+				{
+					int page	=	(appl	>> 16) & 0x0000FFFF;
+					if((page >=	0xFF00)	&& (page <=	0xFFFF))
+						report(RPT_INFO, "(Vendor	Defined	-	0x%04X)\n",page);	
+					else
+						report(RPT_INFO, "(Unknown page	-	needs	to be	added	0x%04X)\n",(appl>>16));	
+					break;
+				}
+			}
+		}
+  }
+  return fd;
+}
+
+//**************************************************************
+// FUNCTION: FindReports
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//
+// OUTPUT:
+//  none
+//
+// DESCRIPTION: This function will print out the type of reports
+//  this HID accepts.
+//**************************************************************
+void FindReports(Driver *drvthis)
+{
+  int iFields, iUsage;
+  int iReportType;
+  struct hiddev_report_info repInfo;
+  struct hiddev_field_info fieldInfo;
+  struct hiddev_usage_ref usageRef;
+  PrivateData *p = drvthis->private_data;
+  int fd = p->fd;
+  
+  //******************************************************
+  // For each type of report (Input, Output, Feature)
+  // find out which is accepted for this device.
+  //******************************************************
+  for(iReportType=HID_REPORT_TYPE_MIN; 
+      iReportType<=HID_REPORT_TYPE_MAX; 
+  	  iReportType ++)
+  {
+    repInfo.report_type = iReportType;
+    repInfo.report_id = HID_REPORT_ID_FIRST;
+
+    //******************************************************
+    // HIDIOCGREPORTINFO - struct hiddev_report_info (read/write)
+    // Obtain the usage information if it is found
+    //******************************************************
+    while(ioctl(fd, HIDIOCGREPORTINFO, &repInfo)>=0)
+    {
+      report(RPT_INFO, "  Report id: %d (%s) (%d fields)\n",
+      	      repInfo.report_id, 
+	            (iReportType == HID_REPORT_TYPE_INPUT) ? "Input" : 
+	            (iReportType == HID_REPORT_TYPE_OUTPUT) ? "Output" : "Feature/Other",
+	            repInfo.num_fields);
+     
+      //******************************************************
+      // HIDIOCGFIELDINFO - struct hiddev_field_info (read/write)
+      // Returns the field information associated with a report 
+      // in a hiddev_field_info structure.  The user must fill 
+      // in report_id and report_type in this structure.  The 
+      // field_index should also be filled in, which should be 
+      // a number between 0 and maxfield-1.
+      //******************************************************
+      for(iFields = 0; iFields<repInfo.num_fields; iFields++)
+      {
+        memset(&fieldInfo, 0, sizeof(fieldInfo));
+	      fieldInfo.report_type = repInfo.report_type;
+        fieldInfo.report_id   = repInfo.report_id;
+        fieldInfo.field_index = iFields;
+        ioctl(fd, HIDIOCGFIELDINFO, &fieldInfo);
+
+        // Print out information about this field
+        report(RPT_INFO, "    Field: %d(id=%d): app: %04x phys %04x flags %x "
+	              "(%d usages) unit %x exp %d\n",
+	        iFields, fieldInfo.report_id, fieldInfo.application, 
+	        fieldInfo.physical, fieldInfo.flags, fieldInfo.maxusage, 
+          fieldInfo.unit, fieldInfo.unit_exponent);
+
+        //******************************************************
+        // HIDIOCGUCODE - struct hiddev_usage_ref(read/write)
+        // Fill in the structure with report_type, report_id,
+        // field_index, and usage_index to obtain the usage_code.
+        //
+        // HIDIOCGUSAGE - struct hiddev_usage_ref(read/write)
+        // Obtain the value for the usage_code.
+        //******************************************************
+        for(iUsage=0; iUsage<fieldInfo.maxusage; iUsage++)
+        {
+          memset(&usageRef, 0, sizeof(usageRef));
+	        usageRef.report_type = fieldInfo.report_type;
+	        usageRef.report_id = fieldInfo.report_id;
+	        usageRef.field_index = iFields;
+	        usageRef.usage_index = iUsage;
+	        ioctl(fd, HIDIOCGUCODE, &usageRef);
+	        ioctl(fd, HIDIOCGUSAGE, &usageRef);
+	        report(RPT_INFO, "      Usage: %04x val %d idx %x\n", usageRef.usage_code,
+	          usageRef.value, usageRef.usage_index);
+        }
+      }
+
+      //******************************************************
+      // Go to the next report if there is one.
+      //******************************************************
+      repInfo.report_id |= HID_REPORT_ID_NEXT;
+    }
+  }
+}
+
+//**************************************************************
+// FUNCTION: SendReport
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//	const char *buf - Message to write
+//	size_t size - size of buf.
+//
+// OUTPUT:
+//  int err - result of the ioctl call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will write the 'buf' to the opened
+//	HID device.  Specifically, it updates the device's usage 
+//	reference with the data and then sends a report to the HID.
+//**************************************************************
+int SendReport(Driver *drvthis, const char *buf, size_t size)
+{
+	struct hiddev_report_info rinfo;
+	struct hiddev_usage_ref	uref;
+	int	i, err;
+	PrivateData *p = drvthis->private_data;
+	int fd = p->fd;
+
+  //******************************************************
+	// Initialize the usage Reference and mark it for OUTPUT
+  //******************************************************
+	memset(&uref, 0, sizeof(uref));
+	uref.report_type = HID_REPORT_TYPE_OUTPUT;
+	uref.report_id	 = 0;
+	uref.field_index = 0;
+
+	//**************************************************************
+	// Fill in the information that we wish to set
+	//**************************************************************
+	uref.usage_code  = 0xffa10005; //	unused?
+	for(i=0;i<size;i++)
+	{
+		uref.usage_index = i;
+		uref.value	 = VALUE_FILTER(buf[i]);
+
+		//**************************************************************
+		// HIDIOCSUSAGE - struct hiddev_usage_ref (write)
+		// Sets the value of a usage in an output report.  The user fills
+		// in the hiddev_usage_ref structure as above, but additionally 
+		// fills in the value field.
+		//**************************************************************
+		if((err	= ioctl(fd, HIDIOCSUSAGE, &uref)) < 0)
+		{
+			report(RPT_INFO, "Error with sending the USAGE ioctl %d\n", err);
+			return err;
+		}
+		uref.usage_code  = 0xffa10006; //	unused?
+	}
+
+	//**************************************************************
+	// HIDIOCSREPORT - struct hiddev_report_info (write)
+	// Instructs the kernel to SEND a report to the device.  This 
+	// report can be filled in by the user through HIDIOCSUSAGE calls 
+	// (below) to fill in individual usage values in the report before
+	// sending the report in full to the device.
+	//**************************************************************
+	memset(&rinfo, 0,	sizeof(rinfo));
+	rinfo.report_type	= HID_REPORT_TYPE_OUTPUT;
+	rinfo.report_id		= 0;
+	rinfo.num_fields	= 0;
+	if((err	= ioctl(fd, HIDIOCSREPORT, &rinfo)) < 0)
+	{
+		report(RPT_INFO, "Error with sending the REPORT ioctl %d\n", errno);
+	}
+
+  //******************************************************
+	// All done, let's return what we did.
+  //******************************************************
+	return err;
+}
+
+
+//**************************************************************
+// FUNCTION: VFDShowIcons
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//	int mask - Icon mask
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will turn on/off various icons
+//  depending upon what was selected.
+//**************************************************************
+int VFDShowIcons(Driver *drvthis, int mask)
+{
+  int i, err;
+  char bitmap[8];
+  const char panelCmd[]  = {0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00};
+  const char iconCmd[]   = {0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+                  
+  memset(bitmap, 0, sizeof(bitmap));
+  for(i=0; i< VFD_ICON_COUNT; i++)
+  {
+    if(!(mask & (1<<i)))
+      continue;
+    bitmap[icon_bits[i]/8] |= 1 << (icon_bits[i] % 8);
+    //report(RPT_INFO, "Bitmap[%d]=%x\n",icon_bits[i]/8,bitmap[icon_bits[i]/8]);
+  }
+
+  err = SendReport(drvthis, panelCmd, sizeof(panelCmd));
+  err = SendReport(drvthis, iconCmd, sizeof(iconCmd));
+  err = SendReport(drvthis, bitmap, sizeof(bitmap));
+  return err;
+}
+
+//**************************************************************
+// FUNCTION: VFDIconSet
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//	int icon - Icon to manipulate
+//	int state - 1 for on, 0 for off.
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will set up the icon mask so that
+//  the selected icons are marked to be on/off as desired.
+//**************************************************************
+int VFDIconSet(Driver *drvthis, int icon, int state)
+{
+  PrivateData *p = drvthis->private_data;
+    
+  if(icon > VFD_ICON_DVD)
+    return -1;
+
+  if(state)
+    p->gIconMask |= 1<<icon;
+  else
+    p->gIconMask &= ~(1<<icon);
+
+  return VFDShowIcons(drvthis, p->gIconMask);
+}
+
+//**************************************************************
+// FUNCTION: VFDIconOn
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//	int icon - icon to turn on
+//
+// OUTPUT:
+//  int err - result of the VFDIconSet call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will turn on one specific icon.
+//**************************************************************
+int VFDIconOn(Driver *drvthis, int icon)
+{
+#ifdef DEBUG
+	report(RPT_INFO, "VFDIconOn %d\n",icon);
+#endif
+  return VFDIconSet(drvthis, icon, 1);
+}
+
+//**************************************************************
+// FUNCTION: VFDIconOff
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//	int icon - icon to turn off
+//
+// OUTPUT:
+//  int err - result of the VFDIconSet call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will turn off one specific icon.
+//**************************************************************
+int VFDIconOff(Driver *drvthis, int icon)
+{
+#ifdef DEBUG
+	report(RPT_INFO, "VFDIconOff %d\n",icon);
+#endif
+  return VFDIconSet(drvthis, icon, 0);
+}
+
+//**************************************************************
+// FUNCTION: VFDTurnOffIcons
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will turn off all the icons
+//**************************************************************
+int VFDTurnOffIcons(Driver *drvthis)
+{
+#ifdef DEBUG
+	report(RPT_INFO, "VFDTurnOffIcons\n");
+#endif
+  int err;
+  const char panelCmd[]  = {0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00};
+  const char iconCmd[]   = {0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};  //icon command
+  const char iconoff[]   = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};  //icon data
+    
+  err = SendReport(drvthis, panelCmd, sizeof(panelCmd));
+  err = SendReport(drvthis, iconCmd, sizeof(iconCmd));
+  err = SendReport(drvthis, iconoff, sizeof(iconoff));
+  return err;
+}
+
+//**************************************************************
+// FUNCTION: VFDSetVolume
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//  int level - volume level (between 0 and 12)
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will raise/lower the volume indicator.
+//**************************************************************
+int VFDSetVolume(Driver *drvthis, int level)
+{
+  int i;
+  PrivateData *p = drvthis->private_data;
+  
+  if(level>12)
+    return -1;
+
+  // Clear all of the volume values
+  p->gIconMask &= ~0xFFFFF800;
+
+  for(i=0;i<level;i++)
+    p->gIconMask |= 1 << (VFD_VOLUME_1 + i);
+
+  return VFDShowIcons(drvthis, p->gIconMask);
+}
+
+//**************************************************************
+// FUNCTION: VFDSetString
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//  int region - region to display the string
+//  int offset - location to display the string
+//  char *buffer - string to display
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will display a string in the 
+//  specified region.
+//**************************************************************
+int VFDSetString(Driver *drvthis, int region, int offset, char *buffer)
+{
+#ifdef DEBUG
+	report(RPT_INFO, "VFDSetString region %d offset %d buffer %s\n",region,offset,buffer);
+#endif
+
+  int i,size;
+  int len = strlen(buffer) + 1;// make sure we make room for the NULL
+  char stringCmd[8];
+
+  if( region > VFD_STR_REGION_4)
+    return -1;
+
+  if( offset > 111)
+    offset = 111;
+
+  if( len > 128) 
+  {
+    len = 128;
+    buffer[127] = 0;
+  }
+
+  //******************************************************
+  // Figure out how many 8 character lines we'll be sending
+  //******************************************************
+  size = ((len + 7) / 8) + 1;
+
+  //******************************************************
+  //  Setup the string command packet
+  //******************************************************
+  memset(stringCmd, 0, 8);
+  stringCmd[VFD_CLC_OFFSET] = size;
+  stringCmd[VFD_FID_OFFSET] = VFD_FID_SET_STRING;
+  stringCmd[VFD_SET_STRING_RN] = region;
+  stringCmd[VFD_SET_STRING_SL] = len;
+  stringCmd[VFD_SET_STRING_XP] = offset;
+  SendReport(drvthis, stringCmd, sizeof(stringCmd));
+
+  //******************************************************
+  // Now send the string for display
+  //******************************************************
+  for(i=0; i<len;i+=8)
+  {
+    // make sure we only send 8 bytes at a time
+    size = (len-i);
+    size = (size > 8) ? 8 : size; 
+    SendReport(drvthis, &buffer[i], size);
+  }
+  return VFDGlobalUpdateDisplay(drvthis);
+}
+
+//**************************************************************
+// FUNCTION: VFDClearString
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//  int region - region to display the string based upon the chosen layout
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will clear a string in the 
+//  specified region.
+//**************************************************************
+int VFDClearString(Driver *drvthis, int region)
+{
+  char pszClearStr[8];
+
+  if( region > VFD_STR_REGION_4)
+    return -1;
+
+  memset(pszClearStr, 0, 8);
+  pszClearStr[VFD_CLC_OFFSET] = 1;
+  pszClearStr[VFD_FID_OFFSET] = VFD_FID_STRING_CLEAR;
+  pszClearStr[VFD_STRING_CLEAR_MD] = VFD_CLEAR_STR;
+  pszClearStr[VFD_STRING_CLEAR_RN] = region;
+  return SendReport(drvthis, pszClearStr, sizeof(pszClearStr));
+}
+
+//**************************************************************
+// FUNCTION: VFDSetDisplay
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//  int mode - VFD_MODE_NONE, VFD_MODE_STR, VFD_MODE_GRAPHICS
+//  char layout - VFD_STR_LAYOUT_1, VFD_STR_LAYOUT_2, VFD_STR_LAYOUT_3
+//  char time - Scrolling Time in 50 ms units
+//  char flags - String Scrolling Enable Flag 
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will turn on scrolling in the specified region.
+//**************************************************************
+int VFDSetDisplay(Driver *drvthis, int mode, char layout, char time, char flags)
+{
+  char packet[VFD_PACKET_SIZE(1)];
+
+  memset(packet, 0, 8);
+
+  packet[VFD_CLC_OFFSET]     = 1;
+  packet[VFD_FID_OFFSET]     = VFD_FID_SET_DISPLAY;
+  packet[VFD_SET_DISPLAY_MD] = mode;
+  packet[VFD_SET_DISPLAY_DM] = layout;
+  packet[VFD_SET_DISPLAY_ST] = time;
+  packet[VFD_SET_DISPLAY_SF] = flags;
+  return SendReport(drvthis, packet, sizeof(packet));
+}
+
+//**************************************************************
+// FUNCTION: VFDUpdateDisplay
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//  int mode - VFD_MODE_NONE, VFD_MODE_STR, VFD_MODE_GRAPHICS
+//  char layout - VFD_STR_LAYOUT_1, VFD_STR_LAYOUT_2, VFD_STR_LAYOUT_3
+//  char time - Scrolling Time in 50 ms units
+//  char flags - String Scrolling Enable Flag 
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will update the display mode/layout/scrolltime.
+//**************************************************************
+int VFDUpdateDisplay(Driver *drvthis, int mode, char layout, char time, char flags)
+{
+  PrivateData *p = drvthis->private_data;
+
+  if(mode != p->gDisplayMode)
+    return 0;
+
+  return VFDSetDisplay(drvthis, mode, layout, time, flags);
+}
+
+//**************************************************************
+// FUNCTION: VFDGlobalUpdateDisplay
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: Update the display based upon the global configuration values.
+//**************************************************************
+int VFDGlobalUpdateDisplay(Driver *drvthis)
+{
+  PrivateData *p = drvthis->private_data;
+  return VFDUpdateDisplay(drvthis, p->gDisplayMode, p->gLayout, p->gScrollTime, p->gFlags);
+}
+
+//**************************************************************
+// FUNCTION: VFDSetScrollRegion
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//  int region - region to scroll
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will turn on scrolling in the specified region.
+//**************************************************************
+int VFDSetScrollRegion(Driver *drvthis, int region)
+{
+  PrivateData *p = drvthis->private_data;
+
+#ifdef DEBUG
+	report(RPT_INFO, "VFDSetScrollRegion region %d\n",region);
+#endif
+  p->gFlags &= ~0x0F;
+  p->gFlags |= (region & 0x0F);
+  return VFDUpdateDisplay(drvthis, VFD_MODE_STR, p->gLayout, p->gScrollTime, p->gFlags | VFD_SCROLL_ENABLE);
+}
+
+//**************************************************************
+// FUNCTION: VFDSetScrollTime
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//  int time - time in ms to scroll
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will set the rate at which to scroll
+//**************************************************************
+int VFDSetScrollTime(Driver *drvthis, int time)
+{
+  PrivateData *p = drvthis->private_data;
+  
+  p->gScrollTime = time / 50;
+  return VFDUpdateDisplay(drvthis, VFD_MODE_STR, p->gLayout, p->gScrollTime, p->gFlags | VFD_SCROLL_ENABLE);
+}
+
+//**************************************************************
+// FUNCTION: VFDEnableDisplay
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//  int mode - VFD_MODE_NONE, VFD_MODE_STR, VFD_MODE_GRAPHICS
+//  char layout - VFD_STR_LAYOUT_1, VFD_STR_LAYOUT_2, VFD_STR_LAYOUT_3
+//  char time - Scrolling Time in 50 ms units
+//  char flags - String Scrolling Enable Flag 
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function specifies how the VFD is segmented.
+//**************************************************************
+int VFDEnableDisplay(Driver *drvthis, int mode, char layout, char time, char flags)
+{
+  PrivateData *p = drvthis->private_data;
+  
+  p->gDisplayMode = mode;
+  return VFDSetDisplay(drvthis, mode, layout, time, flags);
+}
+
+//**************************************************************
+// FUNCTION: VFDDisableDisplay
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function will disable any updates to the display
+//**************************************************************
+int VFDDisableDisplay(Driver *drvthis)
+{
+  PrivateData *p = drvthis->private_data;
+  
+  p->gDisplayMode = VFD_MODE_NONE; 
+  return VFDSetDisplay(drvthis, VFD_MODE_NONE, 0, 0, 0);
+}
+
+
+//**************************************************************
+// FUNCTION: VFDEnableString
+//
+// INPUT: 
+//	int fd - file descriptor to the opened HID device
+//  char ucLayout - specify how the VFD is segmented
+//
+// OUTPUT:
+//  int err - result of the SendReport call (On success 0, On error -1)
+//
+// DESCRIPTION: This function specifies how the VFD is laid out.
+//         LAYOUT 1          LAYOUT 2             LAYOUT 3
+//   /----------------\  /---------------\  /--------------------\
+//   |                |  |   Region 1    |  |Region 1 | Region 2 |
+//   |    Region 1    |  |---------------|  |---------+----------|
+//   |                |  |   Region 3    |  |Region 3 | Region 4 |
+//   \----------------/  \---------------/  \--------------------/
+//**************************************************************
+int VFDEnableString(Driver *drvthis, char ucLayout)
+{
+  PrivateData *p = drvthis->private_data;
+  
+  if(ucLayout < VFD_STR_LAYOUT_1 || ucLayout > VFD_STR_LAYOUT_3)
+    return -1;
+
+  p->gLayout = ucLayout;
+  return VFDEnableDisplay(drvthis, VFD_MODE_STR, p->gLayout, p->gScrollTime, p->gFlags | VFD_SCROLL_ENABLE);
+}
+
+
+//**************************************************************
+// FUNCTION: _set_pixel
+//
+// INPUT: 
+//	int page - page to draw on(VFD_GR_PAGE_1 ... VFD_GR_PAGE_4)
+//  int x - coordinate
+//  int y - coordinate
+//  int color - 0 or 1 - turn on/off the LED
+//
+// OUTPUT:
+//  Nothing
+//
+// DESCRIPTION: This function turns on/off pixels in the graphic page.
+//**************************************************************
+static void _set_pixel(Driver *drvthis, int page, int x, int y, int color)
+{
+  PrivateData *p = drvthis->private_data;
+  
+  char dst = ((y/8) * 112) + x;
+  char mask = (1 << (7 - (y%8)));
+
+  // Turn the LED on/off based upon the color setting
+  if(color) 
+    p->gPages[page][dst] |= mask;
+  else
+    p->gPages[page][dst] &= ~mask;
+}
+
+
+//**************************************************************
+// FUNCTION: VFDGraphicsClearBuffer
+//
+// INPUT: 
+//	int page - page to clear (VFD_GR_PAGE_1 ... VFD_GR_PAGE_4)
+//
+// OUTPUT:
+//  0 on success, -1 on error
+//
+// DESCRIPTION: This function clears the specified graphic page.
+//**************************************************************
+int VFDGraphicsClearBuffer(Driver *drvthis, int page)
+{
+  PrivateData *p = drvthis->private_data;
+  
+  if(page >= VFD_PAGE_COUNT)
+    return -1;
+
+  // Clear the page to all off
+  memset(p->gPages[page], 0, VFD_PAGE_SIZE);
+  return 0;
+}
+
+//**************************************************************
+// FUNCTION: VFDGraphicsCopyPage
+//
+// INPUT: 
+//  int page - Graphic page (dst) (VFD_GR_PAGE_1 ... VFD_GR_PAGE_4)
+//  char *buffer - buffer worth of data (src)
+//
+// OUTPUT:
+//  Nothing
+//
+// DESCRIPTION: This function turns on/off pixels in the graphic page.
+//**************************************************************
+int VFDGraphicsCopyPage(Driver *drvthis, int page, char *buffer)
+{
+  int x, y;
+  int shift;
+
+  if(page >= VFD_PAGE_COUNT)
+    return -1;
+
+  for(y=0; y < VFD_HEIGHT; y++)
+  {
+    for(x=0; x < VFD_WIDTH; x++)
+    {
+      char src = (y*14)+(x/8);
+      shift = 7 - (x%8);
+      if(shift == 0)
+        shift = 1;
+      else
+        shift = 1 << shift;
+      _set_pixel(drvthis, page, x, y, buffer[src] & shift);
+    }
+  }
+  return 0;
+}
+
+//**************************************************************
+// FUNCTION: VFDSetGraphics
+//
+// INPUT: 
+//  int fd - file descriptor to the opened HID device
+//  char region - Graphic Page index
+//  char *buf - data to display
+//
+// OUTPUT:
+//
+// DESCRIPTION: 
+//**************************************************************
+int VFDSetGraphics(Driver *drvthis, char region, char *buf)
+{
+  int i, size;
+  char packet[8];
+
+  // Send the Command to Set Graphics
+  memset(packet, 0, 8);
+
+  packet[VFD_CLC_OFFSET] = 29;
+  packet[VFD_FID_OFFSET] = VFD_FID_SET_GRAPHICS;
+  packet[VFD_SET_GRAPHICS_GP]=region;
+  SendReport(drvthis, packet, sizeof(packet));
+
+  // Send the actual graphics
+  for(i=0; i<VFD_PAGE_SIZE;i+=8)
+  {
+    // make sure we only send 8 bytes at a time
+    size = (VFD_PAGE_SIZE - i);
+    size = (size > 8) ? 8 : size; 
+    SendReport(drvthis, &buf[i], size);
+  }
+  return 0;
+}
+
+//**************************************************************
+// FUNCTION: VFDGraphicsSendPage
+//
+// INPUT: 
+//  int fd - file descriptor to the opened HID device
+//  int page - page to display (VFD_GR_PAGE_1 ... VFD_GR_PAGE_4)
+//
+// OUTPUT:
+//  -1 on error, or results of VFDSetGraphics
+//
+// DESCRIPTION:  Sends the graphics page to the VFD to be displayed.
+//**************************************************************
+int VFDGraphicsSendPage(Driver *drvthis, int page)
+{
+  PrivateData *p = drvthis->private_data;
+  
+  if(page >= VFD_PAGE_COUNT)
+    return -1;
+  return VFDSetGraphics(drvthis, page+1, p->gPages[page]);
+}
+
+//**************************************************************
+// FUNCTION: VFDGraphicsShowPage
+//
+// INPUT: 
+//  int fd - file descriptor to the opened HID device
+//  int page - page to get ready to show (VFD_GR_PAGE_1 ... VFD_GR_PAGE_4)
+//
+// OUTPUT:
+//  -1 on error
+//
+// DESCRIPTION: Sets the VFD into Graphic mode
+//**************************************************************
+int VFDGraphicsShowPage(Driver *drvthis, int page)
+{
+  if(page >= VFD_PAGE_COUNT)
+    return -1;
+  return VFDEnableDisplay(drvthis, VFD_MODE_GRAPHICS, page+1, 0, 0);
+}
+
+//**************************************************************
+// FUNCTION: VFDGraphicsRect
+//
+// INPUT: 
+//  int page - page to get ready to show (VFD_GR_PAGE_1 ... VFD_GR_PAGE_4)
+//  char color - 0 or 1
+//  int srcx - starting X Coordinate
+//  int srcy - starting Y Coordinate
+//  int width - how wide to make the box
+//  int height - how tall to make the box
+//
+// OUTPUT:
+//  -1 on error
+//
+// DESCRIPTION: Draws a box at (srcx,srcy) - (srcx+width, srcy+height)
+//**************************************************************
+int VFDGraphicsRect(Driver *drvthis, int page, char color, int srcx, int srcy, int width, int height)
+{
+  PrivateData *p = drvthis->private_data;
+  
+  char *b;
+  int h, w, x, y;
+
+  if( page >= VFD_PAGE_COUNT)
+    return -1;
+
+  if (srcx > VFD_WIDTH || srcy > VFD_HEIGHT)
+    return 0;
+
+  h = (srcy + height > VFD_HEIGHT) ? VFD_HEIGHT - srcy : srcy + height;
+  w = (srcx + width > VFD_WIDTH) ? VFD_WIDTH - srcx : srcx + width;
+  b = p->gPages[page];
+
+  for( y = srcy; y < h; y++ )
+    for( x = srcx; x < w; x++)
+      _set_pixel(drvthis, page, x, y, color);
+
+  return 0;
+}
diff -Naur lcdproc-0.5.6-old/server/drivers/led.h lcdproc-0.5.6-new/server/drivers/led.h
--- lcdproc-0.5.6-old/server/drivers/led.h	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.6-new/server/drivers/led.h	2012-11-14 12:06:25.000000000 -0800
@@ -0,0 +1,29 @@
+#ifndef LED_H
+#define LED_H
+
+// led.c functions
+int OpenHID(Driver *drvthis);
+int VFDShowIcons(Driver *drvthis, int mask);
+int VFDIconSet(Driver *drvthis, int icon, int state);
+int VFDIconOn(Driver *drvthis, int icon);
+int VFDIconOff(Driver *drvthis, int icon);
+int VFDTurnOffIcons(Driver *drvthis);
+int VFDSetVolume(Driver *drvthis, int level);
+int VFDSetString(Driver *drvthis, int region, int offset, char *buffer);
+int VFDClearString(Driver *drvthis, int region);
+int VFDSetDisplay(Driver *drvthis, int mode, char layout, char time, char flags);
+int VFDUpdateDisplay(Driver *drvthis, int mode, char layout, char time, char flags);
+int VFDGlobalUpdateDisplay(Driver *drvthis);
+int VFDSetScrollRegion(Driver *drvthis, int region);
+int VFDSetScrollTime(Driver *drvthis, int time);
+int VFDEnableDisplay(Driver *drvthis, int mode, char layout, char time, char flags);
+int VFDDisableDisplay(Driver *drvthis);
+int VFDEnableString(Driver *drvthis, char ucLayout);
+int VFDGraphicsClearBuffer(Driver *drvthis, int page);
+int VFDGraphicsCopyPage(Driver *drvthis, int page, char *buffer);
+int VFDSetGraphics(Driver *drvthis, char region, char *buf);
+int VFDGraphicsSendPage(Driver *drvthis, int page);
+int VFDGraphicsShowPage(Driver *drvthis, int page);
+int VFDGraphicsRect(Driver *drvthis, int page, char color, int srcx, int srcy, int width, int height);
+
+#endif
diff -Naur lcdproc-0.5.6-old/server/drivers/libvfd.h lcdproc-0.5.6-new/server/drivers/libvfd.h
--- lcdproc-0.5.6-old/server/drivers/libvfd.h	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.6-new/server/drivers/libvfd.h	2012-11-14 12:06:25.000000000 -0800
@@ -0,0 +1,183 @@
+/* Header for libvfd
+ * Copyright (C) 2006, Advanced Micro Devices, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef LIBVFD_H_
+#define LIBVFD_H_
+
+/* Offsets into the VFD command packet */
+
+#define VFD_CLC_OFFSET          0x00
+#define VFD_FID_OFFSET          0x01
+
+/* VFD FID (Function IDs) */
+
+#define VFD_FID_PANEL_BANK      0x01
+#define VFD_FID_ICON_CONTROL    0x02
+#define VFD_FID_SET_STRING      0x03
+#define VFD_FID_STRING_CLEAR    0x04
+#define VFD_FID_SET_DISPLAY     0x05
+#define VFD_FID_SET_GRAPHICS    0x06
+#define VFD_FID_GRAPHIC_AREA    0x07
+
+/* Command specific offsets */
+
+/* Panel Blank */
+#define VFD_PANEL_BLANK_BL      0x02
+
+/* Icon Control */
+#define VFD_ICON_CONTROL_BITMAP 0x08
+
+/* Set String */
+#define VFD_SET_STRING_RN       0x02
+#define VFD_SET_STRING_SL       0x03
+#define VFD_SET_STRING_XP       0x04
+#define VFD_SET_STRING_DATA     0x08
+
+/* String Clear */
+#define VFD_STRING_CLEAR_MD     0x02
+#define      VFD_CLEAR_STR      0x01
+#define      VFD_CLEAR_GRAPHICS 0x02
+#define VFD_STRING_CLEAR_RN     0x03
+
+/* Set Display */
+#define VFD_SET_DISPLAY_MD      0x02
+#define       VFD_MODE_NONE     0x00
+#define       VFD_MODE_STR      0x02
+#define       VFD_MODE_GRAPHICS 0x03
+#define VFD_SET_DISPLAY_DM      0x03
+#define VFD_SET_DISPLAY_ST      0x04
+#define VFD_SET_DISPLAY_SF      0x06
+
+/* Set Graphics */
+#define VFD_SET_GRAPHICS_GP     0x02
+#define VFD_SET_GRAPHICS_DATA   0x08
+
+/* Graphic Area */
+#define VFD_GRAPHIC_AREA_OOF    0x02
+
+/* LAYOUT 1
+  /-----------------------\
+  |                       |
+  |      Region 1         |
+  |                       |
+  \-----------------------/
+*/
+
+/* LAYOUT 2
+  /-----------------------\
+  |        Region 1       |
+  |---------------------- |
+  |        Region 3       |
+  \-----------------------/
+*/
+
+/* LAYOUT 3
+  /-----------------------\
+  | Region 1 | Region 2   |
+  |---------------------- |
+  | Region 3 | Region 4   |
+  \-----------------------/
+*/
+
+#define VFD_GR_PAGE_1 0x0
+#define VFD_GR_PAGE_2 0x1
+#define VFD_GR_PAGE_3 0x2
+#define VFD_GR_PAGE_4 0x3
+
+#define VFD_STR_LAYOUT_1 0x01
+#define VFD_STR_LAYOUT_2 0x02
+#define VFD_STR_LAYOUT_3 0x03
+
+#define VFD_STR_REGION_1 0x01
+#define VFD_STR_REGION_2 0x02
+#define VFD_STR_REGION_3 0x03
+#define VFD_STR_REGION_4 0x04
+
+#define VFD_SCROLL_REGION1 (1 << 0)
+#define VFD_SCROLL_REGION2 (1 << 1)
+#define VFD_SCROLL_REGION3 (1 << 2)
+#define VFD_SCROLL_REGION4 (1 << 3)
+
+#define VFD_SCROLL_ENABLE  (1 << 7)
+
+/* Graphics defintions */
+/* The graphics area has a static resolution */
+
+#define VFD_WIDTH  112
+#define VFD_HEIGHT 16
+#define VFD_PITCH  (112 / 8)
+#define VFD_PAGE_SIZE  (VFD_PITCH * VFD_HEIGHT)
+#define VFD_PAGE_COUNT   4
+
+#define VFD_ICON_VIDEO   0
+#define VFD_ICON_CD      1   
+#define VFD_ICON_PLAY    2   
+#define VFD_ICON_RWND    3   
+#define VFD_ICON_PAUSE   4   
+#define VFD_ICON_FFWD    5 
+#define VFD_ICON_SPEAKER 6   
+#define VFD_ICON_REC     7   
+#define VFD_ICON_VOLUME  8   
+#define VFD_ICON_RADIO   9   
+#define VFD_ICON_DVD     10  
+
+#define VFD_VOLUME_1     11  
+#define VFD_VOLUME_2     12
+#define VFD_VOLUME_3     13
+#define VFD_VOLUME_4     14
+#define VFD_VOLUME_5     15
+#define VFD_VOLUME_6     16
+#define VFD_VOLUME_7     17
+#define VFD_VOLUME_8     18
+#define VFD_VOLUME_9     19
+#define VFD_VOLUME_10    20
+#define VFD_VOLUME_11    21
+#define VFD_VOLUME_12    22
+
+#define VFD_ICON_COUNT   23
+
+int vfd_cmd_graphic_area_state(unsigned char);
+int vfd_cmd_panel_bank(unsigned char);
+int vfd_cmd_icon_control(unsigned char *);
+int vfd_cmd_set_string(unsigned char, unsigned char, unsigned char *, int);
+int vfd_cmd_clear(unsigned char, unsigned char);
+int vfd_cmd_set_display(unsigned char, unsigned char, unsigned char, unsigned char);
+int vfd_cmd_set_graphics(unsigned char, unsigned char *);
+
+int vfd_enable_display(int, unsigned char, unsigned char, unsigned char);
+int vfd_update_display(int, unsigned char, unsigned char, unsigned char);
+int vfd_disable_display(int);
+
+void vfd_str_set_scroll_time(int);
+void vfd_str_set_scroll_speed(unsigned char);
+void vfd_str_set_scroll_regions(unsigned char);
+int vfd_str_set_string(unsigned char, unsigned char, const unsigned char *);
+int vfd_str_clear_string(unsigned char);
+int vfd_str_enable(unsigned char);
+int vfd_str_disable(void);
+
+int vfd_gr_clear_buffer(unsigned char);
+int vfd_gr_show_page(int);
+int vfd_gr_disable(void);
+int vfd_gr_send_page(int);
+int vfd_gr_clear_page(int);
+int vfd_gr_copy_page(int page, char *src);
+
+int vfd_icon_set(int, int);
+int vfd_icon_on(int, int);
+int vfd_icon_off(int, int);
+
+void vfr_gr_bitmap(int, char *, int, int, int, int, int, int);
+int vfr_gr_rect(int, unsigned char, int, int, int, int);
+
+int vfd_init(void);
+int vfd_send_command(unsigned char, int, unsigned char *);
+void vfd_close(void);
+
+#endif
diff -Naur lcdproc-0.5.6-old/server/drivers/Makefile.am lcdproc-0.5.6-new/server/drivers/Makefile.am
--- lcdproc-0.5.6-old/server/drivers/Makefile.am	2012-08-19 07:29:08.000000000 -0700
+++ lcdproc-0.5.6-new/server/drivers/Makefile.am	2012-11-14 12:07:13.000000000 -0800
@@ -23,7 +23,7 @@
 
 lcdexecbindir = $(pkglibdir)
 lcdexecbin_PROGRAMS = @DRIVERS@
-EXTRA_PROGRAMS = bayrad CFontz CFontzPacket curses debug CwLnx ea65 EyeboxOne g15 glcd glcdlib glk hd44780 icp_a106 imon imonlcd IOWarrior irman joy lb216 lcdm001 lcterm lirc lis MD8800 mdm166a ms6931 mtc_s16209x MtxOrb mx5000 NoritakeVFD picolcd pyramid sdeclcd sed1330 sed1520 serialPOS serialVFD shuttleVFD stv5730 SureElec svga t6963 text tyan sli ula200 vlsys_m428 xosd i2500vfd irtrans
+EXTRA_PROGRAMS = bayrad CFontz CFontzPacket curses debug CwLnx dm140 ea65 EyeboxOne g15 glcd glcdlib glk hd44780 icp_a106 imon imonlcd IOWarrior irman joy lb216 lcdm001 lcterm lirc lis MD8800 mdm166a ms6931 mtc_s16209x MtxOrb mx5000 NoritakeVFD picolcd pyramid sdeclcd sed1330 sed1520 serialPOS serialVFD shuttleVFD stv5730 SureElec svga t6963 text tyan sli ula200 vlsys_m428 xosd i2500vfd irtrans
 noinst_LIBRARIES = libLCD.a libbignum.a
 
 g15_CFLAGS =         @LIBUSB_CFLAGS@ $(AM_CFLAGS)
@@ -87,6 +87,7 @@
 curses_SOURCES =     lcd.h curses_drv.h curses_drv.c report.h
 CwLnx_SOURCES =      lcd.h lcd_lib.h CwLnx.c CwLnx.h report.h
 debug_SOURCES =      lcd.h report.h debug.c debug.h
+dm140_SOURCES =      lcd.h led.c libvfd.h led.h dm140.c dm140.h report.h
 ea65_SOURCES =       lcd.h ea65.h ea65.c report.h
 EyeboxOne_SOURCES =  lcd.h lcd_lib.h EyeboxOne.c EyeboxOne.h report.h
 g15_SOURCES =        lcd.h lcd_lib.h g15.h g15-num.c g15.c report.h
