diff -Naur linux-2.6.31.7-old/Documentation/video4linux/CARDLIST.saa7164 linux-2.6.31.7-new/Documentation/video4linux/CARDLIST.saa7164
--- linux-2.6.31.7-old/Documentation/video4linux/CARDLIST.saa7164	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/Documentation/video4linux/CARDLIST.saa7164	2009-12-10 09:22:11.000000000 -0800
@@ -0,0 +1,9 @@
+  0 -> Unknown
+  1 -> Generic Rev2
+  2 -> Generic Rev3
+  3 -> Hauppauge WinTV-HVR2250                             [0070:8880,0070:8810]
+  4 -> Hauppauge WinTV-HVR2200                             [0070:8980]
+  5 -> Hauppauge WinTV-HVR2200                             [0070:8900]
+  6 -> Hauppauge WinTV-HVR2200                             [0070:8901]
+  7 -> Hauppauge WinTV-HVR2250                             [0070:8891,0070:8851]
+  8 -> Hauppauge WinTV-HVR2250                             [0070:88A1]
diff -Naur linux-2.6.31.7-old/drivers/media/common/tuners/tda18271-fe.c linux-2.6.31.7-new/drivers/media/common/tuners/tda18271-fe.c
--- linux-2.6.31.7-old/drivers/media/common/tuners/tda18271-fe.c	2009-12-10 09:21:28.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/common/tuners/tda18271-fe.c	2009-12-10 09:22:11.000000000 -0800
@@ -27,7 +27,7 @@
 MODULE_PARM_DESC(debug, "set debug level "
 		 "(info=1, map=2, reg=4, adv=8, cal=16 (or-able))");
 
-static int tda18271_cal_on_startup;
+static int tda18271_cal_on_startup = -1;
 module_param_named(cal, tda18271_cal_on_startup, int, 0644);
 MODULE_PARM_DESC(cal, "perform RF tracking filter calibration on startup");
 
@@ -1192,10 +1192,25 @@
 	case 0:
 		goto fail;
 	case 1:
+	{
 		/* new tuner instance */
+		int rf_cal_on_startup;
+
 		priv->gate = (cfg) ? cfg->gate : TDA18271_GATE_AUTO;
 		priv->role = (cfg) ? cfg->role : TDA18271_MASTER;
 		priv->config = (cfg) ? cfg->config : 0;
+
+		/* tda18271_cal_on_startup == -1 when cal
+		 * module option is unset */
+		if (tda18271_cal_on_startup == -1) {
+			/* honor attach-time configuration */
+			rf_cal_on_startup =
+				((cfg) && (cfg->rf_cal_on_startup)) ? 1 : 0;
+		} else {
+			/* module option overrides attach configuration */
+			rf_cal_on_startup = tda18271_cal_on_startup;
+		}
+
 		priv->cal_initialized = false;
 		mutex_init(&priv->lock);
 
@@ -1213,11 +1228,12 @@
 		mutex_lock(&priv->lock);
 		tda18271_init_regs(fe);
 
-		if ((tda18271_cal_on_startup) && (priv->id == TDA18271HDC2))
+		if ((rf_cal_on_startup) && (priv->id == TDA18271HDC2))
 			tda18271c2_rf_cal_init(fe);
 
 		mutex_unlock(&priv->lock);
 		break;
+	}
 	default:
 		/* existing tuner instance */
 		fe->tuner_priv = priv;
diff -Naur linux-2.6.31.7-old/drivers/media/common/tuners/tda18271.h linux-2.6.31.7-new/drivers/media/common/tuners/tda18271.h
--- linux-2.6.31.7-old/drivers/media/common/tuners/tda18271.h	2009-12-10 09:21:28.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/common/tuners/tda18271.h	2009-12-10 09:22:11.000000000 -0800
@@ -77,6 +77,9 @@
 	/* use i2c gate provided by analog or digital demod */
 	enum tda18271_i2c_gate gate;
 
+	/* force rf tracking filter calibration on startup */
+	unsigned int rf_cal_on_startup:1;
+
 	/* some i2c providers cant write all 39 registers at once */
 	unsigned int small_i2c:1;
 
diff -Naur linux-2.6.31.7-old/drivers/media/video/Kconfig linux-2.6.31.7-new/drivers/media/video/Kconfig
--- linux-2.6.31.7-old/drivers/media/video/Kconfig	2009-12-10 09:21:28.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/Kconfig	2009-12-10 09:22:11.000000000 -0800
@@ -690,6 +690,8 @@
 
 source "drivers/media/video/cx18/Kconfig"
 
+source "drivers/media/video/saa7164/Kconfig"
+
 config VIDEO_M32R_AR
 	tristate "AR devices"
 	depends on M32R && VIDEO_V4L1
diff -Naur linux-2.6.31.7-old/drivers/media/video/Makefile linux-2.6.31.7-new/drivers/media/video/Makefile
--- linux-2.6.31.7-old/drivers/media/video/Makefile	2009-12-10 09:21:28.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/Makefile	2009-12-10 09:22:11.000000000 -0800
@@ -157,6 +157,7 @@
 obj-$(CONFIG_VIDEO_AU0828) += au0828/
 
 obj-$(CONFIG_USB_VIDEO_CLASS)	+= uvc/
+obj-$(CONFIG_VIDEO_SAA7164)     += saa7164/
 
 obj-$(CONFIG_VIDEO_IR_I2C)  += ir-kbd-i2c.o
 
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/Kconfig linux-2.6.31.7-new/drivers/media/video/saa7164/Kconfig
--- linux-2.6.31.7-old/drivers/media/video/saa7164/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/Kconfig	2009-12-10 09:22:11.000000000 -0800
@@ -0,0 +1,18 @@
+config VIDEO_SAA7164
+	tristate "NXP SAA7164 support"
+	depends on DVB_CORE && PCI && I2C
+	select I2C_ALGOBIT
+	select FW_LOADER
+	select VIDEO_TUNER
+	select VIDEO_TVEEPROM
+	select VIDEOBUF_DVB
+	select DVB_TDA10048 if !DVB_FE_CUSTOMISE
+	select DVB_S5H1411 if !DVB_FE_CUSTOMISE
+	select MEDIA_TUNER_TDA18271 if !MEDIA_TUNER_CUSTOMISE
+	---help---
+	  This is a video4linux driver for NXP SAA7164 based
+	  TV cards.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called saa7164
+
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/Makefile linux-2.6.31.7-new/drivers/media/video/saa7164/Makefile
--- linux-2.6.31.7-old/drivers/media/video/saa7164/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/Makefile	2009-12-10 09:22:11.000000000 -0800
@@ -0,0 +1,12 @@
+saa7164-objs	:= saa7164-cards.o saa7164-core.o saa7164-i2c.o saa7164-dvb.o \
+			saa7164-fw.o saa7164-bus.o saa7164-cmd.o saa7164-api.o \
+			saa7164-buffer.o
+
+obj-$(CONFIG_VIDEO_SAA7164) += saa7164.o
+
+EXTRA_CFLAGS += -Idrivers/media/video
+EXTRA_CFLAGS += -Idrivers/media/common/tuners
+EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
+EXTRA_CFLAGS += -Idrivers/media/dvb/frontends
+
+EXTRA_CFLAGS += $(extra-cflags-y) $(extra-cflags-m)
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-api.c linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-api.c
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-api.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-api.c	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,600 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/wait.h>
+
+#include "saa7164.h"
+
+int saa7164_api_transition_port(struct saa7164_tsport *port, u8 mode)
+{
+	int ret;
+
+	ret = saa7164_cmd_send(port->dev, port->hwcfg.unitid, SET_CUR,
+		SAA_STATE_CONTROL, sizeof(mode), &mode);
+	if (ret != SAA_OK)
+		printk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);
+
+	return ret;
+}
+
+int saa7164_api_get_fw_version(struct saa7164_dev *dev, u32 *version)
+{
+	int ret;
+
+	ret = saa7164_cmd_send(dev, 0, GET_CUR,
+		GET_FW_VERSION_CONTROL, sizeof(u32), version);
+	if (ret != SAA_OK)
+		printk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);
+
+	return ret;
+}
+
+int saa7164_api_read_eeprom(struct saa7164_dev *dev, u8 *buf, int buflen)
+{
+	u8 reg[] = { 0x0f, 0x00 };
+
+	if (buflen < 128)
+		return -ENOMEM;
+
+	/* Assumption: Hauppauge eeprom is at 0xa0 on on bus 0 */
+	/* TODO: Pull the details from the boards struct */
+	return saa7164_api_i2c_read(&dev->i2c_bus[0], 0xa0 >> 1, sizeof(reg),
+		&reg[0], 128, buf);
+}
+
+
+int saa7164_api_configure_port_mpeg2ts(struct saa7164_dev *dev,
+	struct saa7164_tsport *port,
+	tmComResTSFormatDescrHeader_t *tsfmt)
+{
+	dprintk(DBGLVL_API, "    bFormatIndex = 0x%x\n", tsfmt->bFormatIndex);
+	dprintk(DBGLVL_API, "    bDataOffset  = 0x%x\n", tsfmt->bDataOffset);
+	dprintk(DBGLVL_API, "    bPacketLength= 0x%x\n", tsfmt->bPacketLength);
+	dprintk(DBGLVL_API, "    bStrideLength= 0x%x\n", tsfmt->bStrideLength);
+	dprintk(DBGLVL_API, "    bguid        = (....)\n");
+
+	/* Cache the hardware configuration in the port */
+
+	port->bufcounter = port->hwcfg.BARLocation;
+	port->pitch = port->hwcfg.BARLocation + (2 * sizeof(u32));
+	port->bufsize = port->hwcfg.BARLocation + (3 * sizeof(u32));
+	port->bufoffset = port->hwcfg.BARLocation + (4 * sizeof(u32));
+	port->bufptr32l = port->hwcfg.BARLocation +
+		(4 * sizeof(u32)) +
+		(sizeof(u32) * port->hwcfg.buffercount) + sizeof(u32);
+	port->bufptr32h = port->hwcfg.BARLocation +
+		(4 * sizeof(u32)) +
+		(sizeof(u32) * port->hwcfg.buffercount);
+	port->bufptr64 = port->hwcfg.BARLocation +
+		(4 * sizeof(u32)) +
+		(sizeof(u32) * port->hwcfg.buffercount);
+	dprintk(DBGLVL_API, "   = port->hwcfg.BARLocation = 0x%x\n",
+		port->hwcfg.BARLocation);
+
+	dprintk(DBGLVL_API, "   = VS_FORMAT_MPEGTS (becomes dev->ts[%d])\n",
+		port->nr);
+
+	return 0;
+}
+
+int saa7164_api_dump_subdevs(struct saa7164_dev *dev, u8 *buf, int len)
+{
+	struct saa7164_tsport *port = 0;
+	u32 idx, next_offset;
+	int i;
+	tmComResDescrHeader_t *hdr, *t;
+	tmComResExtDevDescrHeader_t *exthdr;
+	tmComResPathDescrHeader_t *pathhdr;
+	tmComResAntTermDescrHeader_t *anttermhdr;
+	tmComResTunerDescrHeader_t *tunerunithdr;
+	tmComResDMATermDescrHeader_t *vcoutputtermhdr;
+	tmComResTSFormatDescrHeader_t *tsfmt;
+	u32 currpath = 0;
+
+	dprintk(DBGLVL_API,
+		"%s(?,?,%d) sizeof(tmComResDescrHeader_t) = %d bytes\n",
+		__func__, len, (u32)sizeof(tmComResDescrHeader_t));
+
+	for (idx = 0; idx < (len - sizeof(tmComResDescrHeader_t)); ) {
+
+		hdr = (tmComResDescrHeader_t *)(buf + idx);
+
+		if (hdr->type != CS_INTERFACE)
+			return SAA_ERR_NOT_SUPPORTED;
+
+		dprintk(DBGLVL_API, "@ 0x%x = \n", idx);
+		switch (hdr->subtype) {
+		case GENERAL_REQUEST:
+			dprintk(DBGLVL_API, " GENERAL_REQUEST\n");
+			break;
+		case VC_TUNER_PATH:
+			dprintk(DBGLVL_API, " VC_TUNER_PATH\n");
+			pathhdr = (tmComResPathDescrHeader_t *)(buf + idx);
+			dprintk(DBGLVL_API, "  pathid = 0x%x\n",
+				pathhdr->pathid);
+			currpath = pathhdr->pathid;
+			break;
+		case VC_INPUT_TERMINAL:
+			dprintk(DBGLVL_API, " VC_INPUT_TERMINAL\n");
+			anttermhdr =
+				(tmComResAntTermDescrHeader_t *)(buf + idx);
+			dprintk(DBGLVL_API, "  terminalid   = 0x%x\n",
+				anttermhdr->terminalid);
+			dprintk(DBGLVL_API, "  terminaltype = 0x%x\n",
+				anttermhdr->terminaltype);
+			switch (anttermhdr->terminaltype) {
+			case ITT_ANTENNA:
+				dprintk(DBGLVL_API, "   = ITT_ANTENNA\n");
+				break;
+			case LINE_CONNECTOR:
+				dprintk(DBGLVL_API, "   = LINE_CONNECTOR\n");
+				break;
+			case SPDIF_CONNECTOR:
+				dprintk(DBGLVL_API, "   = SPDIF_CONNECTOR\n");
+				break;
+			case COMPOSITE_CONNECTOR:
+				dprintk(DBGLVL_API,
+					"   = COMPOSITE_CONNECTOR\n");
+				break;
+			case SVIDEO_CONNECTOR:
+				dprintk(DBGLVL_API, "   = SVIDEO_CONNECTOR\n");
+				break;
+			case COMPONENT_CONNECTOR:
+				dprintk(DBGLVL_API,
+					"   = COMPONENT_CONNECTOR\n");
+				break;
+			case STANDARD_DMA:
+				dprintk(DBGLVL_API, "   = STANDARD_DMA\n");
+				break;
+			default:
+				dprintk(DBGLVL_API, "   = undefined (0x%x)\n",
+					anttermhdr->terminaltype);
+			}
+			dprintk(DBGLVL_API, "  assocterminal= 0x%x\n",
+				anttermhdr->assocterminal);
+			dprintk(DBGLVL_API, "  iterminal    = 0x%x\n",
+				anttermhdr->iterminal);
+			dprintk(DBGLVL_API, "  controlsize  = 0x%x\n",
+				anttermhdr->controlsize);
+			break;
+		case VC_OUTPUT_TERMINAL:
+			dprintk(DBGLVL_API, " VC_OUTPUT_TERMINAL\n");
+			vcoutputtermhdr =
+				(tmComResDMATermDescrHeader_t *)(buf + idx);
+			dprintk(DBGLVL_API, "  unitid = 0x%x\n",
+				vcoutputtermhdr->unitid);
+			dprintk(DBGLVL_API, "  terminaltype = 0x%x\n",
+				vcoutputtermhdr->terminaltype);
+			switch (vcoutputtermhdr->terminaltype) {
+			case ITT_ANTENNA:
+				dprintk(DBGLVL_API, "   = ITT_ANTENNA\n");
+				break;
+			case LINE_CONNECTOR:
+				dprintk(DBGLVL_API, "   = LINE_CONNECTOR\n");
+				break;
+			case SPDIF_CONNECTOR:
+				dprintk(DBGLVL_API, "   = SPDIF_CONNECTOR\n");
+				break;
+			case COMPOSITE_CONNECTOR:
+				dprintk(DBGLVL_API,
+					"   = COMPOSITE_CONNECTOR\n");
+				break;
+			case SVIDEO_CONNECTOR:
+				dprintk(DBGLVL_API, "   = SVIDEO_CONNECTOR\n");
+				break;
+			case COMPONENT_CONNECTOR:
+				dprintk(DBGLVL_API,
+					"   = COMPONENT_CONNECTOR\n");
+				break;
+			case STANDARD_DMA:
+				dprintk(DBGLVL_API, "   = STANDARD_DMA\n");
+				break;
+			default:
+				dprintk(DBGLVL_API, "   = undefined (0x%x)\n",
+					vcoutputtermhdr->terminaltype);
+			}
+			dprintk(DBGLVL_API, "  assocterminal= 0x%x\n",
+				vcoutputtermhdr->assocterminal);
+			dprintk(DBGLVL_API, "  sourceid     = 0x%x\n",
+				vcoutputtermhdr->sourceid);
+			dprintk(DBGLVL_API, "  iterminal    = 0x%x\n",
+				vcoutputtermhdr->iterminal);
+			dprintk(DBGLVL_API, "  BARLocation  = 0x%x\n",
+				vcoutputtermhdr->BARLocation);
+			dprintk(DBGLVL_API, "  flags        = 0x%x\n",
+				vcoutputtermhdr->flags);
+			dprintk(DBGLVL_API, "  interruptid  = 0x%x\n",
+				vcoutputtermhdr->interruptid);
+			dprintk(DBGLVL_API, "  buffercount  = 0x%x\n",
+				vcoutputtermhdr->buffercount);
+			dprintk(DBGLVL_API, "  metadatasize = 0x%x\n",
+				vcoutputtermhdr->metadatasize);
+			dprintk(DBGLVL_API, "  controlsize  = 0x%x\n",
+				vcoutputtermhdr->controlsize);
+			dprintk(DBGLVL_API, "  numformats   = 0x%x\n",
+				vcoutputtermhdr->numformats);
+
+			t = (tmComResDescrHeader_t *)
+				((tmComResDMATermDescrHeader_t *)(buf + idx));
+			next_offset = idx + (vcoutputtermhdr->len);
+			for (i = 0; i < vcoutputtermhdr->numformats; i++) {
+				t = (tmComResDescrHeader_t *)
+					(buf + next_offset);
+				switch (t->subtype) {
+				case VS_FORMAT_MPEG2TS:
+					tsfmt =
+					(tmComResTSFormatDescrHeader_t *)t;
+					if (currpath == 1)
+						port = &dev->ts1;
+					else
+						port = &dev->ts2;
+					memcpy(&port->hwcfg, vcoutputtermhdr,
+						sizeof(*vcoutputtermhdr));
+					saa7164_api_configure_port_mpeg2ts(dev,
+						port, tsfmt);
+					break;
+				case VS_FORMAT_MPEG2PS:
+					dprintk(DBGLVL_API,
+						"   = VS_FORMAT_MPEG2PS\n");
+					break;
+				case VS_FORMAT_VBI:
+					dprintk(DBGLVL_API,
+						"   = VS_FORMAT_VBI\n");
+					break;
+				case VS_FORMAT_RDS:
+					dprintk(DBGLVL_API,
+						"   = VS_FORMAT_RDS\n");
+					break;
+				case VS_FORMAT_UNCOMPRESSED:
+					dprintk(DBGLVL_API,
+					"   = VS_FORMAT_UNCOMPRESSED\n");
+					break;
+				case VS_FORMAT_TYPE:
+					dprintk(DBGLVL_API,
+						"   = VS_FORMAT_TYPE\n");
+					break;
+				default:
+					dprintk(DBGLVL_API,
+						"   = undefined (0x%x)\n",
+						t->subtype);
+				}
+				next_offset += t->len;
+			}
+
+			break;
+		case TUNER_UNIT:
+			dprintk(DBGLVL_API, " TUNER_UNIT\n");
+			tunerunithdr =
+				(tmComResTunerDescrHeader_t *)(buf + idx);
+			dprintk(DBGLVL_API, "  unitid = 0x%x\n",
+				tunerunithdr->unitid);
+			dprintk(DBGLVL_API, "  sourceid = 0x%x\n",
+				tunerunithdr->sourceid);
+			dprintk(DBGLVL_API, "  iunit = 0x%x\n",
+				tunerunithdr->iunit);
+			dprintk(DBGLVL_API, "  tuningstandards = 0x%x\n",
+				tunerunithdr->tuningstandards);
+			dprintk(DBGLVL_API, "  controlsize = 0x%x\n",
+				tunerunithdr->controlsize);
+			dprintk(DBGLVL_API, "  controls = 0x%x\n",
+				tunerunithdr->controls);
+			break;
+		case VC_SELECTOR_UNIT:
+			dprintk(DBGLVL_API, " VC_SELECTOR_UNIT\n");
+			break;
+		case VC_PROCESSING_UNIT:
+			dprintk(DBGLVL_API, " VC_PROCESSING_UNIT\n");
+			break;
+		case FEATURE_UNIT:
+			dprintk(DBGLVL_API, " FEATURE_UNIT\n");
+			break;
+		case ENCODER_UNIT:
+			dprintk(DBGLVL_API, " ENCODER_UNIT\n");
+			break;
+		case EXTENSION_UNIT:
+			dprintk(DBGLVL_API, " EXTENSION_UNIT\n");
+			exthdr = (tmComResExtDevDescrHeader_t *)(buf + idx);
+			dprintk(DBGLVL_API, "  unitid = 0x%x\n",
+				exthdr->unitid);
+			dprintk(DBGLVL_API, "  deviceid = 0x%x\n",
+				exthdr->deviceid);
+			dprintk(DBGLVL_API, "  devicetype = 0x%x\n",
+				exthdr->devicetype);
+			if (exthdr->devicetype & 0x1)
+				dprintk(DBGLVL_API, "   = Decoder Device\n");
+			if (exthdr->devicetype & 0x2)
+				dprintk(DBGLVL_API, "   = GPIO Source\n");
+			if (exthdr->devicetype & 0x4)
+				dprintk(DBGLVL_API, "   = Video Decoder\n");
+			if (exthdr->devicetype & 0x8)
+				dprintk(DBGLVL_API, "   = Audio Decoder\n");
+			if (exthdr->devicetype & 0x20)
+				dprintk(DBGLVL_API, "   = Crossbar\n");
+			if (exthdr->devicetype & 0x40)
+				dprintk(DBGLVL_API, "   = Tuner\n");
+			if (exthdr->devicetype & 0x80)
+				dprintk(DBGLVL_API, "   = IF PLL\n");
+			if (exthdr->devicetype & 0x100)
+				dprintk(DBGLVL_API, "   = Demodulator\n");
+			if (exthdr->devicetype & 0x200)
+				dprintk(DBGLVL_API, "   = RDS Decoder\n");
+			if (exthdr->devicetype & 0x400)
+				dprintk(DBGLVL_API, "   = Encoder\n");
+			if (exthdr->devicetype & 0x800)
+				dprintk(DBGLVL_API, "   = IR Decoder\n");
+			if (exthdr->devicetype & 0x1000)
+				dprintk(DBGLVL_API, "   = EEPROM\n");
+			if (exthdr->devicetype & 0x2000)
+				dprintk(DBGLVL_API,
+					"   = VBI Decoder\n");
+			if (exthdr->devicetype & 0x10000)
+				dprintk(DBGLVL_API,
+					"   = Streaming Device\n");
+			if (exthdr->devicetype & 0x20000)
+				dprintk(DBGLVL_API,
+					"   = DRM Device\n");
+			if (exthdr->devicetype & 0x40000000)
+				dprintk(DBGLVL_API,
+					"   = Generic Device\n");
+			if (exthdr->devicetype & 0x80000000)
+				dprintk(DBGLVL_API,
+					"   = Config Space Device\n");
+			dprintk(DBGLVL_API, "  numgpiopins = 0x%x\n",
+				exthdr->numgpiopins);
+			dprintk(DBGLVL_API, "  numgpiogroups = 0x%x\n",
+				exthdr->numgpiogroups);
+			dprintk(DBGLVL_API, "  controlsize = 0x%x\n",
+				exthdr->controlsize);
+			break;
+		case PVC_INFRARED_UNIT:
+			dprintk(DBGLVL_API, " PVC_INFRARED_UNIT\n");
+			break;
+		case DRM_UNIT:
+			dprintk(DBGLVL_API, " DRM_UNIT\n");
+			break;
+		default:
+			dprintk(DBGLVL_API, "default %d\n", hdr->subtype);
+		}
+
+		dprintk(DBGLVL_API, " 1.%x\n", hdr->len);
+		dprintk(DBGLVL_API, " 2.%x\n", hdr->type);
+		dprintk(DBGLVL_API, " 3.%x\n", hdr->subtype);
+		dprintk(DBGLVL_API, " 4.%x\n", hdr->unitid);
+
+		idx += hdr->len;
+	}
+
+	return 0;
+}
+
+int saa7164_api_enum_subdevs(struct saa7164_dev *dev)
+{
+	int ret;
+	u32 buflen = 0;
+	u8 *buf;
+
+	dprintk(DBGLVL_API, "%s()\n", __func__);
+
+	/* Get the total descriptor length */
+	ret = saa7164_cmd_send(dev, 0, GET_LEN,
+		GET_DESCRIPTORS_CONTROL, sizeof(buflen), &buflen);
+	if (ret != SAA_OK)
+		printk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);
+
+	dprintk(DBGLVL_API, "%s() total descriptor size = %d bytes.\n",
+		__func__, buflen);
+
+	/* Allocate enough storage for all of the descs */
+	buf = kzalloc(buflen, GFP_KERNEL);
+	if (buf == NULL)
+		return SAA_ERR_NO_RESOURCES;
+
+	/* Retrieve them */
+	ret = saa7164_cmd_send(dev, 0, GET_CUR,
+		GET_DESCRIPTORS_CONTROL, buflen, buf);
+	if (ret != SAA_OK) {
+		printk(KERN_ERR "%s() error, ret = 0x%x\n", __func__, ret);
+		goto out;
+	}
+
+	if (saa_debug & DBGLVL_API)
+		saa7164_dumphex16(dev, buf, (buflen/16)*16);
+
+	saa7164_api_dump_subdevs(dev, buf, buflen);
+
+out:
+	kfree(buf);
+	return ret;
+}
+
+int saa7164_api_i2c_read(struct saa7164_i2c *bus, u8 addr, u32 reglen, u8 *reg,
+	u32 datalen, u8 *data)
+{
+	struct saa7164_dev *dev = bus->dev;
+	u16 len = 0;
+	int unitid;
+	u32 regval;
+	u8 buf[256];
+	int ret;
+
+	dprintk(DBGLVL_API, "%s()\n", __func__);
+
+	if (reglen > 4)
+		return -EIO;
+
+	if (reglen == 1)
+		regval = *(reg);
+	else
+	if (reglen == 2)
+		regval = ((*(reg) << 8) || *(reg+1));
+	else
+	if (reglen == 3)
+		regval = ((*(reg) << 16) | (*(reg+1) << 8) | *(reg+2));
+	else
+	if (reglen == 4)
+		regval = ((*(reg) << 24) | (*(reg+1) << 16) |
+			(*(reg+2) << 8) | *(reg+3));
+
+	/* Prepare the send buffer */
+	/* Bytes 00-03 source register length
+	 *       04-07 source bytes to read
+	 *       08... register address
+	 */
+	memset(buf, 0, sizeof(buf));
+	memcpy((buf + 2 * sizeof(u32) + 0), reg, reglen);
+	*((u32 *)(buf + 0 * sizeof(u32))) = reglen;
+	*((u32 *)(buf + 1 * sizeof(u32))) = datalen;
+
+	unitid = saa7164_i2caddr_to_unitid(bus, addr);
+	if (unitid < 0) {
+		printk(KERN_ERR
+			"%s() error, cannot translate regaddr 0x%x to unitid\n",
+			__func__, addr);
+		return -EIO;
+	}
+
+	ret = saa7164_cmd_send(bus->dev, unitid, GET_LEN,
+		EXU_REGISTER_ACCESS_CONTROL, sizeof(len), &len);
+	if (ret != SAA_OK) {
+		printk(KERN_ERR "%s() error, ret(1) = 0x%x\n", __func__, ret);
+		return -EIO;
+	}
+
+	dprintk(DBGLVL_API, "%s() len = %d bytes\n", __func__, len);
+
+	if (saa_debug & DBGLVL_I2C)
+		saa7164_dumphex16(dev, buf, 2 * 16);
+
+	ret = saa7164_cmd_send(bus->dev, unitid, GET_CUR,
+		EXU_REGISTER_ACCESS_CONTROL, len, &buf);
+	if (ret != SAA_OK)
+		printk(KERN_ERR "%s() error, ret(2) = 0x%x\n", __func__, ret);
+	else {
+		if (saa_debug & DBGLVL_I2C)
+			saa7164_dumphex16(dev, buf, sizeof(buf));
+		memcpy(data, (buf + 2 * sizeof(u32) + reglen), datalen);
+	}
+
+	return ret == SAA_OK ? 0 : -EIO;
+}
+
+/* For a given 8 bit i2c address device, write the buffer */
+int saa7164_api_i2c_write(struct saa7164_i2c *bus, u8 addr, u32 datalen,
+	u8 *data)
+{
+	struct saa7164_dev *dev = bus->dev;
+	u16 len = 0;
+	int unitid;
+	int reglen;
+	u8 buf[256];
+	int ret;
+
+	dprintk(DBGLVL_API, "%s()\n", __func__);
+
+	if ((datalen == 0) || (datalen > 232))
+		return -EIO;
+
+	memset(buf, 0, sizeof(buf));
+
+	unitid = saa7164_i2caddr_to_unitid(bus, addr);
+	if (unitid < 0) {
+		printk(KERN_ERR
+			"%s() error, cannot translate regaddr 0x%x to unitid\n",
+			__func__, addr);
+		return -EIO;
+	}
+
+	reglen = saa7164_i2caddr_to_reglen(bus, addr);
+	if (unitid < 0) {
+		printk(KERN_ERR
+			"%s() error, cannot translate regaddr to reglen\n",
+			__func__);
+		return -EIO;
+	}
+
+	ret = saa7164_cmd_send(bus->dev, unitid, GET_LEN,
+		EXU_REGISTER_ACCESS_CONTROL, sizeof(len), &len);
+	if (ret != SAA_OK) {
+		printk(KERN_ERR "%s() error, ret(1) = 0x%x\n", __func__, ret);
+		return -EIO;
+	}
+
+	dprintk(DBGLVL_API, "%s() len = %d bytes\n", __func__, len);
+
+	/* Prepare the send buffer */
+	/* Bytes 00-03 dest register length
+	 *       04-07 dest bytes to write
+	 *       08... register address
+	 */
+	*((u32 *)(buf + 0 * sizeof(u32))) = reglen;
+	*((u32 *)(buf + 1 * sizeof(u32))) = datalen - reglen;
+	memcpy((buf + 2 * sizeof(u32)), data, datalen);
+
+	if (saa_debug & DBGLVL_I2C)
+		saa7164_dumphex16(dev, buf, sizeof(buf));
+
+	ret = saa7164_cmd_send(bus->dev, unitid, SET_CUR,
+		EXU_REGISTER_ACCESS_CONTROL, len, &buf);
+	if (ret != SAA_OK)
+		printk(KERN_ERR "%s() error, ret(2) = 0x%x\n", __func__, ret);
+
+	return ret == SAA_OK ? 0 : -EIO;
+}
+
+
+int saa7164_api_modify_gpio(struct saa7164_dev *dev, u8 unitid,
+	u8 pin, u8 state)
+{
+	int ret;
+	tmComResGPIO_t t;
+
+	dprintk(DBGLVL_API, "%s(0x%x, %d, %d)\n",
+		__func__, unitid, pin, state);
+
+	if ((pin > 7) || (state > 2))
+		return SAA_ERR_BAD_PARAMETER;
+
+	t.pin = pin;
+	t.state = state;
+
+	ret = saa7164_cmd_send(dev, unitid, SET_CUR,
+		EXU_GPIO_CONTROL, sizeof(t), &t);
+	if (ret != SAA_OK)
+		printk(KERN_ERR "%s() error, ret = 0x%x\n",
+			__func__, ret);
+
+	return ret;
+}
+
+int saa7164_api_set_gpiobit(struct saa7164_dev *dev, u8 unitid,
+	u8 pin)
+{
+	return saa7164_api_modify_gpio(dev, unitid, pin, 1);
+}
+
+int saa7164_api_clear_gpiobit(struct saa7164_dev *dev, u8 unitid,
+	u8 pin)
+{
+	return saa7164_api_modify_gpio(dev, unitid, pin, 0);
+}
+
+
+
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-buffer.c linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-buffer.c
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-buffer.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-buffer.c	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,155 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "saa7164.h"
+
+/* The PCI address space for buffer handling looks like this:
+
+ +-u32 wide-------------+
+ |                      +
+ +-u64 wide------------------------------------+
+ +                                             +
+ +----------------------+
+ | CurrentBufferPtr     + Pointer to current PCI buffer >-+
+ +----------------------+                                 |
+ | Unused               +                                 |
+ +----------------------+                                 |
+ | Pitch                + = 188 (bytes)                   |
+ +----------------------+                                 |
+ | PCI buffer size      + = pitch * number of lines (312) |
+ +----------------------+                                 |
+ |0| Buf0 Write Offset  +                                 |
+ +----------------------+                                 v
+ |1| Buf1 Write Offset  +                                 |
+ +----------------------+                                 |
+ |2| Buf2 Write Offset  +                                 |
+ +----------------------+                                 |
+ |3| Buf3 Write Offset  +                                 |
+ +----------------------+                                 |
+ ... More write offsets                                   |
+ +---------------------------------------------+          |
+ +0| set of ptrs to PCI pagetables             +          |
+ +---------------------------------------------+          |
+ +1| set of ptrs to PCI pagetables             + <--------+
+ +---------------------------------------------+
+ +2| set of ptrs to PCI pagetables             +
+ +---------------------------------------------+
+ +3| set of ptrs to PCI pagetables             + >--+
+ +---------------------------------------------+    |
+ ... More buffer pointers                           |  +----------------+
+						    +->| pt[0] TS data  |
+						    |  +----------------+
+						    |
+						    |  +----------------+
+						    +->| pt[1] TS data  |
+						    |  +----------------+
+						    | etc
+ */
+
+/* Allocate a new buffer structure and associated PCI space in bytes.
+ * len must be a multiple of sizeof(u64)
+ */
+struct saa7164_buffer *saa7164_buffer_alloc(struct saa7164_tsport *port,
+	u32 len)
+{
+	struct saa7164_buffer *buf = 0;
+	struct saa7164_dev *dev = port->dev;
+	int i;
+
+	if ((len == 0) || (len >= 65536) || (len % sizeof(u64))) {
+		log_warn("%s() SAA_ERR_BAD_PARAMETER\n", __func__);
+		goto ret;
+	}
+
+	buf = kzalloc(sizeof(struct saa7164_buffer), GFP_KERNEL);
+	if (buf == NULL) {
+		log_warn("%s() SAA_ERR_NO_RESOURCES\n", __func__);
+		goto ret;
+	}
+
+	buf->port = port;
+	buf->flags = SAA7164_BUFFER_FREE;
+	/* TODO: arg len is being ignored */
+	buf->pci_size = SAA7164_PT_ENTRIES * 0x1000;
+	buf->pt_size = (SAA7164_PT_ENTRIES * sizeof(u64)) + 0x1000;
+
+	/* Allocate contiguous memory */
+	buf->cpu = pci_alloc_consistent(port->dev->pci, buf->pci_size,
+		&buf->dma);
+	if (!buf->cpu)
+		goto fail1;
+
+	buf->pt_cpu = pci_alloc_consistent(port->dev->pci, buf->pt_size,
+		&buf->pt_dma);
+	if (!buf->pt_cpu)
+		goto fail2;
+
+	/* init the buffers to a known pattern, easier during debugging */
+	memset(buf->cpu, 0xff, buf->pci_size);
+	memset(buf->pt_cpu, 0xff, buf->pt_size);
+
+	dprintk(DBGLVL_BUF, "%s()   allocated buffer @ 0x%p\n", __func__, buf);
+	dprintk(DBGLVL_BUF, "  pci_cpu @ 0x%p    dma @ 0x%08lx len = 0x%x\n",
+		buf->cpu, (long)buf->dma, buf->pci_size);
+	dprintk(DBGLVL_BUF, "   pt_cpu @ 0x%p pt_dma @ 0x%08lx len = 0x%x\n",
+		buf->pt_cpu, (long)buf->pt_dma, buf->pt_size);
+
+	/* Format the Page Table Entries to point into the data buffer */
+	for (i = 0 ; i < SAA7164_PT_ENTRIES; i++) {
+
+		*(buf->pt_cpu + i) = buf->dma + (i * 0x1000); /* TODO */
+
+	}
+
+	goto ret;
+
+fail2:
+	pci_free_consistent(port->dev->pci, buf->pci_size, buf->cpu, buf->dma);
+fail1:
+	kfree(buf);
+
+	buf = 0;
+ret:
+	return buf;
+}
+
+int saa7164_buffer_dealloc(struct saa7164_tsport *port,
+	struct saa7164_buffer *buf)
+{
+	struct saa7164_dev *dev = port->dev;
+
+	if ((buf == 0) || (port == 0))
+		return SAA_ERR_BAD_PARAMETER;
+
+	dprintk(DBGLVL_BUF, "%s() deallocating buffer @ 0x%p\n", __func__, buf);
+
+	if (buf->flags != SAA7164_BUFFER_FREE)
+		log_warn(" freeing a non-free buffer\n");
+
+	pci_free_consistent(port->dev->pci, buf->pci_size, buf->cpu, buf->dma);
+	pci_free_consistent(port->dev->pci, buf->pt_size, buf->pt_cpu,
+		buf->pt_dma);
+
+	kfree(buf);
+
+	return SAA_OK;
+}
+
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-bus.c linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-bus.c
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-bus.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-bus.c	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,448 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "saa7164.h"
+
+/* The message bus to/from the firmware is a ring buffer in PCI address
+ * space. Establish the defaults.
+ */
+int saa7164_bus_setup(struct saa7164_dev *dev)
+{
+	tmComResBusInfo_t *b	= &dev->bus;
+
+	mutex_init(&b->lock);
+
+	b->Type			= TYPE_BUS_PCIe;
+	b->m_wMaxReqSize	= SAA_DEVICE_MAXREQUESTSIZE;
+
+	b->m_pdwSetRing		= (u8 *)(dev->bmmio +
+		((u32)dev->busdesc.CommandRing));
+
+	b->m_dwSizeSetRing	= SAA_DEVICE_BUFFERBLOCKSIZE;
+
+	b->m_pdwGetRing		= (u8 *)(dev->bmmio +
+		((u32)dev->busdesc.ResponseRing));
+
+	b->m_dwSizeGetRing	= SAA_DEVICE_BUFFERBLOCKSIZE;
+
+	b->m_pdwSetWritePos	= (u32 *)((u8 *)(dev->bmmio +
+		((u32)dev->intfdesc.BARLocation) + (2 * sizeof(u64))));
+
+	b->m_pdwSetReadPos	= (u32 *)((u8 *)b->m_pdwSetWritePos +
+		1 * sizeof(u32));
+
+	b->m_pdwGetWritePos	= (u32 *)((u8 *)b->m_pdwSetWritePos +
+		2 * sizeof(u32));
+
+	b->m_pdwGetReadPos	= (u32 *)((u8 *)b->m_pdwSetWritePos +
+		3 * sizeof(u32));
+
+	return 0;
+}
+
+void saa7164_bus_dump(struct saa7164_dev *dev)
+{
+	tmComResBusInfo_t *b = &dev->bus;
+
+	dprintk(DBGLVL_BUS, "Dumping the bus structure:\n");
+	dprintk(DBGLVL_BUS, " .type             = %d\n", b->Type);
+	dprintk(DBGLVL_BUS, " .dev->bmmio       = 0x%p\n", dev->bmmio);
+	dprintk(DBGLVL_BUS, " .m_wMaxReqSize    = 0x%x\n", b->m_wMaxReqSize);
+	dprintk(DBGLVL_BUS, " .m_pdwSetRing     = 0x%p\n", b->m_pdwSetRing);
+	dprintk(DBGLVL_BUS, " .m_dwSizeSetRing  = 0x%x\n", b->m_dwSizeSetRing);
+	dprintk(DBGLVL_BUS, " .m_pdwGetRing     = 0x%p\n", b->m_pdwGetRing);
+	dprintk(DBGLVL_BUS, " .m_dwSizeGetRing  = 0x%x\n", b->m_dwSizeGetRing);
+
+	dprintk(DBGLVL_BUS, " .m_pdwSetWritePos = 0x%p (0x%08x)\n",
+		b->m_pdwSetWritePos, *b->m_pdwSetWritePos);
+
+	dprintk(DBGLVL_BUS, " .m_pdwSetReadPos  = 0x%p (0x%08x)\n",
+		b->m_pdwSetReadPos, *b->m_pdwSetReadPos);
+
+	dprintk(DBGLVL_BUS, " .m_pdwGetWritePos = 0x%p (0x%08x)\n",
+		b->m_pdwGetWritePos, *b->m_pdwGetWritePos);
+
+	dprintk(DBGLVL_BUS, " .m_pdwGetReadPos  = 0x%p (0x%08x)\n",
+		b->m_pdwGetReadPos, *b->m_pdwGetReadPos);
+}
+
+void saa7164_bus_dumpmsg(struct saa7164_dev *dev, tmComResInfo_t* m, void *buf)
+{
+	dprintk(DBGLVL_BUS, "Dumping msg structure:\n");
+	dprintk(DBGLVL_BUS, " .id               = %d\n",   m->id);
+	dprintk(DBGLVL_BUS, " .flags            = 0x%x\n", m->flags);
+	dprintk(DBGLVL_BUS, " .size             = 0x%x\n", m->size);
+	dprintk(DBGLVL_BUS, " .command          = 0x%x\n", m->command);
+	dprintk(DBGLVL_BUS, " .controlselector  = 0x%x\n", m->controlselector);
+	dprintk(DBGLVL_BUS, " .seqno            = %d\n",   m->seqno);
+	if (buf)
+		dprintk(DBGLVL_BUS, " .buffer (ignored)\n");
+}
+
+/*
+ * Places a command or a response on the bus. The implementation does not
+ * know if it is a command or a response it just places the data on the
+ * bus depending on the bus information given in the tmComResBusInfo_t
+ * structure. If the command or response does not fit into the bus ring
+ * buffer it will be refused.
+ *
+ * Return Value:
+ *  SAA_OK     The function executed successfully.
+ *  < 0        One or more members are not initialized.
+ */
+int saa7164_bus_set(struct saa7164_dev *dev, tmComResInfo_t* msg, void *buf)
+{
+	tmComResBusInfo_t *bus = &dev->bus;
+	u32 bytes_to_write, read_distance, timeout, curr_srp, curr_swp;
+	u32 new_swp, space_rem;
+	int ret = SAA_ERR_BAD_PARAMETER;
+
+	if (!msg) {
+		printk(KERN_ERR "%s() !msg\n", __func__);
+		return SAA_ERR_BAD_PARAMETER;
+	}
+
+	dprintk(DBGLVL_BUS, "%s()\n", __func__);
+
+	msg->size = cpu_to_le16(msg->size);
+	msg->command = cpu_to_le16(msg->command);
+	msg->controlselector = cpu_to_le16(msg->controlselector);
+
+	if (msg->size > dev->bus.m_wMaxReqSize) {
+		printk(KERN_ERR "%s() Exceeded dev->bus.m_wMaxReqSize\n",
+			__func__);
+		return SAA_ERR_BAD_PARAMETER;
+	}
+
+	if ((msg->size > 0) && (buf == 0)) {
+		printk(KERN_ERR "%s() Missing message buffer\n", __func__);
+		return SAA_ERR_BAD_PARAMETER;
+	}
+
+	/* Lock the bus from any other access */
+	mutex_lock(&bus->lock);
+
+	bytes_to_write = sizeof(*msg) + msg->size;
+	read_distance = 0;
+	timeout = SAA_BUS_TIMEOUT;
+	curr_srp = le32_to_cpu(*bus->m_pdwSetReadPos);
+	curr_swp = le32_to_cpu(*bus->m_pdwSetWritePos);
+
+	/* Deal with ring wrapping issues */
+	if (curr_srp > curr_swp)
+		/* The ring has not wrapped yet */
+		read_distance = curr_srp - curr_swp;
+	else
+		/* Deal with the wrapped ring */
+		read_distance = (curr_srp + bus->m_dwSizeSetRing) - curr_swp;
+
+	dprintk(DBGLVL_BUS, "%s() bytes_to_write = %d\n", __func__,
+		bytes_to_write);
+
+	dprintk(DBGLVL_BUS, "%s() read_distance = %d\n", __func__,
+		read_distance);
+
+	dprintk(DBGLVL_BUS, "%s() curr_srp = %x\n", __func__, curr_srp);
+	dprintk(DBGLVL_BUS, "%s() curr_swp = %x\n", __func__, curr_swp);
+
+	/* Process the msg and write the content onto the bus */
+	while (bytes_to_write >= read_distance) {
+
+		if (timeout-- == 0) {
+			printk(KERN_ERR "%s() bus timeout\n", __func__);
+			ret = SAA_ERR_NO_RESOURCES;
+			goto out;
+		}
+
+		/* TODO: Review this delay, efficient? */
+		/* Wait, allowing the hardware fetch time */
+		mdelay(1);
+
+		/* Check the space usage again */
+		curr_srp = le32_to_cpu(*bus->m_pdwSetReadPos);
+
+		/* Deal with ring wrapping issues */
+		if (curr_srp > curr_swp)
+			/* Read didn't wrap around the buffer */
+			read_distance = curr_srp - curr_swp;
+		else
+			/* Deal with the wrapped ring */
+			read_distance = (curr_srp + bus->m_dwSizeSetRing) -
+				curr_swp;
+
+	}
+
+	/* Calculate the new write position */
+	new_swp = curr_swp + bytes_to_write;
+
+	dprintk(DBGLVL_BUS, "%s() new_swp = %x\n", __func__, new_swp);
+	dprintk(DBGLVL_BUS, "%s() bus->m_dwSizeSetRing = %x\n", __func__,
+		bus->m_dwSizeSetRing);
+
+	/* Mental Note: line 462 tmmhComResBusPCIe.cpp */
+
+	/* Check if we're going to wrap again */
+	if (new_swp > bus->m_dwSizeSetRing) {
+
+		/* Ring wraps */
+		new_swp -= bus->m_dwSizeSetRing;
+
+		space_rem = bus->m_dwSizeSetRing - curr_swp;
+
+		dprintk(DBGLVL_BUS, "%s() space_rem = %x\n", __func__,
+			space_rem);
+
+		dprintk(DBGLVL_BUS, "%s() sizeof(*msg) = %d\n", __func__,
+			(u32)sizeof(*msg));
+
+		if (space_rem < sizeof(*msg)) {
+			dprintk(DBGLVL_BUS, "%s() tr4\n", __func__);
+
+			/* Split the msg into pieces as the ring wraps */
+			memcpy(bus->m_pdwSetRing + curr_swp, msg, space_rem);
+			memcpy(bus->m_pdwSetRing, (u8 *)msg + space_rem,
+				sizeof(*msg) - space_rem);
+
+			memcpy(bus->m_pdwSetRing + sizeof(*msg) - space_rem,
+				buf, msg->size);
+
+		} else if (space_rem == sizeof(*msg)) {
+			dprintk(DBGLVL_BUS, "%s() tr5\n", __func__);
+
+			/* Additional data at the beginning of the ring */
+			memcpy(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));
+			memcpy(bus->m_pdwSetRing, buf, msg->size);
+
+		} else {
+			/* Additional data wraps around the ring */
+			memcpy(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));
+			if (msg->size > 0) {
+				memcpy(bus->m_pdwSetRing + curr_swp +
+					sizeof(*msg), buf, space_rem -
+					sizeof(*msg));
+				memcpy(bus->m_pdwSetRing, (u8 *)buf +
+					space_rem - sizeof(*msg),
+					bytes_to_write - space_rem);
+			}
+
+		}
+
+	} /* (new_swp > bus->m_dwSizeSetRing) */
+	else {
+		dprintk(DBGLVL_BUS, "%s() tr6\n", __func__);
+
+		/* The ring buffer doesn't wrap, two simple copies */
+		memcpy(bus->m_pdwSetRing + curr_swp, msg, sizeof(*msg));
+		memcpy(bus->m_pdwSetRing + curr_swp + sizeof(*msg), buf,
+			msg->size);
+	}
+
+	dprintk(DBGLVL_BUS, "%s() new_swp = %x\n", __func__, new_swp);
+
+	/* TODO: Convert all of the direct PCI writes into
+	 * saa7164_writel/b calls for consistency.
+	 */
+
+	/* Update the bus write position */
+	*bus->m_pdwSetWritePos = cpu_to_le32(new_swp);
+	ret = SAA_OK;
+
+out:
+	mutex_unlock(&bus->lock);
+	return ret;
+}
+
+/*
+ * Receive a command or a response from the bus. The implementation does not
+ * know if it is a command or a response it simply dequeues the data,
+ * depending on the bus information given in the tmComResBusInfo_t structure.
+ *
+ * Return Value:
+ *  0          The function executed successfully.
+ *  < 0        One or more members are not initialized.
+ */
+int saa7164_bus_get(struct saa7164_dev *dev, tmComResInfo_t* msg, void *buf,
+	int peekonly)
+{
+	tmComResBusInfo_t *bus = &dev->bus;
+	u32 bytes_to_read, write_distance, curr_grp, curr_gwp,
+		new_grp, buf_size, space_rem;
+	tmComResInfo_t msg_tmp;
+	int ret = SAA_ERR_BAD_PARAMETER;
+
+	if (msg == 0)
+		return ret;
+
+	if (msg->size > dev->bus.m_wMaxReqSize) {
+		printk(KERN_ERR "%s() Exceeded dev->bus.m_wMaxReqSize\n",
+			__func__);
+		return ret;
+	}
+
+	if ((peekonly == 0) && (msg->size > 0) && (buf == 0)) {
+		printk(KERN_ERR
+			"%s() Missing msg buf, size should be %d bytes\n",
+			__func__, msg->size);
+		return ret;
+	}
+
+	mutex_lock(&bus->lock);
+
+	/* Peek the bus to see if a msg exists, if it's not what we're expecting
+	 * then return cleanly else read the message from the bus.
+	 */
+	curr_gwp = le32_to_cpu(*bus->m_pdwGetWritePos);
+	curr_grp = le32_to_cpu(*bus->m_pdwGetReadPos);
+
+	if (curr_gwp == curr_grp) {
+		dprintk(DBGLVL_BUS, "%s() No message on the bus\n", __func__);
+		ret = SAA_ERR_EMPTY;
+		goto out;
+	}
+
+	bytes_to_read = sizeof(*msg);
+
+	/* Calculate write distance to current read position */
+	write_distance = 0;
+	if (curr_gwp >= curr_grp)
+		/* Write doesn't wrap around the ring */
+		write_distance = curr_gwp - curr_grp;
+	else
+		/* Write wraps around the ring */
+		write_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;
+
+	if (bytes_to_read > write_distance) {
+		printk(KERN_ERR "%s() No message/response found\n", __func__);
+		ret = SAA_ERR_INVALID_COMMAND;
+		goto out;
+	}
+
+	/* Calculate the new read position */
+	new_grp = curr_grp + bytes_to_read;
+	if (new_grp > bus->m_dwSizeGetRing) {
+
+		/* Ring wraps */
+		new_grp -= bus->m_dwSizeGetRing;
+		space_rem = bus->m_dwSizeGetRing - curr_grp;
+
+		memcpy(&msg_tmp, bus->m_pdwGetRing + curr_grp, space_rem);
+		memcpy((u8 *)&msg_tmp + space_rem, bus->m_pdwGetRing,
+			bytes_to_read - space_rem);
+
+	} else {
+		/* No wrapping */
+		memcpy(&msg_tmp, bus->m_pdwGetRing + curr_grp, bytes_to_read);
+	}
+
+	/* No need to update the read positions, because this was a peek */
+	/* If the caller specifically want to peek, return */
+	if (peekonly) {
+		memcpy(msg, &msg_tmp, sizeof(*msg));
+		goto peekout;
+	}
+
+	/* Check if the command/response matches what is expected */
+	if ((msg_tmp.id != msg->id) || (msg_tmp.command != msg->command) ||
+		(msg_tmp.controlselector != msg->controlselector) ||
+		(msg_tmp.seqno != msg->seqno) || (msg_tmp.size != msg->size)) {
+
+		printk(KERN_ERR "%s() Unexpected msg miss-match\n", __func__);
+		saa7164_bus_dumpmsg(dev, msg, buf);
+		saa7164_bus_dumpmsg(dev, &msg_tmp, 0);
+		ret = SAA_ERR_INVALID_COMMAND;
+		goto out;
+	}
+
+	/* Get the actual command and response from the bus */
+	buf_size = msg->size;
+
+	bytes_to_read = sizeof(*msg) + msg->size;
+	/* Calculate write distance to current read position */
+	write_distance = 0;
+	if (curr_gwp >= curr_grp)
+		/* Write doesn't wrap around the ring */
+		write_distance = curr_gwp - curr_grp;
+	else
+		/* Write wraps around the ring */
+		write_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;
+
+	if (bytes_to_read > write_distance) {
+		printk(KERN_ERR "%s() Invalid bus state, missing msg "
+			"or mangled ring, faulty H/W / bad code?\n", __func__);
+		ret = SAA_ERR_INVALID_COMMAND;
+		goto out;
+	}
+
+	/* Calculate the new read position */
+	new_grp = curr_grp + bytes_to_read;
+	if (new_grp > bus->m_dwSizeGetRing) {
+
+		/* Ring wraps */
+		new_grp -= bus->m_dwSizeGetRing;
+		space_rem = bus->m_dwSizeGetRing - curr_grp;
+
+		if (space_rem < sizeof(*msg)) {
+			/* msg wraps around the ring */
+			memcpy(msg, bus->m_pdwGetRing + curr_grp, space_rem);
+			memcpy((u8 *)msg + space_rem, bus->m_pdwGetRing,
+				sizeof(*msg) - space_rem);
+			if (buf)
+				memcpy(buf, bus->m_pdwGetRing + sizeof(*msg) -
+					space_rem, buf_size);
+
+		} else if (space_rem == sizeof(*msg)) {
+			memcpy(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
+			if (buf)
+				memcpy(buf, bus->m_pdwGetRing, buf_size);
+		} else {
+			/* Additional data wraps around the ring */
+			memcpy(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
+			if (buf) {
+				memcpy(buf, bus->m_pdwGetRing + curr_grp +
+					sizeof(*msg), space_rem - sizeof(*msg));
+				memcpy(buf + space_rem - sizeof(*msg),
+					bus->m_pdwGetRing, bytes_to_read -
+					space_rem);
+			}
+
+		}
+
+	} else {
+		/* No wrapping */
+		memcpy(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));
+		if (buf)
+			memcpy(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),
+				buf_size);
+	}
+
+	/* Update the read positions, adjusting the ring */
+	*bus->m_pdwGetReadPos = cpu_to_le32(new_grp);
+
+peekout:
+	msg->size = le16_to_cpu(msg->size);
+	msg->command = le16_to_cpu(msg->command);
+	msg->controlselector = le16_to_cpu(msg->controlselector);
+	ret = SAA_OK;
+out:
+	mutex_unlock(&bus->lock);
+	return ret;
+}
+
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-cards.c linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-cards.c
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-cards.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-cards.c	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,624 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include "saa7164.h"
+
+/* The Bridge API needs to understand register widths (in bytes) for the
+ * attached I2C devices, so we can simplify the virtual i2c mechansms
+ * and keep the -i2c.c implementation clean.
+ */
+#define REGLEN_8bit	1
+#define REGLEN_16bit	2
+
+struct saa7164_board saa7164_boards[] = {
+	[SAA7164_BOARD_UNKNOWN] = {
+		/* Bridge will not load any firmware, without knowing
+		 * the rev this would be fatal. */
+		.name		= "Unknown",
+	},
+	[SAA7164_BOARD_UNKNOWN_REV2] = {
+		/* Bridge will load the v2 f/w and dump descriptors */
+		/* Required during new board bringup */
+		.name		= "Generic Rev2",
+		.chiprev	= SAA7164_CHIP_REV2,
+	},
+	[SAA7164_BOARD_UNKNOWN_REV3] = {
+		/* Bridge will load the v2 f/w and dump descriptors */
+		/* Required during new board bringup */
+		.name		= "Generic Rev3",
+		.chiprev	= SAA7164_CHIP_REV3,
+	},
+	[SAA7164_BOARD_HAUPPAUGE_HVR2200] = {
+		.name		= "Hauppauge WinTV-HVR2200",
+		.porta		= SAA7164_MPEG_DVB,
+		.portb		= SAA7164_MPEG_DVB,
+		.chiprev	= SAA7164_CHIP_REV3,
+		.unit		= {{
+			.id		= 0x1d,
+			.type		= SAA7164_UNIT_EEPROM,
+			.name		= "4K EEPROM",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_0,
+			.i2c_bus_addr	= 0xa0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x04,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x1b,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x1e,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "TDA10048-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0x10 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x1f,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "TDA10048-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0x12 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		} },
+	},
+	[SAA7164_BOARD_HAUPPAUGE_HVR2200_2] = {
+		.name		= "Hauppauge WinTV-HVR2200",
+		.porta		= SAA7164_MPEG_DVB,
+		.portb		= SAA7164_MPEG_DVB,
+		.chiprev	= SAA7164_CHIP_REV2,
+		.unit		= {{
+			.id		= 0x06,
+			.type		= SAA7164_UNIT_EEPROM,
+			.name		= "4K EEPROM",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_0,
+			.i2c_bus_addr	= 0xa0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x04,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x05,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "TDA10048-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0x10 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x1e,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x1f,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "TDA10048-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0x12 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		} },
+	},
+	[SAA7164_BOARD_HAUPPAUGE_HVR2200_3] = {
+		.name		= "Hauppauge WinTV-HVR2200",
+		.porta		= SAA7164_MPEG_DVB,
+		.portb		= SAA7164_MPEG_DVB,
+		.chiprev	= SAA7164_CHIP_REV2,
+		.unit		= {{
+			.id		= 0x1d,
+			.type		= SAA7164_UNIT_EEPROM,
+			.name		= "4K EEPROM",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_0,
+			.i2c_bus_addr	= 0xa0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x04,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x05,
+			.type		= SAA7164_UNIT_ANALOG_DEMODULATOR,
+			.name		= "TDA8290-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0x84 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x1b,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x1c,
+			.type		= SAA7164_UNIT_ANALOG_DEMODULATOR,
+			.name		= "TDA8290-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0x84 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x1e,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "TDA10048-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0x10 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x1f,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "TDA10048-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0x12 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		} },
+	},
+	[SAA7164_BOARD_HAUPPAUGE_HVR2250] = {
+		.name		= "Hauppauge WinTV-HVR2250",
+		.porta		= SAA7164_MPEG_DVB,
+		.portb		= SAA7164_MPEG_DVB,
+		.chiprev	= SAA7164_CHIP_REV3,
+		.unit		= {{
+			.id		= 0x22,
+			.type		= SAA7164_UNIT_EEPROM,
+			.name		= "4K EEPROM",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_0,
+			.i2c_bus_addr	= 0xa0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x04,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x07,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-1 (TOP)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0x32 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x08,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-1 (QAM)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0x34 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x1e,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x20,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-2 (TOP)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0x32 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x23,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-2 (QAM)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0x34 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		} },
+	},
+	[SAA7164_BOARD_HAUPPAUGE_HVR2250_2] = {
+		.name		= "Hauppauge WinTV-HVR2250",
+		.porta		= SAA7164_MPEG_DVB,
+		.portb		= SAA7164_MPEG_DVB,
+		.chiprev	= SAA7164_CHIP_REV3,
+		.unit		= {{
+			.id		= 0x28,
+			.type		= SAA7164_UNIT_EEPROM,
+			.name		= "4K EEPROM",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_0,
+			.i2c_bus_addr	= 0xa0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x04,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x07,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-1 (TOP)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0x32 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x08,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-1 (QAM)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0x34 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x24,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x26,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-2 (TOP)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0x32 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x29,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-2 (QAM)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0x34 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		} },
+	},
+	[SAA7164_BOARD_HAUPPAUGE_HVR2250_3] = {
+		.name		= "Hauppauge WinTV-HVR2250",
+		.porta		= SAA7164_MPEG_DVB,
+		.portb		= SAA7164_MPEG_DVB,
+		.chiprev	= SAA7164_CHIP_REV3,
+		.unit		= {{
+			.id		= 0x26,
+			.type		= SAA7164_UNIT_EEPROM,
+			.name		= "4K EEPROM",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_0,
+			.i2c_bus_addr	= 0xa0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x04,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-1",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x07,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-1 (TOP)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0x32 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x08,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-1 (QAM)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_1,
+			.i2c_bus_addr	= 0x34 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x22,
+			.type		= SAA7164_UNIT_TUNER,
+			.name		= "TDA18271-2",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0xc0 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x24,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-2 (TOP)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0x32 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		}, {
+			.id		= 0x27,
+			.type		= SAA7164_UNIT_DIGITAL_DEMODULATOR,
+			.name		= "CX24228/S5H1411-2 (QAM)",
+			.i2c_bus_nr	= SAA7164_I2C_BUS_2,
+			.i2c_bus_addr	= 0x34 >> 1,
+			.i2c_reg_len	= REGLEN_8bit,
+		} },
+	},
+};
+const unsigned int saa7164_bcount = ARRAY_SIZE(saa7164_boards);
+
+/* ------------------------------------------------------------------ */
+/* PCI subsystem IDs                                                  */
+
+struct saa7164_subid saa7164_subids[] = {
+	{
+		.subvendor = 0x0070,
+		.subdevice = 0x8880,
+		.card      = SAA7164_BOARD_HAUPPAUGE_HVR2250,
+	}, {
+		.subvendor = 0x0070,
+		.subdevice = 0x8810,
+		.card      = SAA7164_BOARD_HAUPPAUGE_HVR2250,
+	}, {
+		.subvendor = 0x0070,
+		.subdevice = 0x8980,
+		.card      = SAA7164_BOARD_HAUPPAUGE_HVR2200,
+	}, {
+		.subvendor = 0x0070,
+		.subdevice = 0x8900,
+		.card      = SAA7164_BOARD_HAUPPAUGE_HVR2200_2,
+	}, {
+		.subvendor = 0x0070,
+		.subdevice = 0x8901,
+		.card      = SAA7164_BOARD_HAUPPAUGE_HVR2200_3,
+	}, {
+		.subvendor = 0x0070,
+		.subdevice = 0x88A1,
+		.card      = SAA7164_BOARD_HAUPPAUGE_HVR2250_3,
+	}, {
+		.subvendor = 0x0070,
+		.subdevice = 0x8891,
+		.card      = SAA7164_BOARD_HAUPPAUGE_HVR2250_2,
+	}, {
+		.subvendor = 0x0070,
+		.subdevice = 0x8851,
+		.card      = SAA7164_BOARD_HAUPPAUGE_HVR2250_2,
+	},
+};
+const unsigned int saa7164_idcount = ARRAY_SIZE(saa7164_subids);
+
+void saa7164_card_list(struct saa7164_dev *dev)
+{
+	int i;
+
+	if (0 == dev->pci->subsystem_vendor &&
+	    0 == dev->pci->subsystem_device) {
+		printk(KERN_ERR
+			"%s: Board has no valid PCIe Subsystem ID and can't\n"
+			"%s: be autodetected. Pass card=<n> insmod option to\n"
+			"%s: workaround that. Send complaints to the vendor\n"
+			"%s: of the TV card. Best regards,\n"
+			"%s:         -- tux\n",
+			dev->name, dev->name, dev->name, dev->name, dev->name);
+	} else {
+		printk(KERN_ERR
+			"%s: Your board isn't known (yet) to the driver.\n"
+			"%s: Try to pick one of the existing card configs via\n"
+			"%s: card=<n> insmod option.  Updating to the latest\n"
+			"%s: version might help as well.\n",
+			dev->name, dev->name, dev->name, dev->name);
+	}
+
+	printk(KERN_ERR "%s: Here are valid choices for the card=<n> insmod "
+		"option:\n", dev->name);
+
+	for (i = 0; i < saa7164_bcount; i++)
+		printk(KERN_ERR "%s:    card=%d -> %s\n",
+		       dev->name, i, saa7164_boards[i].name);
+}
+
+/* TODO: clean this define up into the -cards.c structs */
+#define PCIEBRIDGE_UNITID 2
+
+void saa7164_gpio_setup(struct saa7164_dev *dev)
+{
+
+
+	switch (dev->board) {
+	case SAA7164_BOARD_HAUPPAUGE_HVR2200:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2200_2:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2200_3:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2250:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2250_2:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2250_3:
+		/*
+		GPIO 2: s5h1411 / tda10048-1 demod reset
+		GPIO 3: s5h1411 / tda10048-2 demod reset
+		GPIO 7: IRBlaster Zilog reset
+		 */
+
+		/* Reset parts by going in and out of reset */
+		saa7164_api_clear_gpiobit(dev, PCIEBRIDGE_UNITID, 2);
+		saa7164_api_clear_gpiobit(dev, PCIEBRIDGE_UNITID, 3);
+
+		msleep(10);
+
+		saa7164_api_set_gpiobit(dev, PCIEBRIDGE_UNITID, 2);
+		saa7164_api_set_gpiobit(dev, PCIEBRIDGE_UNITID, 3);
+		break;
+	}
+
+}
+
+static void hauppauge_eeprom(struct saa7164_dev *dev, u8 *eeprom_data)
+{
+	struct tveeprom tv;
+
+	/* TODO: Assumption: eeprom on bus 0 */
+	tveeprom_hauppauge_analog(&dev->i2c_bus[0].i2c_client, &tv,
+		eeprom_data);
+
+	/* Make sure we support the board model */
+	switch (tv.model) {
+	case 88001:
+		/* Development board - Limit circulation */
+		/* WinTV-HVR2250 (PCIe, Retail, full-height bracket)
+		 * ATSC/QAM (TDA18271/S5H1411) and basic analog, no IR, FM */
+	case 88021:
+		/* WinTV-HVR2250 (PCIe, Retail, full-height bracket)
+		 * ATSC/QAM (TDA18271/S5H1411) and basic analog, MCE CIR, FM */
+		break;
+	case 88041:
+		/* WinTV-HVR2250 (PCIe, Retail, full-height bracket)
+		 * ATSC/QAM (TDA18271/S5H1411) and basic analog, no IR, FM */
+		break;
+	case 88061:
+		/* WinTV-HVR2250 (PCIe, Retail, full-height bracket)
+		 * ATSC/QAM (TDA18271/S5H1411) and basic analog, FM */
+		break;
+	case 89519:
+	case 89609:
+		/* WinTV-HVR2200 (PCIe, Retail, full-height)
+		 * DVB-T (TDA18271/TDA10048) and basic analog, no IR */
+		break;
+	case 89619:
+		/* WinTV-HVR2200 (PCIe, Retail, half-height)
+		 * DVB-T (TDA18271/TDA10048) and basic analog, no IR */
+		break;
+	default:
+		printk(KERN_ERR "%s: Warning: Unknown Hauppauge model #%d\n",
+			dev->name, tv.model);
+		break;
+	}
+
+	printk(KERN_INFO "%s: Hauppauge eeprom: model=%d\n", dev->name,
+		tv.model);
+}
+
+void saa7164_card_setup(struct saa7164_dev *dev)
+{
+	static u8 eeprom[256];
+
+	if (dev->i2c_bus[0].i2c_rc == 0) {
+		if (saa7164_api_read_eeprom(dev, &eeprom[0],
+			sizeof(eeprom)) < 0)
+			return;
+	}
+
+	switch (dev->board) {
+	case SAA7164_BOARD_HAUPPAUGE_HVR2200:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2200_2:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2200_3:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2250:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2250_2:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2250_3:
+		hauppauge_eeprom(dev, &eeprom[0]);
+		break;
+	}
+}
+
+/* With most other drivers, the kernel expects to communicate with subdrivers
+ * through i2c. This bridge does not allow that, it does not expose any direct
+ * access to I2C. Instead we have to communicate through the device f/w for
+ * register access to 'processing units'. Each unit has a unique
+ * id, regardless of how the physical implementation occurs across
+ * the three physical i2c busses. The being said if we want leverge of
+ * the existing kernel drivers for tuners and demods we have to 'speak i2c',
+ * to this bridge implements 3 virtual i2c buses. This is a helper function
+ * for those.
+ *
+ * Description: Translate the kernels notion of an i2c address and bus into
+ * the appropriate unitid.
+ */
+int saa7164_i2caddr_to_unitid(struct saa7164_i2c *bus, int addr)
+{
+	/* For a given bus and i2c device address, return the saa7164 unique
+	 * unitid. < 0 on error */
+
+	struct saa7164_dev *dev = bus->dev;
+	struct saa7164_unit *unit;
+	int i;
+
+	for (i = 0; i < SAA7164_MAX_UNITS; i++) {
+		unit = &saa7164_boards[dev->board].unit[i];
+
+		if (unit->type == SAA7164_UNIT_UNDEFINED)
+			continue;
+		if ((bus->nr == unit->i2c_bus_nr) &&
+			(addr == unit->i2c_bus_addr))
+			return unit->id;
+	}
+
+	return -1;
+}
+
+/* The 7164 API needs to know the i2c register length in advance.
+ * this is a helper function. Based on a specific chip addr and bus return the
+ * reg length.
+ */
+int saa7164_i2caddr_to_reglen(struct saa7164_i2c *bus, int addr)
+{
+	/* For a given bus and i2c device address, return the
+	 * saa7164 registry address width. < 0 on error
+	 */
+
+	struct saa7164_dev *dev = bus->dev;
+	struct saa7164_unit *unit;
+	int i;
+
+	for (i = 0; i < SAA7164_MAX_UNITS; i++) {
+		unit = &saa7164_boards[dev->board].unit[i];
+
+		if (unit->type == SAA7164_UNIT_UNDEFINED)
+			continue;
+
+		if ((bus->nr == unit->i2c_bus_nr) &&
+			(addr == unit->i2c_bus_addr))
+			return unit->i2c_reg_len;
+	}
+
+	return -1;
+}
+/* TODO: implement a 'findeeprom' functio like the above and fix any other
+ * eeprom related todo's in -api.c.
+ */
+
+/* Translate a unitid into a x readable device name, for display purposes.  */
+char *saa7164_unitid_name(struct saa7164_dev *dev, u8 unitid)
+{
+	char *undefed = "UNDEFINED";
+	char *bridge = "BRIDGE";
+	struct saa7164_unit *unit;
+	int i;
+
+	if (unitid == 0)
+		return bridge;
+
+	for (i = 0; i < SAA7164_MAX_UNITS; i++) {
+		unit = &saa7164_boards[dev->board].unit[i];
+
+		if (unit->type == SAA7164_UNIT_UNDEFINED)
+			continue;
+
+		if (unitid == unit->id)
+				return unit->name;
+	}
+
+	return undefed;
+}
+
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-cmd.c linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-cmd.c
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-cmd.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-cmd.c	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,572 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/wait.h>
+
+#include "saa7164.h"
+
+int saa7164_cmd_alloc_seqno(struct saa7164_dev *dev)
+{
+	int i, ret = -1;
+
+	mutex_lock(&dev->lock);
+	for (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {
+		if (dev->cmds[i].inuse == 0) {
+			dev->cmds[i].inuse = 1;
+			dev->cmds[i].signalled = 0;
+			dev->cmds[i].timeout = 0;
+			ret = dev->cmds[i].seqno;
+			break;
+		}
+	}
+	mutex_unlock(&dev->lock);
+
+	return ret;
+}
+
+void saa7164_cmd_free_seqno(struct saa7164_dev *dev, u8 seqno)
+{
+	mutex_lock(&dev->lock);
+	if ((dev->cmds[seqno].inuse == 1) &&
+		(dev->cmds[seqno].seqno == seqno)) {
+		dev->cmds[seqno].inuse = 0;
+		dev->cmds[seqno].signalled = 0;
+		dev->cmds[seqno].timeout = 0;
+	}
+	mutex_unlock(&dev->lock);
+}
+
+void saa7164_cmd_timeout_seqno(struct saa7164_dev *dev, u8 seqno)
+{
+	mutex_lock(&dev->lock);
+	if ((dev->cmds[seqno].inuse == 1) &&
+		(dev->cmds[seqno].seqno == seqno)) {
+		dev->cmds[seqno].timeout = 1;
+	}
+	mutex_unlock(&dev->lock);
+}
+
+u32 saa7164_cmd_timeout_get(struct saa7164_dev *dev, u8 seqno)
+{
+	int ret = 0;
+
+	mutex_lock(&dev->lock);
+	if ((dev->cmds[seqno].inuse == 1) &&
+		(dev->cmds[seqno].seqno == seqno)) {
+		ret = dev->cmds[seqno].timeout;
+	}
+	mutex_unlock(&dev->lock);
+
+	return ret;
+}
+
+/* Commands to the f/w get marshelled to/from this code then onto the PCI
+ * -bus/c running buffer. */
+int saa7164_irq_dequeue(struct saa7164_dev *dev)
+{
+	int ret = SAA_OK;
+	u32 timeout;
+	wait_queue_head_t *q = 0;
+	dprintk(DBGLVL_CMD, "%s()\n", __func__);
+
+	/* While any outstand message on the bus exists... */
+	do {
+
+		/* Peek the msg bus */
+		tmComResInfo_t tRsp = { 0, 0, 0, 0, 0, 0 };
+		ret = saa7164_bus_get(dev, &tRsp, NULL, 1);
+		if (ret != SAA_OK)
+			break;
+
+		q = &dev->cmds[tRsp.seqno].wait;
+		timeout = saa7164_cmd_timeout_get(dev, tRsp.seqno);
+		dprintk(DBGLVL_CMD, "%s() timeout = %d\n", __func__, timeout);
+		if (!timeout) {
+			dprintk(DBGLVL_CMD,
+				"%s() signalled seqno(%d) (for dequeue)\n",
+				__func__, tRsp.seqno);
+			dev->cmds[tRsp.seqno].signalled = 1;
+			wake_up(q);
+		} else {
+			printk(KERN_ERR
+				"%s() found timed out command on the bus\n",
+					__func__);
+		}
+	} while (0);
+
+	return ret;
+}
+
+/* Commands to the f/w get marshelled to/from this code then onto the PCI
+ * -bus/c running buffer. */
+int saa7164_cmd_dequeue(struct saa7164_dev *dev)
+{
+	int loop = 1;
+	int ret;
+	u32 timeout;
+	wait_queue_head_t *q = 0;
+	u8 tmp[512];
+	dprintk(DBGLVL_CMD, "%s()\n", __func__);
+
+	while (loop) {
+
+		tmComResInfo_t tRsp = { 0, 0, 0, 0, 0, 0 };
+		ret = saa7164_bus_get(dev, &tRsp, NULL, 1);
+		if (ret == SAA_ERR_EMPTY)
+			return SAA_OK;
+
+		if (ret != SAA_OK)
+			return ret;
+
+		q = &dev->cmds[tRsp.seqno].wait;
+		timeout = saa7164_cmd_timeout_get(dev, tRsp.seqno);
+		dprintk(DBGLVL_CMD, "%s() timeout = %d\n", __func__, timeout);
+		if (timeout) {
+			printk(KERN_ERR "found timed out command on the bus\n");
+
+			/* Clean the bus */
+			ret = saa7164_bus_get(dev, &tRsp, &tmp, 0);
+			printk(KERN_ERR "ret = %x\n", ret);
+			if (ret == SAA_ERR_EMPTY)
+				/* Someone else already fetched the response */
+				return SAA_OK;
+
+			if (ret != SAA_OK)
+				return ret;
+
+			if (tRsp.flags & PVC_CMDFLAG_CONTINUE)
+				printk(KERN_ERR "split response\n");
+			else
+				saa7164_cmd_free_seqno(dev, tRsp.seqno);
+
+			printk(KERN_ERR " timeout continue\n");
+			continue;
+		}
+
+		dprintk(DBGLVL_CMD, "%s() signalled seqno(%d) (for dequeue)\n",
+			__func__, tRsp.seqno);
+		dev->cmds[tRsp.seqno].signalled = 1;
+		wake_up(q);
+		return SAA_OK;
+	}
+
+	return SAA_OK;
+}
+
+int saa7164_cmd_set(struct saa7164_dev *dev, tmComResInfo_t* msg, void *buf)
+{
+	tmComResBusInfo_t *bus = &dev->bus;
+	u8 cmd_sent;
+	u16 size, idx;
+	u32 cmds;
+	void *tmp;
+	int ret = -1;
+
+	if (!msg) {
+		printk(KERN_ERR "%s() !msg\n", __func__);
+		return SAA_ERR_BAD_PARAMETER;
+	}
+
+	mutex_lock(&dev->cmds[msg->id].lock);
+
+	size = msg->size;
+	idx = 0;
+	cmds = size / bus->m_wMaxReqSize;
+	if (size % bus->m_wMaxReqSize == 0)
+		cmds -= 1;
+
+	cmd_sent = 0;
+
+	/* Split the request into smaller chunks */
+	for (idx = 0; idx < cmds; idx++) {
+
+		msg->flags |= SAA_CMDFLAG_CONTINUE;
+		msg->size = bus->m_wMaxReqSize;
+		tmp = buf + idx * bus->m_wMaxReqSize;
+
+		ret = saa7164_bus_set(dev, msg, tmp);
+		if (ret != SAA_OK) {
+			printk(KERN_ERR "%s() set failed %d\n", __func__, ret);
+
+			if (cmd_sent) {
+				ret = SAA_ERR_BUSY;
+				goto out;
+			}
+			ret = SAA_ERR_OVERFLOW;
+			goto out;
+		}
+		cmd_sent = 1;
+	}
+
+	/* If not the last command... */
+	if (idx != 0)
+		msg->flags &= ~SAA_CMDFLAG_CONTINUE;
+
+	msg->size = size - idx * bus->m_wMaxReqSize;
+
+	ret = saa7164_bus_set(dev, msg, buf + idx * bus->m_wMaxReqSize);
+	if (ret != SAA_OK) {
+		printk(KERN_ERR "%s() set last failed %d\n", __func__, ret);
+
+		if (cmd_sent) {
+			ret = SAA_ERR_BUSY;
+			goto out;
+		}
+		ret = SAA_ERR_OVERFLOW;
+		goto out;
+	}
+	ret = SAA_OK;
+
+out:
+	mutex_unlock(&dev->cmds[msg->id].lock);
+	return ret;
+}
+
+/* Wait for a signal event, without holding a mutex. Either return TIMEOUT if
+ * the event never occured, or SAA_OK if it was signaled during the wait.
+ */
+int saa7164_cmd_wait(struct saa7164_dev *dev, u8 seqno)
+{
+	wait_queue_head_t *q = 0;
+	int ret = SAA_BUS_TIMEOUT;
+	unsigned long stamp;
+	int r;
+
+	if (saa_debug >= 4)
+		saa7164_bus_dump(dev);
+
+	dprintk(DBGLVL_CMD, "%s(seqno=%d)\n", __func__, seqno);
+
+	mutex_lock(&dev->lock);
+	if ((dev->cmds[seqno].inuse == 1) &&
+		(dev->cmds[seqno].seqno == seqno)) {
+		q = &dev->cmds[seqno].wait;
+	}
+	mutex_unlock(&dev->lock);
+
+	if (q) {
+		/* If we haven't been signalled we need to wait */
+		if (dev->cmds[seqno].signalled == 0) {
+			stamp = jiffies;
+			dprintk(DBGLVL_CMD,
+				"%s(seqno=%d) Waiting (signalled=%d)\n",
+				__func__, seqno, dev->cmds[seqno].signalled);
+
+			/* Wait for signalled to be flagged or timeout */
+			/* In a highly stressed system this can easily extend
+			 * into multiple seconds before the deferred worker
+			 * is scheduled, and we're woken up via signal.
+			 * We typically are signalled in < 50ms but it can
+			 * take MUCH longer.
+			 */
+			wait_event_timeout(*q, dev->cmds[seqno].signalled, (HZ * waitsecs));
+			r = time_before(jiffies, stamp + (HZ * waitsecs));
+			if (r)
+				ret = SAA_OK;
+			else
+				saa7164_cmd_timeout_seqno(dev, seqno);
+
+			dprintk(DBGLVL_CMD, "%s(seqno=%d) Waiting res = %d "
+				"(signalled=%d)\n", __func__, seqno, r,
+				dev->cmds[seqno].signalled);
+		} else
+			ret = SAA_OK;
+	} else
+		printk(KERN_ERR "%s(seqno=%d) seqno is invalid\n",
+			__func__, seqno);
+
+	return ret;
+}
+
+void saa7164_cmd_signal(struct saa7164_dev *dev, u8 seqno)
+{
+	int i;
+	dprintk(DBGLVL_CMD, "%s()\n", __func__);
+
+	mutex_lock(&dev->lock);
+	for (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {
+		if (dev->cmds[i].inuse == 1) {
+			dprintk(DBGLVL_CMD,
+				"seqno %d inuse, sig = %d, t/out = %d\n",
+				dev->cmds[i].seqno,
+				dev->cmds[i].signalled,
+				dev->cmds[i].timeout);
+		}
+	}
+
+	for (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {
+		if ((dev->cmds[i].inuse == 1) && ((i == 0) ||
+			(dev->cmds[i].signalled) || (dev->cmds[i].timeout))) {
+			dprintk(DBGLVL_CMD, "%s(seqno=%d) calling wake_up\n",
+				__func__, i);
+			dev->cmds[i].signalled = 1;
+			wake_up(&dev->cmds[i].wait);
+		}
+	}
+	mutex_unlock(&dev->lock);
+}
+
+int saa7164_cmd_send(struct saa7164_dev *dev, u8 id, tmComResCmd_t command,
+	u16 controlselector, u16 size, void *buf)
+{
+	tmComResInfo_t command_t, *pcommand_t;
+	tmComResInfo_t response_t, *presponse_t;
+	u8 errdata[256];
+	u16 resp_dsize;
+	u16 data_recd;
+	u32 loop;
+	int ret;
+	int safety = 0;
+
+	dprintk(DBGLVL_CMD, "%s(unitid = %s (%d) , command = 0x%x, "
+		"sel = 0x%x)\n", __func__, saa7164_unitid_name(dev, id), id,
+		command, controlselector);
+
+	if ((size == 0) || (buf == 0)) {
+		printk(KERN_ERR "%s() Invalid param\n", __func__);
+		return SAA_ERR_BAD_PARAMETER;
+	}
+
+	/* Prepare some basic command/response structures */
+	memset(&command_t, 0, sizeof(command_t));
+	memset(&response_t, 0, sizeof(&response_t));
+	pcommand_t = &command_t;
+	presponse_t = &response_t;
+	command_t.id = id;
+	command_t.command = command;
+	command_t.controlselector = controlselector;
+	command_t.size = size;
+
+	/* Allocate a unique sequence number */
+	ret = saa7164_cmd_alloc_seqno(dev);
+	if (ret < 0) {
+		printk(KERN_ERR "%s() No free sequences\n", __func__);
+		ret = SAA_ERR_NO_RESOURCES;
+		goto out;
+	}
+
+	command_t.seqno = (u8)ret;
+
+	/* Send Command */
+	resp_dsize = size;
+	pcommand_t->size = size;
+
+	dprintk(DBGLVL_CMD, "%s() pcommand_t.seqno = %d\n",
+		__func__, pcommand_t->seqno);
+
+	dprintk(DBGLVL_CMD, "%s() pcommand_t.size = %d\n",
+		__func__, pcommand_t->size);
+
+	ret = saa7164_cmd_set(dev, pcommand_t, buf);
+	if (ret != SAA_OK) {
+		printk(KERN_ERR "%s() set command failed %d\n", __func__, ret);
+
+		if (ret != SAA_ERR_BUSY)
+			saa7164_cmd_free_seqno(dev, pcommand_t->seqno);
+		else
+			/* Flag a timeout, because at least one
+			 * command was sent */
+			saa7164_cmd_timeout_seqno(dev, pcommand_t->seqno);
+
+		goto out;
+	}
+
+	/* With split responses we have to collect the msgs piece by piece */
+	data_recd = 0;
+	loop = 1;
+	while (loop) {
+		dprintk(DBGLVL_CMD, "%s() loop\n", __func__);
+
+		ret = saa7164_cmd_wait(dev, pcommand_t->seqno);
+		dprintk(DBGLVL_CMD, "%s() loop ret = %d\n", __func__, ret);
+
+		/* if power is down and this is not a power command ... */
+
+		if (ret == SAA_BUS_TIMEOUT) {
+			printk(KERN_ERR "Event timed out\n");
+			saa7164_cmd_timeout_seqno(dev, pcommand_t->seqno);
+			return ret;
+		}
+
+		if (ret != SAA_OK) {
+			printk(KERN_ERR "spurious error\n");
+			return ret;
+		}
+
+		/* Peek response */
+		ret = saa7164_bus_get(dev, presponse_t, NULL, 1);
+		if (ret == SAA_ERR_EMPTY) {
+			dprintk(4, "%s() SAA_ERR_EMPTY\n", __func__);
+			continue;
+		}
+		if (ret != SAA_OK) {
+			printk(KERN_ERR "peek failed\n");
+			return ret;
+		}
+
+		dprintk(DBGLVL_CMD, "%s() presponse_t->seqno = %d\n",
+			__func__, presponse_t->seqno);
+
+		dprintk(DBGLVL_CMD, "%s() presponse_t->flags = 0x%x\n",
+			__func__, presponse_t->flags);
+
+		dprintk(DBGLVL_CMD, "%s() presponse_t->size = %d\n",
+			__func__, presponse_t->size);
+
+		/* Check if the response was for our command */
+		if (presponse_t->seqno != pcommand_t->seqno) {
+
+			dprintk(DBGLVL_CMD,
+				"wrong event: seqno = %d, "
+				"expected seqno = %d, "
+				"will dequeue regardless\n",
+				presponse_t->seqno, pcommand_t->seqno);
+
+			ret = saa7164_cmd_dequeue(dev);
+			if (ret != SAA_OK) {
+				printk(KERN_ERR "dequeue failed, ret = %d\n",
+					ret);
+				if (safety++ > 16) {
+					printk(KERN_ERR
+					"dequeue exceeded, safety exit\n");
+					return SAA_ERR_BUSY;
+				}
+			}
+
+			continue;
+		}
+
+		if ((presponse_t->flags & PVC_RESPONSEFLAG_ERROR) != 0) {
+
+			memset(&errdata[0], 0, sizeof(errdata));
+
+			ret = saa7164_bus_get(dev, presponse_t, &errdata[0], 0);
+			if (ret != SAA_OK) {
+				printk(KERN_ERR "get error(2)\n");
+				return ret;
+			}
+
+			saa7164_cmd_free_seqno(dev, pcommand_t->seqno);
+
+			dprintk(DBGLVL_CMD, "%s() errdata %02x%02x%02x%02x\n",
+				__func__, errdata[0], errdata[1], errdata[2],
+				errdata[3]);
+
+			/* Map error codes */
+			dprintk(DBGLVL_CMD, "%s() cmd, error code  = 0x%x\n",
+				__func__, errdata[0]);
+
+			switch (errdata[0]) {
+			case PVC_ERRORCODE_INVALID_COMMAND:
+				dprintk(DBGLVL_CMD, "%s() INVALID_COMMAND\n",
+					__func__);
+				ret = SAA_ERR_INVALID_COMMAND;
+				break;
+			case PVC_ERRORCODE_INVALID_DATA:
+				dprintk(DBGLVL_CMD, "%s() INVALID_DATA\n",
+					__func__);
+				ret = SAA_ERR_BAD_PARAMETER;
+				break;
+			case PVC_ERRORCODE_TIMEOUT:
+				dprintk(DBGLVL_CMD, "%s() TIMEOUT\n", __func__);
+				ret = SAA_ERR_TIMEOUT;
+				break;
+			case PVC_ERRORCODE_NAK:
+				dprintk(DBGLVL_CMD, "%s() NAK\n", __func__);
+				ret = SAA_ERR_NULL_PACKET;
+				break;
+			case PVC_ERRORCODE_UNKNOWN:
+			case PVC_ERRORCODE_INVALID_CONTROL:
+				dprintk(DBGLVL_CMD,
+					"%s() UNKNOWN OR INVALID CONTROL\n",
+					__func__);
+			default:
+				dprintk(DBGLVL_CMD, "%s() UNKNOWN\n", __func__);
+				ret = SAA_ERR_NOT_SUPPORTED;
+			}
+
+			/* See of other commands are on the bus */
+			if (saa7164_cmd_dequeue(dev) != SAA_OK)
+				printk(KERN_ERR "dequeue(2) failed\n");
+
+			return ret;
+		}
+
+		/* If response is invalid */
+		if ((presponse_t->id != pcommand_t->id) ||
+			(presponse_t->command != pcommand_t->command) ||
+			(presponse_t->controlselector !=
+				pcommand_t->controlselector) ||
+			(((resp_dsize - data_recd) != presponse_t->size) &&
+				!(presponse_t->flags & PVC_CMDFLAG_CONTINUE)) ||
+			((resp_dsize - data_recd) < presponse_t->size)) {
+
+			/* Invalid */
+			dprintk(DBGLVL_CMD, "%s() Invalid\n", __func__);
+			ret = saa7164_bus_get(dev, presponse_t, 0, 0);
+			if (ret != SAA_OK) {
+				printk(KERN_ERR "get failed\n");
+				return ret;
+			}
+
+			/* See of other commands are on the bus */
+			if (saa7164_cmd_dequeue(dev) != SAA_OK)
+				printk(KERN_ERR "dequeue(3) failed\n");
+			continue;
+		}
+
+		/* OK, now we're actually getting out correct response */
+		ret = saa7164_bus_get(dev, presponse_t, buf + data_recd, 0);
+		if (ret != SAA_OK) {
+			printk(KERN_ERR "get failed\n");
+			return ret;
+		}
+
+		data_recd = presponse_t->size + data_recd;
+		if (resp_dsize == data_recd) {
+			dprintk(DBGLVL_CMD, "%s() Resp recd\n", __func__);
+			break;
+		}
+
+		/* See of other commands are on the bus */
+		if (saa7164_cmd_dequeue(dev) != SAA_OK)
+			printk(KERN_ERR "dequeue(3) failed\n");
+
+		continue;
+
+	} /* (loop) */
+
+	/* Release the sequence number allocation */
+	saa7164_cmd_free_seqno(dev, pcommand_t->seqno);
+
+	/* if powerdown signal all pending commands */
+
+	dprintk(DBGLVL_CMD, "%s() Calling dequeue then exit\n", __func__);
+
+	/* See of other commands are on the bus */
+	if (saa7164_cmd_dequeue(dev) != SAA_OK)
+		printk(KERN_ERR "dequeue(4) failed\n");
+
+	ret = SAA_OK;
+out:
+	return ret;
+}
+
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-core.c linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-core.c
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-core.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-core.c	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,740 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kmod.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <asm/div64.h>
+
+#include "saa7164.h"
+
+MODULE_DESCRIPTION("Driver for NXP SAA7164 based TV cards");
+MODULE_AUTHOR("Steven Toth <stoth@kernellabs.com>");
+MODULE_LICENSE("GPL");
+
+/*
+  1 Basic
+  2
+  4 i2c
+  8 api
+ 16 cmd
+ 32 bus
+ */
+
+unsigned int saa_debug;
+module_param_named(debug, saa_debug, int, 0644);
+MODULE_PARM_DESC(debug, "enable debug messages");
+
+unsigned int waitsecs = 10;
+module_param(waitsecs, int, 0644);
+MODULE_PARM_DESC(debug, "timeout on firmware messages");
+
+static unsigned int card[]  = {[0 ... (SAA7164_MAXBOARDS - 1)] = UNSET };
+module_param_array(card,  int, NULL, 0444);
+MODULE_PARM_DESC(card, "card type");
+
+static unsigned int saa7164_devcount;
+
+static DEFINE_MUTEX(devlist);
+LIST_HEAD(saa7164_devlist);
+
+#define INT_SIZE 16
+
+static void saa7164_work_cmdhandler(struct work_struct *w)
+{
+	struct saa7164_dev *dev = container_of(w, struct saa7164_dev, workcmd);
+
+	/* Wake up any complete commands */
+	saa7164_irq_dequeue(dev);
+}
+
+static void saa7164_buffer_deliver(struct saa7164_buffer *buf)
+{
+	struct saa7164_tsport *port = buf->port;
+
+	/* Feed the transport payload into the kernel demux */
+	dvb_dmx_swfilter_packets(&port->dvb.demux, (u8 *)buf->cpu,
+		SAA7164_TS_NUMBER_OF_LINES);
+
+}
+
+static irqreturn_t saa7164_irq_ts(struct saa7164_tsport *port)
+{
+	struct saa7164_dev *dev = port->dev;
+	struct saa7164_buffer *buf;
+	struct list_head *c, *n;
+	int wp, i = 0, rp;
+
+	/* Find the current write point from the hardware */
+	wp = saa7164_readl(port->bufcounter);
+	if (wp > (port->hwcfg.buffercount - 1))
+		BUG();
+
+	/* Find the previous buffer to the current write point */
+	if (wp == 0)
+		rp = 7;
+	else
+		rp = wp - 1;
+
+	/* Lookup the WP in the buffer list */
+	/* TODO: turn this into a worker thread */
+	list_for_each_safe(c, n, &port->dmaqueue.list) {
+		buf = list_entry(c, struct saa7164_buffer, list);
+		if (i++ > port->hwcfg.buffercount)
+			BUG();
+
+		if (buf->nr == rp) {
+			/* Found the buffer, deal with it */
+			dprintk(DBGLVL_IRQ, "%s() wp: %d processing: %d\n",
+				__func__, wp, rp);
+			saa7164_buffer_deliver(buf);
+			break;
+		}
+
+	}
+	return 0;
+}
+
+/* Primary IRQ handler and dispatch mechanism */
+static irqreturn_t saa7164_irq(int irq, void *dev_id)
+{
+	struct saa7164_dev *dev = dev_id;
+	u32 intid, intstat[INT_SIZE/4];
+	int i, handled = 0, bit;
+
+	if (dev == 0) {
+		printk(KERN_ERR "%s() No device specified\n", __func__);
+		handled = 0;
+		goto out;
+	}
+
+	/* Check that the hardware is accessable. If the status bytes are
+	 * 0xFF then the device is not accessable, the the IRQ belongs
+	 * to another driver.
+	 * 4 x u32 interrupt registers.
+	 */
+	for (i = 0; i < INT_SIZE/4; i++) {
+
+		/* TODO: Convert into saa7164_readl() */
+		/* Read the 4 hardware interrupt registers */
+		intstat[i] = saa7164_readl(dev->int_status + (i * 4));
+
+		if (intstat[i])
+			handled = 1;
+	}
+	if (handled == 0)
+		goto out;
+
+	/* For each of the HW interrupt registers */
+	for (i = 0; i < INT_SIZE/4; i++) {
+
+		if (intstat[i]) {
+			/* Each function of the board has it's own interruptid.
+			 * Find the function that triggered then call
+			 * it's handler.
+			 */
+			for (bit = 0; bit < 32; bit++) {
+
+				if (((intstat[i] >> bit) & 0x00000001) == 0)
+					continue;
+
+				/* Calculate the interrupt id (0x00 to 0x7f) */
+
+				intid = (i * 32) + bit;
+				if (intid == dev->intfdesc.bInterruptId) {
+					/* A response to an cmd/api call */
+					schedule_work(&dev->workcmd);
+				} else if (intid ==
+					dev->ts1.hwcfg.interruptid) {
+
+					/* Transport path 1 */
+					saa7164_irq_ts(&dev->ts1);
+
+				} else if (intid ==
+					dev->ts2.hwcfg.interruptid) {
+
+					/* Transport path 2 */
+					saa7164_irq_ts(&dev->ts2);
+
+				} else {
+					/* Find the function */
+					dprintk(DBGLVL_IRQ,
+						"%s() unhandled interrupt "
+						"reg 0x%x bit 0x%x "
+						"intid = 0x%x\n",
+						__func__, i, bit, intid);
+				}
+			}
+
+			/* Ack it */
+			saa7164_writel(dev->int_ack + (i * 4), intstat[i]);
+
+		}
+	}
+out:
+	return IRQ_RETVAL(handled);
+}
+
+void saa7164_getfirmwarestatus(struct saa7164_dev *dev)
+{
+	struct saa7164_fw_status *s = &dev->fw_status;
+
+	dev->fw_status.status = saa7164_readl(SAA_DEVICE_SYSINIT_STATUS);
+	dev->fw_status.mode = saa7164_readl(SAA_DEVICE_SYSINIT_MODE);
+	dev->fw_status.spec = saa7164_readl(SAA_DEVICE_SYSINIT_SPEC);
+	dev->fw_status.inst = saa7164_readl(SAA_DEVICE_SYSINIT_INST);
+	dev->fw_status.cpuload = saa7164_readl(SAA_DEVICE_SYSINIT_CPULOAD);
+	dev->fw_status.remainheap =
+		saa7164_readl(SAA_DEVICE_SYSINIT_REMAINHEAP);
+
+	dprintk(1, "Firmware status:\n");
+	dprintk(1, " .status     = 0x%08x\n", s->status);
+	dprintk(1, " .mode       = 0x%08x\n", s->mode);
+	dprintk(1, " .spec       = 0x%08x\n", s->spec);
+	dprintk(1, " .inst       = 0x%08x\n", s->inst);
+	dprintk(1, " .cpuload    = 0x%08x\n", s->cpuload);
+	dprintk(1, " .remainheap = 0x%08x\n", s->remainheap);
+}
+
+u32 saa7164_getcurrentfirmwareversion(struct saa7164_dev *dev)
+{
+	u32 reg;
+
+	reg = saa7164_readl(SAA_DEVICE_VERSION);
+	dprintk(1, "Device running firmware version %d.%d.%d.%d (0x%x)\n",
+		(reg & 0x0000fc00) >> 10,
+		(reg & 0x000003e0) >> 5,
+		(reg & 0x0000001f),
+		(reg & 0xffff0000) >> 16,
+		reg);
+
+	return reg;
+}
+
+/* TODO: Debugging func, remove */
+void saa7164_dumphex16(struct saa7164_dev *dev, u8 *buf, int len)
+{
+	int i;
+
+	printk(KERN_INFO "--------------------> "
+		"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n");
+
+	for (i = 0; i < len; i += 16)
+		printk(KERN_INFO "         [0x%08x] "
+			"%02x %02x %02x %02x %02x %02x %02x %02x "
+			"%02x %02x %02x %02x %02x %02x %02x %02x\n", i,
+		*(buf+i+0), *(buf+i+1), *(buf+i+2), *(buf+i+3),
+		*(buf+i+4), *(buf+i+5), *(buf+i+6), *(buf+i+7),
+		*(buf+i+8), *(buf+i+9), *(buf+i+10), *(buf+i+11),
+		*(buf+i+12), *(buf+i+13), *(buf+i+14), *(buf+i+15));
+}
+
+/* TODO: Debugging func, remove */
+void saa7164_dumpregs(struct saa7164_dev *dev, u32 addr)
+{
+	int i;
+
+	dprintk(1, "--------------------> "
+		"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n");
+
+	for (i = 0; i < 0x100; i += 16)
+		dprintk(1, "region0[0x%08x] = "
+			"%02x %02x %02x %02x %02x %02x %02x %02x"
+			" %02x %02x %02x %02x %02x %02x %02x %02x\n", i,
+			(u8)saa7164_readb(addr + i + 0),
+			(u8)saa7164_readb(addr + i + 1),
+			(u8)saa7164_readb(addr + i + 2),
+			(u8)saa7164_readb(addr + i + 3),
+			(u8)saa7164_readb(addr + i + 4),
+			(u8)saa7164_readb(addr + i + 5),
+			(u8)saa7164_readb(addr + i + 6),
+			(u8)saa7164_readb(addr + i + 7),
+			(u8)saa7164_readb(addr + i + 8),
+			(u8)saa7164_readb(addr + i + 9),
+			(u8)saa7164_readb(addr + i + 10),
+			(u8)saa7164_readb(addr + i + 11),
+			(u8)saa7164_readb(addr + i + 12),
+			(u8)saa7164_readb(addr + i + 13),
+			(u8)saa7164_readb(addr + i + 14),
+			(u8)saa7164_readb(addr + i + 15)
+			);
+}
+
+static void saa7164_dump_hwdesc(struct saa7164_dev *dev)
+{
+	dprintk(1, "@0x%p hwdesc sizeof(tmComResHWDescr_t) = %d bytes\n",
+		&dev->hwdesc, (u32)sizeof(tmComResHWDescr_t));
+
+	dprintk(1, " .bLength = 0x%x\n", dev->hwdesc.bLength);
+	dprintk(1, " .bDescriptorType = 0x%x\n", dev->hwdesc.bDescriptorType);
+	dprintk(1, " .bDescriptorSubtype = 0x%x\n",
+		dev->hwdesc.bDescriptorSubtype);
+
+	dprintk(1, " .bcdSpecVersion = 0x%x\n", dev->hwdesc.bcdSpecVersion);
+	dprintk(1, " .dwClockFrequency = 0x%x\n", dev->hwdesc.dwClockFrequency);
+	dprintk(1, " .dwClockUpdateRes = 0x%x\n", dev->hwdesc.dwClockUpdateRes);
+	dprintk(1, " .bCapabilities = 0x%x\n", dev->hwdesc.bCapabilities);
+	dprintk(1, " .dwDeviceRegistersLocation = 0x%x\n",
+		dev->hwdesc.dwDeviceRegistersLocation);
+
+	dprintk(1, " .dwHostMemoryRegion = 0x%x\n",
+		dev->hwdesc.dwHostMemoryRegion);
+
+	dprintk(1, " .dwHostMemoryRegionSize = 0x%x\n",
+		dev->hwdesc.dwHostMemoryRegionSize);
+
+	dprintk(1, " .dwHostHibernatMemRegion = 0x%x\n",
+		dev->hwdesc.dwHostHibernatMemRegion);
+
+	dprintk(1, " .dwHostHibernatMemRegionSize = 0x%x\n",
+		dev->hwdesc.dwHostHibernatMemRegionSize);
+}
+
+static void saa7164_dump_intfdesc(struct saa7164_dev *dev)
+{
+	dprintk(1, "@0x%p intfdesc "
+		"sizeof(tmComResInterfaceDescr_t) = %d bytes\n",
+		&dev->intfdesc, (u32)sizeof(tmComResInterfaceDescr_t));
+
+	dprintk(1, " .bLength = 0x%x\n", dev->intfdesc.bLength);
+	dprintk(1, " .bDescriptorType = 0x%x\n", dev->intfdesc.bDescriptorType);
+	dprintk(1, " .bDescriptorSubtype = 0x%x\n",
+		dev->intfdesc.bDescriptorSubtype);
+
+	dprintk(1, " .bFlags = 0x%x\n", dev->intfdesc.bFlags);
+	dprintk(1, " .bInterfaceType = 0x%x\n", dev->intfdesc.bInterfaceType);
+	dprintk(1, " .bInterfaceId = 0x%x\n", dev->intfdesc.bInterfaceId);
+	dprintk(1, " .bBaseInterface = 0x%x\n", dev->intfdesc.bBaseInterface);
+	dprintk(1, " .bInterruptId = 0x%x\n", dev->intfdesc.bInterruptId);
+	dprintk(1, " .bDebugInterruptId = 0x%x\n",
+		dev->intfdesc.bDebugInterruptId);
+
+	dprintk(1, " .BARLocation = 0x%x\n", dev->intfdesc.BARLocation);
+}
+
+static void saa7164_dump_busdesc(struct saa7164_dev *dev)
+{
+	dprintk(1, "@0x%p busdesc sizeof(tmComResBusDescr_t) = %d bytes\n",
+		&dev->busdesc, (u32)sizeof(tmComResBusDescr_t));
+
+	dprintk(1, " .CommandRing   = 0x%016Lx\n", dev->busdesc.CommandRing);
+	dprintk(1, " .ResponseRing  = 0x%016Lx\n", dev->busdesc.ResponseRing);
+	dprintk(1, " .CommandWrite  = 0x%x\n", dev->busdesc.CommandWrite);
+	dprintk(1, " .CommandRead   = 0x%x\n", dev->busdesc.CommandRead);
+	dprintk(1, " .ResponseWrite = 0x%x\n", dev->busdesc.ResponseWrite);
+	dprintk(1, " .ResponseRead  = 0x%x\n", dev->busdesc.ResponseRead);
+}
+
+/* Much of the hardware configuration and PCI registers are configured
+ * dynamically depending on firmware. We have to cache some initial
+ * structures then use these to locate other important structures
+ * from PCI space.
+ */
+static void saa7164_get_descriptors(struct saa7164_dev *dev)
+{
+	memcpy(&dev->hwdesc, dev->bmmio, sizeof(tmComResHWDescr_t));
+	memcpy(&dev->intfdesc, dev->bmmio + sizeof(tmComResHWDescr_t),
+		sizeof(tmComResInterfaceDescr_t));
+	memcpy(&dev->busdesc, dev->bmmio + dev->intfdesc.BARLocation,
+		sizeof(tmComResBusDescr_t));
+
+	if (dev->hwdesc.bLength != sizeof(tmComResHWDescr_t)) {
+		printk(KERN_ERR "Structure tmComResHWDescr_t is mangled\n");
+		printk(KERN_ERR "Need %x got %d\n", dev->hwdesc.bLength,
+			(u32)sizeof(tmComResHWDescr_t));
+	} else
+		saa7164_dump_hwdesc(dev);
+
+	if (dev->intfdesc.bLength != sizeof(tmComResInterfaceDescr_t)) {
+		printk(KERN_ERR "struct tmComResInterfaceDescr_t is mangled\n");
+		printk(KERN_ERR "Need %x got %d\n", dev->intfdesc.bLength,
+			(u32)sizeof(tmComResInterfaceDescr_t));
+	} else
+		saa7164_dump_intfdesc(dev);
+
+	saa7164_dump_busdesc(dev);
+}
+
+static int saa7164_pci_quirks(struct saa7164_dev *dev)
+{
+	return 0;
+}
+
+static int get_resources(struct saa7164_dev *dev)
+{
+	if (request_mem_region(pci_resource_start(dev->pci, 0),
+		pci_resource_len(dev->pci, 0), dev->name)) {
+
+		if (request_mem_region(pci_resource_start(dev->pci, 2),
+			pci_resource_len(dev->pci, 2), dev->name))
+			return 0;
+	}
+
+	printk(KERN_ERR "%s: can't get MMIO memory @ 0x%llx or 0x%llx\n",
+		dev->name,
+		(u64)pci_resource_start(dev->pci, 0),
+		(u64)pci_resource_start(dev->pci, 2));
+
+	return -EBUSY;
+}
+
+static int saa7164_dev_setup(struct saa7164_dev *dev)
+{
+	int i;
+
+	mutex_init(&dev->lock);
+	atomic_inc(&dev->refcount);
+	dev->nr = saa7164_devcount++;
+
+	sprintf(dev->name, "saa7164[%d]", dev->nr);
+
+	mutex_lock(&devlist);
+	list_add_tail(&dev->devlist, &saa7164_devlist);
+	mutex_unlock(&devlist);
+
+	/* board config */
+	dev->board = UNSET;
+	if (card[dev->nr] < saa7164_bcount)
+		dev->board = card[dev->nr];
+
+	for (i = 0; UNSET == dev->board  &&  i < saa7164_idcount; i++)
+		if (dev->pci->subsystem_vendor == saa7164_subids[i].subvendor &&
+			dev->pci->subsystem_device ==
+				saa7164_subids[i].subdevice)
+				dev->board = saa7164_subids[i].card;
+
+	if (UNSET == dev->board) {
+		dev->board = SAA7164_BOARD_UNKNOWN;
+		saa7164_card_list(dev);
+	}
+
+	dev->pci_bus  = dev->pci->bus->number;
+	dev->pci_slot = PCI_SLOT(dev->pci->devfn);
+
+	/* I2C Defaults / setup */
+	dev->i2c_bus[0].dev = dev;
+	dev->i2c_bus[0].nr = 0;
+	dev->i2c_bus[1].dev = dev;
+	dev->i2c_bus[1].nr = 1;
+	dev->i2c_bus[2].dev = dev;
+	dev->i2c_bus[2].nr = 2;
+
+	/* Transport port A Defaults / setup */
+	dev->ts1.dev = dev;
+	dev->ts1.nr = 0;
+	mutex_init(&dev->ts1.dvb.lock);
+	INIT_LIST_HEAD(&dev->ts1.dmaqueue.list);
+	INIT_LIST_HEAD(&dev->ts1.dummy_dmaqueue.list);
+	mutex_init(&dev->ts1.dmaqueue_lock);
+	mutex_init(&dev->ts1.dummy_dmaqueue_lock);
+
+	/* Transport port B Defaults / setup */
+	dev->ts2.dev = dev;
+	dev->ts2.nr = 1;
+	mutex_init(&dev->ts2.dvb.lock);
+	INIT_LIST_HEAD(&dev->ts2.dmaqueue.list);
+	INIT_LIST_HEAD(&dev->ts2.dummy_dmaqueue.list);
+	mutex_init(&dev->ts2.dmaqueue_lock);
+	mutex_init(&dev->ts2.dummy_dmaqueue_lock);
+
+	if (get_resources(dev) < 0) {
+		printk(KERN_ERR "CORE %s No more PCIe resources for "
+		       "subsystem: %04x:%04x\n",
+		       dev->name, dev->pci->subsystem_vendor,
+		       dev->pci->subsystem_device);
+
+		saa7164_devcount--;
+		return -ENODEV;
+	}
+
+	/* PCI/e allocations */
+	dev->lmmio = ioremap(pci_resource_start(dev->pci, 0),
+			     pci_resource_len(dev->pci, 0));
+
+	dev->lmmio2 = ioremap(pci_resource_start(dev->pci, 2),
+			     pci_resource_len(dev->pci, 2));
+
+	dev->bmmio = (u8 __iomem *)dev->lmmio;
+	dev->bmmio2 = (u8 __iomem *)dev->lmmio2;
+
+	/* Inerrupt and ack register locations offset of bmmio */
+	dev->int_status = 0x183000 + 0xf80;
+	dev->int_ack = 0x183000 + 0xf90;
+
+	printk(KERN_INFO
+		"CORE %s: subsystem: %04x:%04x, board: %s [card=%d,%s]\n",
+	       dev->name, dev->pci->subsystem_vendor,
+	       dev->pci->subsystem_device, saa7164_boards[dev->board].name,
+	       dev->board, card[dev->nr] == dev->board ?
+	       "insmod option" : "autodetected");
+
+	saa7164_pci_quirks(dev);
+
+	return 0;
+}
+
+static void saa7164_dev_unregister(struct saa7164_dev *dev)
+{
+	dprintk(1, "%s()\n", __func__);
+
+	release_mem_region(pci_resource_start(dev->pci, 0),
+		pci_resource_len(dev->pci, 0));
+
+	release_mem_region(pci_resource_start(dev->pci, 2),
+		pci_resource_len(dev->pci, 2));
+
+	if (!atomic_dec_and_test(&dev->refcount))
+		return;
+
+	iounmap(dev->lmmio);
+	iounmap(dev->lmmio2);
+
+	return;
+}
+
+static int __devinit saa7164_initdev(struct pci_dev *pci_dev,
+				     const struct pci_device_id *pci_id)
+{
+	struct saa7164_dev *dev;
+	int err, i;
+	u32 version;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (NULL == dev)
+		return -ENOMEM;
+
+	/* pci init */
+	dev->pci = pci_dev;
+	if (pci_enable_device(pci_dev)) {
+		err = -EIO;
+		goto fail_free;
+	}
+
+	if (saa7164_dev_setup(dev) < 0) {
+		err = -EINVAL;
+		goto fail_free;
+	}
+
+	/* print pci info */
+	pci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &dev->pci_rev);
+	pci_read_config_byte(pci_dev, PCI_LATENCY_TIMER,  &dev->pci_lat);
+	printk(KERN_INFO "%s/0: found at %s, rev: %d, irq: %d, "
+	       "latency: %d, mmio: 0x%llx\n", dev->name,
+	       pci_name(pci_dev), dev->pci_rev, pci_dev->irq,
+	       dev->pci_lat,
+		(unsigned long long)pci_resource_start(pci_dev, 0));
+
+	pci_set_master(pci_dev);
+	/* TODO */
+	if (!pci_dma_supported(pci_dev, 0xffffffff)) {
+		printk("%s/0: Oops: no 32bit PCI DMA ???\n", dev->name);
+		err = -EIO;
+		goto fail_irq;
+	}
+
+	err = request_irq(pci_dev->irq, saa7164_irq,
+		IRQF_SHARED | IRQF_DISABLED, dev->name, dev);
+	if (err < 0) {
+		printk(KERN_ERR "%s: can't get IRQ %d\n", dev->name,
+			pci_dev->irq);
+		err = -EIO;
+		goto fail_irq;
+	}
+
+	pci_set_drvdata(pci_dev, dev);
+
+	/* Init the internal command list */
+	for (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {
+		dev->cmds[i].seqno = i;
+		dev->cmds[i].inuse = 0;
+		mutex_init(&dev->cmds[i].lock);
+		init_waitqueue_head(&dev->cmds[i].wait);
+	}
+
+	/* We need a deferred interrupt handler for cmd handling */
+	INIT_WORK(&dev->workcmd, saa7164_work_cmdhandler);
+
+	/* Only load the firmware if we know the board */
+	if (dev->board != SAA7164_BOARD_UNKNOWN) {
+
+		err = saa7164_downloadfirmware(dev);
+		if (err < 0) {
+			printk(KERN_ERR
+				"Failed to boot firmware, no features "
+				"registered\n");
+			goto fail_fw;
+		}
+
+		saa7164_get_descriptors(dev);
+		saa7164_dumpregs(dev, 0);
+		saa7164_getcurrentfirmwareversion(dev);
+		saa7164_getfirmwarestatus(dev);
+		err = saa7164_bus_setup(dev);
+		if (err < 0)
+			printk(KERN_ERR
+				"Failed to setup the bus, will continue\n");
+		saa7164_bus_dump(dev);
+
+		/* Ping the running firmware via the command bus and get the
+		 * firmware version, this checks the bus is running OK.
+		 */
+		version = 0;
+		if (saa7164_api_get_fw_version(dev, &version) == SAA_OK)
+			dprintk(1, "Bus is operating correctly using "
+				"version %d.%d.%d.%d (0x%x)\n",
+				(version & 0x0000fc00) >> 10,
+				(version & 0x000003e0) >> 5,
+				(version & 0x0000001f),
+				(version & 0xffff0000) >> 16,
+				version);
+		else
+			printk(KERN_ERR
+				"Failed to communicate with the firmware\n");
+
+		/* Bring up the I2C buses */
+		saa7164_i2c_register(&dev->i2c_bus[0]);
+		saa7164_i2c_register(&dev->i2c_bus[1]);
+		saa7164_i2c_register(&dev->i2c_bus[2]);
+		saa7164_gpio_setup(dev);
+		saa7164_card_setup(dev);
+
+
+		/* Parse the dynamic device configuration, find various
+		 * media endpoints (MPEG, WMV, PS, TS) and cache their
+		 * configuration details into the driver, so we can
+		 * reference them later during simething_register() func,
+		 * interrupt handlers, deferred work handlers etc.
+		 */
+		saa7164_api_enum_subdevs(dev);
+
+		/* Begin to create the video sub-systems and register funcs */
+		if (saa7164_boards[dev->board].porta == SAA7164_MPEG_DVB) {
+			if (saa7164_dvb_register(&dev->ts1) < 0) {
+				printk(KERN_ERR "%s() Failed to register "
+					"dvb adapters on porta\n",
+					__func__);
+			}
+		}
+
+		if (saa7164_boards[dev->board].portb == SAA7164_MPEG_DVB) {
+			if (saa7164_dvb_register(&dev->ts2) < 0) {
+				printk(KERN_ERR"%s() Failed to register "
+					"dvb adapters on portb\n",
+					__func__);
+			}
+		}
+
+	} /* != BOARD_UNKNOWN */
+	else
+		printk(KERN_ERR "%s() Unsupported board detected, "
+			"registering without firmware\n", __func__);
+
+	dprintk(1, "%s() parameter debug = %d\n", __func__, saa_debug);
+	dprintk(1, "%s() parameter waitsecs = %d\n", __func__, waitsecs);
+
+fail_fw:
+	return 0;
+
+fail_irq:
+	saa7164_dev_unregister(dev);
+fail_free:
+	kfree(dev);
+	return err;
+}
+
+static void saa7164_shutdown(struct saa7164_dev *dev)
+{
+	dprintk(1, "%s()\n", __func__);
+}
+
+static void __devexit saa7164_finidev(struct pci_dev *pci_dev)
+{
+	struct saa7164_dev *dev = pci_get_drvdata(pci_dev);
+
+	saa7164_shutdown(dev);
+
+	if (saa7164_boards[dev->board].porta == SAA7164_MPEG_DVB)
+		saa7164_dvb_unregister(&dev->ts1);
+
+	if (saa7164_boards[dev->board].portb == SAA7164_MPEG_DVB)
+		saa7164_dvb_unregister(&dev->ts2);
+
+	saa7164_i2c_unregister(&dev->i2c_bus[0]);
+	saa7164_i2c_unregister(&dev->i2c_bus[1]);
+	saa7164_i2c_unregister(&dev->i2c_bus[2]);
+
+	pci_disable_device(pci_dev);
+
+	/* unregister stuff */
+	free_irq(pci_dev->irq, dev);
+	pci_set_drvdata(pci_dev, NULL);
+
+	mutex_lock(&devlist);
+	list_del(&dev->devlist);
+	mutex_unlock(&devlist);
+
+	saa7164_dev_unregister(dev);
+	kfree(dev);
+}
+
+static struct pci_device_id saa7164_pci_tbl[] = {
+	{
+		/* SAA7164 */
+		.vendor       = 0x1131,
+		.device       = 0x7164,
+		.subvendor    = PCI_ANY_ID,
+		.subdevice    = PCI_ANY_ID,
+	}, {
+		/* --- end of list --- */
+	}
+};
+MODULE_DEVICE_TABLE(pci, saa7164_pci_tbl);
+
+static struct pci_driver saa7164_pci_driver = {
+	.name     = "saa7164",
+	.id_table = saa7164_pci_tbl,
+	.probe    = saa7164_initdev,
+	.remove   = __devexit_p(saa7164_finidev),
+	/* TODO */
+	.suspend  = NULL,
+	.resume   = NULL,
+};
+
+static int __init saa7164_init(void)
+{
+	printk(KERN_INFO "saa7164 driver loaded\n");
+	return pci_register_driver(&saa7164_pci_driver);
+}
+
+static void __exit saa7164_fini(void)
+{
+	pci_unregister_driver(&saa7164_pci_driver);
+}
+
+module_init(saa7164_init);
+module_exit(saa7164_fini);
+
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-dvb.c linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-dvb.c
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-dvb.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-dvb.c	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,602 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "saa7164.h"
+
+#include "tda10048.h"
+#include "tda18271.h"
+#include "s5h1411.h"
+
+#define DRIVER_NAME "saa7164"
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+/* addr is in the card struct, get it from there */
+static struct tda10048_config hauppauge_hvr2200_1_config = {
+	.demod_address    = 0x10 >> 1,
+	.output_mode      = TDA10048_SERIAL_OUTPUT,
+	.fwbulkwritelen   = TDA10048_BULKWRITE_200,
+	.inversion        = TDA10048_INVERSION_ON,
+	.dtv6_if_freq_khz = TDA10048_IF_3300,
+	.dtv7_if_freq_khz = TDA10048_IF_3500,
+	.dtv8_if_freq_khz = TDA10048_IF_4000,
+	.clk_freq_khz     = TDA10048_CLK_16000,
+};
+static struct tda10048_config hauppauge_hvr2200_2_config = {
+	.demod_address    = 0x12 >> 1,
+	.output_mode      = TDA10048_SERIAL_OUTPUT,
+	.fwbulkwritelen   = TDA10048_BULKWRITE_200,
+	.inversion        = TDA10048_INVERSION_ON,
+	.dtv6_if_freq_khz = TDA10048_IF_3300,
+	.dtv7_if_freq_khz = TDA10048_IF_3500,
+	.dtv8_if_freq_khz = TDA10048_IF_4000,
+	.clk_freq_khz     = TDA10048_CLK_16000,
+};
+
+static struct tda18271_std_map hauppauge_tda18271_std_map = {
+	.atsc_6   = { .if_freq = 3250, .agc_mode = 3, .std = 3,
+		      .if_lvl = 6, .rfagc_top = 0x37 },
+	.qam_6    = { .if_freq = 4000, .agc_mode = 3, .std = 0,
+		      .if_lvl = 6, .rfagc_top = 0x37 },
+};
+
+static struct tda18271_config hauppauge_hvr22x0_tuner_config = {
+	.std_map	= &hauppauge_tda18271_std_map,
+	.gate		= TDA18271_GATE_ANALOG,
+	.role		= TDA18271_MASTER,
+};
+
+static struct tda18271_config hauppauge_hvr22x0s_tuner_config = {
+	.std_map	= &hauppauge_tda18271_std_map,
+	.gate		= TDA18271_GATE_ANALOG,
+	.role		= TDA18271_SLAVE,
+	.rf_cal_on_startup = 1
+};
+
+static struct s5h1411_config hauppauge_s5h1411_config = {
+	.output_mode   = S5H1411_SERIAL_OUTPUT,
+	.gpio          = S5H1411_GPIO_ON,
+	.qam_if        = S5H1411_IF_4000,
+	.vsb_if        = S5H1411_IF_3250,
+	.inversion     = S5H1411_INVERSION_ON,
+	.status_mode   = S5H1411_DEMODLOCKING,
+	.mpeg_timing   = S5H1411_MPEGTIMING_CONTINOUS_NONINVERTING_CLOCK,
+};
+
+static int saa7164_dvb_stop_tsport(struct saa7164_tsport *port)
+{
+	struct saa7164_dev *dev = port->dev;
+	int ret;
+
+	ret = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);
+	if ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {
+		printk(KERN_ERR "%s() stop transition failed, ret = 0x%x\n",
+			__func__, ret);
+		ret = -EIO;
+	} else {
+		dprintk(DBGLVL_DVB, "%s()    Stopped\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int saa7164_dvb_acquire_tsport(struct saa7164_tsport *port)
+{
+	struct saa7164_dev *dev = port->dev;
+	int ret;
+
+	ret = saa7164_api_transition_port(port, SAA_DMASTATE_ACQUIRE);
+	if ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {
+		printk(KERN_ERR "%s() acquire transition failed, ret = 0x%x\n",
+			__func__, ret);
+		ret = -EIO;
+	} else {
+		dprintk(DBGLVL_DVB, "%s() Acquired\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int saa7164_dvb_pause_tsport(struct saa7164_tsport *port)
+{
+	struct saa7164_dev *dev = port->dev;
+	int ret;
+
+	ret = saa7164_api_transition_port(port, SAA_DMASTATE_PAUSE);
+	if ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {
+		printk(KERN_ERR "%s() pause transition failed, ret = 0x%x\n",
+			__func__, ret);
+		ret = -EIO;
+	} else {
+		dprintk(DBGLVL_DVB, "%s()   Paused\n", __func__);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+/* Firmware is very windows centric, meaning you have to transition
+ * the part through AVStream / KS Windows stages, forwards or backwards.
+ * States are: stopped, acquired (h/w), paused, started.
+ */
+static int saa7164_dvb_stop_streaming(struct saa7164_tsport *port)
+{
+	struct saa7164_dev *dev = port->dev;
+	int ret;
+
+	dprintk(DBGLVL_DVB, "%s(port=%d)\n", __func__, port->nr);
+
+	ret = saa7164_dvb_pause_tsport(port);
+	ret = saa7164_dvb_acquire_tsport(port);
+	ret = saa7164_dvb_stop_tsport(port);
+
+	return ret;
+}
+
+static int saa7164_dvb_cfg_tsport(struct saa7164_tsport *port)
+{
+	tmHWStreamParameters_t *params = &port->hw_streamingparams;
+	struct saa7164_dev *dev = port->dev;
+	struct saa7164_buffer *buf;
+	struct list_head *c, *n;
+	int i = 0;
+
+	dprintk(DBGLVL_DVB, "%s(port=%d)\n", __func__, port->nr);
+
+	saa7164_writel(port->pitch, params->pitch);
+	saa7164_writel(port->bufsize, params->pitch * params->numberoflines);
+
+	dprintk(DBGLVL_DVB, " configured:\n");
+	dprintk(DBGLVL_DVB, "   lmmio       0x%p\n", dev->lmmio);
+	dprintk(DBGLVL_DVB, "   bufcounter  0x%x = 0x%x\n", port->bufcounter,
+		saa7164_readl(port->bufcounter));
+
+	dprintk(DBGLVL_DVB, "   pitch       0x%x = %d\n", port->pitch,
+		saa7164_readl(port->pitch));
+
+	dprintk(DBGLVL_DVB, "   bufsize     0x%x = %d\n", port->bufsize,
+		saa7164_readl(port->bufsize));
+
+	dprintk(DBGLVL_DVB, "   buffercount = %d\n", port->hwcfg.buffercount);
+	dprintk(DBGLVL_DVB, "   bufoffset = 0x%x\n", port->bufoffset);
+	dprintk(DBGLVL_DVB, "   bufptr32h = 0x%x\n", port->bufptr32h);
+	dprintk(DBGLVL_DVB, "   bufptr32l = 0x%x\n", port->bufptr32l);
+
+	/* Poke the buffers and offsets into PCI space */
+	mutex_lock(&port->dmaqueue_lock);
+	list_for_each_safe(c, n, &port->dmaqueue.list) {
+		buf = list_entry(c, struct saa7164_buffer, list);
+
+		/* TODO: Review this in light of 32v64 assignments */
+		saa7164_writel(port->bufoffset + (sizeof(u32) * i), 0);
+		saa7164_writel(port->bufptr32h + ((sizeof(u32) * 2) * i),
+			buf->pt_dma);
+		saa7164_writel(port->bufptr32l + ((sizeof(u32) * 2) * i), 0);
+
+		dprintk(DBGLVL_DVB,
+			"   buf[%d] offset 0x%llx (0x%x) "
+			"buf 0x%llx/%llx (0x%x/%x)\n",
+			i,
+			(u64)port->bufoffset + (i * sizeof(u32)),
+			saa7164_readl(port->bufoffset + (sizeof(u32) * i)),
+			(u64)port->bufptr32h + ((sizeof(u32) * 2) * i),
+			(u64)port->bufptr32l + ((sizeof(u32) * 2) * i),
+			saa7164_readl(port->bufptr32h + ((sizeof(u32) * i)
+				* 2)),
+			saa7164_readl(port->bufptr32l + ((sizeof(u32) * i)
+				* 2)));
+
+		if (i++ > port->hwcfg.buffercount)
+			BUG();
+
+	}
+	mutex_unlock(&port->dmaqueue_lock);
+
+	return 0;
+}
+
+static int saa7164_dvb_start_tsport(struct saa7164_tsport *port)
+{
+	struct saa7164_dev *dev = port->dev;
+	int ret = 0, result;
+
+	dprintk(DBGLVL_DVB, "%s(port=%d)\n", __func__, port->nr);
+
+	saa7164_dvb_cfg_tsport(port);
+
+	/* Acquire the hardware */
+	result = saa7164_api_transition_port(port, SAA_DMASTATE_ACQUIRE);
+	if ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {
+		printk(KERN_ERR "%s() acquire transition failed, res = 0x%x\n",
+			__func__, result);
+
+		/* Stop the hardware, regardless */
+		result = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);
+		if ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {
+			printk(KERN_ERR "%s() acquire/forced stop transition "
+				"failed, res = 0x%x\n", __func__, result);
+		}
+		ret = -EIO;
+		goto out;
+	} else
+		dprintk(DBGLVL_DVB, "%s()   Acquired\n", __func__);
+
+	/* Pause the hardware */
+	result = saa7164_api_transition_port(port, SAA_DMASTATE_PAUSE);
+	if ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {
+		printk(KERN_ERR "%s() pause transition failed, res = 0x%x\n",
+				__func__, result);
+
+		/* Stop the hardware, regardless */
+		result = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);
+		if ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {
+			printk(KERN_ERR "%s() pause/forced stop transition "
+				"failed, res = 0x%x\n", __func__, result);
+		}
+
+		ret = -EIO;
+		goto out;
+	} else
+		dprintk(DBGLVL_DVB, "%s()   Paused\n", __func__);
+
+	/* Start the hardware */
+	result = saa7164_api_transition_port(port, SAA_DMASTATE_RUN);
+	if ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {
+		printk(KERN_ERR "%s() run transition failed, result = 0x%x\n",
+				__func__, result);
+
+		/* Stop the hardware, regardless */
+		result = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);
+		if ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {
+			printk(KERN_ERR "%s() run/forced stop transition "
+				"failed, res = 0x%x\n", __func__, result);
+		}
+
+		ret = -EIO;
+	} else
+		dprintk(DBGLVL_DVB, "%s()   Running\n", __func__);
+
+out:
+	return ret;
+}
+
+static int saa7164_dvb_start_feed(struct dvb_demux_feed *feed)
+{
+	struct dvb_demux *demux = feed->demux;
+	struct saa7164_tsport *port = (struct saa7164_tsport *) demux->priv;
+	struct saa7164_dvb *dvb = &port->dvb;
+	struct saa7164_dev *dev = port->dev;
+	int ret = 0;
+
+	dprintk(DBGLVL_DVB, "%s(port=%d)\n", __func__, port->nr);
+
+	if (!demux->dmx.frontend)
+		return -EINVAL;
+
+	if (dvb) {
+		mutex_lock(&dvb->lock);
+		if (dvb->feeding++ == 0) {
+			/* Start transport */
+			ret = saa7164_dvb_start_tsport(port);
+		}
+		mutex_unlock(&dvb->lock);
+		dprintk(DBGLVL_DVB, "%s(port=%d) now feeding = %d\n",
+			__func__, port->nr, dvb->feeding);
+	}
+
+	return ret;
+}
+
+static int saa7164_dvb_stop_feed(struct dvb_demux_feed *feed)
+{
+	struct dvb_demux *demux = feed->demux;
+	struct saa7164_tsport *port = (struct saa7164_tsport *) demux->priv;
+	struct saa7164_dvb *dvb = &port->dvb;
+	struct saa7164_dev *dev = port->dev;
+	int ret = 0;
+
+	dprintk(DBGLVL_DVB, "%s(port=%d)\n", __func__, port->nr);
+
+	if (dvb) {
+		mutex_lock(&dvb->lock);
+		if (--dvb->feeding == 0) {
+			/* Stop transport */
+			ret = saa7164_dvb_stop_streaming(port);
+		}
+		mutex_unlock(&dvb->lock);
+		dprintk(DBGLVL_DVB, "%s(port=%d) now feeding = %d\n",
+			__func__, port->nr, dvb->feeding);
+	}
+
+	return ret;
+}
+
+static int dvb_register(struct saa7164_tsport *port)
+{
+	struct saa7164_dvb *dvb = &port->dvb;
+	struct saa7164_dev *dev = port->dev;
+	struct saa7164_buffer *buf;
+	int result, i;
+
+	dprintk(DBGLVL_DVB, "%s(port=%d)\n", __func__, port->nr);
+
+	/* Sanity check that the PCI configuration space is active */
+	if (port->hwcfg.BARLocation == 0) {
+		result = -ENOMEM;
+		printk(KERN_ERR "%s: dvb_register_adapter failed "
+		       "(errno = %d), NO PCI configuration\n",
+			DRIVER_NAME, result);
+		goto fail_adapter;
+	}
+
+	/* Init and establish defaults */
+	port->hw_streamingparams.bitspersample = 8;
+	port->hw_streamingparams.samplesperline = 188;
+	port->hw_streamingparams.numberoflines =
+		(SAA7164_TS_NUMBER_OF_LINES * 188) / 188;
+
+	port->hw_streamingparams.pitch = 188;
+	port->hw_streamingparams.linethreshold = 0;
+	port->hw_streamingparams.pagetablelistvirt = 0;
+	port->hw_streamingparams.pagetablelistphys = 0;
+	port->hw_streamingparams.numpagetables = 2 +
+		((SAA7164_TS_NUMBER_OF_LINES * 188) / PAGE_SIZE);
+
+	port->hw_streamingparams.numpagetableentries = port->hwcfg.buffercount;
+
+	/* Allocate the PCI resources */
+	for (i = 0; i < port->hwcfg.buffercount; i++) {
+		buf = saa7164_buffer_alloc(port,
+			port->hw_streamingparams.numberoflines *
+			port->hw_streamingparams.pitch);
+
+		if (!buf) {
+			result = -ENOMEM;
+			printk(KERN_ERR "%s: dvb_register_adapter failed "
+			       "(errno = %d), unable to allocate buffers\n",
+				DRIVER_NAME, result);
+			goto fail_adapter;
+		}
+		buf->nr = i;
+
+		mutex_lock(&port->dmaqueue_lock);
+		list_add_tail(&buf->list, &port->dmaqueue.list);
+		mutex_unlock(&port->dmaqueue_lock);
+	}
+
+	/* register adapter */
+	result = dvb_register_adapter(&dvb->adapter, DRIVER_NAME, THIS_MODULE,
+			&dev->pci->dev, adapter_nr);
+	if (result < 0) {
+		printk(KERN_ERR "%s: dvb_register_adapter failed "
+		       "(errno = %d)\n", DRIVER_NAME, result);
+		goto fail_adapter;
+	}
+	dvb->adapter.priv = port;
+
+	/* register frontend */
+	result = dvb_register_frontend(&dvb->adapter, dvb->frontend);
+	if (result < 0) {
+		printk(KERN_ERR "%s: dvb_register_frontend failed "
+		       "(errno = %d)\n", DRIVER_NAME, result);
+		goto fail_frontend;
+	}
+
+	/* register demux stuff */
+	dvb->demux.dmx.capabilities =
+		DMX_TS_FILTERING | DMX_SECTION_FILTERING |
+		DMX_MEMORY_BASED_FILTERING;
+	dvb->demux.priv       = port;
+	dvb->demux.filternum  = 256;
+	dvb->demux.feednum    = 256;
+	dvb->demux.start_feed = saa7164_dvb_start_feed;
+	dvb->demux.stop_feed  = saa7164_dvb_stop_feed;
+	result = dvb_dmx_init(&dvb->demux);
+	if (result < 0) {
+		printk(KERN_ERR "%s: dvb_dmx_init failed (errno = %d)\n",
+		       DRIVER_NAME, result);
+		goto fail_dmx;
+	}
+
+	dvb->dmxdev.filternum    = 256;
+	dvb->dmxdev.demux        = &dvb->demux.dmx;
+	dvb->dmxdev.capabilities = 0;
+	result = dvb_dmxdev_init(&dvb->dmxdev, &dvb->adapter);
+	if (result < 0) {
+		printk(KERN_ERR "%s: dvb_dmxdev_init failed (errno = %d)\n",
+		       DRIVER_NAME, result);
+		goto fail_dmxdev;
+	}
+
+	dvb->fe_hw.source = DMX_FRONTEND_0;
+	result = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);
+	if (result < 0) {
+		printk(KERN_ERR "%s: add_frontend failed "
+		       "(DMX_FRONTEND_0, errno = %d)\n", DRIVER_NAME, result);
+		goto fail_fe_hw;
+	}
+
+	dvb->fe_mem.source = DMX_MEMORY_FE;
+	result = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);
+	if (result < 0) {
+		printk(KERN_ERR "%s: add_frontend failed "
+		       "(DMX_MEMORY_FE, errno = %d)\n", DRIVER_NAME, result);
+		goto fail_fe_mem;
+	}
+
+	result = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);
+	if (result < 0) {
+		printk(KERN_ERR "%s: connect_frontend failed (errno = %d)\n",
+		       DRIVER_NAME, result);
+		goto fail_fe_conn;
+	}
+
+	/* register network adapter */
+	dvb_net_init(&dvb->adapter, &dvb->net, &dvb->demux.dmx);
+	return 0;
+
+fail_fe_conn:
+	dvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);
+fail_fe_mem:
+	dvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);
+fail_fe_hw:
+	dvb_dmxdev_release(&dvb->dmxdev);
+fail_dmxdev:
+	dvb_dmx_release(&dvb->demux);
+fail_dmx:
+	dvb_unregister_frontend(dvb->frontend);
+fail_frontend:
+	dvb_frontend_detach(dvb->frontend);
+	dvb_unregister_adapter(&dvb->adapter);
+fail_adapter:
+	return result;
+}
+
+int saa7164_dvb_unregister(struct saa7164_tsport *port)
+{
+	struct saa7164_dvb *dvb = &port->dvb;
+	struct saa7164_dev *dev = port->dev;
+	struct saa7164_buffer *b;
+	struct list_head *c, *n;
+
+	dprintk(DBGLVL_DVB, "%s()\n", __func__);
+
+	/* Remove any allocated buffers */
+	mutex_lock(&port->dmaqueue_lock);
+	list_for_each_safe(c, n, &port->dmaqueue.list) {
+		b = list_entry(c, struct saa7164_buffer, list);
+		list_del(c);
+		saa7164_buffer_dealloc(port, b);
+	}
+	mutex_unlock(&port->dmaqueue_lock);
+
+	if (dvb->frontend == NULL)
+		return 0;
+
+	dvb_net_release(&dvb->net);
+	dvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);
+	dvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);
+	dvb_dmxdev_release(&dvb->dmxdev);
+	dvb_dmx_release(&dvb->demux);
+	dvb_unregister_frontend(dvb->frontend);
+	dvb_frontend_detach(dvb->frontend);
+	dvb_unregister_adapter(&dvb->adapter);
+	return 0;
+}
+
+/* All the DVB attach calls go here, this function get's modified
+ * for each new card.
+ */
+int saa7164_dvb_register(struct saa7164_tsport *port)
+{
+	struct saa7164_dev *dev = port->dev;
+	struct saa7164_dvb *dvb = &port->dvb;
+	struct saa7164_i2c *i2c_bus = NULL;
+	int ret;
+
+	dprintk(DBGLVL_DVB, "%s()\n", __func__);
+
+	/* init frontend */
+	switch (dev->board) {
+	case SAA7164_BOARD_HAUPPAUGE_HVR2200:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2200_2:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2200_3:
+		i2c_bus = &dev->i2c_bus[port->nr + 1];
+		switch (port->nr) {
+		case 0:
+			port->dvb.frontend = dvb_attach(tda10048_attach,
+				&hauppauge_hvr2200_1_config,
+				&i2c_bus->i2c_adap);
+
+			if (port->dvb.frontend != NULL) {
+				/* TODO: addr is in the card struct */
+				dvb_attach(tda18271_attach, port->dvb.frontend,
+					0xc0 >> 1, &i2c_bus->i2c_adap,
+					&hauppauge_hvr22x0_tuner_config);
+			}
+
+			break;
+		case 1:
+			port->dvb.frontend = dvb_attach(tda10048_attach,
+				&hauppauge_hvr2200_2_config,
+				&i2c_bus->i2c_adap);
+
+			if (port->dvb.frontend != NULL) {
+				/* TODO: addr is in the card struct */
+				dvb_attach(tda18271_attach, port->dvb.frontend,
+					0xc0 >> 1, &i2c_bus->i2c_adap,
+					&hauppauge_hvr22x0s_tuner_config);
+			}
+
+			break;
+		}
+		break;
+	case SAA7164_BOARD_HAUPPAUGE_HVR2250:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2250_2:
+	case SAA7164_BOARD_HAUPPAUGE_HVR2250_3:
+		i2c_bus = &dev->i2c_bus[port->nr + 1];
+
+		port->dvb.frontend = dvb_attach(s5h1411_attach,
+			&hauppauge_s5h1411_config,
+			&i2c_bus->i2c_adap);
+
+		if (port->dvb.frontend != NULL) {
+			if (port->nr == 0) {
+				/* Master TDA18271 */
+				/* TODO: addr is in the card struct */
+				dvb_attach(tda18271_attach, port->dvb.frontend,
+					0xc0 >> 1, &i2c_bus->i2c_adap,
+					&hauppauge_hvr22x0_tuner_config);
+			} else {
+				/* Slave TDA18271 */
+				dvb_attach(tda18271_attach, port->dvb.frontend,
+					0xc0 >> 1, &i2c_bus->i2c_adap,
+					&hauppauge_hvr22x0s_tuner_config);
+			}
+		}
+
+		break;
+	default:
+		printk(KERN_ERR "%s: The frontend isn't supported\n",
+		       dev->name);
+		break;
+	}
+	if (NULL == dvb->frontend) {
+		printk(KERN_ERR "%s() Frontend initialization failed\n",
+		       __func__);
+		return -1;
+	}
+
+	/* Put the analog decoder in standby to keep it quiet */
+
+	/* register everything */
+	ret = dvb_register(port);
+	if (ret < 0) {
+		if (dvb->frontend->ops.release)
+			dvb->frontend->ops.release(dvb->frontend);
+		return ret;
+	}
+
+	return 0;
+}
+
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-fw.c linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-fw.c
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-fw.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-fw.c	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,613 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/firmware.h>
+
+#include "saa7164.h"
+
+#define SAA7164_REV2_FIRMWARE		"v4l-saa7164-1.0.2.fw"
+#define SAA7164_REV2_FIRMWARE_SIZE	3978608
+
+#define SAA7164_REV3_FIRMWARE		"v4l-saa7164-1.0.3.fw"
+#define SAA7164_REV3_FIRMWARE_SIZE	3978608
+
+struct fw_header {
+	u32	firmwaresize;
+	u32	bslsize;
+	u32	reserved;
+	u32	version;
+};
+
+int saa7164_dl_wait_ack(struct saa7164_dev *dev, u32 reg)
+{
+	u32 timeout = SAA_DEVICE_TIMEOUT;
+	while ((saa7164_readl(reg) & 0x01) == 0) {
+		timeout -= 10;
+		if (timeout == 0) {
+			printk(KERN_ERR "%s() timeout (no d/l ack)\n",
+				__func__);
+			return -EBUSY;
+		}
+		msleep(100);
+	}
+
+	return 0;
+}
+
+int saa7164_dl_wait_clr(struct saa7164_dev *dev, u32 reg)
+{
+	u32 timeout = SAA_DEVICE_TIMEOUT;
+	while (saa7164_readl(reg) & 0x01) {
+		timeout -= 10;
+		if (timeout == 0) {
+			printk(KERN_ERR "%s() timeout (no d/l clr)\n",
+				__func__);
+			return -EBUSY;
+		}
+		msleep(100);
+	}
+
+	return 0;
+}
+
+/* TODO: move dlflags into dev-> and change to write/readl/b */
+/* TODO: Excessive levels of debug */
+int saa7164_downloadimage(struct saa7164_dev *dev, u8 *src, u32 srcsize,
+	u32 dlflags, u8 *dst, u32 dstsize)
+{
+	u32 reg, timeout, offset;
+	u8 *srcbuf = NULL;
+	int ret;
+
+	u32 dlflag = dlflags;
+	u32 dlflag_ack = dlflag + 4;
+	u32 drflag = dlflag_ack + 4;
+	u32 drflag_ack = drflag + 4;
+	u32 bleflag = drflag_ack + 4;
+
+	dprintk(DBGLVL_FW,
+		"%s(image=%p, size=%d, flags=0x%x, dst=%p, dstsize=0x%x)\n",
+		__func__, src, srcsize, dlflags, dst, dstsize);
+
+	if ((src == 0) || (dst == 0)) {
+		ret = -EIO;
+		goto out;
+	}
+
+	srcbuf = kzalloc(4 * 1048576, GFP_KERNEL);
+	if (NULL == srcbuf) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (srcsize > (4*1048576)) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memcpy(srcbuf, src, srcsize);
+
+	dprintk(DBGLVL_FW, "%s() dlflag = 0x%x\n", __func__, dlflag);
+	dprintk(DBGLVL_FW, "%s() dlflag_ack = 0x%x\n", __func__, dlflag_ack);
+	dprintk(DBGLVL_FW, "%s() drflag = 0x%x\n", __func__, drflag);
+	dprintk(DBGLVL_FW, "%s() drflag_ack = 0x%x\n", __func__, drflag_ack);
+	dprintk(DBGLVL_FW, "%s() bleflag = 0x%x\n", __func__, bleflag);
+
+	reg = saa7164_readl(dlflag);
+	dprintk(DBGLVL_FW, "%s() dlflag (0x%x)= 0x%x\n", __func__, dlflag, reg);
+	if (reg == 1)
+		dprintk(DBGLVL_FW,
+			"%s() Download flag already set, please reboot\n",
+			__func__);
+
+	/* Indicate download start */
+	saa7164_writel(dlflag, 1);
+	ret = saa7164_dl_wait_ack(dev, dlflag_ack);
+	if (ret < 0)
+		goto out;
+
+	/* Ack download start, then wait for wait */
+	saa7164_writel(dlflag, 0);
+	ret = saa7164_dl_wait_clr(dev, dlflag_ack);
+	if (ret < 0)
+		goto out;
+
+	/* Deal with the raw firmware, in the appropriate chunk size */
+	for (offset = 0; srcsize > dstsize;
+		srcsize -= dstsize, offset += dstsize) {
+
+		dprintk(DBGLVL_FW, "%s() memcpy %d\n", __func__, dstsize);
+		memcpy(dst, srcbuf + offset, dstsize);
+
+		/* Flag the data as ready */
+		saa7164_writel(drflag, 1);
+		ret = saa7164_dl_wait_ack(dev, drflag_ack);
+		if (ret < 0)
+			goto out;
+
+		/* Wait for indication data was received */
+		saa7164_writel(drflag, 0);
+		ret = saa7164_dl_wait_clr(dev, drflag_ack);
+		if (ret < 0)
+			goto out;
+
+	}
+
+	dprintk(DBGLVL_FW, "%s() memcpy(l) %d\n", __func__, dstsize);
+	/* Write last block to the device */
+	memcpy(dst, srcbuf+offset, srcsize);
+
+	/* Flag the data as ready */
+	saa7164_writel(drflag, 1);
+	ret = saa7164_dl_wait_ack(dev, drflag_ack);
+	if (ret < 0)
+		goto out;
+
+	saa7164_writel(drflag, 0);
+	timeout = 0;
+	while (saa7164_readl(bleflag) != SAA_DEVICE_IMAGE_BOOTING) {
+		if (saa7164_readl(bleflag) & SAA_DEVICE_IMAGE_CORRUPT) {
+			printk(KERN_ERR "%s() image corrupt\n", __func__);
+			ret = -EBUSY;
+			goto out;
+		}
+
+		if (saa7164_readl(bleflag) & SAA_DEVICE_MEMORY_CORRUPT) {
+			printk(KERN_ERR "%s() device memory corrupt\n",
+				__func__);
+			ret = -EBUSY;
+			goto out;
+		}
+
+		msleep(10);
+		if (timeout++ > 60)
+			break;
+	}
+
+	printk(KERN_INFO "%s() Image downloaded, booting...\n", __func__);
+
+	ret = saa7164_dl_wait_clr(dev, drflag_ack);
+	if (ret < 0)
+		goto out;
+
+	printk(KERN_INFO "%s() Image booted successfully.\n", __func__);
+	ret = 0;
+
+out:
+	kfree(srcbuf);
+	return ret;
+}
+
+/* TODO: Excessive debug */
+/* Load the firmware. Optionally it can be in ROM or newer versions
+ * can be on disk, saving the expense of the ROM hardware. */
+int saa7164_downloadfirmware(struct saa7164_dev *dev)
+{
+	/* u32 second_timeout = 60 * SAA_DEVICE_TIMEOUT; */
+	u32 tmp, filesize, version, err_flags, first_timeout, fwlength;
+	u32 second_timeout, updatebootloader = 1, bootloadersize = 0;
+	const struct firmware *fw = NULL;
+	struct fw_header *hdr, *boothdr = NULL, *fwhdr;
+	u32 bootloaderversion = 0, fwloadersize;
+	u8 *bootloaderoffset = NULL, *fwloaderoffset;
+	char *fwname;
+	int ret;
+
+	dprintk(DBGLVL_FW, "%s()\n", __func__);
+
+	if (saa7164_boards[dev->board].chiprev == SAA7164_CHIP_REV2) {
+		fwname = SAA7164_REV2_FIRMWARE;
+		fwlength = SAA7164_REV2_FIRMWARE_SIZE;
+	} else {
+		fwname = SAA7164_REV3_FIRMWARE;
+		fwlength = SAA7164_REV3_FIRMWARE_SIZE;
+	}
+
+	version = saa7164_getcurrentfirmwareversion(dev);
+
+	if (version == 0x00) {
+
+		second_timeout = 100;
+		first_timeout = 100;
+		err_flags = saa7164_readl(SAA_BOOTLOADERERROR_FLAGS);
+		dprintk(DBGLVL_FW, "%s() err_flags = %x\n",
+			__func__, err_flags);
+
+		while (err_flags != SAA_DEVICE_IMAGE_BOOTING) {
+			dprintk(DBGLVL_FW, "%s() err_flags = %x\n",
+				__func__, err_flags);
+			msleep(10);
+
+			if (err_flags & SAA_DEVICE_IMAGE_CORRUPT) {
+				printk(KERN_ERR "%s() firmware corrupt\n",
+					__func__);
+				break;
+			}
+			if (err_flags & SAA_DEVICE_MEMORY_CORRUPT) {
+				printk(KERN_ERR "%s() device memory corrupt\n",
+					__func__);
+				break;
+			}
+			if (err_flags & SAA_DEVICE_NO_IMAGE) {
+				printk(KERN_ERR "%s() no first image\n",
+				__func__);
+				break;
+			}
+			if (err_flags & SAA_DEVICE_IMAGE_SEARCHING) {
+				first_timeout -= 10;
+				if (first_timeout == 0) {
+					printk(KERN_ERR
+						"%s() no first image\n",
+						__func__);
+					break;
+				}
+			} else if (err_flags & SAA_DEVICE_IMAGE_LOADING) {
+				second_timeout -= 10;
+				if (second_timeout == 0) {
+					printk(KERN_ERR
+					"%s() FW load time exceeded\n",
+						__func__);
+					break;
+				}
+			} else {
+				second_timeout -= 10;
+				if (second_timeout == 0) {
+					printk(KERN_ERR
+					"%s() Unknown bootloader flags 0x%x\n",
+						__func__, err_flags);
+					break;
+				}
+			}
+
+			err_flags = saa7164_readl(SAA_BOOTLOADERERROR_FLAGS);
+		} /* While != Booting */
+
+		if (err_flags == SAA_DEVICE_IMAGE_BOOTING) {
+			dprintk(DBGLVL_FW, "%s() Loader 1 has loaded.\n",
+				__func__);
+			first_timeout = SAA_DEVICE_TIMEOUT;
+			second_timeout = 60 * SAA_DEVICE_TIMEOUT;
+			second_timeout = 100;
+
+			err_flags = saa7164_readl(SAA_SECONDSTAGEERROR_FLAGS);
+			dprintk(DBGLVL_FW, "%s() err_flags2 = %x\n",
+				__func__, err_flags);
+			while (err_flags != SAA_DEVICE_IMAGE_BOOTING) {
+				dprintk(DBGLVL_FW, "%s() err_flags2 = %x\n",
+					__func__, err_flags);
+				msleep(10);
+
+				if (err_flags & SAA_DEVICE_IMAGE_CORRUPT) {
+					printk(KERN_ERR
+						"%s() firmware corrupt\n",
+						__func__);
+					break;
+				}
+				if (err_flags & SAA_DEVICE_MEMORY_CORRUPT) {
+					printk(KERN_ERR
+						"%s() device memory corrupt\n",
+						__func__);
+					break;
+				}
+				if (err_flags & SAA_DEVICE_NO_IMAGE) {
+					printk(KERN_ERR "%s() no first image\n",
+						__func__);
+					break;
+				}
+				if (err_flags & SAA_DEVICE_IMAGE_SEARCHING) {
+					first_timeout -= 10;
+					if (first_timeout == 0) {
+						printk(KERN_ERR
+						"%s() no second image\n",
+							__func__);
+						break;
+					}
+				} else if (err_flags &
+					SAA_DEVICE_IMAGE_LOADING) {
+					second_timeout -= 10;
+					if (second_timeout == 0) {
+						printk(KERN_ERR
+						"%s() FW load time exceeded\n",
+							__func__);
+						break;
+					}
+				} else {
+					second_timeout -= 10;
+					if (second_timeout == 0) {
+						printk(KERN_ERR
+					"%s() Unknown bootloader flags 0x%x\n",
+							__func__, err_flags);
+						break;
+					}
+				}
+
+				err_flags =
+				saa7164_readl(SAA_SECONDSTAGEERROR_FLAGS);
+			} /* err_flags != SAA_DEVICE_IMAGE_BOOTING */
+
+			dprintk(DBGLVL_FW, "%s() Loader flags 1:0x%x 2:0x%x.\n",
+				__func__,
+				saa7164_readl(SAA_BOOTLOADERERROR_FLAGS),
+				saa7164_readl(SAA_SECONDSTAGEERROR_FLAGS));
+
+		} /* err_flags == SAA_DEVICE_IMAGE_BOOTING */
+
+		/* It's possible for both firmwares to have booted,
+		 * but that doesn't mean they've finished booting yet.
+		 */
+		if ((saa7164_readl(SAA_BOOTLOADERERROR_FLAGS) ==
+			SAA_DEVICE_IMAGE_BOOTING) &&
+			(saa7164_readl(SAA_SECONDSTAGEERROR_FLAGS) ==
+			SAA_DEVICE_IMAGE_BOOTING)) {
+
+
+			dprintk(DBGLVL_FW, "%s() Loader 2 has loaded.\n",
+				__func__);
+
+			first_timeout = SAA_DEVICE_TIMEOUT;
+			while (first_timeout) {
+				msleep(10);
+
+				version =
+					saa7164_getcurrentfirmwareversion(dev);
+				if (version) {
+					dprintk(DBGLVL_FW,
+					"%s() All f/w loaded successfully\n",
+						__func__);
+					break;
+				} else {
+					first_timeout -= 10;
+					if (first_timeout == 0) {
+						printk(KERN_ERR
+						"%s() FW did not boot\n",
+							__func__);
+						break;
+					}
+				}
+			}
+		}
+		version = saa7164_getcurrentfirmwareversion(dev);
+	} /* version == 0 */
+
+	/* Has the firmware really booted? */
+	if ((saa7164_readl(SAA_BOOTLOADERERROR_FLAGS) ==
+		SAA_DEVICE_IMAGE_BOOTING) &&
+		(saa7164_readl(SAA_SECONDSTAGEERROR_FLAGS) ==
+		SAA_DEVICE_IMAGE_BOOTING) && (version == 0)) {
+
+		printk(KERN_ERR
+			"%s() The firmware hung, probably bad firmware\n",
+			__func__);
+
+		/* Tell the second stage loader we have a deadlock */
+		saa7164_writel(SAA_DEVICE_DEADLOCK_DETECTED_OFFSET,
+			SAA_DEVICE_DEADLOCK_DETECTED);
+
+		saa7164_getfirmwarestatus(dev);
+
+		return -ENOMEM;
+	}
+
+	dprintk(DBGLVL_FW, "Device has Firmware Version %d.%d.%d.%d\n",
+		(version & 0x0000fc00) >> 10,
+		(version & 0x000003e0) >> 5,
+		(version & 0x0000001f),
+		(version & 0xffff0000) >> 16);
+
+	/* Load the firmwware from the disk if required */
+	if (version == 0) {
+
+		printk(KERN_INFO "%s() Waiting for firmware upload (%s)\n",
+			__func__, fwname);
+
+		ret = request_firmware(&fw, fwname, &dev->pci->dev);
+		if (ret) {
+			printk(KERN_ERR "%s() Upload failed. "
+				"(file not found?)\n", __func__);
+			return -ENOMEM;
+		}
+
+		printk(KERN_INFO "%s() firmware read %Zu bytes.\n",
+			__func__, fw->size);
+
+		if (fw->size != fwlength) {
+			printk(KERN_ERR "xc5000: firmware incorrect size\n");
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		printk(KERN_INFO "%s() firmware loaded.\n", __func__);
+
+		hdr = (struct fw_header *)fw->data;
+		printk(KERN_INFO "Firmware file header part 1:\n");
+		printk(KERN_INFO " .FirmwareSize = 0x%x\n", hdr->firmwaresize);
+		printk(KERN_INFO " .BSLSize = 0x%x\n", hdr->bslsize);
+		printk(KERN_INFO " .Reserved = 0x%x\n", hdr->reserved);
+		printk(KERN_INFO " .Version = 0x%x\n", hdr->version);
+
+		/* Retreive bootloader if reqd */
+		if ((hdr->firmwaresize == 0) && (hdr->bslsize == 0))
+			/* Second bootloader in the firmware file */
+			filesize = hdr->reserved * 16;
+		else
+			filesize = (hdr->firmwaresize + hdr->bslsize) *
+				16 + sizeof(struct fw_header);
+
+		printk(KERN_INFO "%s() SecBootLoader.FileSize = %d\n",
+			__func__, filesize);
+
+		/* Get bootloader (if reqd) and firmware header */
+		if ((hdr->firmwaresize == 0) && (hdr->bslsize == 0)) {
+			/* Second boot loader is required */
+
+			/* Get the loader header */
+			boothdr = (struct fw_header *)(fw->data +
+				sizeof(struct fw_header));
+
+			bootloaderversion =
+				saa7164_readl(SAA_DEVICE_2ND_VERSION);
+			dprintk(DBGLVL_FW, "Onboard BootLoader:\n");
+			dprintk(DBGLVL_FW, "->Flag 0x%x\n",
+				saa7164_readl(SAA_BOOTLOADERERROR_FLAGS));
+			dprintk(DBGLVL_FW, "->Ack 0x%x\n",
+				saa7164_readl(SAA_DATAREADY_FLAG_ACK));
+			dprintk(DBGLVL_FW, "->FW Version 0x%x\n", version);
+			dprintk(DBGLVL_FW, "->Loader Version 0x%x\n",
+				bootloaderversion);
+
+			if ((saa7164_readl(SAA_BOOTLOADERERROR_FLAGS) ==
+				0x03) && (saa7164_readl(SAA_DATAREADY_FLAG_ACK)
+				== 0x00) && (version == 0x00)) {
+
+				dprintk(DBGLVL_FW, "BootLoader version in  "
+					"rom %d.%d.%d.%d\n",
+					(bootloaderversion & 0x0000fc00) >> 10,
+					(bootloaderversion & 0x000003e0) >> 5,
+					(bootloaderversion & 0x0000001f),
+					(bootloaderversion & 0xffff0000) >> 16
+					);
+				dprintk(DBGLVL_FW, "BootLoader version "
+					"in file %d.%d.%d.%d\n",
+					(boothdr->version & 0x0000fc00) >> 10,
+					(boothdr->version & 0x000003e0) >> 5,
+					(boothdr->version & 0x0000001f),
+					(boothdr->version & 0xffff0000) >> 16
+					);
+
+				if (bootloaderversion == boothdr->version)
+					updatebootloader = 0;
+			}
+
+			/* Calculate offset to firmware header */
+			tmp = (boothdr->firmwaresize + boothdr->bslsize) * 16 +
+				(sizeof(struct fw_header) +
+				sizeof(struct fw_header));
+
+			fwhdr = (struct fw_header *)(fw->data+tmp);
+		} else {
+			/* No second boot loader */
+			fwhdr = hdr;
+		}
+
+		dprintk(DBGLVL_FW, "Firmware version in file %d.%d.%d.%d\n",
+			(fwhdr->version & 0x0000fc00) >> 10,
+			(fwhdr->version & 0x000003e0) >> 5,
+			(fwhdr->version & 0x0000001f),
+			(fwhdr->version & 0xffff0000) >> 16
+			);
+
+		if (version == fwhdr->version) {
+			/* No download, firmware already on board */
+			ret = 0;
+			goto out;
+		}
+
+		if ((hdr->firmwaresize == 0) && (hdr->bslsize == 0)) {
+			if (updatebootloader) {
+				/* Get ready to upload the bootloader */
+				bootloadersize = (boothdr->firmwaresize +
+					boothdr->bslsize) * 16 +
+					sizeof(struct fw_header);
+
+				bootloaderoffset = (u8 *)(fw->data +
+					sizeof(struct fw_header));
+
+				dprintk(DBGLVL_FW, "bootloader d/l starts.\n");
+				printk(KERN_INFO "%s() FirmwareSize = 0x%x\n",
+					__func__, boothdr->firmwaresize);
+				printk(KERN_INFO "%s() BSLSize = 0x%x\n",
+					__func__, boothdr->bslsize);
+				printk(KERN_INFO "%s() Reserved = 0x%x\n",
+					__func__, boothdr->reserved);
+				printk(KERN_INFO "%s() Version = 0x%x\n",
+					__func__, boothdr->version);
+				ret = saa7164_downloadimage(
+					dev,
+					bootloaderoffset,
+					bootloadersize,
+					SAA_DOWNLOAD_FLAGS,
+					dev->bmmio + SAA_DEVICE_DOWNLOAD_OFFSET,
+					SAA_DEVICE_BUFFERBLOCKSIZE);
+				if (ret < 0) {
+					printk(KERN_ERR
+						"bootloader d/l has failed\n");
+					goto out;
+				}
+				dprintk(DBGLVL_FW,
+					"bootloader download complete.\n");
+
+			}
+
+			printk(KERN_ERR "starting firmware download(2)\n");
+			bootloadersize = (boothdr->firmwaresize +
+				boothdr->bslsize) * 16 +
+				sizeof(struct fw_header);
+
+			bootloaderoffset =
+				(u8 *)(fw->data + sizeof(struct fw_header));
+
+			fwloaderoffset = bootloaderoffset + bootloadersize;
+
+			/* TODO: fix this bounds overrun here with old f/ws */
+			fwloadersize = (fwhdr->firmwaresize + fwhdr->bslsize) *
+				16 + sizeof(struct fw_header);
+
+			ret = saa7164_downloadimage(
+				dev,
+				fwloaderoffset,
+				fwloadersize,
+				SAA_DEVICE_2ND_DOWNLOADFLAG_OFFSET,
+				dev->bmmio + SAA_DEVICE_2ND_DOWNLOAD_OFFSET,
+				SAA_DEVICE_2ND_BUFFERBLOCKSIZE);
+			if (ret < 0) {
+				printk(KERN_ERR "firmware download failed\n");
+				goto out;
+			}
+			printk(KERN_ERR "firmware download complete.\n");
+
+		} else {
+
+			/* No bootloader update reqd, download firmware only */
+			printk(KERN_ERR "starting firmware download(3)\n");
+
+			ret = saa7164_downloadimage(
+				dev,
+				(u8 *)fw->data,
+				fw->size,
+				SAA_DOWNLOAD_FLAGS,
+				dev->bmmio + SAA_DEVICE_DOWNLOAD_OFFSET,
+				SAA_DEVICE_BUFFERBLOCKSIZE);
+			if (ret < 0) {
+				printk(KERN_ERR "firmware download failed\n");
+				goto out;
+			}
+			printk(KERN_ERR "firmware download complete.\n");
+		}
+	}
+
+	ret = 0;
+
+out:
+	if (fw)
+		release_firmware(fw);
+
+	return ret;
+}
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164.h linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164.h
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164.h	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,400 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+	Driver architecture
+	*******************
+
+	saa7164_core.c/buffer.c/cards.c/i2c.c/dvb.c
+		|	: Standard Linux driver framework for creating
+		|	: exposing and managing interfaces to the rest
+		|	: of the kernel or userland. Also uses _fw.c to load
+		|	: firmware direct into the PCIe bus, bypassing layers.
+		V
+	saa7164_api..()	: Translate kernel specific functions/features
+		|	: into command buffers.
+		V
+	saa7164_cmd..()	: Manages the flow of command packets on/off,
+		|	: the bus. Deal with bus errors, timeouts etc.
+		V
+	saa7164_bus..() : Manage a read/write memory ring buffer in the
+		|	: PCIe Address space.
+		|
+		|		saa7164_fw...()	: Load any frimware
+		|			|	: direct into the device
+		V			V
+	<- ----------------- PCIe address space -------------------- ->
+*/
+
+#include <linux/pci.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+#include <linux/kdev_t.h>
+
+#include <media/tuner.h>
+#include <media/tveeprom.h>
+#include <media/videobuf-dma-sg.h>
+#include <media/videobuf-dvb.h>
+
+#include "saa7164-reg.h"
+#include "saa7164-types.h"
+
+#include <linux/version.h>
+#include <linux/mutex.h>
+
+#define SAA7164_MAXBOARDS 8
+
+#define UNSET (-1U)
+#define SAA7164_BOARD_NOAUTO			UNSET
+#define SAA7164_BOARD_UNKNOWN			0
+#define SAA7164_BOARD_UNKNOWN_REV2		1
+#define SAA7164_BOARD_UNKNOWN_REV3		2
+#define SAA7164_BOARD_HAUPPAUGE_HVR2250		3
+#define SAA7164_BOARD_HAUPPAUGE_HVR2200		4
+#define SAA7164_BOARD_HAUPPAUGE_HVR2200_2	5
+#define SAA7164_BOARD_HAUPPAUGE_HVR2200_3	6
+#define SAA7164_BOARD_HAUPPAUGE_HVR2250_2	7
+#define SAA7164_BOARD_HAUPPAUGE_HVR2250_3	8
+
+#define SAA7164_MAX_UNITS		8
+#define SAA7164_TS_NUMBER_OF_LINES	312
+#define SAA7164_PT_ENTRIES		16 /* (312 * 188) / 4096 */
+
+#define DBGLVL_FW    4
+#define DBGLVL_DVB   8
+#define DBGLVL_I2C  16
+#define DBGLVL_API  32
+#define DBGLVL_CMD  64
+#define DBGLVL_BUS 128
+#define DBGLVL_IRQ 256
+#define DBGLVL_BUF 512
+
+enum port_t {
+	SAA7164_MPEG_UNDEFINED = 0,
+	SAA7164_MPEG_DVB,
+};
+
+enum saa7164_i2c_bus_nr {
+	SAA7164_I2C_BUS_0 = 0,
+	SAA7164_I2C_BUS_1,
+	SAA7164_I2C_BUS_2,
+};
+
+enum saa7164_buffer_flags {
+	SAA7164_BUFFER_UNDEFINED = 0,
+	SAA7164_BUFFER_FREE,
+	SAA7164_BUFFER_BUSY,
+	SAA7164_BUFFER_FULL
+};
+
+enum saa7164_unit_type {
+	SAA7164_UNIT_UNDEFINED = 0,
+	SAA7164_UNIT_DIGITAL_DEMODULATOR,
+	SAA7164_UNIT_ANALOG_DEMODULATOR,
+	SAA7164_UNIT_TUNER,
+	SAA7164_UNIT_EEPROM,
+	SAA7164_UNIT_ZILOG_IRBLASTER,
+	SAA7164_UNIT_ENCODER,
+};
+
+/* The PCIe bridge doesn't grant direct access to i2c.
+ * Instead, you address i2c devices using a uniqely
+ * allocated 'unitid' value via a messaging API. This
+ * is a problem. The kernel and existing demod/tuner
+ * drivers expect to talk 'i2c', so we have to maintain
+ * a translation layer, and a series of functions to
+ * convert i2c bus + device address into a unit id.
+ */
+struct saa7164_unit {
+	enum saa7164_unit_type type;
+	u8	id;
+	char	*name;
+	enum saa7164_i2c_bus_nr i2c_bus_nr;
+	u8	i2c_bus_addr;
+	u8	i2c_reg_len;
+};
+
+struct saa7164_board {
+	char	*name;
+	enum port_t porta, portb;
+	enum {
+		SAA7164_CHIP_UNDEFINED = 0,
+		SAA7164_CHIP_REV2,
+		SAA7164_CHIP_REV3,
+	} chiprev;
+	struct	saa7164_unit unit[SAA7164_MAX_UNITS];
+};
+
+struct saa7164_subid {
+	u16     subvendor;
+	u16     subdevice;
+	u32     card;
+};
+
+struct saa7164_fw_status {
+
+	/* RISC Core details */
+	u32	status;
+	u32	mode;
+	u32	spec;
+	u32	inst;
+	u32	cpuload;
+	u32	remainheap;
+
+	/* Firmware version */
+	u32	version;
+	u32	major;
+	u32	sub;
+	u32	rel;
+	u32	buildnr;
+};
+
+struct saa7164_dvb {
+	struct mutex lock;
+	struct dvb_adapter adapter;
+	struct dvb_frontend *frontend;
+	struct dvb_demux demux;
+	struct dmxdev dmxdev;
+	struct dmx_frontend fe_hw;
+	struct dmx_frontend fe_mem;
+	struct dvb_net net;
+	int feeding;
+};
+
+struct saa7164_i2c {
+	struct saa7164_dev		*dev;
+
+	enum saa7164_i2c_bus_nr		nr;
+
+	/* I2C I/O */
+	struct i2c_adapter		i2c_adap;
+	struct i2c_algo_bit_data	i2c_algo;
+	struct i2c_client		i2c_client;
+	u32				i2c_rc;
+};
+
+struct saa7164_tsport;
+
+struct saa7164_buffer {
+	struct list_head list;
+
+	u32 nr;
+
+	struct saa7164_tsport *port;
+
+	/* Hardware Specific */
+	/* PCI Memory allocations */
+	enum saa7164_buffer_flags flags; /* Free, Busy, Full */
+
+	/* A block of page align PCI memory */
+	u32 pci_size;	/* PCI allocation size in bytes */
+	u64 *cpu;	/* Virtual address */
+	dma_addr_t dma;	/* Physical address */
+
+	/* A page table that splits the block into a number of entries */
+	u32 pt_size;		/* PCI allocation size in bytes */
+	u64 *pt_cpu;		/* Virtual address */
+	dma_addr_t pt_dma;	/* Physical address */
+};
+
+struct saa7164_tsport {
+
+	struct saa7164_dev *dev;
+	int nr;
+	enum port_t type;
+
+	struct saa7164_dvb dvb;
+
+	/* HW related stream parameters */
+	tmHWStreamParameters_t hw_streamingparams;
+
+	/* DMA configuration values, is seeded during initialization */
+	tmComResDMATermDescrHeader_t hwcfg;
+
+	/* hardware specific registers */
+	u32 bufcounter;
+	u32 pitch;
+	u32 bufsize;
+	u32 bufoffset;
+	u32 bufptr32l;
+	u32 bufptr32h;
+	u64 bufptr64;
+
+	u32 numpte;	/* Number of entries in array, only valid in head */
+	struct mutex dmaqueue_lock;
+	struct mutex dummy_dmaqueue_lock;
+	struct saa7164_buffer dmaqueue;
+	struct saa7164_buffer dummy_dmaqueue;
+
+};
+
+struct saa7164_dev {
+	struct list_head	devlist;
+	atomic_t		refcount;
+
+	/* pci stuff */
+	struct pci_dev	*pci;
+	unsigned char	pci_rev, pci_lat;
+	int		pci_bus, pci_slot;
+	u32		__iomem *lmmio;
+	u8		__iomem *bmmio;
+	u32		__iomem *lmmio2;
+	u8		__iomem *bmmio2;
+	int		pci_irqmask;
+
+	/* board details */
+	int	nr;
+	int	hwrevision;
+	u32	board;
+	char	name[32];
+
+	/* firmware status */
+	struct saa7164_fw_status	fw_status;
+
+	tmComResHWDescr_t		hwdesc;
+	tmComResInterfaceDescr_t	intfdesc;
+	tmComResBusDescr_t		busdesc;
+
+	tmComResBusInfo_t		bus;
+
+	/* Interrupt status and ack registers */
+	u32 int_status;
+	u32 int_ack;
+
+	struct cmd			cmds[SAA_CMD_MAX_MSG_UNITS];
+	struct mutex			lock;
+
+	/* I2c related */
+	struct saa7164_i2c i2c_bus[3];
+
+	/* Transport related */
+	struct saa7164_tsport ts1, ts2;
+
+	/* Deferred command/api interrupts handling */
+	struct work_struct workcmd;
+
+};
+
+extern struct list_head saa7164_devlist;
+extern unsigned int waitsecs;
+
+/* ----------------------------------------------------------- */
+/* saa7164-core.c                                              */
+void saa7164_dumpregs(struct saa7164_dev *dev, u32 addr);
+void saa7164_dumphex16(struct saa7164_dev *dev, u8 *buf, int len);
+void saa7164_getfirmwarestatus(struct saa7164_dev *dev);
+u32 saa7164_getcurrentfirmwareversion(struct saa7164_dev *dev);
+
+/* ----------------------------------------------------------- */
+/* saa7164-fw.c                                                */
+int saa7164_downloadfirmware(struct saa7164_dev *dev);
+
+/* ----------------------------------------------------------- */
+/* saa7164-i2c.c                                               */
+extern int saa7164_i2c_register(struct saa7164_i2c *bus);
+extern int saa7164_i2c_unregister(struct saa7164_i2c *bus);
+extern void saa7164_call_i2c_clients(struct saa7164_i2c *bus,
+	unsigned int cmd, void *arg);
+
+/* ----------------------------------------------------------- */
+/* saa7164-bus.c                                               */
+int saa7164_bus_setup(struct saa7164_dev *dev);
+void saa7164_bus_dump(struct saa7164_dev *dev);
+int saa7164_bus_set(struct saa7164_dev *dev, tmComResInfo_t* msg, void *buf);
+int saa7164_bus_get(struct saa7164_dev *dev, tmComResInfo_t* msg,
+	void *buf, int peekonly);
+
+/* ----------------------------------------------------------- */
+/* saa7164-cmd.c                                               */
+int saa7164_cmd_send(struct saa7164_dev *dev,
+	u8 id, tmComResCmd_t command, u16 controlselector,
+	u16 size, void *buf);
+void saa7164_cmd_signal(struct saa7164_dev *dev, u8 seqno);
+int saa7164_irq_dequeue(struct saa7164_dev *dev);
+
+/* ----------------------------------------------------------- */
+/* saa7164-api.c                                               */
+int saa7164_api_get_fw_version(struct saa7164_dev *dev, u32 *version);
+int saa7164_api_enum_subdevs(struct saa7164_dev *dev);
+int saa7164_api_i2c_read(struct saa7164_i2c *bus, u8 addr, u32 reglen, u8 *reg,
+	u32 datalen, u8 *data);
+int saa7164_api_i2c_write(struct saa7164_i2c *bus, u8 addr,
+	u32 datalen, u8 *data);
+int saa7164_api_dif_write(struct saa7164_i2c *bus, u8 addr,
+	u32 datalen, u8 *data);
+int saa7164_api_read_eeprom(struct saa7164_dev *dev, u8 *buf, int buflen);
+int saa7164_api_set_gpiobit(struct saa7164_dev *dev, u8 unitid, u8 pin);
+int saa7164_api_clear_gpiobit(struct saa7164_dev *dev, u8 unitid, u8 pin);
+int saa7164_api_transition_port(struct saa7164_tsport *port, u8 mode);
+
+/* ----------------------------------------------------------- */
+/* saa7164-cards.c                                             */
+extern struct saa7164_board saa7164_boards[];
+extern const unsigned int saa7164_bcount;
+
+extern struct saa7164_subid saa7164_subids[];
+extern const unsigned int saa7164_idcount;
+
+extern void saa7164_card_list(struct saa7164_dev *dev);
+extern void saa7164_gpio_setup(struct saa7164_dev *dev);
+extern void saa7164_card_setup(struct saa7164_dev *dev);
+
+extern int saa7164_i2caddr_to_reglen(struct saa7164_i2c *bus, int addr);
+extern int saa7164_i2caddr_to_unitid(struct saa7164_i2c *bus, int addr);
+extern char *saa7164_unitid_name(struct saa7164_dev *dev, u8 unitid);
+
+/* ----------------------------------------------------------- */
+/* saa7164-dvb.c                                               */
+extern int saa7164_dvb_register(struct saa7164_tsport *port);
+extern int saa7164_dvb_unregister(struct saa7164_tsport *port);
+
+/* ----------------------------------------------------------- */
+/* saa7164-buffer.c                                            */
+extern struct saa7164_buffer *saa7164_buffer_alloc(struct saa7164_tsport *port,
+	u32 len);
+extern int saa7164_buffer_dealloc(struct saa7164_tsport *port,
+	struct saa7164_buffer *buf);
+
+/* ----------------------------------------------------------- */
+
+extern unsigned int saa_debug;
+#define dprintk(level, fmt, arg...)\
+	do { if (saa_debug & level)\
+		printk(KERN_DEBUG "%s: " fmt, dev->name, ## arg);\
+	} while (0)
+
+#define log_warn(fmt, arg...)\
+	do { \
+		printk(KERN_WARNING "%s: " fmt, dev->name, ## arg);\
+	} while (0)
+
+#define log_err(fmt, arg...)\
+	do { \
+		printk(KERN_ERROR "%s: " fmt, dev->name, ## arg);\
+	} while (0)
+
+#define saa7164_readl(reg) readl(dev->lmmio + ((reg) >> 2))
+#define saa7164_writel(reg, value) writel((value), dev->lmmio + ((reg) >> 2))
+
+
+#define saa7164_readb(reg)             readl(dev->bmmio + (reg))
+#define saa7164_writeb(reg, value)     writel((value), dev->bmmio + (reg))
+
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-i2c.c linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-i2c.c
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-i2c.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-i2c.c	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,141 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+
+#include "saa7164.h"
+
+static int i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)
+{
+	struct saa7164_i2c *bus = i2c_adap->algo_data;
+	struct saa7164_dev *dev = bus->dev;
+	int i, retval = 0;
+
+	dprintk(DBGLVL_I2C, "%s(num = %d)\n", __func__, num);
+
+	for (i = 0 ; i < num; i++) {
+		dprintk(DBGLVL_I2C, "%s(num = %d) addr = 0x%02x  len = 0x%x\n",
+			__func__, num, msgs[i].addr, msgs[i].len);
+		if (msgs[i].flags & I2C_M_RD) {
+			/* Unsupported - Yet*/
+			printk(KERN_ERR "%s() Unsupported - Yet\n", __func__);
+			continue;
+		} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&
+			   msgs[i].addr == msgs[i + 1].addr) {
+			/* write then read from same address */
+
+			retval = saa7164_api_i2c_read(bus, msgs[i].addr,
+				msgs[i].len, msgs[i].buf,
+				msgs[i+1].len, msgs[i+1].buf
+				);
+
+			i++;
+
+			if (retval < 0)
+				goto err;
+		} else {
+			/* write */
+			retval = saa7164_api_i2c_write(bus, msgs[i].addr,
+				msgs[i].len, msgs[i].buf);
+		}
+		if (retval < 0)
+			goto err;
+	}
+	return num;
+
+ err:
+	return retval;
+}
+
+void saa7164_call_i2c_clients(struct saa7164_i2c *bus, unsigned int cmd,
+	void *arg)
+{
+	if (bus->i2c_rc != 0)
+		return;
+
+	i2c_clients_command(&bus->i2c_adap, cmd, arg);
+}
+
+static u32 saa7164_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm saa7164_i2c_algo_template = {
+	.master_xfer	= i2c_xfer,
+	.functionality	= saa7164_functionality,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static struct i2c_adapter saa7164_i2c_adap_template = {
+	.name              = "saa7164",
+	.owner             = THIS_MODULE,
+	.algo              = &saa7164_i2c_algo_template,
+};
+
+static struct i2c_client saa7164_i2c_client_template = {
+	.name	= "saa7164 internal",
+};
+
+int saa7164_i2c_register(struct saa7164_i2c *bus)
+{
+	struct saa7164_dev *dev = bus->dev;
+
+	dprintk(DBGLVL_I2C, "%s(bus = %d)\n", __func__, bus->nr);
+
+	memcpy(&bus->i2c_adap, &saa7164_i2c_adap_template,
+	       sizeof(bus->i2c_adap));
+
+	memcpy(&bus->i2c_algo, &saa7164_i2c_algo_template,
+	       sizeof(bus->i2c_algo));
+
+	memcpy(&bus->i2c_client, &saa7164_i2c_client_template,
+	       sizeof(bus->i2c_client));
+
+	bus->i2c_adap.dev.parent = &dev->pci->dev;
+
+	strlcpy(bus->i2c_adap.name, bus->dev->name,
+		sizeof(bus->i2c_adap.name));
+
+	bus->i2c_algo.data = bus;
+	bus->i2c_adap.algo_data = bus;
+	i2c_set_adapdata(&bus->i2c_adap, bus);
+	i2c_add_adapter(&bus->i2c_adap);
+
+	bus->i2c_client.adapter = &bus->i2c_adap;
+
+	if (0 != bus->i2c_rc)
+		printk(KERN_ERR "%s: i2c bus %d register FAILED\n",
+			dev->name, bus->nr);
+
+	return bus->i2c_rc;
+}
+
+int saa7164_i2c_unregister(struct saa7164_i2c *bus)
+{
+	i2c_del_adapter(&bus->i2c_adap);
+	return 0;
+}
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-reg.h linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-reg.h
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-reg.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-reg.h	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,166 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* TODO: Retest the driver with errors expressed as negatives */
+
+/* Result codes */
+#define SAA_OK				0
+#define SAA_ERR_BAD_PARAMETER		0x09
+#define SAA_ERR_NO_RESOURCES		0x0c
+#define SAA_ERR_NOT_SUPPORTED		0x13
+#define SAA_ERR_BUSY			0x15
+#define SAA_ERR_READ			0x17
+#define SAA_ERR_TIMEOUT			0x1f
+#define SAA_ERR_OVERFLOW		0x20
+#define SAA_ERR_EMPTY			0x22
+#define SAA_ERR_NOT_STARTED		0x23
+#define SAA_ERR_ALREADY_STARTED		0x24
+#define SAA_ERR_NOT_STOPPED		0x25
+#define SAA_ERR_ALREADY_STOPPED		0x26
+#define SAA_ERR_INVALID_COMMAND		0x3e
+#define SAA_ERR_NULL_PACKET		0x59
+
+/* Errors and flags from the silicon */
+#define PVC_ERRORCODE_UNKNOWN		0x00
+#define PVC_ERRORCODE_INVALID_COMMAND	0x01
+#define PVC_ERRORCODE_INVALID_CONTROL	0x02
+#define PVC_ERRORCODE_INVALID_DATA	0x03
+#define PVC_ERRORCODE_TIMEOUT		0x04
+#define PVC_ERRORCODE_NAK		0x05
+#define PVC_RESPONSEFLAG_ERROR		0x01
+#define PVC_RESPONSEFLAG_OVERFLOW	0x02
+#define PVC_RESPONSEFLAG_RESET		0x04
+#define PVC_RESPONSEFLAG_INTERFACE	0x08
+#define PVC_RESPONSEFLAG_CONTINUED	0x10
+#define PVC_CMDFLAG_INTERRUPT		0x02
+#define PVC_CMDFLAG_INTERFACE		0x04
+#define PVC_CMDFLAG_SERIALIZE		0x08
+#define PVC_CMDFLAG_CONTINUE		0x10
+
+/* Silicon Commands */
+#define GET_DESCRIPTORS_CONTROL		0x01
+#define GET_STRING_CONTROL		0x03
+#define GET_LANGUAGE_CONTROL		0x05
+#define SET_POWER_CONTROL		0x07
+#define GET_FW_VERSION_CONTROL		0x09
+#define SET_DEBUG_LEVEL_CONTROL		0x0B
+#define GET_DEBUG_DATA_CONTROL		0x0C
+#define GET_PRODUCTION_INFO_CONTROL	0x0D
+
+/* cmd defines */
+#define SAA_CMDFLAG_CONTINUE		0x10
+#define SAA_CMD_MAX_MSG_UNITS		256
+
+/* Some defines */
+#define SAA_BUS_TIMEOUT			50
+#define SAA_DEVICE_TIMEOUT		5000
+#define SAA_DEVICE_MAXREQUESTSIZE	256
+
+/* Register addresses */
+#define SAA_DEVICE_VERSION		0x30
+#define SAA_DOWNLOAD_FLAGS		0x34
+#define SAA_DOWNLOAD_FLAG		0x34
+#define SAA_DOWNLOAD_FLAG_ACK		0x38
+#define SAA_DATAREADY_FLAG		0x3C
+#define SAA_DATAREADY_FLAG_ACK		0x40
+
+/* Boot loader register and bit definitions */
+#define SAA_BOOTLOADERERROR_FLAGS	0x44
+#define SAA_DEVICE_IMAGE_SEARCHING	0x01
+#define SAA_DEVICE_IMAGE_LOADING	0x02
+#define SAA_DEVICE_IMAGE_BOOTING	0x03
+#define SAA_DEVICE_IMAGE_CORRUPT	0x04
+#define SAA_DEVICE_MEMORY_CORRUPT	0x08
+#define SAA_DEVICE_NO_IMAGE		0x10
+
+/* Register addresses */
+#define SAA_DEVICE_2ND_VERSION			0x50
+#define SAA_DEVICE_2ND_DOWNLOADFLAG_OFFSET	0x54
+
+/* Register addresses */
+#define SAA_SECONDSTAGEERROR_FLAGS		0x64
+
+/* Bootloader regs and flags */
+#define SAA_DEVICE_DEADLOCK_DETECTED_OFFSET	0x6C
+#define SAA_DEVICE_DEADLOCK_DETECTED		0xDEADDEAD
+
+/* Basic firmware status registers */
+#define SAA_DEVICE_SYSINIT_STATUS_OFFSET	0x70
+#define SAA_DEVICE_SYSINIT_STATUS		0x70
+#define SAA_DEVICE_SYSINIT_MODE			0x74
+#define SAA_DEVICE_SYSINIT_SPEC			0x78
+#define SAA_DEVICE_SYSINIT_INST			0x7C
+#define SAA_DEVICE_SYSINIT_CPULOAD		0x80
+#define SAA_DEVICE_SYSINIT_REMAINHEAP		0x84
+
+#define SAA_DEVICE_DOWNLOAD_OFFSET		0x1000
+#define SAA_DEVICE_BUFFERBLOCKSIZE		0x1000
+
+#define SAA_DEVICE_2ND_BUFFERBLOCKSIZE		0x100000
+#define SAA_DEVICE_2ND_DOWNLOAD_OFFSET		0x200000
+
+/* Descriptors */
+#define CS_INTERFACE	0x24
+
+/* Descriptor subtypes */
+#define VC_INPUT_TERMINAL		0x02
+#define VC_OUTPUT_TERMINAL		0x03
+#define VC_SELECTOR_UNIT		0x04
+#define VC_PROCESSING_UNIT		0x05
+#define FEATURE_UNIT			0x06
+#define TUNER_UNIT			0x09
+#define ENCODER_UNIT			0x0A
+#define EXTENSION_UNIT			0x0B
+#define VC_TUNER_PATH			0xF0
+#define PVC_HARDWARE_DESCRIPTOR		0xF1
+#define PVC_INTERFACE_DESCRIPTOR	0xF2
+#define PVC_INFRARED_UNIT		0xF3
+#define DRM_UNIT			0xF4
+#define GENERAL_REQUEST			0xF5
+
+/* Format Types */
+#define VS_FORMAT_TYPE         0x02
+#define VS_FORMAT_TYPE_I       0x01
+#define VS_FORMAT_UNCOMPRESSED 0x04
+#define VS_FRAME_UNCOMPRESSED  0x05
+#define VS_FORMAT_MPEG2PS      0x09
+#define VS_FORMAT_MPEG2TS      0x0A
+#define VS_FORMAT_MPEG4SL      0x0B
+#define VS_FORMAT_WM9          0x0C
+#define VS_FORMAT_DIVX         0x0D
+#define VS_FORMAT_VBI          0x0E
+#define VS_FORMAT_RDS          0x0F
+
+/* Device extension commands */
+#define EXU_REGISTER_ACCESS_CONTROL	0x00
+#define EXU_GPIO_CONTROL		0x01
+#define EXU_GPIO_GROUP_CONTROL		0x02
+#define EXU_INTERRUPT_CONTROL		0x03
+
+/* State Transition and args */
+#define SAA_STATE_CONTROL	0x03
+#define SAA_DMASTATE_STOP	0x00
+#define SAA_DMASTATE_ACQUIRE	0x01
+#define SAA_DMASTATE_PAUSE	0x02
+#define SAA_DMASTATE_RUN	0x03
+
+/* Hardware registers */
+
diff -Naur linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-types.h linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-types.h
--- linux-2.6.31.7-old/drivers/media/video/saa7164/saa7164-types.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.31.7-new/drivers/media/video/saa7164/saa7164-types.h	2009-12-10 09:22:12.000000000 -0800
@@ -0,0 +1,287 @@
+/*
+ *  Driver for the NXP SAA7164 PCIe bridge
+ *
+ *  Copyright (c) 2009 Steven Toth <stoth@kernellabs.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* TODO: Cleanup and shorten the namespace */
+
+/* Some structues are passed directly to/from the firmware and
+ * have strict alignment requirements. This is one of them.
+ */
+typedef struct {
+	u8	bLength;
+	u8	bDescriptorType;
+	u8	bDescriptorSubtype;
+	u16	bcdSpecVersion;
+	u32	dwClockFrequency;
+	u32	dwClockUpdateRes;
+	u8	bCapabilities;
+	u32	dwDeviceRegistersLocation;
+	u32	dwHostMemoryRegion;
+	u32	dwHostMemoryRegionSize;
+	u32	dwHostHibernatMemRegion;
+	u32	dwHostHibernatMemRegionSize;
+} __attribute__((packed)) tmComResHWDescr_t;
+
+/* This is DWORD aligned on windows but I can't find the right
+ * gcc syntax to match the binary data from the device.
+ * I've manually padded with Reserved[3] bytes to match the hardware,
+ * but this could break if GCC decies to pack in a different way.
+ */
+typedef struct {
+	u8	bLength;
+	u8	bDescriptorType;
+	u8	bDescriptorSubtype;
+	u8	bFlags;
+	u8	bInterfaceType;
+	u8	bInterfaceId;
+	u8	bBaseInterface;
+	u8	bInterruptId;
+	u8	bDebugInterruptId;
+	u8	BARLocation;
+	u8	Reserved[3];
+} tmComResInterfaceDescr_t;
+
+typedef struct {
+	u64	CommandRing;
+	u64	ResponseRing;
+	u32	CommandWrite;
+	u32	CommandRead;
+	u32	ResponseWrite;
+	u32	ResponseRead;
+} tmComResBusDescr_t;
+
+typedef enum {
+	NONE		= 0,
+	TYPE_BUS_PCI	= 1,
+	TYPE_BUS_PCIe	= 2,
+	TYPE_BUS_USB	= 3,
+	TYPE_BUS_I2C	= 4
+} tmBusType_t;
+
+typedef struct {
+	tmBusType_t Type;
+	u16	m_wMaxReqSize;
+	u8	*m_pdwSetRing;
+	u32	m_dwSizeSetRing;
+	u8	*m_pdwGetRing;
+	u32	m_dwSizeGetRing;
+	u32	*m_pdwSetWritePos;
+	u32	*m_pdwSetReadPos;
+	u32	*m_pdwGetWritePos;
+	u32	*m_pdwGetReadPos;
+
+	/* All access is protected */
+	struct mutex lock;
+
+} tmComResBusInfo_t;
+
+typedef struct {
+	u8	id;
+	u8	flags;
+	u16	size;
+	u32	command;
+	u16	controlselector;
+	u8	seqno;
+} __attribute__((packed)) tmComResInfo_t;
+
+typedef enum {
+	SET_CUR  = 0x01,
+	GET_CUR  = 0x81,
+	GET_MIN  = 0x82,
+	GET_MAX  = 0x83,
+	GET_RES  = 0x84,
+	GET_LEN  = 0x85,
+	GET_INFO = 0x86,
+	GET_DEF  = 0x87
+} tmComResCmd_t;
+
+struct cmd {
+	u8 seqno;
+	u32 inuse;
+	u32 timeout;
+	u32 signalled;
+	struct mutex lock;
+	wait_queue_head_t wait;
+};
+
+typedef struct {
+	u32	pathid;
+	u32	size;
+	void	*descriptor;
+} tmDescriptor_t;
+
+typedef struct {
+	u8	len;
+	u8	type;
+	u8	subtype;
+	u8	unitid;
+} __attribute__((packed)) tmComResDescrHeader_t;
+
+typedef struct {
+	u8	len;
+	u8	type;
+	u8	subtype;
+	u8	unitid;
+	u32	devicetype;
+	u16	deviceid;
+	u32	numgpiopins;
+	u8	numgpiogroups;
+	u8	controlsize;
+} __attribute__((packed)) tmComResExtDevDescrHeader_t;
+
+typedef struct {
+	u32	pin;
+	u8	state;
+} __attribute__((packed)) tmComResGPIO_t;
+
+typedef struct {
+	u8	len;
+	u8	type;
+	u8	subtype;
+	u8	pathid;
+} __attribute__((packed)) tmComResPathDescrHeader_t;
+
+/* terminaltype */
+typedef enum {
+	ITT_ANTENNA              = 0x0203,
+	LINE_CONNECTOR           = 0x0603,
+	SPDIF_CONNECTOR          = 0x0605,
+	COMPOSITE_CONNECTOR      = 0x0401,
+	SVIDEO_CONNECTOR         = 0x0402,
+	COMPONENT_CONNECTOR      = 0x0403,
+	STANDARD_DMA             = 0xF101
+} tmComResTermType_t;
+
+typedef struct {
+	u8	len;
+	u8	type;
+	u8	subtype;
+	u8	terminalid;
+	u16	terminaltype;
+	u8	assocterminal;
+	u8	iterminal;
+	u8	controlsize;
+} __attribute__((packed)) tmComResAntTermDescrHeader_t;
+
+typedef struct {
+	u8	len;
+	u8	type;
+	u8	subtype;
+	u8	unitid;
+	u8	sourceid;
+	u8	iunit;
+	u32	tuningstandards;
+	u8	controlsize;
+	u32	controls;
+} __attribute__((packed)) tmComResTunerDescrHeader_t;
+
+typedef enum {
+	/* the buffer does not contain any valid data */
+	TM_BUFFER_FLAG_EMPTY,
+
+	/* the buffer is filled with valid data */
+	TM_BUFFER_FLAG_DONE,
+
+	/* the buffer is the dummy buffer - TODO??? */
+	TM_BUFFER_FLAG_DUMMY_BUFFER
+} tmBufferFlag_t;
+
+typedef struct {
+	u64		*pagetablevirt;
+	u64		pagetablephys;
+	u16		offset;
+	u8		*context;
+	u64		timestamp;
+	tmBufferFlag_t	BufferFlag_t;
+	u32		lostbuffers;
+	u32		validbuffers;
+	u64		*dummypagevirt;
+	u64		dummypagephys;
+	u64		*addressvirt;
+} tmBuffer_t;
+
+typedef struct {
+	u32	bitspersample;
+	u32	samplesperline;
+	u32	numberoflines;
+	u32	pitch;
+	u32	linethreshold;
+	u64	**pagetablelistvirt;
+	u64	*pagetablelistphys;
+	u32	numpagetables;
+	u32	numpagetableentries;
+} tmHWStreamParameters_t;
+
+typedef struct {
+	tmHWStreamParameters_t		HWStreamParameters_t;
+	u64				qwDummyPageTablePhys;
+	u64				*pDummyPageTableVirt;
+} tmStreamParameters_t;
+
+typedef struct {
+	u8	len;
+	u8	type;
+	u8	subtyle;
+	u8	unitid;
+	u16	terminaltype;
+	u8	assocterminal;
+	u8	sourceid;
+	u8	iterminal;
+	u32	BARLocation;
+	u8	flags;
+	u8	interruptid;
+	u8	buffercount;
+	u8	metadatasize;
+	u8	numformats;
+	u8	controlsize;
+} __attribute__((packed)) tmComResDMATermDescrHeader_t;
+
+/*
+ *
+ * Description:
+ *  This is the transport stream format header.
+ *
+ * Settings:
+ *  bLength                 - The size of this descriptor in bytes.
+ *  bDescriptorType         - CS_INTERFACE.
+ *  bDescriptorSubtype      - VS_FORMAT_MPEG2TS descriptor subtype.
+ *  bFormatIndex            - A non-zero constant that uniquely identifies the
+ *                            format.
+ *  bDataOffset             - Offset to TSP packet within MPEG-2 TS transport
+ *                            stride, in bytes.
+ *  bPacketLength           - Length of TSP packet, in bytes (typically 188).
+ *  bStrideLength           - Length of MPEG-2 TS transport stride.
+ *  guidStrideFormat        - A Globally Unique Identifier indicating the
+ *                            format of the stride data (if any). Set to zeros
+ *                            if there is no Stride Data, or if the Stride
+ *                            Data is to be ignored by the application.
+ *
+ */
+typedef struct {
+	u8	len;
+	u8	type;
+	u8	subtype;
+	u8	bFormatIndex;
+	u8	bDataOffset;
+	u8	bPacketLength;
+	u8	bStrideLength;
+	u8	guidStrideFormat[16];
+} __attribute__((packed)) tmComResTSFormatDescrHeader_t;
+
