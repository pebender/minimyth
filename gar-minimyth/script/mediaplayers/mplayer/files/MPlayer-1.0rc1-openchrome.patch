diff -Naur MPlayer-1.0rc1-old/codec-cfg.c MPlayer-1.0rc1-new/codec-cfg.c
--- MPlayer-1.0rc1-old/codec-cfg.c	2006-10-22 15:32:31.000000000 -0700
+++ MPlayer-1.0rc1-new/codec-cfg.c	2006-12-28 15:30:56.000000000 -0800
@@ -178,6 +178,7 @@
 		{"ZRMJPEGIT", IMGFMT_ZRMJPEGIT},
 		{"ZRMJPEGIB", IMGFMT_ZRMJPEGIB},
 
+		{"VLD_MPEG2",IMGFMT_XVMC_VLD_MPEG2},
 		{"IDCT_MPEG2",IMGFMT_XVMC_IDCT_MPEG2},
 		{"MOCO_MPEG2",IMGFMT_XVMC_MOCO_MPEG2},
 
diff -Naur MPlayer-1.0rc1-old/configure MPlayer-1.0rc1-new/configure
--- MPlayer-1.0rc1-old/configure	2006-10-22 15:32:31.000000000 -0700
+++ MPlayer-1.0rc1-new/configure	2006-12-28 15:30:56.000000000 -0800
@@ -438,7 +438,8 @@
   --with-xmmsplugindir=DIR XMMS plugins in DIR
   --with-xmmslibdir=DIR    libxmms.so.1 in DIR
   --with-cdparanoialibdir=DIR  cdparanoia libraries (libcdda_*) in DIR (*)
-  --with-xvmclib=NAME      name of adapter-specific library (e.g. XvMCNVIDIA)
+  --with-xvmclib=NAME      name of adapter-specific library
+                           (e.g. XvMCNVIDIA/I810XvMC/viaXvMC/viaXvMCPro)
 
   --with-freetype-config=PATH path to freetype-config
                               (e.g. /opt/bin/freetype-config)
@@ -1553,6 +1554,7 @@
 fi
 
 _prefix="/usr/local"
+_xvmclib=""
 
 # GOTCHA: the variables below defines the default behavior for autodetection
 # and have - unless stated otherwise - at least 2 states : yes no
@@ -3909,34 +3911,88 @@
 echores "$_xv"
 
 
-echocheck "XvMC"
-if test "$_xv" = yes && test "$_xvmc" != no ; then
-  _xvmc=no
-  cat > $TMPC <<EOF
-#include <X11/Xlib.h>
+xvmc_check()
+{
+  if test "$_xvmcvld" = yes; then
+    _xvmcinc="vldXvMC.h"
+  else
+    _xvmcinc="XvMClib.h"
+  fi
+
+  echo "#include <X11/Xlib.h>
 #include <X11/extensions/Xvlib.h>
-#include <X11/extensions/XvMClib.h>
+#include <X11/extensions/$_xvmcinc>
 int main(void) { 
   (void) XvMCQueryExtension(0,0,0);
   (void) XvMCCreateContext(0,0,0,0,0,0,0);
-  return 0; }
-EOF
-  for _ld_tmp in $_xvmclib XvMCNVIDIA XvMCW I810XvMC ; do
-    cc_check -lXvMC -l$_ld_tmp $_ld_xv $_ld_x11 && _xvmc=yes && _xvmclib="$_ld_tmp" && break
-  done
-fi
-if test "$_xvmc" = yes ; then
+  return 0; }" > $TMPC
+
+  _success=0
+  cc_check $_inc_x11 -lXvMC -l$_xvmclib $_ld_xv $_ld_x11 && _success=1
+  return $_ok
+}
+
+# Note: here we try to determine what xvmc capability is available
+# if the xvmc wrapper is available then we link to that, also we
+# check whether we can include the vld (slice) level xvmc include file
+if test "$_x11" = yes && test "$_xv" = yes && test "$_xvmc" != no ; then
+  _xvmc=no
+
+# No explicit xvmc lib specified so try and find one
+  if test "$_xvmclib" = ""; then
+# Try with the xvmc wrapper+vld first
+    echocheck "XvMC (Wrapper+vld)"
+    _xvmclib="XvMCW"
+    _xvmcvld=yes
+    xvmc_check && _xvmc=yes
+    echores $_xvmc
+
+# Try with the xvmc wrapper
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC (Wrapper)"
+      _xvmcvld=no
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+
+# Try with the nvidia lib
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC (NVIDIA)"
+      _xvmclib="XvMCNVIDIA"
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+  else
+# check for specified xvmc lib
+    echocheck "XvMC vld+("$_xvmclib")"
+    _xvmcvld=yes
+    xvmc_check && _xvmc=yes
+    echores $_xvmc
+
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC ("$_xvmclib")"
+      _xvmcvld=no
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+  fi
+
+  if test "$_xvmc" = yes ; then
   _def_xvmc='#define HAVE_XVMC 1'
   _ld_xvmc="-lXvMC -l$_xvmclib"
   _vosrc="$_vosrc vo_xvmc.c"
   _vomodules="xvmc $_vomodules"
-  _res_comment="using $_xvmclib"
-else
-  _def_xvmc='#undef HAVE_XVMC'
+  else
   _novomodules="xvmc $_novomodules"
-fi
-echores "$_xvmc"
+    _def_xvmc='#undef HAVE_XVMC'
+  fi
 
+  if test "$_xvmcvld" = yes; then
+    _def_xvmc_vld='#define HAVE_XVMC_VLD 1'
+  else
+    _def_xvmc_vld='#undef HAVE_XVMC_VLD'
+  fi
+fi
 
 echocheck "Xinerama"
 if test "$_xinerama" = auto ; then
@@ -8339,6 +8395,7 @@
 $_def_x11
 $_def_xv
 $_def_xvmc
+$_def_xvmc_vld
 $_def_vm
 $_def_xf86keysym
 $_def_xinerama
diff -Naur MPlayer-1.0rc1-old/etc/codecs.conf MPlayer-1.0rc1-new/etc/codecs.conf
--- MPlayer-1.0rc1-old/etc/codecs.conf	2006-10-22 15:32:31.000000000 -0700
+++ MPlayer-1.0rc1-new/etc/codecs.conf	2006-12-28 15:30:56.000000000 -0800
@@ -124,6 +124,7 @@
   fourcc mx5p        ; MPEG IMX 625/50 (50 Mb/s)
   driver ffmpeg
   dll "mpegvideo_xvmc"
+  out VLD_MPEG2
   out IDCT_MPEG2
   out MOCO_MPEG2
 
diff -Naur MPlayer-1.0rc1-old/help/help_mp-en.h MPlayer-1.0rc1-new/help/help_mp-en.h
--- MPlayer-1.0rc1-old/help/help_mp-en.h	2006-10-22 15:32:29.000000000 -0700
+++ MPlayer-1.0rc1-new/help/help_mp-en.h	2006-12-28 15:30:56.000000000 -0800
@@ -1525,6 +1525,7 @@
 #define MSGTR_MPCODECS_DRIFailure "[VD_FFMPEG] DRI failure.\n"
 #define MSGTR_MPCODECS_CouldntAllocateImageForCodec "[VD_FFMPEG] Couldn't allocate image for codec.\n"
 #define MSGTR_MPCODECS_XVMCAcceleratedMPEG2 "[VD_FFMPEG] XVMC-accelerated MPEG-2.\n"
+#define MSGTR_MPCODECS_XVMCVLDAcceleratedMPEG2 "[VD_FFMPEG] XVMC-VLD-accelerated MPEG-2.\n"
 #define MSGTR_MPCODECS_TryingPixfmt "[VD_FFMPEG] Trying pixfmt=%d.\n"
 #define MSGTR_MPCODECS_McGetBufferShouldWorkOnlyWithXVMC "[VD_FFMPEG] The mc_get_buffer should work only with XVMC acceleration!!"
 #define MSGTR_MPCODECS_UnexpectedInitVoError "[VD_FFMPEG] Unexpected init_vo error.\n"
diff -Naur MPlayer-1.0rc1-old/libavcodec/allcodecs.c MPlayer-1.0rc1-new/libavcodec/allcodecs.c
--- MPlayer-1.0rc1-old/libavcodec/allcodecs.c	2006-10-22 15:32:34.000000000 -0700
+++ MPlayer-1.0rc1-new/libavcodec/allcodecs.c	2006-12-28 15:30:56.000000000 -0800
@@ -309,6 +309,11 @@
 #ifdef CONFIG_MPEGVIDEO_DECODER
     register_avcodec(&mpegvideo_decoder);
 #endif //CONFIG_MPEGVIDEO_DECODER
+#ifdef HAVE_XVMC_VLD
+#ifdef CONFIG_MPEG_XVMC_DECODER
+    register_avcodec(&mpeg_xxmc_decoder);
+#endif //CONFIG_MPEG_XVMC_DECODER
+#endif
 #ifdef HAVE_XVMC
 #ifdef CONFIG_MPEG_XVMC_DECODER
     register_avcodec(&mpeg_xvmc_decoder);
diff -Naur MPlayer-1.0rc1-old/libavcodec/avcodec.h MPlayer-1.0rc1-new/libavcodec/avcodec.h
--- MPlayer-1.0rc1-old/libavcodec/avcodec.h	2006-10-22 15:32:34.000000000 -0700
+++ MPlayer-1.0rc1-new/libavcodec/avcodec.h	2006-12-28 15:30:56.000000000 -0800
@@ -2193,6 +2193,7 @@
 extern AVCodec mpeg2video_decoder;
 extern AVCodec mpegvideo_decoder;
 extern AVCodec mpeg_xvmc_decoder;
+extern AVCodec mpeg_xxmc_decoder;
 extern AVCodec h263i_decoder;
 extern AVCodec flv_decoder;
 extern AVCodec rv10_decoder;
diff -Naur MPlayer-1.0rc1-old/libavcodec/mpeg12.c MPlayer-1.0rc1-new/libavcodec/mpeg12.c
--- MPlayer-1.0rc1-old/libavcodec/mpeg12.c	2006-10-22 15:32:34.000000000 -0700
+++ MPlayer-1.0rc1-new/libavcodec/mpeg12.c	2006-12-28 15:30:56.000000000 -0800
@@ -85,10 +85,17 @@
 extern void XVMC_init_block(MpegEncContext *s);//set s->block
 #endif
 
+
+#ifdef HAVE_XVMC_VLD
+extern int XVMC_decode_slice(MpegEncContext *s, int start_code,
+                                 uint8_t *buffer, int buf_size);
+#endif
+
 const enum PixelFormat pixfmt_yuv_420[]= {PIX_FMT_YUV420P,-1};
 const enum PixelFormat pixfmt_yuv_422[]= {PIX_FMT_YUV422P,-1};
 const enum PixelFormat pixfmt_yuv_444[]= {PIX_FMT_YUV444P,-1};
 const enum PixelFormat pixfmt_xvmc_mpg2_420[] = {
+                                           PIX_FMT_XVMC_MPEG2_VLD,
                                            PIX_FMT_XVMC_MPEG2_IDCT,
                                            PIX_FMT_XVMC_MPEG2_MC,
                                            -1};
@@ -2527,6 +2534,16 @@
         return -1;
     }
 
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4){
+        int used = XVMC_decode_slice(s, mb_y, *buf, buf_size);
+        if (used < 0)
+            return DECODE_SLICE_ERROR;
+        *buf += used - 1;
+        return DECODE_SLICE_OK;
+    }
+#endif
+
     init_get_bits(&s->gb, *buf, buf_size*8);
 
     ff_mpeg1_clean_buffers(s);
@@ -3310,6 +3327,41 @@
 
 #endif
 
+#ifdef HAVE_XVMC_VLD
+static int mpeg_xxmc_decode_init(AVCodecContext *avctx){
+    Mpeg1Context *s;
+    if( avctx->thread_count > 1)
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_CODED_ORDER) )
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD) )
+        dprintf("mpeg12.c: XVMC_VLD decoder will work better if SLICE_FLAG_ALLOW_FIELD is set\n");
+
+    mpeg_decode_init(avctx);
+    s = avctx->priv_data;
+
+    avctx->pix_fmt = PIX_FMT_XVMC_MPEG2_VLD;
+    avctx->xvmc_acceleration = 4;
+
+    return 0;
+}
+
+AVCodec mpeg_xxmc_decoder = {
+    "mpegvideo_xvmc",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_MPEG2VIDEO_XVMC,
+    sizeof(Mpeg1Context),
+    mpeg_xxmc_decode_init,
+    NULL,
+    mpeg_decode_end,
+    mpeg_decode_frame,
+    CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED| CODEC_CAP_HWACCEL,
+    .flush= ff_mpeg_flush,
+};
+
+#endif
+
+
 /* this is ugly i know, but the alternative is too make
    hundreds of vars global and prefix them with ff_mpeg1_
    which is far uglier. */
diff -Naur MPlayer-1.0rc1-old/libavcodec/xvmcvideo.c MPlayer-1.0rc1-new/libavcodec/xvmcvideo.c
--- MPlayer-1.0rc1-old/libavcodec/xvmcvideo.c	2006-10-22 15:32:34.000000000 -0700
+++ MPlayer-1.0rc1-new/libavcodec/xvmcvideo.c	2006-12-28 15:30:56.000000000 -0800
@@ -72,10 +72,67 @@
     }
 }
 
+#ifdef HAVE_XVMC_VLD
+static XvMCSurface* findPastSurface(MpegEncContext *s,
+                                    xvmc_render_state_t *render)
+{
+    Picture *lastp = s->last_picture_ptr;
+    xvmc_render_state_t *last = NULL;
+
+    if (NULL!=lastp) {
+        last = (xvmc_render_state_t*)(lastp->data[2]);
+        if (B_TYPE==last->pict_type)
+            av_log(s->avctx,AV_LOG_DEBUG, "Past frame is a B frame in findPastSurface, this is bad.\n");
+        //assert(B_TYPE!=last->pict_type);
+    }
+
+    if (NULL==last)
+        if (!s->first_field)
+            last = render; // predict second field from the first
+        else
+            return 0;
+
+    if (last->magic != MP_XVMC_RENDER_MAGIC)
+        return 0;
+
+    return (last->state & MP_XVMC_STATE_PREDICTION) ? last->p_surface : 0;
+}
+
+static XvMCSurface* findFutureSurface(MpegEncContext *s)
+{
+    Picture *nextp = s->next_picture_ptr;
+    xvmc_render_state_t *next = NULL;
+
+    if (NULL!=nextp) {
+        next = (xvmc_render_state_t*)(nextp->data[2]);
+        if (B_TYPE==next->pict_type)
+            av_log(s->avctx,AV_LOG_DEBUG, "Next frame is a B frame in findFutureSurface, thisis bad.\n");
+        //assert(B_TYPE!=next->pict_type);
+    }
+
+    assert(NULL!=next);
+
+    if (next->magic != MP_XVMC_RENDER_MAGIC)
+        return 0;
+
+    return (next->state & MP_XVMC_STATE_PREDICTION) ? next->p_surface : 0;
+}
+#endif //HAVE_XVMC_VLD
+
 //these functions should be called on every new field or/and frame
 //They should be safe if they are called few times for same field!
 int XVMC_field_start(MpegEncContext*s, AVCodecContext *avctx){
-xvmc_render_state_t * render,* last, * next;
+    xvmc_render_state_t * render, * last, * next;
+
+#ifdef HAVE_XVMC_VLD
+    XvMCMpegControl     binfo;
+    XvMCQMatrix         qmatrix;
+    int                 i;
+    Status              status;
+
+    memset(&binfo, 0, sizeof(binfo));
+    memset(&qmatrix, 0, sizeof(qmatrix));
+#endif
 
     assert(avctx != NULL);
 
@@ -87,12 +144,53 @@
     render->picture_structure = s->picture_structure;
     render->flags = (s->first_field)? 0: XVMC_SECOND_FIELD;
 
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        if (render->picture_structure == PICT_FRAME)
+            render->flags |= XVMC_FRAME_PICTURE;
+        else if (render->picture_structure == PICT_TOP_FIELD)
+            render->flags |= XVMC_TOP_FIELD;
+        else if (render->picture_structure == PICT_BOTTOM_FIELD)
+            render->flags |= XVMC_BOTTOM_FIELD;
+    }
+    else
+#endif
+    {
 //make sure that all data is drawn by XVMC_end_frame
     assert(render->filled_mv_blocks_num==0);
+    }
 
     render->p_future_surface = NULL;
     render->p_past_surface = NULL;
 
+    render->pict_type = s->pict_type; // for later frame dropping use
+
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+{
+    switch(s->pict_type){
+        case  I_TYPE:
+            break;
+        case  B_TYPE:
+            render->p_past_surface = findPastSurface(s, render);
+            render->p_future_surface = findFutureSurface(s);
+            if (!render->p_past_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding B frame and past frame is null!");
+            else if (!render->p_future_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding B frame and future frame is null!");
+            break;
+            
+        case  P_TYPE:
+            render->p_past_surface = findPastSurface(s, render);
+            render->p_future_surface = render->p_surface;
+            if (!render->p_past_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding P frame and past frame is null!");
+            break;
+    }
+} else
+#endif
+{
     switch(s->pict_type){
         case  I_TYPE:
             return 0;// no prediction from other frames
@@ -113,8 +211,96 @@
             render->p_past_surface = last->p_surface;
             return 0;
     }
+}
+
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        for (i = 0; i < 64; i++){
+        qmatrix.intra_quantiser_matrix[i] = s->intra_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.non_intra_quantiser_matrix[i] = s->inter_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.chroma_intra_quantiser_matrix[i] = s->chroma_intra_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.chroma_non_intra_quantiser_matrix[i] = s->chroma_inter_matrix[s->dsp.idct_permutation[i]];
+        }
+
+    qmatrix.load_intra_quantiser_matrix = 1;
+    qmatrix.load_non_intra_quantiser_matrix = 1;
+    qmatrix.load_chroma_intra_quantiser_matrix = 1;
+    qmatrix.load_chroma_non_intra_quantiser_matrix = 1;
+
+
+    binfo.flags = 0;
+    if (s->alternate_scan)
+        binfo.flags |= XVMC_ALTERNATE_SCAN;
+    if (s->top_field_first)
+        binfo.flags |= XVMC_TOP_FIELD_FIRST;
+    if (s->frame_pred_frame_dct)
+        binfo.flags |= XVMC_PRED_DCT_FRAME;
+    else
+        binfo.flags |= XVMC_PRED_DCT_FIELD;
+
+    if (s->intra_vlc_format)
+        binfo.flags |= XVMC_INTRA_VLC_FORMAT;
+    if (!s->first_field && !s->progressive_sequence)
+        binfo.flags |= XVMC_SECOND_FIELD;
+    if (s->q_scale_type)
+        binfo.flags |= XVMC_Q_SCALE_TYPE;
+    if (s->concealment_motion_vectors)
+        binfo.flags |= XVMC_CONCEALMENT_MOTION_VECTORS;
+    if (s->progressive_sequence)
+        binfo.flags |= XVMC_PROGRESSIVE_SEQUENCE;
+
+    binfo.picture_structure = s->picture_structure;
+    switch (s->pict_type)
+    {
+    case I_TYPE:    binfo.picture_coding_type = XVMC_I_PICTURE;     break;
+    case P_TYPE:    binfo.picture_coding_type = XVMC_P_PICTURE;     break;
+    case B_TYPE:    binfo.picture_coding_type = XVMC_B_PICTURE;     break;
+    default:    av_log(avctx, AV_LOG_ERROR, "%s: Unknown picture coding type: %d\n", __FUNCTION__, s->pict_type);
+    }
+
+    binfo.intra_dc_precision = s->intra_dc_precision;;
+
+    if (s->codec_id == CODEC_ID_MPEG2VIDEO)
+        binfo.mpeg_coding = 2;
+    else
+        binfo.mpeg_coding = 1;
+
+    s->mb_width = (s->width + 15) / 16;
+    s->mb_height = (s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence) ?
+        2 * ((s->height + 31) / 32) : (s->height + 15) / 16;
+
+    if (s->codec_id == CODEC_ID_MPEG2VIDEO)
+{
+    binfo.FVMV_range = (s->mpeg_f_code[0][1] - 1);
+    binfo.FHMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.BVMV_range = (s->mpeg_f_code[1][1] - 1);
+    binfo.BHMV_range = (s->mpeg_f_code[1][0] - 1);
+}
+else
+{
+    binfo.FVMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.FHMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.BVMV_range = (s->mpeg_f_code[1][1] - 1);
+    binfo.BHMV_range = (s->mpeg_f_code[1][1] - 1);
+}
+
+    status = XvMCLoadQMatrix(render->disp, render->ctx, &qmatrix);
+    if (status)
+        av_log(avctx,AV_LOG_ERROR, "XvMCLoadQMatrix: Error: %d\n", status);
+
+    status = XvMCBeginSurface(render->disp, render->ctx, render->p_surface,
+                              render->p_past_surface, render->p_future_surface,
+                              &binfo);
+    if (status)
+        av_log(avctx,AV_LOG_ERROR, "XvMCBeginSurface: Error: %d\n", status);
+
+    if (!status)
+        return 0;
+    }
+#endif
 
-return -1;
+    return -1;
 }
 
 void XVMC_field_end(MpegEncContext *s){
@@ -122,10 +308,22 @@
     render = (xvmc_render_state_t*)s->current_picture.data[2];
     assert(render != NULL);
 
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        XvMCFlushSurface(render->disp, render->p_surface);
+        XvMCSyncSurface(render->disp, render->p_surface);
+
+    	s->error_count = 0;
+    }
+    else
+#endif
+    {
     if(render->filled_mv_blocks_num > 0){
 //        printf("xvmcvideo.c: rendering %d left blocks after last slice!!!\n",render->filled_mv_blocks_num );
         ff_draw_horiz_band(s,0,0);
     }
+    }
 }
 
 void XVMC_decode_mb(MpegEncContext *s){
@@ -315,4 +513,50 @@
 
 }
 
+#ifdef HAVE_XVMC_VLD
+static int length_to_next_start(uint8_t* pbuf_ptr, int buf_size)
+{
+    uint8_t*    buf_ptr;
+    unsigned int    state = 0xFFFFFFFF, v;
+
+    buf_ptr = pbuf_ptr;
+    while (buf_ptr < pbuf_ptr + buf_size)
+    {
+        v = *buf_ptr++;
+        if (state == 0x000001) {
+            return buf_ptr - pbuf_ptr - 4;
+        }
+        state = ((state << 8) | v) & 0xffffff;
+    }
+    return -1;
+}
+
+#define SLICE_MIN_START_CODE   0x00000101
+#define SLICE_MAX_START_CODE   0x000001af
+
+void XVMC_decode_slice(MpegEncContext *s, int mb_y, uint8_t* buffer, int buf_size)
+{
+    int slicelen = length_to_next_start(buffer, buf_size);
+    xvmc_render_state_t*    render;
+
+    if (slicelen < 0)
+    {
+        if ((mb_y == s->mb_height - 1) || 
+            (!s->progressive_sequence && mb_y == (s->mb_height >> 1) -1) ||
+	    (s->codec_id != CODEC_ID_MPEG2VIDEO))
+            slicelen = buf_size;
+        else
+            return;
+    }
+
+    render = (xvmc_render_state_t*)s->current_picture.data[2];
+    render->slice_code = SLICE_MIN_START_CODE + mb_y;
+    render->slice_data = buffer;
+    render->slice_datalen = slicelen;
+
+    ff_draw_horiz_band(s, 0, 0);
+}
+#endif
+
 #endif
+
diff -Naur MPlayer-1.0rc1-old/libavutil/avutil.h MPlayer-1.0rc1-new/libavutil/avutil.h
--- MPlayer-1.0rc1-old/libavutil/avutil.h	2006-10-22 15:32:31.000000000 -0700
+++ MPlayer-1.0rc1-new/libavutil/avutil.h	2006-12-28 15:30:56.000000000 -0800
@@ -88,6 +88,7 @@
     PIX_FMT_YUVJ444P,  ///< Planar YUV 4:4:4, 24bpp, full scale (jpeg)
     PIX_FMT_XVMC_MPEG2_MC,///< XVideo Motion Acceleration via common packet passing(xvmc_render.h)
     PIX_FMT_XVMC_MPEG2_IDCT,
+    PIX_FMT_XVMC_MPEG2_VLD,
     PIX_FMT_UYVY422,   ///< Packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
     PIX_FMT_UYYVYY411, ///< Packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
     PIX_FMT_BGR32,     ///< Packed RGB 8:8:8, 32bpp, (msb)8A 8B 8G 8R(lsb), in cpu endianness
diff -Naur MPlayer-1.0rc1-old/libmpcodecs/img_format.c MPlayer-1.0rc1-new/libmpcodecs/img_format.c
--- MPlayer-1.0rc1-old/libmpcodecs/img_format.c	2006-10-22 15:32:24.000000000 -0700
+++ MPlayer-1.0rc1-new/libmpcodecs/img_format.c	2006-12-28 15:30:56.000000000 -0800
@@ -65,6 +65,7 @@
 	case IMGFMT_ZRMJPEGIB: return("Zoran MJPEG bottom field first");
 	case IMGFMT_XVMC_MOCO_MPEG2: return("MPEG1/2 Motion Compensation");
 	case IMGFMT_XVMC_IDCT_MPEG2: return("MPEG1/2 Motion Compensation and IDCT");
+	case IMGFMT_XVMC_VLD_MPEG2: return("MPEG1/2 Motion Compensation and VLD");
     }
     return("Unknown");
 }
diff -Naur MPlayer-1.0rc1-old/libmpcodecs/img_format.h MPlayer-1.0rc1-new/libmpcodecs/img_format.h
--- MPlayer-1.0rc1-old/libmpcodecs/img_format.h	2006-10-22 15:32:24.000000000 -0700
+++ MPlayer-1.0rc1-new/libmpcodecs/img_format.h	2006-12-28 15:30:56.000000000 -0800
@@ -106,6 +106,7 @@
 //these are chroma420
 #define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
 #define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
+#define IMGFMT_XVMC_VLD_MPEG2 (IMGFMT_XVMC|0x42)
 
 typedef struct {
     void* data;
diff -Naur MPlayer-1.0rc1-old/libmpcodecs/vd_ffmpeg.c MPlayer-1.0rc1-new/libmpcodecs/vd_ffmpeg.c
--- MPlayer-1.0rc1-old/libmpcodecs/vd_ffmpeg.c	2006-10-22 15:32:24.000000000 -0700
+++ MPlayer-1.0rc1-new/libmpcodecs/vd_ffmpeg.c	2006-12-28 15:30:56.000000000 -0800
@@ -10,6 +10,7 @@
 #include "bswap.h"
 
 #include "vd_internal.h"
+#include "libvo/video_out.h"
 
 static vd_info_t info = {
 	"FFmpeg's libavcodec codec family",
@@ -153,6 +154,8 @@
         case IMGFMT_XVMC_IDCT_MPEG2:
         case IMGFMT_XVMC_MOCO_MPEG2:
             if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_IDCT) return CONTROL_TRUE;
+        case IMGFMT_XVMC_VLD_MPEG2:
+            if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_VLD) return CONTROL_TRUE;
 #endif
 	}
         return CONTROL_FALSE;
@@ -173,6 +176,9 @@
     vd_ffmpeg_ctx *ctx;
     AVCodec *lavc_codec;
     int lowres_w=0;
+#ifdef HAVE_XVMC
+    char *voname = 0;
+#endif
     int do_vis_debug= lavc_param_vismv || (lavc_param_debug&(FF_DEBUG_VIS_MB_TYPE|FF_DEBUG_VIS_QP));
 
     if(!avcodec_inited){
@@ -206,11 +212,23 @@
 
 #ifdef HAVE_XVMC
 
+    // Try and get the name of the selected vo system
+    // so that if its _not_ xvmc we can fail gracefully
+    // and mplayer can fall back to a sw decoder
+    if (sh->video_out) {
+      vo_info_t *voinfo;
+      vo_functions_t * shvoc=sh->video_out;
+      if (shvoc) {
+        voinfo = shvoc->info;
+        if (voinfo) voname=voinfo->short_name;
+      }
+    }
 #ifdef CODEC_CAP_HWACCEL
-    if(lavc_codec->capabilities & CODEC_CAP_HWACCEL){
+    if((lavc_codec->capabilities & CODEC_CAP_HWACCEL) &&
 #else
-    if(lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC){
+    if((lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC) &&
 #endif
+        voname && !strcmp(voname,"xvmc") ) {
         mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCAcceleratedCodec);
         assert(ctx->do_dr1);//these are must to!
         assert(ctx->do_slices); //it is (vo_)ffmpeg bug if this fails
@@ -479,6 +497,7 @@
 #ifdef HAVE_XVMC
         case PIX_FMT_XVMC_MPEG2_MC:ctx->best_csp=IMGFMT_XVMC_MOCO_MPEG2;break;
         case PIX_FMT_XVMC_MPEG2_IDCT:ctx->best_csp=IMGFMT_XVMC_IDCT_MPEG2;break;
+        case PIX_FMT_XVMC_MPEG2_VLD:ctx->best_csp=IMGFMT_XVMC_VLD_MPEG2;break;
 #endif
 	default:
 	    ctx->best_csp=0;
@@ -854,7 +873,11 @@
         avctx->get_buffer= mc_get_buffer;
         avctx->release_buffer= mc_release_buffer;
         avctx->draw_horiz_band = mc_render_slice;
+        if (avctx->xvmc_acceleration != 4)
         mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCAcceleratedMPEG2);
+        else
+            mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCVLDAcceleratedMPEG2);
+
         assert(ctx->do_dr1);//these are must to!
         assert(ctx->do_slices); //it is (vo_)ffmpeg bug if this fails
         avctx->flags|= CODEC_FLAG_EMU_EDGE;//do i need that??!!
diff -Naur MPlayer-1.0rc1-old/libvo/vo_xvmc.c MPlayer-1.0rc1-new/libvo/vo_xvmc.c
--- MPlayer-1.0rc1-old/libvo/vo_xvmc.c	2006-10-22 15:32:26.000000000 -0700
+++ MPlayer-1.0rc1-new/libvo/vo_xvmc.c	2006-12-28 15:30:56.000000000 -0800
@@ -24,6 +24,10 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
+
 #include "x11_common.h"
 #include "xvmc_render.h"
 
@@ -44,7 +48,7 @@
 
 
 #define UNUSED(x) ((void)(x))
-
+extern unsigned int video_format; 
 
 static int benchmark;
 static int use_sleep;
@@ -53,6 +57,8 @@
 static int xv_port_request = 0;
 static int bob_deinterlace;
 static int top_field_first;
+static int use_deint_one;
+static int use_tv_clip;
 
 static int image_width,image_height;
 static uint32_t  drwX,drwY;
@@ -115,7 +121,7 @@
   "XVideo Motion Compensation",
   "xvmc",
   "Ivan Kalvachev <iive@users.sf.net>",
-  ""
+  "Ivor Hewitt <ivor@ivor.org> - VIA VLD support"
 };
 
 LIBVO_EXTERN(xvmc);
@@ -188,7 +194,23 @@
 }
 //end of vo_xv shm/xvimage code
 
+int hasVLDAcceleration()
+{
+#ifdef HAVE_XVMC_VLD
+    return XVMC_VLD == (surface_info.mc_type & XVMC_VLD);
+#else
+    return 0;
+#endif
+}            
+
 static int xvmc_check_surface_format(uint32_t format, XvMCSurfaceInfo * surf_info){
+#ifdef HAVE_XVMC_VLD
+    if (format == IMGFMT_XVMC_VLD_MPEG2 ){
+        if( surf_info->mc_type != (XVMC_VLD|XVMC_MPEG_2) ) return -1;
+        if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
+        return 0;
+    }
+#endif
    if ( format == IMGFMT_XVMC_IDCT_MPEG2 ){ 
       if( surf_info->mc_type != (XVMC_IDCT|XVMC_MPEG_2) ) return -1;
       if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
@@ -367,9 +389,16 @@
   {  "sleep",     OPT_ARG_BOOL, &use_sleep,       NULL },
   {  "queue",     OPT_ARG_BOOL, &use_queue,       NULL },
   {  "bobdeint",  OPT_ARG_BOOL, &bob_deinterlace, NULL },
+  {  "onedeint",  OPT_ARG_BOOL, &use_deint_one,   NULL },
+  {  "tv-clip",   OPT_ARG_BOOL, &use_tv_clip,     NULL },
   {  NULL }
 };
 
+   // If the video is not MPEG1 or MPEG2, we can't decode it, so
+   // fail cleanly to allow mplayer to fallback to another vo system
+   if (video_format != 0x10000001 && video_format != 0x10000002) return -1;
+
+
    //Obtain display handler
    if (!vo_init()) return -1;//vo_xv
 
@@ -405,6 +434,8 @@
    use_sleep = 0;
    use_queue = 0;
    bob_deinterlace = 0;
+   use_deint_one = 0;
+   use_tv_clip = 0;
 
    /* parse suboptions */
    if ( subopt_parse( arg, subopts ) != 0 )
@@ -476,6 +507,8 @@
    if(surface_info.chroma_format == XVMC_CHROMA_FORMAT_444)
       blocks_per_macroblock = 12;
 
+if (!hasVLDAcceleration())
+{
    rez = XvMCCreateBlocks(mDisplay,&ctx,numblocks*blocks_per_macroblock,&data_blocks);
    if( rez != Success ){
       XvMCDestroyContext(mDisplay,&ctx);
@@ -491,6 +524,8 @@
    }
    printf("vo_xvmc: mv_blocks allocated\n");
 
+}
+
    if(surface_render==NULL)
       surface_render=malloc(MAX_SURFACES*sizeof(xvmc_render_state_t));//easy mem debug
    memset(surface_render,0,MAX_SURFACES*sizeof(xvmc_render_state_t));
@@ -509,6 +544,11 @@
       surface_render[i].chroma_format = surface_info.chroma_format;
       surface_render[i].unsigned_intra = (surface_info.flags & XVMC_INTRA_UNSIGNED) == XVMC_INTRA_UNSIGNED;
       surface_render[i].p_surface = &surface_array[i];
+
+      surface_render[i].state = 0;
+      surface_render[i].disp = mDisplay;
+      surface_render[i].ctx = &ctx;
+
       if( mp_msg_test(MSGT_VO,MSGL_DBG4) )
           printf("vo_xvmc: surface[%d] = %p .rndr=%p\n",i,&surface_array[i], &surface_render[i]);
    }
@@ -585,8 +625,8 @@
          printf("vo_xvmc: OSD support by additional frontend rendering\n");
          break;
       case BACKEND_SUBPICTURE:
-         printf("vo_xvmc: OSD support by beckend rendering (fast)\n");
-         printf("vo_xvmc: Pleace send feedback to configrm that it work,otherwise send bugreport!\n");
+         printf("vo_xvmc: OSD support by backend rendering "
+		"(fast, but untested with mplayer.)\n");
          break;
    }
 
@@ -1020,6 +1060,8 @@
 int rez;
 int clipX,clipY,clipW,clipH;
 int i;
+ int srcY=0, srcH=image_height;
+ int fieldnobob;
 
    if(p_render_surface == NULL)
       return;
@@ -1029,22 +1071,38 @@
    clipW = vo_dwidth+vo_panscan_x;
    clipH = vo_dheight+vo_panscan_y;
    
+   if (use_tv_clip) {
+     /*
+      * Clip top few lines off to get rid of annoying flicker
+      * when using bob de-interlacing on TV sourced video.
+      */
+     srcY+=4;
+     srcH-=4;
+   }
+   
    if(draw_ck)
       vo_xv_draw_colorkey(clipX,clipY,clipW,clipH);
 
    if(benchmark)
       return;
 
+   fieldnobob = XVMC_FRAME_PICTURE;
+
+   if (use_deint_one) 
+     fieldnobob = (top_field_first) ? XVMC_TOP_FIELD : XVMC_BOTTOM_FIELD;
+
    for (i = 1; i <= bob_deinterlace + 1; i++) {
-   int field = top_field_first ? i : i ^ 3;
+     int field = top_field_first ? i : i ^ XVMC_FRAME_PICTURE;
    rez = XvMCPutSurface(mDisplay, p_render_surface->p_surface, 
                         vo_window,
-                        0, 0, image_width, image_height,
+			  0, srcY, image_width, srcH,
                         clipX, clipY, clipW, clipH,
-                        bob_deinterlace ? field : 3);
-                        //p_render_surface_to_show->display_flags);
+			  bob_deinterlace ? field : fieldnobob);
+     if (i == 1 && bob_deinterlace) {
+       usleep(10*1000);
+     }
    if(rez != Success){
-      printf("vo_xvmc: PutSurface failer, critical error %d!\n",rez);
+       printf("vo_xvmc: PutSurface failure, critical error %d!\n",rez);
       assert(0);
    }
    }
@@ -1147,9 +1205,11 @@
 
    if( number_of_surfaces ){
 
+      if (!hasVLDAcceleration())
+      {
       XvMCDestroyMacroBlocks(mDisplay,&mv_blocks);
       XvMCDestroyBlocks(mDisplay,&data_blocks);
-
+      }
       for(i=0; i<number_of_surfaces; i++)
       {
          XvMCHideSurface(mDisplay,&surface_array[i]);//it doesn't hurt, I hope
@@ -1183,7 +1243,13 @@
 static void uninit(void){
    if( mp_msg_test(MSGT_VO,MSGL_DBG4) ) {
       printf("vo_xvmc: uninit called\n"); }
-   xvmc_free();
+   //
+   // This function can be called as part of a signal handler, and
+   // calling xvmc_free() thus may result in a deadlock.
+   // Don't do it this way. 
+   // The xvmc subsystem should take care of this anyway.
+   //
+   // xvmc_free();
  //from vo_xv
 #ifdef HAVE_XF86VM
    vo_vm_close(mDisplay);
@@ -1227,6 +1293,17 @@
    assert( rndr != NULL );
    assert( rndr->magic == MP_XVMC_RENDER_MAGIC );
 
+   if (hasVLDAcceleration())
+   {
+        rez = XvMCPutSlice2(mDisplay,&ctx,(char*)rndr->slice_data,
+                            rndr->slice_datalen,
+                            rndr->slice_code);
+        if (rez)
+           printf("vo_xxmc::slice Error %d\n",rez);
+
+   }
+   else
+   {
    rez = XvMCRenderSurface(mDisplay,&ctx,rndr->picture_structure,
              		   rndr->p_surface,
                            rndr->p_past_surface,
@@ -1238,7 +1315,7 @@
    if(rez != Success)
    {
    int i;
-      printf("vo_xvmc::slice: RenderSirface returned %d\n",rez);
+      printf("vo_xvmc::slice: RenderSurface returned %d\n",rez);
 
       printf("vo_xvmc::slice: pict=%d,flags=%x,start_blocks=%d,num_blocks=%d\n",
              rndr->picture_structure,rndr->flags,rndr->start_mv_blocks_num,
@@ -1266,6 +1343,7 @@
    rez = XvMCFlushSurface(mDisplay, rndr->p_surface);
    assert(rez==Success);
 
+}
 //   rndr->start_mv_blocks_num += rndr->filled_mv_blocks_num;
    rndr->start_mv_blocks_num = 0;
    rndr->filled_mv_blocks_num = 0;
@@ -1358,8 +1436,16 @@
 
 // these are shared!! so watch out
 // do call RenderSurface before overwriting
+if (!hasVLDAcceleration())
+{
    mpi->planes[0] = (char*)data_blocks.blocks;   
    mpi->planes[1] = (char*)mv_blocks.macro_blocks;
+}
+else
+{
+   mpi->planes[0] = 1;
+   mpi->planes[1] = 0;
+}
    mpi->priv =
    mpi->planes[2] = (char*)rndr;
 
diff -Naur MPlayer-1.0rc1-old/Makefile MPlayer-1.0rc1-new/Makefile
--- MPlayer-1.0rc1-old/Makefile	2006-10-22 15:32:31.000000000 -0700
+++ MPlayer-1.0rc1-new/Makefile	2006-12-28 15:30:56.000000000 -0800
@@ -204,7 +204,9 @@
 ifeq ($(TREMOR_INTERNAL),yes)
 PARTS += tremor
 endif
-
+ifeq ($(HAVE_XVMC_ACCEL),yes)
+CODEC_LIBS += $(X_LIB)
+endif
 ALL_PRG = $(PRG)
 ifeq ($(MENCODER),yes)
 ALL_PRG += $(PRG_MENCODER)
diff -Naur MPlayer-1.0rc1-old/mplayer.c MPlayer-1.0rc1-new/mplayer.c
--- MPlayer-1.0rc1-old/mplayer.c	2006-10-22 15:32:31.000000000 -0700
+++ MPlayer-1.0rc1-new/mplayer.c	2006-12-28 15:30:56.000000000 -0800
@@ -88,6 +88,8 @@
 int quiet=0;
 int enable_mouse_movements=0;
 
+unsigned int video_format=0;
+
 #ifdef WIN32
 char * proc_priority=NULL;
 #endif
@@ -3830,6 +3832,11 @@
 
 vo_config_count=0;
 //if((video_out->preinit(vo_subdevice))!=0){
+
+// let the video driver know what format the video is in so it can
+// reject it if it wants - lets vo_xvmc fail if ffmpeg12mc codec not used
+video_format=sh_video->format; 
+
 if(!(video_out=init_best_video_out(video_driver_list))){
     mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_ErrorInitializingVODevice);
     goto goto_next_file; // exit_player(MSGTR_Exit_error);
diff -Naur MPlayer-1.0rc1-old/radeon_vid.c MPlayer-1.0rc1-new/radeon_vid.c
--- MPlayer-1.0rc1-old/radeon_vid.c	1969-12-31 16:00:00.000000000 -0800
+++ MPlayer-1.0rc1-new/radeon_vid.c	2006-12-28 15:30:56.000000000 -0800
@@ -0,0 +1,2096 @@
+/*
+   radeon_vid - VIDIX based video driver for Radeon and Rage128 chips
+   Copyrights 2002 Nick Kurshev. This file is based on sources from
+   GATOS (gatos.sf.net) and X11 (www.xfree86.org)
+   Licence: GPL
+
+   31.12.2002 added support for fglrx drivers by Marcel Naziri (zwobbl@zwobbl.de)
+   6.04.2004 fixes to allow compiling vidix without X11 (broken in original patch)
+   PPC support by Alex Beregszaszi
+*/
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <inttypes.h>
+
+#include "../../config.h"
+#include "../../bswap.h"
+#include "../../libdha/pci_ids.h"
+#include "../../libdha/pci_names.h"
+#include "../vidix.h"
+#include "../fourcc.h"
+#include "../../libdha/libdha.h"
+#include "radeon.h"
+
+#ifdef HAVE_X11
+#include <X11/Xlib.h>
+#endif
+
+#ifdef RAGE128
+#define RADEON_MSG "[rage128]"
+#define X_ADJUST 0
+#else
+#define RADEON_MSG "[radeon]"
+#define X_ADJUST (is_shift_required ? 8 : 0)
+#ifndef RADEON
+#define RADEON
+#endif
+#endif
+
+static int __verbose = 0;
+#ifdef RADEON
+static int is_shift_required = 0;
+#endif
+
+typedef struct bes_registers_s
+{
+  /* base address of yuv framebuffer */
+  uint32_t yuv_base;
+  uint32_t fourcc;
+  uint32_t dest_bpp;
+  /* YUV BES registers */
+  uint32_t reg_load_cntl;
+  uint32_t h_inc;
+  uint32_t step_by;
+  uint32_t y_x_start;
+  uint32_t y_x_end;
+  uint32_t v_inc;
+  uint32_t p1_blank_lines_at_top;
+  uint32_t p23_blank_lines_at_top;
+  uint32_t vid_buf_pitch0_value;
+  uint32_t vid_buf_pitch1_value;
+  uint32_t p1_x_start_end;
+  uint32_t p2_x_start_end;
+  uint32_t p3_x_start_end;
+  uint32_t base_addr;
+  uint32_t vid_buf_base_adrs_y[VID_PLAY_MAXFRAMES];
+  uint32_t vid_buf_base_adrs_u[VID_PLAY_MAXFRAMES];
+  uint32_t vid_buf_base_adrs_v[VID_PLAY_MAXFRAMES];
+  uint32_t vid_nbufs;
+
+  uint32_t p1_v_accum_init;
+  uint32_t p1_h_accum_init;
+  uint32_t p23_v_accum_init;
+  uint32_t p23_h_accum_init;
+  uint32_t scale_cntl;
+  uint32_t exclusive_horz;
+  uint32_t auto_flip_cntl;
+  uint32_t filter_cntl;
+  uint32_t key_cntl;
+  uint32_t test;
+  /* Configurable stuff */
+  int double_buff;
+  
+  int brightness;
+  int saturation;
+  
+  int ckey_on;
+  uint32_t graphics_key_clr;
+  uint32_t graphics_key_msk;
+  uint32_t ckey_cntl;
+  
+  int deinterlace_on;
+  uint32_t deinterlace_pattern;
+  
+} bes_registers_t;
+
+typedef struct video_registers_s
+{
+  const char * sname;
+  uint32_t name;
+  uint32_t value;
+}video_registers_t;
+
+static bes_registers_t besr;
+#ifndef RAGE128
+static int RadeonFamily=100;
+#endif
+#define DECLARE_VREG(name) { #name, name, 0 }
+static video_registers_t vregs[] = 
+{
+  DECLARE_VREG(VIDEOMUX_CNTL),
+  DECLARE_VREG(VIPPAD_MASK),
+  DECLARE_VREG(VIPPAD1_A),
+  DECLARE_VREG(VIPPAD1_EN),
+  DECLARE_VREG(VIPPAD1_Y),
+  DECLARE_VREG(OV0_Y_X_START),
+  DECLARE_VREG(OV0_Y_X_END),
+  DECLARE_VREG(OV0_PIPELINE_CNTL),
+  DECLARE_VREG(OV0_EXCLUSIVE_HORZ),
+  DECLARE_VREG(OV0_EXCLUSIVE_VERT),
+  DECLARE_VREG(OV0_REG_LOAD_CNTL),
+  DECLARE_VREG(OV0_SCALE_CNTL),
+  DECLARE_VREG(OV0_V_INC),
+  DECLARE_VREG(OV0_P1_V_ACCUM_INIT),
+  DECLARE_VREG(OV0_P23_V_ACCUM_INIT),
+  DECLARE_VREG(OV0_P1_BLANK_LINES_AT_TOP),
+  DECLARE_VREG(OV0_P23_BLANK_LINES_AT_TOP),
+#ifdef RADEON
+  DECLARE_VREG(OV0_BASE_ADDR),
+#endif
+  DECLARE_VREG(OV0_VID_BUF0_BASE_ADRS),
+  DECLARE_VREG(OV0_VID_BUF1_BASE_ADRS),
+  DECLARE_VREG(OV0_VID_BUF2_BASE_ADRS),
+  DECLARE_VREG(OV0_VID_BUF3_BASE_ADRS),
+  DECLARE_VREG(OV0_VID_BUF4_BASE_ADRS),
+  DECLARE_VREG(OV0_VID_BUF5_BASE_ADRS),
+  DECLARE_VREG(OV0_VID_BUF_PITCH0_VALUE),
+  DECLARE_VREG(OV0_VID_BUF_PITCH1_VALUE),
+  DECLARE_VREG(OV0_AUTO_FLIP_CNTL),
+  DECLARE_VREG(OV0_DEINTERLACE_PATTERN),
+  DECLARE_VREG(OV0_SUBMIT_HISTORY),
+  DECLARE_VREG(OV0_H_INC),
+  DECLARE_VREG(OV0_STEP_BY),
+  DECLARE_VREG(OV0_P1_H_ACCUM_INIT),
+  DECLARE_VREG(OV0_P23_H_ACCUM_INIT),
+  DECLARE_VREG(OV0_P1_X_START_END),
+  DECLARE_VREG(OV0_P2_X_START_END),
+  DECLARE_VREG(OV0_P3_X_START_END),
+  DECLARE_VREG(OV0_FILTER_CNTL),
+  DECLARE_VREG(OV0_FOUR_TAP_COEF_0),
+  DECLARE_VREG(OV0_FOUR_TAP_COEF_1),
+  DECLARE_VREG(OV0_FOUR_TAP_COEF_2),
+  DECLARE_VREG(OV0_FOUR_TAP_COEF_3),
+  DECLARE_VREG(OV0_FOUR_TAP_COEF_4),
+  DECLARE_VREG(OV0_FLAG_CNTL),
+#ifdef RAGE128
+  DECLARE_VREG(OV0_COLOUR_CNTL),
+#else
+  DECLARE_VREG(OV0_SLICE_CNTL),
+#endif
+  DECLARE_VREG(OV0_VID_KEY_CLR),
+  DECLARE_VREG(OV0_VID_KEY_MSK),
+  DECLARE_VREG(OV0_GRAPHICS_KEY_CLR),
+  DECLARE_VREG(OV0_GRAPHICS_KEY_MSK),
+  DECLARE_VREG(OV0_KEY_CNTL),
+  DECLARE_VREG(OV0_TEST),
+  DECLARE_VREG(OV0_LIN_TRANS_A),
+  DECLARE_VREG(OV0_LIN_TRANS_B),
+  DECLARE_VREG(OV0_LIN_TRANS_C),
+  DECLARE_VREG(OV0_LIN_TRANS_D),
+  DECLARE_VREG(OV0_LIN_TRANS_E),
+  DECLARE_VREG(OV0_LIN_TRANS_F),
+  DECLARE_VREG(OV0_GAMMA_0_F),
+  DECLARE_VREG(OV0_GAMMA_10_1F),
+  DECLARE_VREG(OV0_GAMMA_20_3F),
+  DECLARE_VREG(OV0_GAMMA_40_7F),
+  DECLARE_VREG(OV0_GAMMA_380_3BF),
+  DECLARE_VREG(OV0_GAMMA_3C0_3FF),
+  DECLARE_VREG(SUBPIC_CNTL),
+  DECLARE_VREG(SUBPIC_DEFCOLCON),
+  DECLARE_VREG(SUBPIC_Y_X_START),
+  DECLARE_VREG(SUBPIC_Y_X_END),
+  DECLARE_VREG(SUBPIC_V_INC),
+  DECLARE_VREG(SUBPIC_H_INC),
+  DECLARE_VREG(SUBPIC_BUF0_OFFSET),
+  DECLARE_VREG(SUBPIC_BUF1_OFFSET),
+  DECLARE_VREG(SUBPIC_LC0_OFFSET),
+  DECLARE_VREG(SUBPIC_LC1_OFFSET),
+  DECLARE_VREG(SUBPIC_PITCH),
+  DECLARE_VREG(SUBPIC_BTN_HLI_COLCON),
+  DECLARE_VREG(SUBPIC_BTN_HLI_Y_X_START),
+  DECLARE_VREG(SUBPIC_BTN_HLI_Y_X_END),
+  DECLARE_VREG(SUBPIC_PALETTE_INDEX),
+  DECLARE_VREG(SUBPIC_PALETTE_DATA),
+  DECLARE_VREG(SUBPIC_H_ACCUM_INIT),
+  DECLARE_VREG(SUBPIC_V_ACCUM_INIT),
+  DECLARE_VREG(IDCT_RUNS),
+  DECLARE_VREG(IDCT_LEVELS),
+  DECLARE_VREG(IDCT_AUTH_CONTROL),
+  DECLARE_VREG(IDCT_AUTH),
+  DECLARE_VREG(IDCT_CONTROL),
+  DECLARE_VREG(CONFIG_CNTL)
+};
+
+#ifdef HAVE_X11
+static uint32_t firegl_shift = 0;
+#endif
+static void * radeon_mmio_base = 0;
+static void * radeon_mem_base = 0; 
+static int32_t radeon_overlay_off = 0;
+static uint32_t radeon_ram_size = 0;
+/* Restore on exit */
+static uint32_t SAVED_OV0_GRAPHICS_KEY_CLR = 0;
+static uint32_t SAVED_OV0_GRAPHICS_KEY_MSK = 0;
+static uint32_t SAVED_OV0_VID_KEY_CLR = 0;
+static uint32_t SAVED_OV0_VID_KEY_MSK = 0;
+static uint32_t SAVED_OV0_KEY_CNTL = 0;
+#ifdef WORDS_BIGENDIAN
+static uint32_t SAVED_CONFIG_CNTL = 0;
+#if defined(RAGE128)
+#define APER_0_BIG_ENDIAN_16BPP_SWAP (1<<0)
+#define APER_0_BIG_ENDIAN_32BPP_SWAP (2<<0)
+#else
+#define RADEON_SURFACE_CNTL                 0x0b00
+#define RADEON_NONSURF_AP0_SWP_16BPP (1 << 20)
+#define RADEON_NONSURF_AP0_SWP_32BPP (1 << 21)
+#endif
+#endif
+
+#define GETREG(TYPE,PTR,OFFZ)		(*((volatile TYPE*)((PTR)+(OFFZ))))
+#define SETREG(TYPE,PTR,OFFZ,VAL)	(*((volatile TYPE*)((PTR)+(OFFZ))))=VAL
+
+#define INREG8(addr)		GETREG(uint8_t,(uint8_t*)(radeon_mmio_base),addr)
+#define OUTREG8(addr,val)	SETREG(uint8_t,(uint8_t*)(radeon_mmio_base),addr,val)
+
+static inline uint32_t INREG (uint32_t addr) {
+	uint32_t tmp = GETREG(uint32_t,(uint8_t*)(radeon_mmio_base),addr);
+	return le2me_32(tmp);
+}
+//#define OUTREG(addr,val)	SETREG(uint32_t,(uint8_t*)(radeon_mmio_base),addr,val)
+#define OUTREG(addr,val)	SETREG(uint32_t,(uint8_t*)(radeon_mmio_base),addr,le2me_32(val))
+#define OUTREGP(addr,val,mask)  					\
+	do {								\
+		unsigned int _tmp = INREG(addr);			\
+		_tmp &= (mask);						\
+		_tmp |= (val);						\
+		OUTREG(addr, _tmp);					\
+	} while (0)
+
+static __inline__ uint32_t INPLL(uint32_t addr)
+{
+	OUTREG8(CLOCK_CNTL_INDEX, addr & 0x0000001f);
+	return (INREG(CLOCK_CNTL_DATA));
+}
+
+#define OUTPLL(addr,val)	OUTREG8(CLOCK_CNTL_INDEX, (addr & 0x0000001f) | 0x00000080); \
+				OUTREG(CLOCK_CNTL_DATA, val)
+#define OUTPLLP(addr,val,mask)  					\
+	do {								\
+		unsigned int _tmp = INPLL(addr);			\
+		_tmp &= (mask);						\
+		_tmp |= (val);						\
+		OUTPLL(addr, _tmp);					\
+	} while (0)
+
+static uint32_t radeon_vid_get_dbpp( void )
+{
+  uint32_t dbpp,retval;
+  dbpp = (INREG(CRTC_GEN_CNTL)>>8)& 0xF;
+  switch(dbpp)
+  {
+    case DST_8BPP: retval = 8; break;
+    case DST_15BPP: retval = 15; break;
+    case DST_16BPP: retval = 16; break;
+    case DST_24BPP: retval = 24; break;
+    default: retval=32; break;
+  }
+  return retval;
+}
+
+static int radeon_is_dbl_scan( void )
+{
+  return (INREG(CRTC_GEN_CNTL))&CRTC_DBL_SCAN_EN;
+}
+
+static int radeon_is_interlace( void )
+{
+  return (INREG(CRTC_GEN_CNTL))&CRTC_INTERLACE_EN;
+}
+
+static uint32_t radeon_get_xres( void )
+{
+  /* FIXME: currently we extract that from CRTC!!!*/
+  uint32_t xres,h_total;
+  h_total = INREG(CRTC_H_TOTAL_DISP);
+  xres = (h_total >> 16) & 0xffff;
+  return (xres + 1)*8;
+}
+
+static uint32_t radeon_get_yres( void )
+{
+  /* FIXME: currently we extract that from CRTC!!!*/
+  uint32_t yres,v_total;
+  v_total = INREG(CRTC_V_TOTAL_DISP);
+  yres = (v_total >> 16) & 0xffff;
+  return yres + 1;
+}
+
+/* get flat panel x resolution*/
+static uint32_t radeon_get_fp_xres( void ){
+  uint32_t xres=(INREG(FP_HORZ_STRETCH)&0x00fff000)>>16;
+  xres=(xres+1)*8;
+  return xres;
+}
+
+/* get flat panel y resolution*/
+static uint32_t radeon_get_fp_yres( void ){
+  uint32_t yres=(INREG(FP_VERT_STRETCH)&0x00fff000)>>12;
+  return yres+1;
+}
+
+static void radeon_wait_vsync(void)
+{
+    int i;
+
+    OUTREG(GEN_INT_STATUS, VSYNC_INT_AK);
+    for (i = 0; i < 2000000; i++) 
+    {
+	if (INREG(GEN_INT_STATUS) & VSYNC_INT) break;
+    }
+}
+
+#ifdef RAGE128
+static void _radeon_engine_idle(void);
+static void _radeon_fifo_wait(unsigned);
+#define radeon_engine_idle()		_radeon_engine_idle()
+#define radeon_fifo_wait(entries)	_radeon_fifo_wait(entries)
+/* Flush all dirty data in the Pixel Cache to memory. */
+static __inline__ void radeon_engine_flush ( void )
+{
+    unsigned i;
+
+    OUTREGP(PC_NGUI_CTLSTAT, PC_FLUSH_ALL, ~PC_FLUSH_ALL);
+    for (i = 0; i < 2000000; i++) {
+	if (!(INREG(PC_NGUI_CTLSTAT) & PC_BUSY)) break;
+    }
+}
+
+/* Reset graphics card to known state. */
+static void radeon_engine_reset( void )
+{
+    uint32_t clock_cntl_index;
+    uint32_t mclk_cntl;
+    uint32_t gen_reset_cntl;
+
+    radeon_engine_flush();
+
+    clock_cntl_index = INREG(CLOCK_CNTL_INDEX);
+    mclk_cntl        = INPLL(MCLK_CNTL);
+
+    OUTPLL(MCLK_CNTL, mclk_cntl | FORCE_GCP | FORCE_PIPE3D_CP);
+
+    gen_reset_cntl   = INREG(GEN_RESET_CNTL);
+
+    OUTREG(GEN_RESET_CNTL, gen_reset_cntl | SOFT_RESET_GUI);
+    INREG(GEN_RESET_CNTL);
+    OUTREG(GEN_RESET_CNTL,
+	gen_reset_cntl & (uint32_t)(~SOFT_RESET_GUI));
+    INREG(GEN_RESET_CNTL);
+
+    OUTPLL(MCLK_CNTL,        mclk_cntl);
+    OUTREG(CLOCK_CNTL_INDEX, clock_cntl_index);
+    OUTREG(GEN_RESET_CNTL,   gen_reset_cntl);
+}
+#else
+
+static __inline__ void radeon_engine_flush ( void )
+{
+	int i;
+
+	/* initiate flush */
+	OUTREGP(RB2D_DSTCACHE_CTLSTAT, RB2D_DC_FLUSH_ALL,
+	        ~RB2D_DC_FLUSH_ALL);
+
+	for (i=0; i < 2000000; i++) {
+		if (!(INREG(RB2D_DSTCACHE_CTLSTAT) & RB2D_DC_BUSY))
+			break;
+	}
+}
+
+static void _radeon_engine_idle(void);
+static void _radeon_fifo_wait(unsigned);
+#define radeon_engine_idle()		_radeon_engine_idle()
+#define radeon_fifo_wait(entries)	_radeon_fifo_wait(entries)
+
+static void radeon_engine_reset( void )
+{
+	uint32_t clock_cntl_index, mclk_cntl, rbbm_soft_reset;
+
+	radeon_engine_flush ();
+
+	clock_cntl_index = INREG(CLOCK_CNTL_INDEX);
+	mclk_cntl = INPLL(MCLK_CNTL);
+
+	OUTPLL(MCLK_CNTL, (mclk_cntl |
+			   FORCEON_MCLKA |
+			   FORCEON_MCLKB |
+			   FORCEON_YCLKA |
+			   FORCEON_YCLKB |
+			   FORCEON_MC |
+			   FORCEON_AIC));
+	rbbm_soft_reset = INREG(RBBM_SOFT_RESET);
+
+	OUTREG(RBBM_SOFT_RESET, rbbm_soft_reset |
+				SOFT_RESET_CP |
+				SOFT_RESET_HI |
+				SOFT_RESET_SE |
+				SOFT_RESET_RE |
+				SOFT_RESET_PP |
+				SOFT_RESET_E2 |
+				SOFT_RESET_RB |
+				SOFT_RESET_HDP);
+	INREG(RBBM_SOFT_RESET);
+	OUTREG(RBBM_SOFT_RESET, rbbm_soft_reset & (uint32_t)
+				~(SOFT_RESET_CP |
+				  SOFT_RESET_HI |
+				  SOFT_RESET_SE |
+				  SOFT_RESET_RE |
+				  SOFT_RESET_PP |
+				  SOFT_RESET_E2 |
+				  SOFT_RESET_RB |
+				  SOFT_RESET_HDP));
+	INREG(RBBM_SOFT_RESET);
+
+	OUTPLL(MCLK_CNTL, mclk_cntl);
+	OUTREG(CLOCK_CNTL_INDEX, clock_cntl_index);
+	OUTREG(RBBM_SOFT_RESET, rbbm_soft_reset);
+
+	return;
+}
+#endif
+static void radeon_engine_restore( void )
+{
+#ifndef RAGE128
+    int pitch64;
+    uint32_t xres,yres,bpp;
+    radeon_fifo_wait(1);
+    xres = radeon_get_xres();
+    yres = radeon_get_yres();
+    bpp = radeon_vid_get_dbpp();
+    /* turn of all automatic flushing - we'll do it all */
+    OUTREG(RB2D_DSTCACHE_MODE, 0);
+
+    pitch64 = ((xres * (bpp / 8) + 0x3f)) >> 6;
+
+    radeon_fifo_wait(1);
+    OUTREG(DEFAULT_OFFSET, (INREG(DEFAULT_OFFSET) & 0xC0000000) |
+				  (pitch64 << 22));
+
+    radeon_fifo_wait(1);
+#if defined(WORDS_BIGENDIAN)
+#ifdef RADEON
+    OUTREGP(DP_DATATYPE, HOST_BIG_ENDIAN_EN, ~HOST_BIG_ENDIAN_EN);
+#endif
+#else
+    OUTREGP(DP_DATATYPE, 0, ~HOST_BIG_ENDIAN_EN);
+#endif
+
+    radeon_fifo_wait(1);
+    OUTREG(DEFAULT_SC_BOTTOM_RIGHT, (DEFAULT_SC_RIGHT_MAX
+				    | DEFAULT_SC_BOTTOM_MAX));
+    radeon_fifo_wait(1);
+    OUTREG(DP_GUI_MASTER_CNTL, (INREG(DP_GUI_MASTER_CNTL)
+				       | GMC_BRUSH_SOLID_COLOR
+				       | GMC_SRC_DATATYPE_COLOR));
+
+    radeon_fifo_wait(7);
+    OUTREG(DST_LINE_START,    0);
+    OUTREG(DST_LINE_END,      0);
+    OUTREG(DP_BRUSH_FRGD_CLR, 0xffffffff);
+    OUTREG(DP_BRUSH_BKGD_CLR, 0x00000000);
+    OUTREG(DP_SRC_FRGD_CLR,   0xffffffff);
+    OUTREG(DP_SRC_BKGD_CLR,   0x00000000);
+    OUTREG(DP_WRITE_MASK,     0xffffffff);
+
+    radeon_engine_idle();
+#endif
+}
+#ifdef RAGE128
+static void _radeon_fifo_wait (unsigned entries)
+{
+    unsigned i;
+
+    for(;;)
+    {
+	for (i=0; i<2000000; i++)
+		if ((INREG(GUI_STAT) & GUI_FIFOCNT_MASK) >= entries)
+			return;
+	radeon_engine_reset();
+	radeon_engine_restore();
+    }
+}
+
+static void _radeon_engine_idle ( void )
+{
+    unsigned i;
+
+    /* ensure FIFO is empty before waiting for idle */
+    radeon_fifo_wait (64);
+    for(;;)
+    {
+	for (i=0; i<2000000; i++) {
+		if ((INREG(GUI_STAT) & GUI_ACTIVE) == 0) {
+			radeon_engine_flush ();
+			return;
+		}
+	}
+	radeon_engine_reset();
+	radeon_engine_restore();
+    }
+}
+#else
+static void _radeon_fifo_wait (unsigned entries)
+{
+    unsigned i;
+
+    for(;;)
+    {
+	for (i=0; i<2000000; i++)
+		if ((INREG(RBBM_STATUS) & RBBM_FIFOCNT_MASK) >= entries)
+			return;
+	radeon_engine_reset();
+	radeon_engine_restore();
+    }
+}
+static void _radeon_engine_idle ( void )
+{
+    int i;
+
+    /* ensure FIFO is empty before waiting for idle */
+    radeon_fifo_wait (64);
+    for(;;)
+    {
+	for (i=0; i<2000000; i++) {
+		if (((INREG(RBBM_STATUS) & RBBM_ACTIVE)) == 0) {
+			radeon_engine_flush ();
+			return;
+		}
+	}
+	radeon_engine_reset();
+	radeon_engine_restore();
+    }
+}
+#endif
+
+#ifndef RAGE128
+/* Reference color space transform data */
+typedef struct tagREF_TRANSFORM
+{
+	float RefLuma;
+	float RefRCb;
+	float RefRCr;
+	float RefGCb;
+	float RefGCr;
+	float RefBCb;
+	float RefBCr;
+} REF_TRANSFORM;
+
+/* Parameters for ITU-R BT.601 and ITU-R BT.709 colour spaces */
+REF_TRANSFORM trans[2] =
+{
+	{1.1678, 0.0, 1.6007, -0.3929, -0.8154, 2.0232, 0.0}, /* BT.601 */
+	{1.1678, 0.0, 1.7980, -0.2139, -0.5345, 2.1186, 0.0}  /* BT.709 */
+};
+/****************************************************************************
+ * SetTransform                                                             *
+ *  Function: Calculates and sets color space transform from supplied       *
+ *            reference transform, gamma, brightness, contrast, hue and     *
+ *            saturation.                                                   *
+ *    Inputs: bright - brightness                                           *
+ *            cont - contrast                                               *
+ *            sat - saturation                                              *
+ *            hue - hue                                                     *
+ *            red_intensity - intense of red component                      *
+ *            green_intensity - intense of green component                  *
+ *            blue_intensity - intense of blue component                    *
+ *            ref - index to the table of refernce transforms               *
+ *   Outputs: NONE                                                          *
+ ****************************************************************************/
+
+static void radeon_set_transform(float bright, float cont, float sat,
+				 float hue, float red_intensity,
+				 float green_intensity,float blue_intensity,
+				 unsigned ref)
+{
+	float OvHueSin, OvHueCos;
+	float CAdjLuma, CAdjOff;
+	float RedAdj,GreenAdj,BlueAdj;
+	float CAdjRCb, CAdjRCr;
+	float CAdjGCb, CAdjGCr;
+	float CAdjBCb, CAdjBCr;
+	float OvLuma, OvROff, OvGOff, OvBOff;
+	float OvRCb, OvRCr;
+	float OvGCb, OvGCr;
+	float OvBCb, OvBCr;
+	float Loff = 64.0;
+	float Coff = 512.0f;
+
+	uint32_t dwOvLuma, dwOvROff, dwOvGOff, dwOvBOff;
+	uint32_t dwOvRCb, dwOvRCr;
+	uint32_t dwOvGCb, dwOvGCr;
+	uint32_t dwOvBCb, dwOvBCr;
+
+	if (ref >= 2) return;
+
+	OvHueSin = sin((double)hue);
+	OvHueCos = cos((double)hue);
+
+	CAdjLuma = cont * trans[ref].RefLuma;
+	CAdjOff = cont * trans[ref].RefLuma * bright * 1023.0;
+	RedAdj = cont * trans[ref].RefLuma * red_intensity * 1023.0;
+	GreenAdj = cont * trans[ref].RefLuma * green_intensity * 1023.0;
+	BlueAdj = cont * trans[ref].RefLuma * blue_intensity * 1023.0;
+
+	CAdjRCb = sat * -OvHueSin * trans[ref].RefRCr;
+	CAdjRCr = sat * OvHueCos * trans[ref].RefRCr;
+	CAdjGCb = sat * (OvHueCos * trans[ref].RefGCb - OvHueSin * trans[ref].RefGCr);
+	CAdjGCr = sat * (OvHueSin * trans[ref].RefGCb + OvHueCos * trans[ref].RefGCr);
+	CAdjBCb = sat * OvHueCos * trans[ref].RefBCb;
+	CAdjBCr = sat * OvHueSin * trans[ref].RefBCb;
+    
+#if 0 /* default constants */
+        CAdjLuma = 1.16455078125;
+
+	CAdjRCb = 0.0;
+	CAdjRCr = 1.59619140625;
+	CAdjGCb = -0.39111328125;
+	CAdjGCr = -0.8125;
+	CAdjBCb = 2.01708984375;
+	CAdjBCr = 0;
+#endif
+	OvLuma = CAdjLuma;
+	OvRCb = CAdjRCb;
+	OvRCr = CAdjRCr;
+	OvGCb = CAdjGCb;
+	OvGCr = CAdjGCr;
+	OvBCb = CAdjBCb;
+	OvBCr = CAdjBCr;
+	OvROff = RedAdj + CAdjOff -
+		OvLuma * Loff - (OvRCb + OvRCr) * Coff;
+	OvGOff = GreenAdj + CAdjOff - 
+		OvLuma * Loff - (OvGCb + OvGCr) * Coff;
+	OvBOff = BlueAdj + CAdjOff - 
+		OvLuma * Loff - (OvBCb + OvBCr) * Coff;
+#if 0 /* default constants */
+	OvROff = -888.5;
+	OvGOff = 545;
+	OvBOff = -1104;
+#endif 
+   
+	dwOvROff = ((int)(OvROff * 2.0)) & 0x1fff;
+	dwOvGOff = (int)(OvGOff * 2.0) & 0x1fff;
+	dwOvBOff = (int)(OvBOff * 2.0) & 0x1fff;
+	/* Whatever docs say about R200 having 3.8 format instead of 3.11
+	   as in Radeon is a lie */
+#if 0
+	if(RadeonFamily == 100)
+	{
+#endif
+		dwOvLuma =(((int)(OvLuma * 2048.0))&0x7fff)<<17;
+		dwOvRCb = (((int)(OvRCb * 2048.0))&0x7fff)<<1;
+		dwOvRCr = (((int)(OvRCr * 2048.0))&0x7fff)<<17;
+		dwOvGCb = (((int)(OvGCb * 2048.0))&0x7fff)<<1;
+		dwOvGCr = (((int)(OvGCr * 2048.0))&0x7fff)<<17;
+		dwOvBCb = (((int)(OvBCb * 2048.0))&0x7fff)<<1;
+		dwOvBCr = (((int)(OvBCr * 2048.0))&0x7fff)<<17;
+#if 0
+	}
+	else
+	{
+		dwOvLuma = (((int)(OvLuma * 256.0))&0x7ff)<<20;
+		dwOvRCb = (((int)(OvRCb * 256.0))&0x7ff)<<4;
+		dwOvRCr = (((int)(OvRCr * 256.0))&0x7ff)<<20;
+		dwOvGCb = (((int)(OvGCb * 256.0))&0x7ff)<<4;
+		dwOvGCr = (((int)(OvGCr * 256.0))&0x7ff)<<20;
+		dwOvBCb = (((int)(OvBCb * 256.0))&0x7ff)<<4;
+		dwOvBCr = (((int)(OvBCr * 256.0))&0x7ff)<<20;
+	}
+#endif
+	OUTREG(OV0_LIN_TRANS_A, dwOvRCb | dwOvLuma);
+	OUTREG(OV0_LIN_TRANS_B, dwOvROff | dwOvRCr);
+	OUTREG(OV0_LIN_TRANS_C, dwOvGCb | dwOvLuma);
+	OUTREG(OV0_LIN_TRANS_D, dwOvGOff | dwOvGCr);
+	OUTREG(OV0_LIN_TRANS_E, dwOvBCb | dwOvLuma);
+	OUTREG(OV0_LIN_TRANS_F, dwOvBOff | dwOvBCr);
+}
+
+/* Gamma curve definition */
+typedef struct 
+{
+	unsigned int gammaReg;
+	unsigned int gammaSlope;
+	unsigned int gammaOffset;
+}GAMMA_SETTINGS;
+
+/* Recommended gamma curve parameters */
+GAMMA_SETTINGS r200_def_gamma[18] = 
+{
+	{OV0_GAMMA_0_F, 0x100, 0x0000},
+	{OV0_GAMMA_10_1F, 0x100, 0x0020},
+	{OV0_GAMMA_20_3F, 0x100, 0x0040},
+	{OV0_GAMMA_40_7F, 0x100, 0x0080},
+	{OV0_GAMMA_80_BF, 0x100, 0x0100},
+	{OV0_GAMMA_C0_FF, 0x100, 0x0100},
+	{OV0_GAMMA_100_13F, 0x100, 0x0200},
+	{OV0_GAMMA_140_17F, 0x100, 0x0200},
+	{OV0_GAMMA_180_1BF, 0x100, 0x0300},
+	{OV0_GAMMA_1C0_1FF, 0x100, 0x0300},
+	{OV0_GAMMA_200_23F, 0x100, 0x0400},
+	{OV0_GAMMA_240_27F, 0x100, 0x0400},
+	{OV0_GAMMA_280_2BF, 0x100, 0x0500},
+	{OV0_GAMMA_2C0_2FF, 0x100, 0x0500},
+	{OV0_GAMMA_300_33F, 0x100, 0x0600},
+	{OV0_GAMMA_340_37F, 0x100, 0x0600},
+	{OV0_GAMMA_380_3BF, 0x100, 0x0700},
+	{OV0_GAMMA_3C0_3FF, 0x100, 0x0700}
+};
+
+GAMMA_SETTINGS r100_def_gamma[6] = 
+{
+	{OV0_GAMMA_0_F, 0x100, 0x0000},
+	{OV0_GAMMA_10_1F, 0x100, 0x0020},
+	{OV0_GAMMA_20_3F, 0x100, 0x0040},
+	{OV0_GAMMA_40_7F, 0x100, 0x0080},
+	{OV0_GAMMA_380_3BF, 0x100, 0x0100},
+	{OV0_GAMMA_3C0_3FF, 0x100, 0x0100}
+};
+
+static void make_default_gamma_correction( void )
+{
+    size_t i;
+    if(RadeonFamily == 100) {
+	OUTREG(OV0_LIN_TRANS_A, 0x12A00000);
+	OUTREG(OV0_LIN_TRANS_B, 0x199018FE);
+	OUTREG(OV0_LIN_TRANS_C, 0x12A0F9B0);
+	OUTREG(OV0_LIN_TRANS_D, 0xF2F0043B);
+	OUTREG(OV0_LIN_TRANS_E, 0x12A02050);
+	OUTREG(OV0_LIN_TRANS_F, 0x0000174E);
+	for(i=0; i<6; i++){
+		OUTREG(r100_def_gamma[i].gammaReg,
+		       (r100_def_gamma[i].gammaSlope<<16) |
+		        r100_def_gamma[i].gammaOffset);
+	}
+    }
+    else{
+	OUTREG(OV0_LIN_TRANS_A, 0x12a00000);
+	OUTREG(OV0_LIN_TRANS_B, 0x1990190e);
+	OUTREG(OV0_LIN_TRANS_C, 0x12a0f9c0);
+	OUTREG(OV0_LIN_TRANS_D, 0xf3000442);
+	OUTREG(OV0_LIN_TRANS_E, 0x12a02040);
+	OUTREG(OV0_LIN_TRANS_F, 0x175f);
+
+	/* Default Gamma,
+	   Of 18 segments for gamma cure, all segments in R200 are programmable,
+	   while only lower 4 and upper 2 segments are programmable in Radeon*/
+	for(i=0; i<18; i++){
+		OUTREG(r200_def_gamma[i].gammaReg,
+		       (r200_def_gamma[i].gammaSlope<<16) |
+		        r200_def_gamma[i].gammaOffset);
+	}
+    }
+}
+#endif
+	
+static void radeon_vid_make_default(void)
+{
+#ifdef RAGE128
+  OUTREG(OV0_COLOUR_CNTL,0x00101000UL); /* Default brightness and saturation for Rage128 */
+#else
+  make_default_gamma_correction();
+#endif
+  besr.deinterlace_pattern = 0x900AAAAA;
+  OUTREG(OV0_DEINTERLACE_PATTERN,besr.deinterlace_pattern);
+  besr.deinterlace_on=1;
+  besr.double_buff=1;
+  besr.ckey_on=0;
+  besr.graphics_key_msk=0;
+  besr.graphics_key_clr=0;
+  besr.ckey_cntl = VIDEO_KEY_FN_TRUE|GRAPHIC_KEY_FN_TRUE|CMP_MIX_AND;
+}
+
+
+unsigned vixGetVersion( void ) { return VIDIX_VERSION; }
+
+static unsigned short ati_card_ids[] = 
+{
+#ifdef RAGE128
+ /*
+    This driver should be compatible with Rage128 (pro) chips.
+    (include adaptive deinterlacing!!!).
+    Moreover: the same logic can be used with Mach64 chips.
+    (I mean: mach64xx, 3d rage, 3d rage IIc, 3D rage pro, 3d rage mobility).
+    but they are incompatible by i/o ports. So if enthusiasts will want
+    then they can redefine OUTREG and INREG macros and redefine OV0_*
+    constants. Also it seems that mach64 chips supports only: YUY2, YV12, UYVY
+    fourccs (422 and 420 formats only).
+  */
+/* Rage128 Pro GL */
+ DEVICE_ATI_RAGE_128_PA_PRO,
+ DEVICE_ATI_RAGE_128_PB_PRO,
+ DEVICE_ATI_RAGE_128_PC_PRO,
+ DEVICE_ATI_RAGE_128_PD_PRO,
+ DEVICE_ATI_RAGE_128_PE_PRO,
+ DEVICE_ATI_RAGE_128_PF_PRO,
+/* Rage128 Pro VR */
+ DEVICE_ATI_RAGE_128_PG_PRO,
+ DEVICE_ATI_RAGE_128_PH_PRO,
+ DEVICE_ATI_RAGE_128_PI_PRO,
+ DEVICE_ATI_RAGE_128_PJ_PRO,
+ DEVICE_ATI_RAGE_128_PK_PRO,
+ DEVICE_ATI_RAGE_128_PL_PRO,
+ DEVICE_ATI_RAGE_128_PM_PRO,
+ DEVICE_ATI_RAGE_128_PN_PRO,
+ DEVICE_ATI_RAGE_128_PO_PRO,
+ DEVICE_ATI_RAGE_128_PP_PRO,
+ DEVICE_ATI_RAGE_128_PQ_PRO,
+ DEVICE_ATI_RAGE_128_PR_PRO,
+ DEVICE_ATI_RAGE_128_PS_PRO,
+ DEVICE_ATI_RAGE_128_PT_PRO,
+ DEVICE_ATI_RAGE_128_PU_PRO,
+ DEVICE_ATI_RAGE_128_PV_PRO,
+ DEVICE_ATI_RAGE_128_PW_PRO,
+ DEVICE_ATI_RAGE_128_PX_PRO,
+/* Rage128 GL */
+ DEVICE_ATI_RAGE_128_RE_SG,
+ DEVICE_ATI_RAGE_128_RF_SG,
+ DEVICE_ATI_RAGE_128_RG,
+ DEVICE_ATI_RAGE_128_RK_VR,
+ DEVICE_ATI_RAGE_128_RL_VR,
+ DEVICE_ATI_RAGE_128_SE_4X,
+ DEVICE_ATI_RAGE_128_SF_4X,
+ DEVICE_ATI_RAGE_128_SG_4X,
+ DEVICE_ATI_RAGE_128_SH,
+ DEVICE_ATI_RAGE_128_SK_4X,
+ DEVICE_ATI_RAGE_128_SL_4X,
+ DEVICE_ATI_RAGE_128_SM_4X,
+ DEVICE_ATI_RAGE_128_4X,
+ DEVICE_ATI_RAGE_128_PRO,
+ DEVICE_ATI_RAGE_128_PRO2,
+ DEVICE_ATI_RAGE_128_PRO3,
+/* these seem to be based on rage 128 instead of mach64 */
+ DEVICE_ATI_RAGE_MOBILITY_M3,
+ DEVICE_ATI_RAGE_MOBILITY_M32
+#else
+/* Radeons (indeed: Rage 256 Pro ;) */
+ DEVICE_ATI_RADEON_R100_QD,
+ DEVICE_ATI_RADEON_R100_QE,
+ DEVICE_ATI_RADEON_R100_QF,
+ DEVICE_ATI_RADEON_R100_QG,
+ DEVICE_ATI_RADEON_VE_QY,
+ DEVICE_ATI_RADEON_VE_QZ,
+ DEVICE_ATI_RADEON_MOBILITY_M7,
+ DEVICE_ATI_RADEON_MOBILITY_M72,
+ DEVICE_ATI_RADEON_MOBILITY_M6,
+ DEVICE_ATI_RADEON_MOBILITY_M62,
+ DEVICE_ATI_RADEON_MOBILITY_U1,
+ DEVICE_ATI_RADEON_R200_BB,
+ DEVICE_ATI_RADEON_R200_QH,
+ DEVICE_ATI_RADEON_R200_QI,
+ DEVICE_ATI_RADEON_R200_QJ,
+ DEVICE_ATI_RADEON_R200_QK,
+ DEVICE_ATI_RADEON_R200_QL,
+ DEVICE_ATI_RADEON_R200_QM,
+ DEVICE_ATI_RADEON_R200_QH2,
+ DEVICE_ATI_RADEON_R200_QI2,
+ DEVICE_ATI_RADEON_R200_QJ2,
+ DEVICE_ATI_RADEON_R200_QK2,
+ DEVICE_ATI_RADEON_RV200_QW,
+ DEVICE_ATI_RADEON_RV200_QX,
+ DEVICE_ATI_RADEON_R250_ID,
+ DEVICE_ATI_RADEON_R250_IE,
+ DEVICE_ATI_RADEON_R250_IF,
+ DEVICE_ATI_RADEON_R250_IG,
+ DEVICE_ATI_RADEON_R250_LD,
+ DEVICE_ATI_RADEON_R250_LE,
+ DEVICE_ATI_RADEON_R250_LF,
+ DEVICE_ATI_RADEON_R250_LG,
+ DEVICE_ATI_RV370_5B60_RADEON,
+ DEVICE_ATI_RV250_5C61_RADEON,
+ DEVICE_ATI_RV250_5C63_RADEON,
+ DEVICE_ATI_RV280_RADEON_9200,
+ DEVICE_ATI_RV280_RADEON_92002,
+ DEVICE_ATI_RV280_RADEON_92003,
+ DEVICE_ATI_RV280_RADEON_92004,
+ DEVICE_ATI_RV280_RADEON_92005,
+ DEVICE_ATI_RV280_RADEON_92006,
+ DEVICE_ATI_RADEON_R300_ND,
+ DEVICE_ATI_RADEON_R300_NE,
+ DEVICE_ATI_RADEON_R300_NF,
+ DEVICE_ATI_RADEON_R300_NG,
+ DEVICE_ATI_RADEON_R300_AE,
+ DEVICE_ATI_RADEON_R300_AF,
+ DEVICE_ATI_RADEON_RV350_AP,
+ DEVICE_ATI_RADEON_RV350_AR,
+ DEVICE_ATI_RADEON_RV350_BK,
+ DEVICE_ATI_RADEON_R350_AH,
+ DEVICE_ATI_RADEON_R350_AI,
+ DEVICE_ATI_RADEON_R350_NH,
+ DEVICE_ATI_RADEON_R360_NJ,
+ DEVICE_ATI_RV350_MOBILITY_RADEON,
+ DEVICE_ATI_RV350_MOBILITY_RADEON2
+#endif
+};
+
+static int find_chip(unsigned chip_id)
+{
+  unsigned i;
+  for(i = 0;i < sizeof(ati_card_ids)/sizeof(unsigned short);i++)
+  {
+    if(chip_id == ati_card_ids[i]) return i;
+  }
+  return -1;
+}
+
+static pciinfo_t pci_info;
+static int probed=0;
+
+vidix_capability_t def_cap = 
+{
+#ifdef RAGE128
+    "BES driver for Rage128 cards",
+#else
+    "BES driver for Radeon cards",
+#endif
+    "Nick Kurshev",
+    TYPE_OUTPUT | TYPE_FX,
+    { 0, 0, 0, 0 },
+    2048,
+    2048,
+    4,
+    4,
+    -1,
+    FLAG_UPSCALER | FLAG_DOWNSCALER | FLAG_EQUALIZER,
+    VENDOR_ATI,
+    0,
+    { 0, 0, 0, 0}
+};
+
+#ifdef HAVE_X11
+static void probe_fireGL_driver(void) {
+  Display *dp = XOpenDisplay ((void*)0);
+  int n = 0;
+  char **extlist;
+  if (dp==NULL) {
+       return;
+  }
+  extlist = XListExtensions (dp, &n);
+  XCloseDisplay (dp);
+  if (extlist) {
+    int i;
+    int ext_fgl = 0, ext_fglrx = 0;
+    for (i = 0; i < n; i++) {
+      if (!strcmp(extlist[i], "ATIFGLEXTENSION")) ext_fgl = 1;
+      if (!strcmp(extlist[i], "ATIFGLRXDRI")) ext_fglrx = 1;
+    }
+    if (ext_fgl) {
+      printf(RADEON_MSG" ATI FireGl driver detected");
+      firegl_shift = 0x500000;
+      if (!ext_fglrx) {
+        printf(", but DRI seems not to be activated\n");
+        printf(RADEON_MSG" Output may not work correctly, check your DRI configuration!");
+      }
+      printf("\n");
+    }
+  }
+}
+#endif
+
+int vixProbe( int verbose,int force )
+{
+  pciinfo_t lst[MAX_PCI_DEVICES];
+  unsigned i,num_pci;
+  int err;
+  __verbose = verbose;
+  err = pci_scan(lst,&num_pci);
+  if(err)
+  {
+    printf(RADEON_MSG" Error occurred during pci scan: %s\n",strerror(err));
+    return err;
+  }
+  else
+  {
+    err = ENXIO;
+    for(i=0;i<num_pci;i++)
+    {
+      if(lst[i].vendor == VENDOR_ATI)
+      {
+        int idx;
+	const char *dname;
+	idx = find_chip(lst[i].device);
+	if(idx == -1 && force == PROBE_NORMAL) continue;
+	dname = pci_device_name(VENDOR_ATI,lst[i].device);
+	dname = dname ? dname : "Unknown chip";
+	printf(RADEON_MSG" Found chip: %s\n",dname);
+	if ((lst[i].command & PCI_COMMAND_IO) == 0)
+	{
+		printf("[radeon] Device is disabled, ignoring\n");
+		continue;
+	}
+#ifndef RAGE128	
+	if(idx != -1)
+#ifdef HAVE_X11
+	probe_fireGL_driver();
+#endif
+	{
+          switch(ati_card_ids[idx]) {
+            /* Original radeon */
+            case DEVICE_ATI_RADEON_R100_QD:
+            case DEVICE_ATI_RADEON_R100_QE:
+            case DEVICE_ATI_RADEON_R100_QF:
+            case DEVICE_ATI_RADEON_R100_QG:
+              RadeonFamily = 100;
+              break;
+              
+            /* Radeon VE / Radeon Mobility */
+            case DEVICE_ATI_RADEON_VE_QY:
+            case DEVICE_ATI_RADEON_VE_QZ:
+            case DEVICE_ATI_RADEON_MOBILITY_M6:
+            case DEVICE_ATI_RADEON_MOBILITY_M62:
+	    case DEVICE_ATI_RADEON_MOBILITY_U1:
+              RadeonFamily = 120;
+              break;
+              
+            /* Radeon 7500 / Radeon Mobility 7500 */
+            case DEVICE_ATI_RADEON_RV200_QW:
+            case DEVICE_ATI_RADEON_RV200_QX: 
+            case DEVICE_ATI_RADEON_MOBILITY_M7:
+            case DEVICE_ATI_RADEON_MOBILITY_M72:
+              RadeonFamily = 150;
+              break;
+              
+            /* Radeon 8500 */
+            case DEVICE_ATI_RADEON_R200_BB:
+            case DEVICE_ATI_RADEON_R200_QH:
+            case DEVICE_ATI_RADEON_R200_QI:
+            case DEVICE_ATI_RADEON_R200_QJ:
+            case DEVICE_ATI_RADEON_R200_QK:
+            case DEVICE_ATI_RADEON_R200_QL:
+            case DEVICE_ATI_RADEON_R200_QM:
+            case DEVICE_ATI_RADEON_R200_QH2:
+            case DEVICE_ATI_RADEON_R200_QI2:
+            case DEVICE_ATI_RADEON_R200_QJ2:
+            case DEVICE_ATI_RADEON_R200_QK2:
+              RadeonFamily = 200;
+              break;
+              
+            /* Radeon 9000 */
+            case DEVICE_ATI_RADEON_R250_ID:
+            case DEVICE_ATI_RADEON_R250_IE:
+            case DEVICE_ATI_RADEON_R250_IF:
+            case DEVICE_ATI_RADEON_R250_IG:
+            case DEVICE_ATI_RADEON_R250_LD:
+            case DEVICE_ATI_RADEON_R250_LE:
+            case DEVICE_ATI_RADEON_R250_LF:
+            case DEVICE_ATI_RADEON_R250_LG:
+            case DEVICE_ATI_RV250_5C61_RADEON:
+            case DEVICE_ATI_RV250_5C63_RADEON:
+              RadeonFamily = 250;
+              break;
+              
+            /* Radeon 9200 */
+            case DEVICE_ATI_RV280_RADEON_9200:
+            case DEVICE_ATI_RV280_RADEON_92002:
+            case DEVICE_ATI_RV280_RADEON_92003:
+            case DEVICE_ATI_RV280_RADEON_92004:
+            case DEVICE_ATI_RV280_RADEON_92005:
+            case DEVICE_ATI_RV280_RADEON_92006:
+              RadeonFamily = 280;
+              break;
+
+            /* Radeon 9700 */
+            case DEVICE_ATI_RADEON_R300_ND:
+            case DEVICE_ATI_RADEON_R300_NE:
+            case DEVICE_ATI_RADEON_R300_NF:
+            case DEVICE_ATI_RADEON_R300_NG:
+            case DEVICE_ATI_RADEON_R300_AE:
+            case DEVICE_ATI_RADEON_R300_AF:
+              RadeonFamily = 300;
+              break;
+
+            /* Radeon 9600/9800 */
+            case DEVICE_ATI_RV370_5B60_RADEON:
+            case DEVICE_ATI_RADEON_RV350_AP:
+            case DEVICE_ATI_RADEON_RV350_AR:
+            case DEVICE_ATI_RADEON_RV350_BK:
+            case DEVICE_ATI_RADEON_R350_NH:
+            case DEVICE_ATI_RADEON_R350_AH:
+            case DEVICE_ATI_RADEON_R350_AI:
+            case DEVICE_ATI_RADEON_R360_NJ:
+            case DEVICE_ATI_RV350_MOBILITY_RADEON:
+            case DEVICE_ATI_RV350_MOBILITY_RADEON2:
+              RadeonFamily = 350;
+              break;
+
+            default:
+              break;
+          }
+	}
+#endif
+	if(force > PROBE_NORMAL)
+	{
+	    printf(RADEON_MSG" Driver was forced. Was found %sknown chip\n",idx == -1 ? "un" : "");
+	    if(idx == -1)
+#ifdef RAGE128
+		printf(RADEON_MSG" Assuming it as Rage128\n");
+#else
+		printf(RADEON_MSG" Assuming it as Radeon1\n");
+#endif
+	}
+	def_cap.device_id = lst[i].device;
+	err = 0;
+	memcpy(&pci_info,&lst[i],sizeof(pciinfo_t));
+	probed=1;
+	break;
+      }
+    }
+  }
+  if(err && verbose) printf(RADEON_MSG" Can't find chip\n");
+  return err;
+}
+
+static void radeon_vid_dump_regs( void ); /* forward declaration */
+
+int vixInit( void )
+{
+  int err;
+  if(!probed) 
+  {
+    printf(RADEON_MSG" Driver was not probed but is being initializing\n");
+    return EINTR;
+  }    
+  if((radeon_mmio_base = map_phys_mem(pci_info.base2,0xFFFF))==(void *)-1) return ENOMEM;
+  radeon_ram_size = INREG(CONFIG_MEMSIZE);
+  /* mem size is bits [28:0], mask off the rest. Range: from 1Mb up to 512 Mb */
+  radeon_ram_size &=  CONFIG_MEMSIZE_MASK;
+#ifdef RADEON
+  /* according to XFree86 4.2.0, some production M6's return 0 for 8MB */
+  if (radeon_ram_size == 0 &&
+      (def_cap.device_id == DEVICE_ATI_RADEON_MOBILITY_M6 ||
+       def_cap.device_id == DEVICE_ATI_RADEON_MOBILITY_M62))
+  {
+      printf(RADEON_MSG" Workarounding buggy Radeon Mobility M6 (0 vs. 8MB ram)\n");
+      radeon_ram_size = 8192*1024;
+  }
+#else
+  /* Rage Mobility (rage128) also has memsize bug */
+  if (radeon_ram_size == 0 &&
+      (def_cap.device_id == DEVICE_ATI_RAGE_MOBILITY_M3 ||
+       def_cap.device_id == DEVICE_ATI_RAGE_128_RL_VR ||
+       def_cap.device_id == DEVICE_ATI_RAGE_MOBILITY_M32))
+  {
+      printf(RADEON_MSG" Workarounding buggy Rage Mobility M3 (0 vs. 8MB ram)\n");
+      radeon_ram_size = 8192*1024;
+  }
+#endif
+  printf(RADEON_MSG" Video memory = %uMb\n",radeon_ram_size/0x100000);
+#ifdef WIN32
+  //mapping large areas of video ram will fail on windows
+  if(radeon_ram_size > 16*1024*1024)radeon_ram_size=16*1024*1024;
+#endif
+  if((radeon_mem_base = map_phys_mem(pci_info.base0,radeon_ram_size))==(void *)-1) return ENOMEM;
+  memset(&besr,0,sizeof(bes_registers_t));
+  radeon_vid_make_default();
+  err = mtrr_set_type(pci_info.base0,radeon_ram_size,MTRR_TYPE_WRCOMB);
+  if(!err) printf(RADEON_MSG" Set write-combining type of video memory\n");
+
+  radeon_fifo_wait(3);
+  SAVED_OV0_GRAPHICS_KEY_CLR = INREG(OV0_GRAPHICS_KEY_CLR);
+  SAVED_OV0_GRAPHICS_KEY_MSK = INREG(OV0_GRAPHICS_KEY_MSK);
+  SAVED_OV0_VID_KEY_CLR = INREG(OV0_VID_KEY_CLR);
+  SAVED_OV0_VID_KEY_MSK = INREG(OV0_VID_KEY_MSK);
+  SAVED_OV0_KEY_CNTL = INREG(OV0_KEY_CNTL);
+  printf(RADEON_MSG" Saved overlay colorkey settings\n");
+
+#ifdef RADEON
+  switch(RadeonFamily)
+    {
+    case 100:
+    case 120:
+    case 150:
+    case 250:
+    case 280:
+      is_shift_required=1;
+      break;
+    default:
+      break;
+    }
+#endif
+
+/* XXX: hack, but it works for me (tm) */
+#ifdef WORDS_BIGENDIAN
+#if defined(RAGE128) 
+    /* code from gatos */
+    {
+	SAVED_CONFIG_CNTL = INREG(CONFIG_CNTL);
+	OUTREG(CONFIG_CNTL, SAVED_CONFIG_CNTL &
+	    ~(APER_0_BIG_ENDIAN_16BPP_SWAP|APER_0_BIG_ENDIAN_32BPP_SWAP));
+	    
+//	printf("saved: %x, current: %x\n", SAVED_CONFIG_CNTL,
+//	    INREG(CONFIG_CNTL));
+    }
+#else
+    /*code from radeon_video.c*/
+    {
+    	SAVED_CONFIG_CNTL = INREG(RADEON_SURFACE_CNTL);
+/*	OUTREG(RADEON_SURFACE_CNTL, (SAVED_CONFIG_CNTL |
+		RADEON_NONSURF_AP0_SWP_32BPP) & ~RADEON_NONSURF_AP0_SWP_16BPP);
+*/
+	OUTREG(RADEON_SURFACE_CNTL, SAVED_CONFIG_CNTL & ~(RADEON_NONSURF_AP0_SWP_32BPP
+						   | RADEON_NONSURF_AP0_SWP_16BPP));
+
+/*
+	OUTREG(RADEON_SURFACE_CNTL, (SAVED_CONFIG_CNTL | RADEON_NONSURF_AP0_SWP_32BPP)
+				    & ~RADEON_NONSURF_AP0_SWP_16BPP);
+*/
+    }
+#endif
+#endif
+
+  if(__verbose > 1) radeon_vid_dump_regs();
+  return 0;  
+}
+
+void vixDestroy( void )
+{
+  /* remove colorkeying */
+  radeon_fifo_wait(3);
+  OUTREG(OV0_GRAPHICS_KEY_CLR, SAVED_OV0_GRAPHICS_KEY_CLR);
+  OUTREG(OV0_GRAPHICS_KEY_MSK, SAVED_OV0_GRAPHICS_KEY_MSK);
+  OUTREG(OV0_VID_KEY_CLR, SAVED_OV0_VID_KEY_CLR);
+  OUTREG(OV0_VID_KEY_MSK, SAVED_OV0_VID_KEY_MSK);
+  OUTREG(OV0_KEY_CNTL, SAVED_OV0_KEY_CNTL);
+  printf(RADEON_MSG" Restored overlay colorkey settings\n");
+
+#ifdef WORDS_BIGENDIAN
+#if defined(RAGE128)
+    OUTREG(CONFIG_CNTL, SAVED_CONFIG_CNTL);
+//    printf("saved: %x, restored: %x\n", SAVED_CONFIG_CNTL,
+//	INREG(CONFIG_CNTL));
+#else
+    OUTREG(RADEON_SURFACE_CNTL, SAVED_CONFIG_CNTL);
+#endif
+#endif
+
+  unmap_phys_mem(radeon_mem_base,radeon_ram_size);
+  unmap_phys_mem(radeon_mmio_base,0xFFFF);
+}
+
+int vixGetCapability(vidix_capability_t *to)
+{
+  memcpy(to,&def_cap,sizeof(vidix_capability_t));
+  return 0; 
+}
+
+/*
+  Full list of fourcc which are supported by Win2K redeon driver:
+  YUY2, UYVY, DDES, OGLT, OGL2, OGLS, OGLB, OGNT, OGNZ, OGNS,
+  IF09, YVU9, IMC4, M2IA, IYUV, VBID, DXT1, DXT2, DXT3, DXT4, DXT5
+*/
+uint32_t supported_fourcc[] = 
+{
+  IMGFMT_Y800, IMGFMT_Y8, IMGFMT_YVU9, IMGFMT_IF09,
+  IMGFMT_YV12, IMGFMT_I420, IMGFMT_IYUV, 
+  IMGFMT_UYVY, IMGFMT_YUY2, IMGFMT_YVYU,
+  IMGFMT_RGB15, IMGFMT_BGR15,
+  IMGFMT_RGB16, IMGFMT_BGR16,
+  IMGFMT_RGB32, IMGFMT_BGR32
+};
+
+inline static int is_supported_fourcc(uint32_t fourcc)
+{
+  unsigned int i;
+  for(i=0;i<sizeof(supported_fourcc)/sizeof(uint32_t);i++)
+  {
+    if(fourcc==supported_fourcc[i]) return 1;
+  }
+  return 0;
+}
+
+int vixQueryFourcc(vidix_fourcc_t *to)
+{
+    if(is_supported_fourcc(to->fourcc))
+    {
+	to->depth = VID_DEPTH_1BPP | VID_DEPTH_2BPP |
+		    VID_DEPTH_4BPP | VID_DEPTH_8BPP |
+		    VID_DEPTH_12BPP| VID_DEPTH_15BPP|
+		    VID_DEPTH_16BPP| VID_DEPTH_24BPP|
+		    VID_DEPTH_32BPP;
+	to->flags = VID_CAP_EXPAND | VID_CAP_SHRINK | VID_CAP_COLORKEY;
+	return 0;
+    }
+    else  to->depth = to->flags = 0;
+    return ENOSYS;
+}
+
+static void radeon_vid_dump_regs( void )
+{
+  size_t i;
+  printf(RADEON_MSG"*** Begin of DRIVER variables dump ***\n");
+  printf(RADEON_MSG"radeon_mmio_base=%p\n",radeon_mmio_base);
+  printf(RADEON_MSG"radeon_mem_base=%p\n",radeon_mem_base);
+  printf(RADEON_MSG"radeon_overlay_off=%08X\n",radeon_overlay_off);
+  printf(RADEON_MSG"radeon_ram_size=%08X\n",radeon_ram_size);
+  printf(RADEON_MSG"video mode: %ux%u@%u\n",radeon_get_xres(),radeon_get_yres(),radeon_vid_get_dbpp());
+  printf(RADEON_MSG"flatpanel size: %ux%u\n",radeon_get_fp_xres(),radeon_get_fp_yres());
+  printf(RADEON_MSG"*** Begin of OV0 registers dump ***\n");
+  for(i=0;i<sizeof(vregs)/sizeof(video_registers_t);i++)
+	printf(RADEON_MSG"%s = %08X\n",vregs[i].sname,INREG(vregs[i].name));
+  printf(RADEON_MSG"*** End of OV0 registers dump ***\n");
+}
+
+static void radeon_vid_stop_video( void )
+{
+    radeon_engine_idle();
+    OUTREG(OV0_SCALE_CNTL, SCALER_SOFT_RESET);
+    OUTREG(OV0_EXCLUSIVE_HORZ, 0);
+    OUTREG(OV0_AUTO_FLIP_CNTL, 0);   /* maybe */
+    OUTREG(OV0_FILTER_CNTL, FILTER_HARDCODED_COEF);
+#ifdef RADEON
+    OUTREG(OV0_KEY_CNTL, GRAPHIC_KEY_FN_EQ);
+#else
+    OUTREG(OV0_KEY_CNTL, GRAPHIC_KEY_FN_NE);
+#endif
+    OUTREG(OV0_TEST, 0);
+}
+
+static void radeon_vid_display_video( void )
+{
+    int bes_flags;
+    /** workaround for Xorg-6.8 not saving the surface registers on bigendian architectures */
+#ifdef WORDS_BIGENDIAN
+#if defined(RAGE128) 
+    /* code from gatos */
+    {
+	SAVED_CONFIG_CNTL = INREG(CONFIG_CNTL);
+	OUTREG(CONFIG_CNTL, SAVED_CONFIG_CNTL &
+	    ~(APER_0_BIG_ENDIAN_16BPP_SWAP|APER_0_BIG_ENDIAN_32BPP_SWAP));
+	    
+//	printf("saved: %x, current: %x\n", SAVED_CONFIG_CNTL,
+//	    INREG(CONFIG_CNTL));
+    }
+#else
+    /*code from radeon_video.c*/
+    {
+    	SAVED_CONFIG_CNTL = INREG(RADEON_SURFACE_CNTL);
+/*	OUTREG(RADEON_SURFACE_CNTL, (SAVED_CONFIG_CNTL |
+		RADEON_NONSURF_AP0_SWP_32BPP) & ~RADEON_NONSURF_AP0_SWP_16BPP);
+*/
+	OUTREG(RADEON_SURFACE_CNTL, SAVED_CONFIG_CNTL & ~(RADEON_NONSURF_AP0_SWP_32BPP
+						   | RADEON_NONSURF_AP0_SWP_16BPP));
+
+/*
+	OUTREG(RADEON_SURFACE_CNTL, (SAVED_CONFIG_CNTL | RADEON_NONSURF_AP0_SWP_32BPP)
+				    & ~RADEON_NONSURF_AP0_SWP_16BPP);
+*/
+    }
+#endif
+#endif
+
+
+ 
+    radeon_fifo_wait(2);
+    OUTREG(OV0_REG_LOAD_CNTL,		REG_LD_CTL_LOCK);
+    radeon_engine_idle();
+    while(!(INREG(OV0_REG_LOAD_CNTL)&REG_LD_CTL_LOCK_READBACK));
+    radeon_fifo_wait(15);
+
+    /* Shutdown capturing */
+    OUTREG(FCP_CNTL, FCP_CNTL__GND);
+    OUTREG(CAP0_TRIG_CNTL, 0);
+
+    OUTREG(VID_BUFFER_CONTROL, (1<<16) | 0x01);
+    OUTREG(DISP_TEST_DEBUG_CNTL, 0);
+
+    OUTREG(OV0_AUTO_FLIP_CNTL,OV0_AUTO_FLIP_CNTL_SOFT_BUF_ODD);
+
+    if(besr.deinterlace_on) OUTREG(OV0_DEINTERLACE_PATTERN,besr.deinterlace_pattern);
+#ifdef RAGE128
+    OUTREG(OV0_COLOUR_CNTL, (((besr.brightness*64)/1000) & 0x7f) |
+                            (((besr.saturation*31+31000)/2000) << 8) |
+                            (((besr.saturation*31+31000)/2000) << 16));
+#endif
+    radeon_fifo_wait(2);
+    OUTREG(OV0_GRAPHICS_KEY_MSK, besr.graphics_key_msk);
+    OUTREG(OV0_GRAPHICS_KEY_CLR, besr.graphics_key_clr);
+    OUTREG(OV0_KEY_CNTL,besr.ckey_cntl);
+
+    OUTREG(OV0_H_INC,			besr.h_inc);
+    OUTREG(OV0_STEP_BY,			besr.step_by);
+    OUTREG(OV0_Y_X_START,		besr.y_x_start);
+    OUTREG(OV0_Y_X_END,			besr.y_x_end);
+    OUTREG(OV0_V_INC,			besr.v_inc);
+    OUTREG(OV0_P1_BLANK_LINES_AT_TOP,	besr.p1_blank_lines_at_top);
+    OUTREG(OV0_P23_BLANK_LINES_AT_TOP,	besr.p23_blank_lines_at_top);
+    OUTREG(OV0_VID_BUF_PITCH0_VALUE,	besr.vid_buf_pitch0_value);
+    OUTREG(OV0_VID_BUF_PITCH1_VALUE,	besr.vid_buf_pitch1_value);
+    OUTREG(OV0_P1_X_START_END,		besr.p1_x_start_end);
+    OUTREG(OV0_P2_X_START_END,		besr.p2_x_start_end);
+    OUTREG(OV0_P3_X_START_END,		besr.p3_x_start_end);
+#ifdef RADEON
+    OUTREG(OV0_BASE_ADDR,		besr.base_addr);
+#endif
+    OUTREG(OV0_VID_BUF0_BASE_ADRS,	besr.vid_buf_base_adrs_y[0]);
+    OUTREG(OV0_VID_BUF1_BASE_ADRS,	besr.vid_buf_base_adrs_v[0]);
+    OUTREG(OV0_VID_BUF2_BASE_ADRS,	besr.vid_buf_base_adrs_u[0]);
+    radeon_fifo_wait(9);
+    OUTREG(OV0_VID_BUF3_BASE_ADRS,	besr.vid_buf_base_adrs_y[0]);
+    OUTREG(OV0_VID_BUF4_BASE_ADRS,	besr.vid_buf_base_adrs_v[0]);
+    OUTREG(OV0_VID_BUF5_BASE_ADRS,	besr.vid_buf_base_adrs_u[0]);
+    OUTREG(OV0_P1_V_ACCUM_INIT,		besr.p1_v_accum_init);
+    OUTREG(OV0_P1_H_ACCUM_INIT,		besr.p1_h_accum_init);
+    OUTREG(OV0_P23_H_ACCUM_INIT,	besr.p23_h_accum_init);
+    OUTREG(OV0_P23_V_ACCUM_INIT,	besr.p23_v_accum_init);
+
+#ifdef RADEON
+    bes_flags = SCALER_ENABLE |
+                SCALER_SMART_SWITCH;
+//		SCALER_HORZ_PICK_NEAREST |
+//		SCALER_VERT_PICK_NEAREST |
+#endif
+    bes_flags = SCALER_ENABLE |
+                SCALER_SMART_SWITCH |
+		SCALER_Y2R_TEMP |
+		SCALER_PIX_EXPAND;
+    if(besr.double_buff) bes_flags |= SCALER_DOUBLE_BUFFER;
+    if(besr.deinterlace_on) bes_flags |= SCALER_ADAPTIVE_DEINT;
+#ifdef RAGE128
+    bes_flags |= SCALER_BURST_PER_PLANE;
+#endif
+    switch(besr.fourcc)
+    {
+        case IMGFMT_RGB15:
+        case IMGFMT_BGR15: bes_flags |= SCALER_SOURCE_15BPP; break;
+	case IMGFMT_RGB16:
+	case IMGFMT_BGR16: bes_flags |= SCALER_SOURCE_16BPP; break;
+/*
+        case IMGFMT_RGB24:
+        case IMGFMT_BGR24: bes_flags |= SCALER_SOURCE_24BPP; break;
+*/
+        case IMGFMT_RGB32:
+	case IMGFMT_BGR32: bes_flags |= SCALER_SOURCE_32BPP; break;
+        /* 4:1:0 */
+	case IMGFMT_IF09:
+        case IMGFMT_YVU9:  bes_flags |= SCALER_SOURCE_YUV9; break;
+	/* 4:0:0 */
+	case IMGFMT_Y800:
+	case IMGFMT_Y8:
+        /* 4:2:0 */
+	case IMGFMT_IYUV:
+	case IMGFMT_I420:
+	case IMGFMT_YV12:  bes_flags |= SCALER_SOURCE_YUV12; break;
+        /* 4:2:2 */
+        case IMGFMT_YVYU:
+	case IMGFMT_UYVY:  bes_flags |= SCALER_SOURCE_YVYU422; break;
+	case IMGFMT_YUY2:
+	default:           bes_flags |= SCALER_SOURCE_VYUY422; break;
+    }
+    OUTREG(OV0_SCALE_CNTL,		bes_flags);
+    OUTREG(OV0_REG_LOAD_CNTL,		0);
+    if(__verbose > 1) printf(RADEON_MSG"we wanted: scaler=%08X\n",bes_flags);
+    if(__verbose > 1) radeon_vid_dump_regs();
+}
+
+static unsigned radeon_query_pitch(unsigned fourcc,const vidix_yuv_t *spitch)
+{
+  unsigned pitch,spy,spv,spu;
+  spy = spv = spu = 0;
+  switch(spitch->y)
+  {
+    case 16:
+    case 32:
+    case 64:
+    case 128:
+    case 256: spy = spitch->y; break;
+    default: break;
+  }
+  switch(spitch->u)
+  {
+    case 16:
+    case 32:
+    case 64:
+    case 128:
+    case 256: spu = spitch->u; break;
+    default: break;
+  }
+  switch(spitch->v)
+  {
+    case 16:
+    case 32:
+    case 64:
+    case 128:
+    case 256: spv = spitch->v; break;
+    default: break;
+  }
+  switch(fourcc)
+  {
+	/* 4:2:0 */
+	case IMGFMT_IYUV:
+	case IMGFMT_YV12:
+	case IMGFMT_I420:
+		if(spy > 16 && spu == spy/2 && spv == spy/2)	pitch = spy;
+		else						pitch = 32;
+		break;
+	/* 4:1:0 */
+	case IMGFMT_IF09:
+	case IMGFMT_YVU9:
+		if(spy > 32 && spu == spy/4 && spv == spy/4)	pitch = spy;
+		else						pitch = 64;
+		break;
+	default:
+		if(spy >= 16)	pitch = spy;
+		else		pitch = 16;
+		break;
+  }
+  return pitch;
+}
+
+static int radeon_vid_init_video( vidix_playback_t *config )
+{
+    uint32_t i,tmp,src_w,src_h,dest_w,dest_h,pitch,h_inc,step_by,left,leftUV,top;
+    int is_400,is_410,is_420,is_rgb32,is_rgb,best_pitch,mpitch;
+    radeon_vid_stop_video();
+    left = config->src.x << 16;
+    top =  config->src.y << 16;
+    src_h = config->src.h;
+    src_w = config->src.w;
+    is_400 = is_410 = is_420 = is_rgb32 = is_rgb = 0;
+    if(config->fourcc == IMGFMT_YV12 ||
+       config->fourcc == IMGFMT_I420 ||
+       config->fourcc == IMGFMT_IYUV) is_420 = 1;
+    if(config->fourcc == IMGFMT_YVU9 ||
+       config->fourcc == IMGFMT_IF09) is_410 = 1;
+    if(config->fourcc == IMGFMT_Y800 ||
+       config->fourcc == IMGFMT_Y8) is_400 = 1;
+    if(config->fourcc == IMGFMT_RGB32 ||
+       config->fourcc == IMGFMT_BGR32) is_rgb32 = 1;
+    if(config->fourcc == IMGFMT_RGB32 ||
+       config->fourcc == IMGFMT_BGR32 ||
+       config->fourcc == IMGFMT_RGB24 ||
+       config->fourcc == IMGFMT_BGR24 ||
+       config->fourcc == IMGFMT_RGB16 ||
+       config->fourcc == IMGFMT_BGR16 ||
+       config->fourcc == IMGFMT_RGB15 ||
+       config->fourcc == IMGFMT_BGR15) is_rgb = 1;
+    best_pitch = radeon_query_pitch(config->fourcc,&config->src.pitch);
+    mpitch = best_pitch-1;
+    switch(config->fourcc)
+    {
+	/* 4:0:0 */
+	case IMGFMT_Y800:
+	case IMGFMT_Y8:
+	/* 4:1:0 */
+	case IMGFMT_YVU9:
+	case IMGFMT_IF09:
+	/* 4:2:0 */
+	case IMGFMT_IYUV:
+	case IMGFMT_YV12:
+	case IMGFMT_I420: pitch = (src_w + mpitch) & ~mpitch;
+			  config->dest.pitch.y = 
+			  config->dest.pitch.u = 
+			  config->dest.pitch.v = best_pitch;
+			  break;
+	/* RGB 4:4:4:4 */
+	case IMGFMT_RGB32:
+	case IMGFMT_BGR32: pitch = (src_w*4 + mpitch) & ~mpitch;
+			  config->dest.pitch.y = 
+			  config->dest.pitch.u = 
+			  config->dest.pitch.v = best_pitch;
+			  break;
+	/* 4:2:2 */
+        default: /* RGB15, RGB16, YVYU, UYVY, YUY2 */
+			  pitch = ((src_w*2) + mpitch) & ~mpitch;
+			  config->dest.pitch.y =
+			  config->dest.pitch.u =
+			  config->dest.pitch.v = best_pitch;
+			  break;
+    }
+    dest_w = config->dest.w;
+    dest_h = config->dest.h;
+    if(radeon_is_dbl_scan()) dest_h *= 2;
+    besr.dest_bpp = radeon_vid_get_dbpp();
+    besr.fourcc = config->fourcc;
+
+    /* flat panel */
+    if(INREG(FP_VERT_STRETCH)&VERT_STRETCH_ENABLE){
+      besr.v_inc = (src_h * radeon_get_yres() / radeon_get_fp_yres() << 20) / dest_h;
+    }
+    else besr.v_inc = (src_h << 20) / dest_h;
+    if(radeon_is_interlace()) besr.v_inc *= 2;
+    h_inc = (src_w << 12) / dest_w;
+
+    {
+        unsigned int ecp_div;
+        ecp_div = (INPLL(VCLK_ECP_CNTL) >> 8) & 3;
+        h_inc <<= ecp_div;
+    }
+
+
+    step_by = 1;
+    while(h_inc >= (2 << 12)) {
+	step_by++;
+	h_inc >>= 1;
+    }
+
+    /* keep everything in 16.16 */
+    besr.base_addr = INREG(DISPLAY_BASE_ADDR);
+    config->offsets[0] = 0;
+    for(i=1;i<besr.vid_nbufs;i++)
+	    config->offsets[i] = config->offsets[i-1]+config->frame_size;
+    if(is_420 || is_410 || is_400)
+    {
+        uint32_t d1line,d2line,d3line;
+	d1line = top*pitch;
+	if(is_420)
+	{
+	    d2line = src_h*pitch+(d1line>>2);
+	    d3line = d2line+((src_h*pitch)>>2);
+	}
+	else
+	if(is_410)
+	{
+	    d2line = src_h*pitch+(d1line>>4);
+	    d3line = d2line+((src_h*pitch)>>4);
+	}
+	else
+	{
+	    d2line = 0;
+	    d3line = 0;
+	}
+	d1line += (left >> 16) & ~15;
+	if(is_420)
+	{
+	    d2line += (left >> 17) & ~15;
+	    d3line += (left >> 17) & ~15;
+	}
+	else
+	if(is_410)
+	{
+	    d2line += (left >> 18) & ~15;
+	    d3line += (left >> 18) & ~15;
+	}
+	config->offset.y = d1line & VIF_BUF0_BASE_ADRS_MASK;
+	if(is_400)
+	{
+	    config->offset.v = 0;
+	    config->offset.u = 0;
+	}
+	else
+	{
+	    config->offset.v = d2line & VIF_BUF1_BASE_ADRS_MASK;
+	    config->offset.u = d3line & VIF_BUF2_BASE_ADRS_MASK;
+	}
+	for(i=0;i<besr.vid_nbufs;i++)
+	{
+	    besr.vid_buf_base_adrs_y[i]=((radeon_overlay_off+config->offsets[i]+config->offset.y)&VIF_BUF0_BASE_ADRS_MASK);
+	    if(is_400)
+	    {
+		besr.vid_buf_base_adrs_v[i]=0;
+		besr.vid_buf_base_adrs_u[i]=0;
+	    }
+	    else
+	    {
+		if (besr.fourcc == IMGFMT_I420 || besr.fourcc == IMGFMT_IYUV)
+		{
+		    besr.vid_buf_base_adrs_u[i]=((radeon_overlay_off+config->offsets[i]+config->offset.v)&VIF_BUF1_BASE_ADRS_MASK)|VIF_BUF1_PITCH_SEL;
+		    besr.vid_buf_base_adrs_v[i]=((radeon_overlay_off+config->offsets[i]+config->offset.u)&VIF_BUF2_BASE_ADRS_MASK)|VIF_BUF2_PITCH_SEL;
+		}
+		else
+		{
+		    besr.vid_buf_base_adrs_v[i]=((radeon_overlay_off+config->offsets[i]+config->offset.v)&VIF_BUF1_BASE_ADRS_MASK)|VIF_BUF1_PITCH_SEL;
+		    besr.vid_buf_base_adrs_u[i]=((radeon_overlay_off+config->offsets[i]+config->offset.u)&VIF_BUF2_BASE_ADRS_MASK)|VIF_BUF2_PITCH_SEL;
+		}
+	    }
+	}
+	config->offset.y = ((besr.vid_buf_base_adrs_y[0])&VIF_BUF0_BASE_ADRS_MASK) - radeon_overlay_off;
+	if(is_400)
+	{
+	    config->offset.v = 0;
+	    config->offset.u = 0;
+	}
+	else
+	{
+	    config->offset.v = ((besr.vid_buf_base_adrs_v[0])&VIF_BUF1_BASE_ADRS_MASK) - radeon_overlay_off;
+	    config->offset.u = ((besr.vid_buf_base_adrs_u[0])&VIF_BUF2_BASE_ADRS_MASK) - radeon_overlay_off;
+	}
+    }
+    else
+    {
+      config->offset.y = config->offset.u = config->offset.v = ((left & ~7) << 1)&VIF_BUF0_BASE_ADRS_MASK;
+      for(i=0;i<besr.vid_nbufs;i++)
+      {
+	besr.vid_buf_base_adrs_y[i] =
+	besr.vid_buf_base_adrs_u[i] =
+	besr.vid_buf_base_adrs_v[i] = radeon_overlay_off + config->offsets[i] + config->offset.y;
+      }
+    }
+
+    tmp = (left & 0x0003ffff) + 0x00028000 + (h_inc << 3);
+    besr.p1_h_accum_init = ((tmp <<  4) & 0x000f8000) |
+			   ((tmp << 12) & 0xf0000000);
+
+    tmp = ((left >> 1) & 0x0001ffff) + 0x00028000 + (h_inc << 2);
+    besr.p23_h_accum_init = ((tmp <<  4) & 0x000f8000) |
+			    ((tmp << 12) & 0x70000000);
+    tmp = (top & 0x0000ffff) + 0x00018000;
+    besr.p1_v_accum_init = ((tmp << 4) & OV0_P1_V_ACCUM_INIT_MASK)
+			    |(OV0_P1_MAX_LN_IN_PER_LN_OUT & 1);
+
+    tmp = ((top >> 1) & 0x0000ffff) + 0x00018000;
+    besr.p23_v_accum_init = (is_420||is_410) ?
+			    ((tmp << 4) & OV0_P23_V_ACCUM_INIT_MASK)
+			    |(OV0_P23_MAX_LN_IN_PER_LN_OUT & 1) : 0;
+
+    leftUV = (left >> (is_410?18:17)) & 15;
+    left = (left >> 16) & 15;
+    if(is_rgb && !is_rgb32) h_inc<<=1;
+    if(is_rgb32)
+	besr.h_inc = (h_inc >> 1) | ((h_inc >> 1) << 16);
+    else
+    if(is_410)
+	besr.h_inc = h_inc | ((h_inc >> 2) << 16);
+    else
+	besr.h_inc = h_inc | ((h_inc >> 1) << 16);
+    besr.step_by = step_by | (step_by << 8);
+    besr.y_x_start = (config->dest.x+X_ADJUST) | (config->dest.y << 16);
+    besr.y_x_end = (config->dest.x + dest_w+X_ADJUST) | ((config->dest.y + dest_h) << 16);
+    besr.p1_blank_lines_at_top = P1_BLNK_LN_AT_TOP_M1_MASK|((src_h-1)<<16);
+    if(is_420 || is_410)
+    {
+	src_h = (src_h + 1) >> (is_410?2:1);
+	besr.p23_blank_lines_at_top = P23_BLNK_LN_AT_TOP_M1_MASK|((src_h-1)<<16);
+    }
+    else besr.p23_blank_lines_at_top = 0;
+    besr.vid_buf_pitch0_value = pitch;
+    besr.vid_buf_pitch1_value = is_410 ? pitch>>2 : is_420 ? pitch>>1 : pitch;
+    besr.p1_x_start_end = (src_w+left-1)|(left<<16);
+    if (is_410||is_420) src_w>>=is_410?2:1;
+    if(is_400)
+    {
+	besr.p2_x_start_end = 0;
+	besr.p3_x_start_end = 0;
+    }
+    else
+    {
+	besr.p2_x_start_end = (src_w+left-1)|(leftUV<<16);
+	besr.p3_x_start_end = besr.p2_x_start_end;
+    }
+
+    return 0;
+}
+
+static void radeon_compute_framesize(vidix_playback_t *info)
+{
+  unsigned pitch,awidth,dbpp;
+  pitch = radeon_query_pitch(info->fourcc,&info->src.pitch);
+  dbpp = radeon_vid_get_dbpp();
+  switch(info->fourcc)
+  {
+    case IMGFMT_I420:
+    case IMGFMT_YV12:
+    case IMGFMT_IYUV:
+		awidth = (info->src.w + (pitch-1)) & ~(pitch-1);
+		info->frame_size = awidth*(info->src.h+info->src.h/2);
+		break;
+    case IMGFMT_Y800:
+    case IMGFMT_Y8:
+		awidth = (info->src.w + (pitch-1)) & ~(pitch-1);
+		info->frame_size = awidth*info->src.h;
+		break;
+    case IMGFMT_IF09:
+    case IMGFMT_YVU9:
+		awidth = (info->src.w + (pitch-1)) & ~(pitch-1);
+		info->frame_size = awidth*(info->src.h+info->src.h/8);
+		break;
+    case IMGFMT_RGB32:
+    case IMGFMT_BGR32:
+		awidth = (info->src.w*4 + (pitch-1)) & ~(pitch-1);
+		info->frame_size = awidth*info->src.h;
+		break;
+    /* YUY2 YVYU, RGB15, RGB16 */
+    default:	
+		awidth = (info->src.w*2 + (pitch-1)) & ~(pitch-1);
+		info->frame_size = awidth*info->src.h;
+		break;
+  }
+}
+
+int vixConfigPlayback(vidix_playback_t *info)
+{
+  unsigned rgb_size,nfr;
+  if(!is_supported_fourcc(info->fourcc)) return ENOSYS;
+  if(info->num_frames>VID_PLAY_MAXFRAMES) info->num_frames=VID_PLAY_MAXFRAMES;
+  if(info->num_frames==1) besr.double_buff=0;
+  else                    besr.double_buff=1;
+  radeon_compute_framesize(info);
+    
+  rgb_size = radeon_get_xres()*radeon_get_yres()*((radeon_vid_get_dbpp()+7)/8);
+  nfr = info->num_frames;
+  for(;nfr>0; nfr--)
+  {
+      radeon_overlay_off = radeon_ram_size - info->frame_size*nfr;
+#ifdef HAVE_X11
+      radeon_overlay_off -= firegl_shift;
+#endif
+      radeon_overlay_off &= 0xffff0000;
+      if(radeon_overlay_off >= (int)rgb_size ) break;
+  }
+  if(nfr <= 3)
+  {
+   nfr = info->num_frames;
+   for(;nfr>0; nfr--)
+   {
+      radeon_overlay_off = radeon_ram_size - info->frame_size*nfr;
+#ifdef HAVE_X11
+      radeon_overlay_off -= firegl_shift;
+#endif
+      radeon_overlay_off &= 0xffff0000;
+      if(radeon_overlay_off > 0) break;
+   }
+  }
+  if(nfr <= 0) return EINVAL;
+  info->num_frames = nfr;
+  besr.vid_nbufs = info->num_frames;
+  info->dga_addr = (char *)radeon_mem_base + radeon_overlay_off;  
+  radeon_vid_init_video(info);
+  return 0;
+}
+
+int vixPlaybackOn( void )
+{
+  radeon_vid_display_video();
+  return 0;
+}
+
+int vixPlaybackOff( void )
+{
+  radeon_vid_stop_video();
+  return 0;
+}
+
+int vixPlaybackFrameSelect(unsigned frame)
+{
+    uint32_t off[6];
+    int prev_frame= (frame-1+besr.vid_nbufs) % besr.vid_nbufs;
+    /*
+    buf3-5 always should point onto second buffer for better
+    deinterlacing and TV-in
+    */
+    if(!besr.double_buff) return 0;
+    if(frame > besr.vid_nbufs) frame = besr.vid_nbufs-1;
+    if(prev_frame > (int)besr.vid_nbufs) prev_frame = besr.vid_nbufs-1;
+    off[0] = besr.vid_buf_base_adrs_y[frame];
+    off[1] = besr.vid_buf_base_adrs_v[frame];
+    off[2] = besr.vid_buf_base_adrs_u[frame];
+    off[3] = besr.vid_buf_base_adrs_y[prev_frame];
+    off[4] = besr.vid_buf_base_adrs_v[prev_frame];
+    off[5] = besr.vid_buf_base_adrs_u[prev_frame];
+    radeon_fifo_wait(8);
+    OUTREG(OV0_REG_LOAD_CNTL,		REG_LD_CTL_LOCK);
+    radeon_engine_idle();
+    while(!(INREG(OV0_REG_LOAD_CNTL)&REG_LD_CTL_LOCK_READBACK));
+    OUTREG(OV0_VID_BUF0_BASE_ADRS,	off[0]);
+    OUTREG(OV0_VID_BUF1_BASE_ADRS,	off[1]);
+    OUTREG(OV0_VID_BUF2_BASE_ADRS,	off[2]);
+    OUTREG(OV0_VID_BUF3_BASE_ADRS,	off[3]);
+    OUTREG(OV0_VID_BUF4_BASE_ADRS,	off[4]);
+    OUTREG(OV0_VID_BUF5_BASE_ADRS,	off[5]);
+    OUTREG(OV0_REG_LOAD_CNTL,		0);
+    if(besr.vid_nbufs == 2) radeon_wait_vsync();
+    if(__verbose > 1) radeon_vid_dump_regs();
+    return 0;
+}
+
+vidix_video_eq_t equal =
+{
+ VEQ_CAP_BRIGHTNESS | VEQ_CAP_SATURATION
+#ifndef RAGE128
+ | VEQ_CAP_CONTRAST | VEQ_CAP_HUE | VEQ_CAP_RGB_INTENSITY
+#endif
+ ,
+ 0, 0, 0, 0, 0, 0, 0, 0 };
+
+int 	vixPlaybackGetEq( vidix_video_eq_t * eq)
+{
+  memcpy(eq,&equal,sizeof(vidix_video_eq_t));
+  return 0;
+}
+
+#ifndef RAGE128
+#define RTFSaturation(a)   (1.0 + ((a)*1.0)/1000.0)
+#define RTFBrightness(a)   (((a)*1.0)/2000.0)
+#define RTFIntensity(a)    (((a)*1.0)/2000.0)
+#define RTFContrast(a)   (1.0 + ((a)*1.0)/1000.0)
+#define RTFHue(a)   (((a)*3.1416)/1000.0)
+#define RTFCheckParam(a) {if((a)<-1000) (a)=-1000; if((a)>1000) (a)=1000;}
+#endif
+
+int 	vixPlaybackSetEq( const vidix_video_eq_t * eq)
+{
+#ifdef RAGE128
+  int br,sat;
+#else
+  int itu_space;
+#endif
+    if(eq->cap & VEQ_CAP_BRIGHTNESS) equal.brightness = eq->brightness;
+    if(eq->cap & VEQ_CAP_CONTRAST)   equal.contrast   = eq->contrast;
+    if(eq->cap & VEQ_CAP_SATURATION) equal.saturation = eq->saturation;
+    if(eq->cap & VEQ_CAP_HUE)        equal.hue        = eq->hue;
+    if(eq->cap & VEQ_CAP_RGB_INTENSITY)
+    {
+      equal.red_intensity   = eq->red_intensity;
+      equal.green_intensity = eq->green_intensity;
+      equal.blue_intensity  = eq->blue_intensity;
+    }
+    equal.flags = eq->flags;
+#ifdef RAGE128
+    br = equal.brightness * 64 / 1000;
+    if(br < -64) br = -64; if(br > 63) br = 63;
+    sat = (equal.saturation + 1000) * 16 / 1000;
+    if(sat < 0) sat = 0; if(sat > 31) sat = 31;
+    OUTREG(OV0_COLOUR_CNTL, (br & 0x7f) | (sat << 8) | (sat << 16));
+#else
+  itu_space = equal.flags == VEQ_FLG_ITU_R_BT_709 ? 1 : 0;
+  RTFCheckParam(equal.brightness);
+  RTFCheckParam(equal.saturation);
+  RTFCheckParam(equal.contrast);
+  RTFCheckParam(equal.hue);
+  RTFCheckParam(equal.red_intensity);
+  RTFCheckParam(equal.green_intensity);
+  RTFCheckParam(equal.blue_intensity);
+  radeon_set_transform(RTFBrightness(equal.brightness),
+		       RTFContrast(equal.contrast),
+		       RTFSaturation(equal.saturation),
+		       RTFHue(equal.hue),
+		       RTFIntensity(equal.red_intensity),
+		       RTFIntensity(equal.green_intensity),
+		       RTFIntensity(equal.blue_intensity),
+		       itu_space);
+#endif
+  return 0;
+}
+
+int 	vixPlaybackSetDeint( const vidix_deinterlace_t * info)
+{
+  unsigned sflg;
+  switch(info->flags)
+  {
+    default:
+    case CFG_NON_INTERLACED:
+			    besr.deinterlace_on = 0;
+			    break;
+    case CFG_EVEN_ODD_INTERLACING:
+    case CFG_INTERLACED:
+			    besr.deinterlace_on = 1;
+			    besr.deinterlace_pattern = 0x900AAAAA;
+			    break;
+    case CFG_ODD_EVEN_INTERLACING:
+			    besr.deinterlace_on = 1;
+			    besr.deinterlace_pattern = 0x00055555;
+			    break;
+    case CFG_UNIQUE_INTERLACING:
+			    besr.deinterlace_on = 1;
+			    besr.deinterlace_pattern = info->deinterlace_pattern;
+			    break;
+  }
+  OUTREG(OV0_REG_LOAD_CNTL,		REG_LD_CTL_LOCK);
+  radeon_engine_idle();
+  while(!(INREG(OV0_REG_LOAD_CNTL)&REG_LD_CTL_LOCK_READBACK));
+  radeon_fifo_wait(15);
+  sflg = INREG(OV0_SCALE_CNTL);
+  if(besr.deinterlace_on)
+  {
+    OUTREG(OV0_SCALE_CNTL,sflg | SCALER_ADAPTIVE_DEINT);
+    OUTREG(OV0_DEINTERLACE_PATTERN,besr.deinterlace_pattern);
+  }
+  else OUTREG(OV0_SCALE_CNTL,sflg & (~SCALER_ADAPTIVE_DEINT));
+  OUTREG(OV0_REG_LOAD_CNTL,		0);
+  return 0;  
+}
+
+int 	vixPlaybackGetDeint( vidix_deinterlace_t * info)
+{
+  if(!besr.deinterlace_on) info->flags = CFG_NON_INTERLACED;
+  else
+  {
+    info->flags = CFG_UNIQUE_INTERLACING;
+    info->deinterlace_pattern = besr.deinterlace_pattern;
+  }
+  return 0;
+}
+
+
+/* Graphic keys */
+static vidix_grkey_t radeon_grkey;
+
+static void set_gr_key( void )
+{
+    if(radeon_grkey.ckey.op == CKEY_TRUE)
+    {
+	int dbpp=radeon_vid_get_dbpp();
+	besr.ckey_on=1;
+
+	switch(dbpp)
+	{
+	case 15:
+#ifdef RADEON
+		if(RadeonFamily > 100)
+			besr.graphics_key_clr=
+				  ((radeon_grkey.ckey.blue &0xF8))
+				| ((radeon_grkey.ckey.green&0xF8)<<8)
+				| ((radeon_grkey.ckey.red  &0xF8)<<16);
+		else
+#endif
+		besr.graphics_key_clr=
+			  ((radeon_grkey.ckey.blue &0xF8)>>3)
+			| ((radeon_grkey.ckey.green&0xF8)<<2)
+			| ((radeon_grkey.ckey.red  &0xF8)<<7);
+		break;
+	case 16:
+#ifdef RADEON
+		/* This test may be too general/specific */
+		if(RadeonFamily > 100)
+			besr.graphics_key_clr=
+				  ((radeon_grkey.ckey.blue &0xF8))
+				| ((radeon_grkey.ckey.green&0xFC)<<8)
+				| ((radeon_grkey.ckey.red  &0xF8)<<16);
+		else
+#endif
+		besr.graphics_key_clr=
+			  ((radeon_grkey.ckey.blue &0xF8)>>3)
+			| ((radeon_grkey.ckey.green&0xFC)<<3)
+			| ((radeon_grkey.ckey.red  &0xF8)<<8);
+		break;
+	case 24:
+		besr.graphics_key_clr=
+			  ((radeon_grkey.ckey.blue &0xFF))
+			| ((radeon_grkey.ckey.green&0xFF)<<8)
+			| ((radeon_grkey.ckey.red  &0xFF)<<16);
+		break;
+	case 32:
+		besr.graphics_key_clr=
+			  ((radeon_grkey.ckey.blue &0xFF))
+			| ((radeon_grkey.ckey.green&0xFF)<<8)
+			| ((radeon_grkey.ckey.red  &0xFF)<<16);
+		break;
+	default:
+		besr.ckey_on=0;
+		besr.graphics_key_msk=0;
+		besr.graphics_key_clr=0;
+	}
+#ifdef RAGE128
+	besr.graphics_key_msk=(1<<dbpp)-1;
+	besr.ckey_cntl = VIDEO_KEY_FN_TRUE|GRAPHIC_KEY_FN_NE|CMP_MIX_AND;
+#else
+	besr.graphics_key_msk=besr.graphics_key_clr;
+	besr.ckey_cntl = VIDEO_KEY_FN_TRUE|CMP_MIX_AND|GRAPHIC_KEY_FN_EQ;
+#endif
+    }
+    else
+    {
+	besr.ckey_on=0;
+	besr.graphics_key_msk=0;
+	besr.graphics_key_clr=0;
+	besr.ckey_cntl = VIDEO_KEY_FN_TRUE|GRAPHIC_KEY_FN_TRUE|CMP_MIX_AND;
+    }
+    radeon_fifo_wait(3);
+    OUTREG(OV0_GRAPHICS_KEY_MSK, besr.graphics_key_msk);
+    OUTREG(OV0_GRAPHICS_KEY_CLR, besr.graphics_key_clr);
+    OUTREG(OV0_KEY_CNTL,besr.ckey_cntl);
+}
+
+int vixGetGrKeys(vidix_grkey_t *grkey)
+{
+    memcpy(grkey, &radeon_grkey, sizeof(vidix_grkey_t));
+    return(0);
+}
+
+int vixSetGrKeys(const vidix_grkey_t *grkey)
+{
+    memcpy(&radeon_grkey, grkey, sizeof(vidix_grkey_t));
+    set_gr_key();
+    return(0);
+}
diff -Naur MPlayer-1.0rc1-old/vidix/drivers/radeon_vid.c MPlayer-1.0rc1-new/vidix/drivers/radeon_vid.c
--- MPlayer-1.0rc1-old/vidix/drivers/radeon_vid.c	2006-10-22 15:32:26.000000000 -0700
+++ MPlayer-1.0rc1-new/vidix/drivers/radeon_vid.c	2006-12-28 15:30:56.000000000 -0800
@@ -905,7 +905,7 @@
  DEVICE_ATI_RADEON_R300_AF,
  DEVICE_ATI_RADEON_RV350_AP,
  DEVICE_ATI_RADEON_RV350_AR,
- DEVICE_ATI_RADEON_RV350_BK,
+// DEVICE_ATI_RADEON_RV350_BK,
  DEVICE_ATI_RADEON_R350_AH,
  DEVICE_ATI_RADEON_R350_AI,
  DEVICE_ATI_RADEON_R350_NH,
diff -Naur MPlayer-1.0rc1-old/xvmc_render.h MPlayer-1.0rc1-new/xvmc_render.h
--- MPlayer-1.0rc1-old/xvmc_render.h	2006-10-22 15:32:31.000000000 -0700
+++ MPlayer-1.0rc1-new/xvmc_render.h	2006-12-28 15:30:56.000000000 -0800
@@ -5,6 +5,9 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
 
 //the surface should be shown, video driver manipulate this
 #define MP_XVMC_STATE_DISPLAY_PENDING 1
@@ -27,7 +30,20 @@
   int idct;//does we use IDCT acceleration?
   int chroma_format;//420,422,444
   int unsigned_intra;//+-128 for intra pictures after clip
+
+#ifdef HAVE_XVMC_VLD
+  int reserved1[3];
+  // These are for the XVMC VLD slice interface
+  int pict_type; //this is for skipping frames
+  int   slice_code; 
+  int   slice_datalen;
+  unsigned char *slice_data;
+  Display *disp;
+  XvMCContext *ctx;
+#else
   int reserved1[12];//future extenstions (e.g. gmc,qpel)
+#endif
+  
   void * p_osd_target_surface_render;//pointer to the surface where subpicture is rendered
   XvMCSurface* p_surface;//pointer to rendered surface, never changed
 
@@ -47,4 +63,6 @@
   
   int next_free_data_block_num;//used in add_mv_block, pointer to next free block
 
+
+
 } xvmc_render_state_t;
