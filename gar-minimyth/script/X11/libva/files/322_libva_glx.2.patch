diff --git a/src/glx/va_glx.c b/src/glx/va_glx.c
index 49f09e0..dcbd6cc 100644
--- a/src/glx/va_glx.c
+++ b/src/glx/va_glx.c
@@ -105,3 +105,63 @@ VAStatus vaCopySurfaceToTextureGLX(
     /* XXX: implement with the GLX texture-from-pixmap + FBO extension? */
     return VA_STATUS_ERROR_UNIMPLEMENTED;
 }
+
+VAStatus vaBindSurfaceToTextureGLX(
+    VADisplay    dpy,
+    VASurfaceID  surface,
+    unsigned int texture,
+    unsigned int flags
+)
+{
+    VADisplayContextP pDisplayContext = (VADisplayContextP)dpy;
+    VADriverContextP ctx;
+
+    if (!pDisplayContext)
+        return VA_STATUS_ERROR_INVALID_DISPLAY;
+    if (!pDisplayContext->vaIsValid)
+        return VA_STATUS_ERROR_INVALID_DISPLAY;
+    if (!pDisplayContext->vaIsValid(pDisplayContext))
+        return VA_STATUS_ERROR_INVALID_DISPLAY;
+
+    ctx = pDisplayContext->pDriverContext;
+    if (!ctx)
+        return VA_STATUS_ERROR_OPERATION_FAILED;
+
+    if (ctx->vtable.vaBindSurfaceToTextureGLX) {
+        if (!ctx->vtable.vaReleaseSurfaceFromTextureGLX)
+            return VA_STATUS_ERROR_UNIMPLEMENTED;
+        return ctx->vtable.vaBindSurfaceToTextureGLX(ctx, surface, texture, flags);
+    }
+
+    /* XXX: implement with the GLX texture-from-pixmap? */
+    return VA_STATUS_ERROR_UNIMPLEMENTED;
+}
+
+VAStatus vaReleaseSurfaceFromTextureGLX(
+    VADisplay    dpy,
+    VASurfaceID  surface
+)
+{
+    VADisplayContextP pDisplayContext = (VADisplayContextP)dpy;
+    VADriverContextP ctx;
+
+    if (!pDisplayContext)
+        return VA_STATUS_ERROR_INVALID_DISPLAY;
+    if (!pDisplayContext->vaIsValid)
+        return VA_STATUS_ERROR_INVALID_DISPLAY;
+    if (!pDisplayContext->vaIsValid(pDisplayContext))
+        return VA_STATUS_ERROR_INVALID_DISPLAY;
+
+    ctx = pDisplayContext->pDriverContext;
+    if (!ctx)
+        return VA_STATUS_ERROR_OPERATION_FAILED;
+
+    if (ctx->vtable.vaReleaseSurfaceFromTextureGLX) {
+        if (!ctx->vtable.vaBindSurfaceToTextureGLX)
+            return VA_STATUS_ERROR_UNIMPLEMENTED;
+        return ctx->vtable.vaReleaseSurfaceFromTextureGLX(ctx, surface);
+    }
+
+    /* XXX: implement with the GLX texture-from-pixmap? */
+    return VA_STATUS_ERROR_UNIMPLEMENTED;
+}
diff --git a/src/glx/va_glx.h b/src/glx/va_glx.h
index f0bc21f..748fe52 100644
--- a/src/glx/va_glx.h
+++ b/src/glx/va_glx.h
@@ -64,4 +64,42 @@ VAStatus vaCopySurfaceToTextureGLX(
     unsigned int flags
 );
 
+/**
+ * Bind VA API surface to an OpenGL texture
+ *
+ * The application shall maintain the live GLX context itself.
+ * Implementations are free to use glXGetCurrentContext() and
+ * glXGetCurrentDrawable() functions for internal purposes.
+ *
+ * @param dpy the VA API display
+ * @param surface the VA API surface
+ * @param texture the OpenGL 2D texture
+ * @param flags the PutSurface flags
+ * @return VA_STATUS_SUCCESS if successful
+ */
+VAStatus vaBindSurfaceToTextureGLX(
+    VADisplay    dpy,
+    VASurfaceID  surface,
+    unsigned int texture,
+    unsigned int flags
+);
+
+/**
+ * Release VA API surface from an OpenGL texture
+ *
+ * The application shall maintain the live GLX context itself.
+ * Implementations are free to use glXGetCurrentContext() and
+ * glXGetCurrentDrawable() functions for internal purposes.
+ *
+ * The default texture (0) will be bound on exit from this function.
+ *
+ * @param dpy the VA API display
+ * @param surface the VA API surface
+ * @return VA_STATUS_SUCCESS if successful
+ */
+VAStatus vaReleaseSurfaceFromTextureGLX(
+    VADisplay    dpy,
+    VASurfaceID  surface
+);
+
 #endif /* VA_GLX_H */
diff --git a/src/va_backend.h b/src/va_backend.h
index ec56070..ba5d41b 100644
--- a/src/va_backend.h
+++ b/src/va_backend.h
@@ -411,6 +411,22 @@ struct VADriverVTable
                 unsigned int tex,
                 unsigned int flags
         );
+
+        /* Optional: bind surface to an OpenGL texture */
+        /* NOTE: this is mandatory if vaReleaseSurfaceFromTextureGLX() exists */
+        VAStatus (*vaBindSurfaceToTextureGLX) (
+                VADriverContextP ctx,
+                VASurfaceID surface,
+                unsigned int texture,
+                unsigned int flags
+        );
+
+        /* Optional: release surface from an OpenGL texture */
+        /* NOTE: this is mandatory if vaBindSurfaceToTextureGLX() exists */
+        VAStatus (*vaReleaseSurfaceFromTextureGLX) (
+                VADriverContextP ctx,
+                VASurfaceID surface
+        );
 };
 
 struct VADriverContext
