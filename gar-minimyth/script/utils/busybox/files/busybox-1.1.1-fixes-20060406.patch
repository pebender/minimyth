diff -Naur busybox-1.1.1-old/coreutils/comm.c busybox-1.1.1-new/coreutils/comm.c
--- busybox-1.1.1-old/coreutils/comm.c	2006-03-22 13:16:21.000000000 -0800
+++ busybox-1.1.1-new/coreutils/comm.c	2006-04-08 09:16:54.000000000 -0700
@@ -4,21 +4,7 @@
  *
  * Copyright (C) 2005 by Robert Sullivan <cogito.ergo.cogito@gmail.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
- * 02111-1307 USA
- *
+ * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  */
 
 #include <stdio.h>
@@ -75,16 +61,16 @@
 		fgets(thisline[i], LINE_LEN, streams[i]);
 	}
 
-	while (thisline[0] || thisline[1]) {
+	while (*thisline[0] || *thisline[1]) {
 		int order = 0;
 
 		i = 0;
 		if (feof(streams[0])) i |= BB_EOF_0;
 		if (feof(streams[1])) i |= BB_EOF_1;
 
-		if (!thisline[0])
+		if (!*thisline[0])
 			order = 1;
-		else if (!thisline[1])
+		else if (!*thisline[1])
 			order = -1;
 		else {
 			int tl0_len, tl1_len;
diff -Naur busybox-1.1.1-old/findutils/find.c busybox-1.1.1-new/findutils/find.c
--- busybox-1.1.1-old/findutils/find.c	2006-03-22 13:16:25.000000000 -0800
+++ busybox-1.1.1-new/findutils/find.c	2006-04-08 09:16:54.000000000 -0700
@@ -79,6 +79,15 @@
 
 static int fileAction(const char *fileName, struct stat *statbuf, void* junk)
 {
+#ifdef CONFIG_FEATURE_FIND_XDEV
+	if (S_ISDIR(statbuf->st_mode) && xdev_count) {
+		int i;
+		for (i=0; i<xdev_count; i++) {
+			if (xdev_dev[i] != statbuf->st_dev)
+				return SKIP;
+		}
+	}
+#endif
 	if (pattern != NULL) {
 		const char *tmp = strrchr(fileName, '/');
 
@@ -125,21 +134,6 @@
 			goto no_match;
 	}
 #endif
-#ifdef CONFIG_FEATURE_FIND_XDEV
-	if (xdev_count) {
-		int i;
-		for (i=0; i<xdev_count; i++) {
-			if (xdev_dev[i] == statbuf-> st_dev)
-				break;
-		}
-		if (i == xdev_count) {
-			if(S_ISDIR(statbuf->st_mode))
-				return SKIP;
-			else
-				goto no_match;
-		}
-	}
-#endif
 #ifdef CONFIG_FEATURE_FIND_NEWER
 	if (newer_mtime != 0) {
 		time_t file_age = newer_mtime - statbuf->st_mtime;
diff -Naur busybox-1.1.1-old/libbb/Makefile.in busybox-1.1.1-new/libbb/Makefile.in
--- busybox-1.1.1-old/libbb/Makefile.in	2006-03-22 13:16:22.000000000 -0800
+++ busybox-1.1.1-new/libbb/Makefile.in	2006-04-08 09:16:54.000000000 -0700
@@ -39,6 +39,7 @@
 # conditionally compiled objects:
 LIBBB-$(CONFIG_FEATURE_SHADOWPASSWDS)+=pwd2spwd.c
 LIBBB-$(CONFIG_FEATURE_MOUNT_LOOP)+= loop.c
+LIBBB-$(CONFIG_LOSETUP)+= loop.c
 LIBBB-$(CONFIG_FEATURE_MTAB_SUPPORT)+= mtab.c
 LIBBB-$(CONFIG_PASSWD)+= pw_encrypt.c
 LIBBB-$(CONFIG_SULOGIN)+= pw_encrypt.c
diff -Naur busybox-1.1.1-old/Makefile busybox-1.1.1-new/Makefile
--- busybox-1.1.1-old/Makefile	2006-03-22 13:16:26.000000000 -0800
+++ busybox-1.1.1-new/Makefile	2006-04-08 09:16:54.000000000 -0700
@@ -258,6 +258,7 @@
 DO_INSTALL_LIBS:=$(LD_LIBBUSYBOX) \
 	$(LD_LIBBUSYBOX).$(MAJOR_VERSION) \
 	$(LD_LIBBUSYBOX).$(MAJOR_VERSION).$(MINOR_VERSION)
+endif # CONFIG_BUILD_LIBBUSYBOX
 
 ifeq ($(strip $(CONFIG_BUILD_AT_ONCE)),y)
 ifneq ($(strip $(CONFIG_FEATURE_SHARED_BUSYBOX)),y)
@@ -269,7 +270,6 @@
 else # CONFIG_BUILD_AT_ONCE
 $(LIBBUSYBOX_SONAME): $(libbusybox-obj)
 endif # CONFIG_BUILD_AT_ONCE
-endif # CONFIG_BUILD_LIBBUSYBOX
 
 ifeq ($(strip $(CONFIG_FEATURE_SHARED_BUSYBOX)),y)
 LDBUSYBOX:=-L$(top_builddir) -lbusybox
diff -Naur busybox-1.1.1-old/modutils/insmod.c busybox-1.1.1-new/modutils/insmod.c
--- busybox-1.1.1-old/modutils/insmod.c	2006-03-22 13:16:20.000000000 -0800
+++ busybox-1.1.1-new/modutils/insmod.c	2006-04-08 09:16:54.000000000 -0700
@@ -516,12 +516,6 @@
 #include <elf.h>
 #include <endian.h>
 
-#if BB_LITTLE_ENDIAN
-# define ELFDATAM	ELFDATA2LSB
-#else
-# define ELFDATAM	ELFDATA2MSB
-#endif
-
 #ifndef ElfW
 # if ELFCLASSM == ELFCLASS32
 #  define ElfW(x)  Elf32_ ## x
@@ -3331,7 +3325,8 @@
 		return NULL;
 	}
 	if (f->header.e_ident[EI_CLASS] != ELFCLASSM
-			|| f->header.e_ident[EI_DATA] != ELFDATAM
+			|| f->header.e_ident[EI_DATA] != (BB_BIG_ENDIAN
+			   	? ELFDATA2MSB : ELFDATA2LSB)
 			|| f->header.e_ident[EI_VERSION] != EV_CURRENT
 			|| !MATCH_MACHINE(f->header.e_machine)) {
 		bb_error_msg("ELF file not for this architecture");
diff -Naur busybox-1.1.1-old/util-linux/Makefile.in busybox-1.1.1-new/util-linux/Makefile.in
--- busybox-1.1.1-old/util-linux/Makefile.in	2006-03-22 13:16:26.000000000 -0800
+++ busybox-1.1.1-new/util-linux/Makefile.in	2006-04-08 09:16:54.000000000 -0700
@@ -38,6 +38,8 @@
 UTILLINUX-$(CONFIG_SWITCH_ROOT)   +=switch_root.o
 UTILLINUX-$(CONFIG_UMOUNT)        +=umount.o
 
+UTILLINUX-y:=$(sort $(UTILLINUX-y))
+
 ifneq ($(strip $(UTILLINUX-y)),)
 libraries-y+=$(UTILLINUX_DIR)$(UTILLINUX_AR)
 endif
diff -Naur busybox-1.1.1-old/util-linux/mount.c busybox-1.1.1-new/util-linux/mount.c
--- busybox-1.1.1-old/util-linux/mount.c	2006-03-22 13:16:26.000000000 -0800
+++ busybox-1.1.1-new/util-linux/mount.c	2006-04-08 09:16:54.000000000 -0700
@@ -184,6 +184,8 @@
 {
 	llist_free(fslist);
 }
+#else
+void delete_block_backed_filesystems(void);
 #endif
 
 #if ENABLE_FEATURE_MTAB_SUPPORT
@@ -196,12 +198,9 @@
 
 // Perform actual mount of specific filesystem at specific location.
 
-static int mount_it_now(struct mntent *mp, int vfsflags)
+static int mount_it_now(struct mntent *mp, int vfsflags, char *filteropts)
 {
 	int rc;
-	char *filteropts = 0;
-
-	parse_mount_options(mp->mnt_opts, &filteropts);
 
 	if (fakeIt) { return 0; }
 
@@ -217,8 +216,6 @@
 		vfsflags |= MS_RDONLY;
 	}
 
-    free(filteropts);
-
 	// Abort entirely if permission denied.
 
 	if (rc && errno == EPERM)
@@ -266,11 +263,11 @@
 static int singlemount(struct mntent *mp)
 {
 	int rc = 1, vfsflags;
-	char *loopFile = 0;
+	char *loopFile = 0, *filteropts = 0;
 	llist_t *fl = 0;
 	struct stat st;
 
-	vfsflags = parse_mount_options(mp->mnt_opts, 0);
+	vfsflags = parse_mount_options(mp->mnt_opts, &filteropts);
 
 	// Treat fstype "auto" as unspecified.
 
@@ -282,23 +279,24 @@
 		(!mp->mnt_type || !strcmp(mp->mnt_type,"nfs")) &&
 		strchr(mp->mnt_fsname, ':') != NULL)
 	{
-		char *options=0;
-		parse_mount_options(mp->mnt_opts, &options);
-		if (nfsmount(mp->mnt_fsname, mp->mnt_dir, &vfsflags, &options, 1)) {
+		if (nfsmount(mp->mnt_fsname, mp->mnt_dir, &vfsflags, &filteropts, 1)) {
 			bb_perror_msg("nfsmount failed");
 			return 1;
+		} else {
+			// Strangely enough, nfsmount() doesn't actually mount() anything.
+			mp->mnt_type = "nfs";
+			rc = mount_it_now(mp, vfsflags, filteropts);
+			if (ENABLE_FEATURE_CLEAN_UP) free(filteropts);
+			
+			return rc;
 		}
-
-		// Strangely enough, nfsmount() doesn't actually mount() anything.
-
-		else return mount_it_now(mp, vfsflags);
 	}
 
-	// Look at the file.  (Not found isn't a failure for remount.)
+	// Look at the file.  (Not found isn't a failure for remount, or for
+	// a synthetic filesystem like proc or sysfs.)
 
 	if (lstat(mp->mnt_fsname, &st));
-
-	if (!(vfsflags & (MS_REMOUNT | MS_BIND | MS_MOVE))) {
+	else if (!(vfsflags & (MS_REMOUNT | MS_BIND | MS_MOVE))) {
 		// Do we need to allocate a loopback device for it?
 
 		if (ENABLE_FEATURE_MOUNT_LOOP && S_ISREG(st.st_mode)) {
@@ -324,7 +322,7 @@
 	 * to the actual mount. */
 
 	if (mp->mnt_type || (vfsflags & (MS_REMOUNT | MS_BIND | MS_MOVE)))
-		rc = mount_it_now(mp, vfsflags);
+		rc = mount_it_now(mp, vfsflags, filteropts);
 
 	// Loop through filesystem types until mount succeeds or we run out
 
@@ -336,25 +334,26 @@
 
 		if (!fslist) {
 			fslist = get_block_backed_filesystems();
-#if ENABLE_FEATURE_CLEAN_UP
 			if (ENABLE_FEATURE_CLEAN_UP && fslist)
 				atexit(delete_block_backed_filesystems);
-#endif
 		}
 
 		for (fl = fslist; fl; fl = fl->link) {
 			mp->mnt_type = fl->data;
 
-			if (!(rc = mount_it_now(mp,vfsflags))) break;
+			if (!(rc = mount_it_now(mp,vfsflags, filteropts))) break;
 
 			mp->mnt_type = 0;
 		}
 	}
 
-	// Mount failed.  Clean up
+	if (ENABLE_FEATURE_CLEAN_UP) free(filteropts);
+
+	// If mount failed, clean up loop file (if any).
+
 	if (rc && loopFile) {
 		del_loop(mp->mnt_fsname);
-		if(ENABLE_FEATURE_CLEAN_UP) {
+		if (ENABLE_FEATURE_CLEAN_UP) {
 			free(loopFile);
 			free(mp->mnt_fsname);
 		}
@@ -477,8 +476,9 @@
 
 		// Get next fstab entry
 
-		if (!getmntent_r(fstab, mtcur, bb_common_bufsiz1,
-					sizeof(bb_common_bufsiz1)))
+		if (!getmntent_r(fstab, mtcur, bb_common_bufsiz1
+					+ (mtcur==mtpair ? sizeof(bb_common_bufsiz1)/2 : 0),
+				sizeof(bb_common_bufsiz1)/2))
 		{
 			// Were we looking for something specific?
 
@@ -548,7 +548,6 @@
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		free(storage_path);
 		free(cmdopts);
-		free(fstype);
 	}
 
 	if(rc)
