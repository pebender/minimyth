diff -Naur busybox-1.31.1/applets/.gitignore busybox-be5a505d/applets/.gitignore
--- busybox-1.31.1/applets/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ busybox-be5a505d/applets/.gitignore	2019-10-24 07:26:55.000000000 -0700
@@ -0,0 +1,3 @@
+/applet_tables
+/usage
+/usage_pod
diff -Naur busybox-1.31.1/archival/bbunzip.c busybox-be5a505d/archival/bbunzip.c
--- busybox-1.31.1/archival/bbunzip.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/bbunzip.c	2019-10-24 07:26:55.000000000 -0700
@@ -114,7 +114,7 @@
 
 		/* Check that the input is sane */
 		if (!(option_mask32 & BBUNPK_OPT_FORCE) && isatty(STDIN_FILENO)) {
-			bb_error_msg_and_die("compressed data not read from terminal, "
+			bb_simple_error_msg_and_die("compressed data not read from terminal, "
 					"use -f to force it");
 		}
 
diff -Naur busybox-1.31.1/archival/bzip2.c busybox-be5a505d/archival/bzip2.c
--- busybox-1.31.1/archival/bzip2.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/bzip2.c	2019-10-24 07:26:55.000000000 -0700
@@ -145,7 +145,7 @@
 			if (n2 != n) {
 				if (n2 >= 0)
 					errno = 0; /* prevent bogus error message */
-				bb_perror_msg(n2 >= 0 ? "short write" : bb_msg_write_error);
+				bb_simple_perror_msg(n2 >= 0 ? "short write" : bb_msg_write_error);
 				return -1;
 			}
 		}
@@ -187,7 +187,7 @@
 	while (1) {
 		count = full_read(STDIN_FILENO, rbuf, IOBUF_SIZE);
 		if (count < 0) {
-			bb_perror_msg(bb_msg_read_error);
+			bb_simple_perror_msg(bb_msg_read_error);
 			total = -1;
 			break;
 		}
diff -Naur busybox-1.31.1/archival/dpkg.c busybox-be5a505d/archival/dpkg.c
--- busybox-1.31.1/archival/dpkg.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/dpkg.c	2019-10-24 07:26:55.000000000 -0700
@@ -487,7 +487,7 @@
 					} else if (strncmp(version, ">=", offset_ch) == 0) {
 						edge->operator = VER_MORE_EQUAL;
 					} else {
-						bb_error_msg_and_die("illegal operator");
+						bb_simple_error_msg_and_die("illegal operator");
 					}
 				}
 				/* skip to start of version numbers */
@@ -730,7 +730,7 @@
 			status = new_value_num;
 			break;
 		default:
-			bb_error_msg_and_die("DEBUG ONLY: this shouldnt happen");
+			bb_simple_error_msg_and_die("DEBUG ONLY: this shouldnt happen");
 	}
 
 	new_status = xasprintf("%s %s %s", name_hashtable[want], name_hashtable[flag], name_hashtable[status]);
@@ -944,10 +944,10 @@
 	/* Create a separate backfile to dpkg */
 	if (rename("/var/lib/dpkg/status", "/var/lib/dpkg/status.udeb.bak") == -1) {
 		if (errno != ENOENT)
-			bb_error_msg_and_die("can't create backup status file");
+			bb_simple_error_msg_and_die("can't create backup status file");
 		/* Its ok if renaming the status file fails because status
 		 * file doesn't exist, maybe we are starting from scratch */
-		bb_error_msg("no status file found, creating new one");
+		bb_simple_error_msg("no status file found, creating new one");
 	}
 
 	xrename("/var/lib/dpkg/status.udeb", "/var/lib/dpkg/status");
@@ -1816,7 +1816,7 @@
 			init_archive_deb_control(archive_handle);
 			deb_file[deb_count]->control_file = deb_extract_control_file_to_buffer(archive_handle, control_list);
 			if (deb_file[deb_count]->control_file == NULL) {
-				bb_error_msg_and_die("can't extract control file");
+				bb_simple_error_msg_and_die("can't extract control file");
 			}
 			deb_file[deb_count]->filename = xstrdup(argv[0]);
 			package_num = fill_package_struct(deb_file[deb_count]->control_file);
@@ -1879,13 +1879,13 @@
 		argv++;
 	}
 	if (!deb_count)
-		bb_error_msg_and_die("no package files specified");
+		bb_simple_error_msg_and_die("no package files specified");
 	deb_file[deb_count] = NULL;
 
 	/* Check that the deb file arguments are installable */
 	if (!(opt & OPT_force_ignore_depends)) {
 		if (!check_deps(deb_file, 0 /*, deb_count*/)) {
-			bb_error_msg_and_die("dependency check failed");
+			bb_simple_error_msg_and_die("dependency check failed");
 		}
 	}
 
diff -Naur busybox-1.31.1/archival/gzip.c busybox-be5a505d/archival/gzip.c
--- busybox-1.31.1/archival/gzip.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/gzip.c	2019-10-24 07:26:55.000000000 -0700
@@ -52,7 +52,7 @@
 //config:	help
 //config:	Enable support for compression levels 4-9. The default level
 //config:	is 6. If levels 1-3 are specified, 4 is used.
-//config:	If this option is not selected, -N options are ignored and -9
+//config:	If this option is not selected, -N options are ignored and -6
 //config:	is used.
 //config:
 //config:config FEATURE_GZIP_DECOMPRESS
@@ -99,7 +99,7 @@
 /* Diagnostic functions */
 #ifdef DEBUG
 static int verbose;
-#  define Assert(cond,msg) { if (!(cond)) bb_error_msg(msg); }
+#  define Assert(cond,msg) { if (!(cond)) bb_simple_error_msg(msg); }
 #  define Trace(x) fprintf x
 #  define Tracev(x) {if (verbose) fprintf x; }
 #  define Tracevv(x) {if (verbose > 1) fprintf x; }
@@ -259,12 +259,13 @@
 
 #if !ENABLE_FEATURE_GZIP_LEVELS
 
-	max_chain_length = 4096,
+	comp_level_minus4 = 6 - 4,
+	max_chain_length = 128,
 /* To speed up deflation, hash chains are never searched beyond this length.
  * A higher limit improves compression ratio but degrades the speed.
  */
 
-	max_lazy_match = 258,
+	max_lazy_match = 16,
 /* Attempt to find a better match only when the current match is strictly
  * smaller than this value. This mechanism is used only for compression
  * levels >= 4.
@@ -276,7 +277,7 @@
  * max_insert_length is used only for compression levels <= 3.
  */
 
-	good_match = 32,
+	good_match = 8,
 /* Use a faster search when the previous match is longer than this */
 
 /* Values for max_lazy_match, good_match and max_chain_length, depending on
@@ -285,7 +286,7 @@
  * found for specific files.
  */
 
-	nice_match = 258,	/* Stop searching when current match exceeds this */
+	nice_match = 128,	/* Stop searching when current match exceeds this */
 /* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
  * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
  * meaning.
@@ -334,14 +335,16 @@
 #define head (G1.prev + WSIZE) /* hash head (see deflate.c) */
 
 #if ENABLE_FEATURE_GZIP_LEVELS
+	unsigned comp_level_minus4;	/* can be a byte */
 	unsigned max_chain_length;
 	unsigned max_lazy_match;
 	unsigned good_match;
 	unsigned nice_match;
-#define max_chain_length (G1.max_chain_length)
-#define max_lazy_match   (G1.max_lazy_match)
-#define good_match	 (G1.good_match)
-#define nice_match	 (G1.nice_match)
+#define comp_level_minus4 (G1.comp_level_minus4)
+#define max_chain_length  (G1.max_chain_length)
+#define max_lazy_match    (G1.max_lazy_match)
+#define good_match        (G1.good_match)
+#define nice_match        (G1.nice_match)
 #endif
 
 /* =========================================================================== */
@@ -504,7 +507,7 @@
  * pointer, then initialize the crc shift register contents instead.
  * Return the current crc in either case.
  */
-static void updcrc(uch * s, unsigned n)
+static void updcrc(uch *s, unsigned n)
 {
 	G1.crc = crc32_block_endian0(G1.crc, s, n, global_crc32_table /*G1.crc_32_tab*/);
 }
@@ -607,7 +610,7 @@
  * Copy a stored block to the zip file, storing first the length and its
  * one's complement if requested.
  */
-static void copy_block(char *buf, unsigned len, int header)
+static void copy_block(const char *buf, unsigned len, int header)
 {
 	bi_windup();		/* align on byte boundary */
 
@@ -787,7 +790,7 @@
 	/* check that the match is indeed a match */
 	if (memcmp(G1.window + match, G1.window + start, length) != 0) {
 		bb_error_msg(" start %d, match %d, length %d", start, match, length);
-		bb_error_msg("invalid match");
+		bb_simple_error_msg("invalid match");
 	}
 	if (verbose > 1) {
 		bb_error_msg("\\[%d,%d]", start - match, length);
@@ -1007,7 +1010,8 @@
 	tree_desc d_desc;
 	tree_desc bl_desc;
 
-	ush bl_count[MAX_BITS + 1];
+	/* was "ush", but "unsigned" results in smaller code */
+	unsigned bl_count[MAX_BITS + 1];
 
 /* The lengths of the bit length codes are sent in order of decreasing
  * probability, to avoid transmitting the lengths for unused bit length codes.
@@ -1118,7 +1122,7 @@
 	(tree[n].Freq < tree[m].Freq \
 	|| (tree[n].Freq == tree[m].Freq && G2.depth[n] <= G2.depth[m]))
 
-static void pqdownheap(ct_data * tree, int k)
+static void pqdownheap(const ct_data *tree, int k)
 {
 	int v = G2.heap[k];
 	int j = k << 1;		/* left son of k */
@@ -1152,22 +1156,15 @@
  *     The length opt_len is updated; static_len is also updated if stree is
  *     not null.
  */
-static void gen_bitlen(tree_desc * desc)
+static void gen_bitlen(const tree_desc *desc)
 {
-	ct_data *tree = desc->dyn_tree;
-	const uint8_t *extra = desc->extra_bits;
-	int base = desc->extra_base;
-	int max_code = desc->max_code;
-	int max_length = desc->max_length;
-	ct_data *stree = desc->static_tree;
-	int h;				/* heap index */
-	int n, m;			/* iterate over the tree elements */
-	int bits;			/* bit length */
-	int xbits;			/* extra bits */
-	ush f;				/* frequency */
-	int overflow = 0;	/* number of elements with bit length too large */
+#define tree desc->dyn_tree
+	int h;          /* heap index */
+	int n, m;       /* iterate over the tree elements */
+	int bits;       /* bit length */
+	int overflow;   /* number of elements with bit length too large */
 
-	for (bits = 0; bits <= MAX_BITS; bits++)
+	for (bits = 0; bits < ARRAY_SIZE(G2.bl_count); bits++)
 		G2.bl_count[bits] = 0;
 
 	/* In a first pass, compute the optimal bit lengths (which may
@@ -1175,28 +1172,32 @@
 	 */
 	tree[G2.heap[G2.heap_max]].Len = 0;	/* root of the heap */
 
+	overflow = 0;
 	for (h = G2.heap_max + 1; h < HEAP_SIZE; h++) {
+		ulg f;          /* frequency */
+		int xbits;      /* extra bits */
+
 		n = G2.heap[h];
 		bits = tree[tree[n].Dad].Len + 1;
-		if (bits > max_length) {
-			bits = max_length;
+		if (bits > desc->max_length) {
+			bits = desc->max_length;
 			overflow++;
 		}
 		tree[n].Len = (ush) bits;
 		/* We overwrite tree[n].Dad which is no longer needed */
 
-		if (n > max_code)
+		if (n > desc->max_code)
 			continue;	/* not a leaf node */
 
 		G2.bl_count[bits]++;
 		xbits = 0;
-		if (n >= base)
-			xbits = extra[n - base];
+		if (n >= desc->extra_base)
+			xbits = desc->extra_bits[n - desc->extra_base];
 		f = tree[n].Freq;
-		G2.opt_len += (ulg) f *(bits + xbits);
+		G2.opt_len += f * (bits + xbits);
 
-		if (stree)
-			G2.static_len += (ulg) f * (stree[n].Len + xbits);
+		if (desc->static_tree)
+			G2.static_len += f * (desc->static_tree[n].Len + xbits);
 	}
 	if (overflow == 0)
 		return;
@@ -1206,14 +1207,14 @@
 
 	/* Find the first bit length which could increase: */
 	do {
-		bits = max_length - 1;
+		bits = desc->max_length - 1;
 		while (G2.bl_count[bits] == 0)
 			bits--;
 		G2.bl_count[bits]--;	/* move one leaf down the tree */
 		G2.bl_count[bits + 1] += 2;	/* move one overflow item as its brother */
-		G2.bl_count[max_length]--;
+		G2.bl_count[desc->max_length]--;
 		/* The brother of the overflow item also moves one step up,
-		 * but this does not affect bl_count[max_length]
+		 * but this does not affect bl_count[desc->max_length]
 		 */
 		overflow -= 2;
 	} while (overflow > 0);
@@ -1223,11 +1224,11 @@
 	 * lengths instead of fixing only the wrong ones. This idea is taken
 	 * from 'ar' written by Haruhiko Okumura.)
 	 */
-	for (bits = max_length; bits != 0; bits--) {
+	for (bits = desc->max_length; bits != 0; bits--) {
 		n = G2.bl_count[bits];
 		while (n != 0) {
 			m = G2.heap[--h];
-			if (m > max_code)
+			if (m > desc->max_code)
 				continue;
 			if (tree[m].Len != (unsigned) bits) {
 				Trace((stderr, "code %d bits %d->%d\n", m, tree[m].Len, bits));
@@ -1237,6 +1238,7 @@
 			n--;
 		}
 	}
+#undef tree
 }
 
 /* ===========================================================================
@@ -1247,12 +1249,13 @@
  * OUT assertion: the field code is set for all tree elements of non
  *     zero code length.
  */
-static void gen_codes(ct_data * tree, int max_code)
+static void gen_codes(ct_data *tree, int max_code)
 {
-	ush next_code[MAX_BITS + 1];	/* next code value for each bit length */
-	ush code = 0;		/* running code value */
-	int bits;			/* bit index */
-	int n;				/* code index */
+	/* next_code[] and code used to be "ush", but "unsigned" results in smaller code */
+	unsigned next_code[MAX_BITS + 1]; /* next code value for each bit length */
+	unsigned code = 0;      /* running code value */
+	int bits;               /* bit index */
+	int n;                  /* code index */
 
 	/* The distribution counts are first used to generate the code values
 	 * without bit reversal.
@@ -1304,7 +1307,7 @@
 	pqdownheap(tree, SMALLEST); \
 } while (0)
 
-static void build_tree(tree_desc * desc)
+static void build_tree(tree_desc *desc)
 {
 	ct_data *tree = desc->dyn_tree;
 	ct_data *stree = desc->static_tree;
@@ -1382,10 +1385,10 @@
 	/* At this point, the fields freq and dad are set. We can now
 	 * generate the bit lengths.
 	 */
-	gen_bitlen((tree_desc *) desc);
+	gen_bitlen(desc);
 
 	/* The field len is now set, we can generate the bit codes */
-	gen_codes((ct_data *) tree, max_code);
+	gen_codes(tree, max_code);
 }
 
 /* ===========================================================================
@@ -1394,7 +1397,7 @@
  * counts. (The contribution of the bit length codes will be added later
  * during the construction of bl_tree.)
  */
-static void scan_tree(ct_data * tree, int max_code)
+static void scan_tree(ct_data *tree, int max_code)
 {
 	int n;				/* iterates over all tree elements */
 	int prevlen = -1;	/* last emitted length */
@@ -1446,7 +1449,7 @@
  * Send a literal or distance tree in compressed form, using the codes in
  * bl_tree.
  */
-static void send_tree(ct_data * tree, int max_code)
+static void send_tree(const ct_data *tree, int max_code)
 {
 	int n;				/* iterates over all tree elements */
 	int prevlen = -1;	/* last emitted length */
@@ -1622,7 +1625,7 @@
 /* ===========================================================================
  * Send the block data compressed using the given Huffman trees
  */
-static void compress_block(ct_data * ltree, ct_data * dtree)
+static void compress_block(const ct_data *ltree, const ct_data *dtree)
 {
 	unsigned dist;          /* distance of matched string */
 	int lc;                 /* match length or unmatched char (if dist == 0) */
@@ -1672,7 +1675,7 @@
  * trees or store, and output the encoded block to the zip file. This function
  * returns the total compressed length for the file so far.
  */
-static void flush_block(char *buf, ulg stored_len, int eof)
+static void flush_block(const char *buf, ulg stored_len, int eof)
 {
 	ulg opt_lenb, static_lenb;      /* opt_len and static_len in bytes */
 	int max_blindex;                /* index of last bit length code of non zero freq */
@@ -1919,7 +1922,7 @@
 /* ===========================================================================
  * Initialize the "longest match" routines for a new file
  */
-static void lm_init(unsigned *flags16p)
+static void lm_init(void)
 {
 	unsigned j;
 
@@ -1927,8 +1930,6 @@
 	memset(head, 0, HASH_SIZE * sizeof(*head));
 	/* prev will be initialized on the fly */
 
-	/* speed options for the general purpose bit flag */
-	*flags16p |= 2;	/* FAST 4, SLOW 2 */
 	/* ??? reduce max_chain_length for binary files */
 
 	//G1.strstart = 0; // globals are zeroed in pack_gzip()
@@ -2076,10 +2077,16 @@
 
 	bi_init();
 	ct_init();
-	deflate_flags = 0;  /* pkzip -es, -en or -ex equivalent */
-	lm_init(&deflate_flags);
+	lm_init();
 
-	put_16bit(deflate_flags | 0x300); /* extra flags. OS id = 3 (Unix) */
+	deflate_flags = 0x300; /* extra flags. OS id = 3 (Unix) */
+#if ENABLE_FEATURE_GZIP_LEVELS
+	/* Note that comp_level < 4 do not exist in this version of gzip */
+	if (comp_level_minus4 == 9 - 4) {
+		deflate_flags |= 0x02; /* SLOW flag */
+	}
+#endif
+	put_16bit(deflate_flags);
 
 	/* The above 32-bit misaligns outbuf (10 bytes are stored), flush it */
 	flush_outbuf_if_32bit_optimized();
@@ -2222,8 +2229,11 @@
 #if ENABLE_FEATURE_GZIP_LEVELS
 	opt >>= (BBUNPK_OPTSTRLEN IF_FEATURE_GZIP_DECOMPRESS(+ 2) + 1); /* drop cfkvq[dt]n bits */
 	if (opt == 0)
-		opt = 1 << 6; /* default: 6 */
+		opt = 1 << 5; /* default: 6 */
 	opt = ffs(opt >> 4); /* Maps -1..-4 to [0], -5 to [1] ... -9 to [5] */
+
+	comp_level_minus4 = opt;
+
 	max_chain_length = 1 << gzip_level_config[opt].chain_shift;
 	good_match	 = gzip_level_config[opt].good;
 	max_lazy_match	 = gzip_level_config[opt].lazy2 * 2;
diff -Naur busybox-1.31.1/archival/libarchive/data_extract_all.c busybox-be5a505d/archival/libarchive/data_extract_all.c
--- busybox-1.31.1/archival/libarchive/data_extract_all.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/data_extract_all.c	2019-10-24 07:26:55.000000000 -0700
@@ -103,7 +103,7 @@
 		struct stat existing_sb;
 		if (lstat(dst_name, &existing_sb) == -1) {
 			if (errno != ENOENT) {
-				bb_perror_msg_and_die("can't stat old file");
+				bb_simple_perror_msg_and_die("can't stat old file");
 			}
 		}
 		else if (existing_sb.st_mtime >= file_header->mtime) {
@@ -207,7 +207,7 @@
 		}
 		break;
 	default:
-		bb_error_msg_and_die("unrecognized file type");
+		bb_simple_error_msg_and_die("unrecognized file type");
 	}
 
 	if (!S_ISLNK(file_header->mode)) {
diff -Naur busybox-1.31.1/archival/libarchive/decompress_bunzip2.c busybox-be5a505d/archival/libarchive/decompress_bunzip2.c
--- busybox-1.31.1/archival/libarchive/decompress_bunzip2.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/decompress_bunzip2.c	2019-10-24 07:26:55.000000000 -0700
@@ -817,7 +817,7 @@
 			break;
 		}
 		if (bd->headerCRC != bd->totalCRC) {
-			bb_error_msg("CRC error");
+			bb_simple_error_msg("CRC error");
 			break;
 		}
 
diff -Naur busybox-1.31.1/archival/libarchive/decompress_gunzip.c busybox-be5a505d/archival/libarchive/decompress_gunzip.c
--- busybox-1.31.1/archival/libarchive/decompress_gunzip.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/decompress_gunzip.c	2019-10-24 07:26:55.000000000 -0700
@@ -39,7 +39,8 @@
 	unsigned char e;	/* number of extra bits or operation */
 	unsigned char b;	/* number of bits in this code or subcode */
 	union {
-		unsigned short n;	/* literal, length base, or distance base */
+		unsigned n;	/* literal, length base, or distance base */
+		/* ^^^^^ was "unsigned short", but that results in larger code */
 		struct huft_t *t;	/* pointer to next level of table */
 	} v;
 } huft_t;
@@ -184,29 +185,26 @@
 	0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
 };
 
-/* Copy lengths for literal codes 257..285 */
-static const uint16_t cplens[] ALIGN2 = {
-	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
-	67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
+/* Put lengths/offsets and extra bits in a struct of arrays
+ * to make calls to huft_build() have one fewer parameter.
+ */
+struct cp_ext {
+	uint16_t cp[31];
+	uint8_t ext[31];
 };
-
+/* Copy lengths and extra bits for literal codes 257..285 */
 /* note: see note #13 above about the 258 in this list. */
-/* Extra bits for literal codes 257..285 */
-static const uint8_t cplext[] ALIGN1 = {
-	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
-	5, 5, 5, 0, 99, 99
-}; /* 99 == invalid */
-
-/* Copy offsets for distance codes 0..29 */
-static const uint16_t cpdist[] ALIGN2 = {
-	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
-	769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577
+static const struct cp_ext lit = {
+	/*257 258 259 260 261 262 263 264 265 266 267 268 269 270 271  272  273  274  275  276   277   278   279   280   281   282   283    284    285 */
+	/*0   1   2   3   4   5   6   7   8   9   10  11  12  13   14   15   16   17   18   19    20    21    22    23    24    25    26     27     28     29  30 */
+	{ 3,  4,  5,  6,  7,  8,  9,  10, 11, 13, 15, 17, 19, 23,  27,  31,  35,  43,  51,  59,   67,   83,   99,  115,  131,  163,  195,   227,   258,     0, 0  },
+	{ 0,  0,  0,  0,  0,  0,  0,   0,  1,  1,  1,  1,  2,  2,   2,   2,   3,   3,   3,   3,    4,    4,    4,    4,    5,    5,    5,     5,     0,    99, 99 } /* 99 == invalid */
 };
-
-/* Extra bits for distance codes */
-static const uint8_t cpdext[] ALIGN1 = {
-	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
-	11, 11, 12, 12, 13, 13
+/* Copy offsets and extra bits for distance codes 0..29 */
+static const struct cp_ext dist = {
+	/*0   1   2   3   4   5   6   7   8   9   10  11  12  13   14   15   16   17   18   19    20    21    22    23    24    25    26     27     28     29 */
+	{ 1,  2,  3,  4,  5,  7,  9,  13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 },
+	{ 0,  0,  0,  0,  1,  1,  2,   2,  3,  3,  4,  4,  5,  5,   6,   6,   7,   7,   8,   8,    9,    9,   10,   10,   11,   11,   12,    12,    13,    13 }
 };
 
 /* Tables for deflate from PKZIP's appnote.txt. */
@@ -277,22 +275,19 @@
 
 
 /* Given a list of code lengths and a maximum table size, make a set of
- * tables to decode that set of codes.  Return zero on success, one if
- * the given code set is incomplete (the tables are still built in this
- * case), two if the input is invalid (an oversubscribed set of lengths)
- * - in this case stores NULL in *t.
+ * tables to decode that set of codes.
  *
  * b:	code lengths in bits (all assumed <= BMAX)
  * n:	number of codes (assumed <= N_MAX)
  * s:	number of simple-valued codes (0..s-1)
  * d:	list of base values for non-simple codes
  * e:	list of extra bits for non-simple codes
- * t:	result: starting table
  * m:	maximum lookup bits, returns actual
+ * result: starting table
  */
-static int huft_build(const unsigned *b, const unsigned n,
-			const unsigned s, const unsigned short *d,
-			const unsigned char *e, huft_t **t, unsigned *m)
+static huft_t* huft_build(const unsigned *b, const unsigned n,
+			const unsigned s, const struct cp_ext *cp_ext,
+			unsigned *m)
 {
 	unsigned a;             /* counter for codes of length k */
 	unsigned c[BMAX + 1];   /* bit length count table */
@@ -314,12 +309,12 @@
 	unsigned *xp;           /* pointer into x */
 	int y;                  /* number of dummy codes added */
 	unsigned z;             /* number of entries in current table */
+	huft_t *result;
+	huft_t **t;
 
 	/* Length of EOB code, if any */
 	eob_len = n > 256 ? b[256] : BMAX;
 
-	*t = NULL;
-
 	/* Generate counts for each bit length */
 	memset(c, 0, sizeof(c));
 	p = b;
@@ -335,9 +330,8 @@
 		q[1].b = 1;
 		q[2].e = 99;    /* invalid code marker */
 		q[2].b = 1;
-		*t = q + 1;
 		*m = 1;
-		return 0;
+		return q + 1;
 	}
 
 	/* Find minimum and maximum length, bound *m by those */
@@ -353,11 +347,11 @@
 	for (y = 1 << j; j < i; j++, y <<= 1) {
 		y -= c[j];
 		if (y < 0)
-			return 2; /* bad input: more codes than bits */
+			return NULL; /* bad input: more codes than bits */
 	}
 	y -= c[i];
 	if (y < 0)
-		return 2;
+		return NULL;
 	c[i] += y;
 
 	/* Generate starting offsets into the value table for each length */
@@ -384,6 +378,8 @@
 	} while (++i < n);
 
 	/* Generate the Huffman codes and for each, make the table entries */
+	result = NULL;
+	t = &result;
 	x[0] = i = 0;   /* first Huffman code is zero */
 	p = v;          /* grab values in bit order */
 	htl = -1;       /* no tables yet--level -1 */
@@ -449,8 +445,8 @@
 				r.e = (unsigned char) (*p < 256 ? 16 : 15);	/* 256 is EOB code */
 				r.v.n = (unsigned short) (*p++); /* simple code is just the value */
 			} else {
-				r.e = (unsigned char) e[*p - s]; /* non-simple--look up in lists */
-				r.v.n = d[*p++ - s];
+				r.e = (unsigned char) cp_ext->ext[*p - s]; /* non-simple--look up in lists */
+				r.v.n = cp_ext->cp[*p++ - s];
 			}
 
 			/* fill code-like entries with r */
@@ -475,8 +471,10 @@
 	/* return actual size of base table */
 	*m = ws[1];
 
-	/* Return 1 if we were given an incomplete table */
-	return y != 0 && g != 1;
+	if (y != 0 && g != 1) /* we were given an incomplete table */
+		return NULL;
+
+	return result;
 }
 
 
@@ -777,14 +775,14 @@
 		for (; i < 288; i++) /* make a complete, but wrong code set */
 			ll[i] = 8;
 		bl = 7;
-		huft_build(ll, 288, 257, cplens, cplext, &inflate_codes_tl, &bl);
-		/* huft_build() never return nonzero - we use known data */
+		inflate_codes_tl = huft_build(ll, 288, 257, &lit, &bl);
+		/* huft_build() never returns error here - we use known data */
 
 		/* set up distance table */
 		for (i = 0; i < 30; i++) /* make an incomplete code set */
 			ll[i] = 5;
 		bd = 5;
-		huft_build(ll, 30, 0, cpdist, cpdext, &inflate_codes_td, &bd);
+		inflate_codes_td = huft_build(ll, 30, 0, &dist, &bd);
 
 		/* set up data for inflate_codes() */
 		inflate_codes_setup(PASS_STATE bl, bd);
@@ -850,9 +848,9 @@
 
 		/* build decoding table for trees - single level, 7 bit lookup */
 		bl = 7;
-		i = huft_build(ll, 19, 19, NULL, NULL, &inflate_codes_tl, &bl);
-		if (i != 0) {
-			abort_unzip(PASS_STATE_ONLY); //return i;	/* incomplete code set */
+		inflate_codes_tl = huft_build(ll, 19, 19, NULL, &bl);
+		if (!inflate_codes_tl) {
+			abort_unzip(PASS_STATE_ONLY);	/* incomplete code set */
 		}
 
 		/* read in literal and distance code lengths */
@@ -915,14 +913,13 @@
 
 		/* build the decoding tables for literal/length and distance codes */
 		bl = lbits;
-
-		i = huft_build(ll, nl, 257, cplens, cplext, &inflate_codes_tl, &bl);
-		if (i != 0) {
+		inflate_codes_tl = huft_build(ll, nl, 257, &lit, &bl);
+		if (!inflate_codes_tl) {
 			abort_unzip(PASS_STATE_ONLY);
 		}
 		bd = dbits;
-		i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &inflate_codes_td, &bd);
-		if (i != 0) {
+		inflate_codes_td = huft_build(ll + nl, nd, 0, &dist, &bd);
+		if (!inflate_codes_td) {
 			abort_unzip(PASS_STATE_ONLY);
 		}
 
@@ -1012,7 +1009,7 @@
 	error_msg = "corrupted data";
 	if (setjmp(error_jmp)) {
 		/* Error from deep inside zip machinery */
-		bb_error_msg(error_msg);
+		bb_simple_error_msg(error_msg);
 		n = -1;
 		goto ret;
 	}
@@ -1085,7 +1082,7 @@
 		bytebuffer_offset = 0;
 		bytebuffer_size = full_read(gunzip_src_fd, &bytebuffer[count], bytebuffer_max - count);
 		if ((int)bytebuffer_size < 0) {
-			bb_error_msg(bb_msg_read_error);
+			bb_simple_error_msg(bb_msg_read_error);
 			return 0;
 		}
 		bytebuffer_size += count;
@@ -1211,7 +1208,7 @@
 
 		if (full_read(xstate->src_fd, &magic2, 2) != 2) {
  bad_magic:
-			bb_error_msg("invalid magic");
+			bb_simple_error_msg("invalid magic");
 			return -1;
 		}
 		if (magic2 == COMPRESS_MAGIC) {
@@ -1233,7 +1230,7 @@
 
  again:
 	if (!check_header_gzip(PASS_STATE xstate)) {
-		bb_error_msg("corrupted data");
+		bb_simple_error_msg("corrupted data");
 		total = -1;
 		goto ret;
 	}
@@ -1246,7 +1243,7 @@
 	total += n;
 
 	if (!top_up(PASS_STATE 8)) {
-		bb_error_msg("corrupted data");
+		bb_simple_error_msg("corrupted data");
 		total = -1;
 		goto ret;
 	}
@@ -1254,7 +1251,7 @@
 	/* Validate decompression - crc */
 	v32 = buffer_read_le_u32(PASS_STATE_ONLY);
 	if ((~gunzip_crc) != v32) {
-		bb_error_msg("crc error");
+		bb_simple_error_msg("crc error");
 		total = -1;
 		goto ret;
 	}
@@ -1262,7 +1259,7 @@
 	/* Validate decompression - size */
 	v32 = buffer_read_le_u32(PASS_STATE_ONLY);
 	if ((uint32_t)gunzip_bytes_out != v32) {
-		bb_error_msg("incorrect length");
+		bb_simple_error_msg("incorrect length");
 		total = -1;
 	}
 
diff -Naur busybox-1.31.1/archival/libarchive/decompress_uncompress.c busybox-be5a505d/archival/libarchive/decompress_uncompress.c
--- busybox-1.31.1/archival/libarchive/decompress_uncompress.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/decompress_uncompress.c	2019-10-24 07:26:55.000000000 -0700
@@ -113,7 +113,7 @@
 	/* xread isn't good here, we have to return - caller may want
 	 * to do some cleanup (e.g. delete incomplete unpacked file etc) */
 	if (full_read(xstate->src_fd, inbuf, 1) != 1) {
-		bb_error_msg("short read");
+		bb_simple_error_msg("short read");
 		goto err;
 	}
 
@@ -166,7 +166,7 @@
 		if (insize < (int) (IBUFSIZ + 64) - IBUFSIZ) {
 			rsize = safe_read(xstate->src_fd, inbuf + insize, IBUFSIZ);
 			if (rsize < 0)
-				bb_error_msg_and_die(bb_msg_read_error);
+				bb_simple_error_msg_and_die(bb_msg_read_error);
 			insize += rsize;
 		}
 
@@ -200,7 +200,7 @@
 
 			if (oldcode == -1) {
 				if (code >= 256)
-					bb_error_msg_and_die("corrupted data"); /* %ld", code); */
+					bb_simple_error_msg_and_die("corrupted data"); /* %ld", code); */
 				oldcode = code;
 				finchar = (int) oldcode;
 				outbuf[outpos++] = (unsigned char) finchar;
@@ -236,7 +236,7 @@
 						insize, posbits, p[-1], p[0], p[1], p[2], p[3],
 						(posbits & 07));
 */
-					bb_error_msg("corrupted data");
+					bb_simple_error_msg("corrupted data");
 					goto err;
 				}
 
@@ -247,7 +247,7 @@
 			/* Generate output characters in reverse order */
 			while (code >= 256) {
 				if (stackp <= &htabof(0))
-					bb_error_msg_and_die("corrupted data");
+					bb_simple_error_msg_and_die("corrupted data");
 				*--stackp = tab_suffixof(code);
 				code = tab_prefixof(code);
 			}
diff -Naur busybox-1.31.1/archival/libarchive/decompress_unlzma.c busybox-be5a505d/archival/libarchive/decompress_unlzma.c
--- busybox-1.31.1/archival/libarchive/decompress_unlzma.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/decompress_unlzma.c	2019-10-24 07:26:55.000000000 -0700
@@ -59,7 +59,7 @@
 //TODO: return -1 instead
 //This will make unlzma delete broken unpacked file on unpack errors
 	if (buffer_size <= 0)
-		bb_error_msg_and_die("unexpected EOF");
+		bb_simple_error_msg_and_die("unexpected EOF");
 	rc->buffer_end = RC_BUFFER + buffer_size;
 	rc->ptr = RC_BUFFER;
 }
@@ -234,7 +234,7 @@
 	if (full_read(xstate->src_fd, &header, sizeof(header)) != sizeof(header)
 	 || header.pos >= (9 * 5 * 5)
 	) {
-		bb_error_msg("bad lzma header");
+		bb_simple_error_msg("bad lzma header");
 		return -1;
 	}
 
@@ -513,7 +513,7 @@
 			 * potentially more detailed information).
 			 * Do not fail silently.
 			 */
-			bb_error_msg("corrupted data");
+			bb_simple_error_msg("corrupted data");
 			total_written = -1; /* failure */
 		}
 		rc_free(rc);
diff -Naur busybox-1.31.1/archival/libarchive/decompress_unxz.c busybox-be5a505d/archival/libarchive/decompress_unxz.c
--- busybox-1.31.1/archival/libarchive/decompress_unxz.c	2019-10-21 07:54:40.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/decompress_unxz.c	2019-10-24 07:26:55.000000000 -0700
@@ -74,7 +74,7 @@
 		if (iobuf.in_pos == iobuf.in_size) {
 			int rd = safe_read(xstate->src_fd, membuf, BUFSIZ);
 			if (rd < 0) {
-				bb_error_msg(bb_msg_read_error);
+				bb_simple_error_msg(bb_msg_read_error);
 				total = -1;
 				break;
 			}
@@ -141,7 +141,7 @@
 			continue;
 		}
 		if (xz_result != XZ_OK && xz_result != XZ_UNSUPPORTED_CHECK) {
-			bb_error_msg("corrupted data");
+			bb_simple_error_msg("corrupted data");
 			total = -1;
 			break;
 		}
diff -Naur busybox-1.31.1/archival/libarchive/get_header_ar.c busybox-be5a505d/archival/libarchive/get_header_ar.c
--- busybox-1.31.1/archival/libarchive/get_header_ar.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/get_header_ar.c	2019-10-24 07:26:55.000000000 -0700
@@ -22,7 +22,7 @@
 	 * on misformatted numbers bb_strtou returns all-ones */
 	err = bb_strtou(str, NULL, base);
 	if (err == -1)
-		bb_error_msg_and_die("invalid ar header");
+		bb_simple_error_msg_and_die("invalid ar header");
 	return err;
 }
 
@@ -53,7 +53,7 @@
 	archive_handle->offset += 60;
 
 	if (ar.formatted.magic[0] != '`' || ar.formatted.magic[1] != '\n')
-		bb_error_msg_and_die("invalid ar header");
+		bb_simple_error_msg_and_die("invalid ar header");
 
 	/*
 	 * Note that the fields MUST be read in reverse order as
@@ -86,7 +86,7 @@
 			return get_header_ar(archive_handle);
 		}
 #else
-		bb_error_msg_and_die("long filenames not supported");
+		bb_simple_error_msg_and_die("long filenames not supported");
 #endif
 	}
 	/* Only size is always present, the rest may be missing in
@@ -107,7 +107,7 @@
 		long_offset = read_num(&ar.formatted.name[1], 10,
 				       sizeof(ar.formatted.name) - 1);
 		if (long_offset >= archive_handle->ar__long_name_size) {
-			bb_error_msg_and_die("can't resolve long filename");
+			bb_simple_error_msg_and_die("can't resolve long filename");
 		}
 		typed->name = xstrdup(archive_handle->ar__long_names + long_offset);
 	} else
diff -Naur busybox-1.31.1/archival/libarchive/get_header_cpio.c busybox-be5a505d/archival/libarchive/get_header_cpio.c
--- busybox-1.31.1/archival/libarchive/get_header_cpio.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/get_header_cpio.c	2019-10-24 07:26:55.000000000 -0700
@@ -33,14 +33,14 @@
 		goto create_hardlinks;
 	}
 	if (size != 110) {
-		bb_error_msg_and_die("short read");
+		bb_simple_error_msg_and_die("short read");
 	}
 	archive_handle->offset += 110;
 
 	if (!is_prefixed_with(&cpio_header[0], "07070")
 	 || (cpio_header[5] != '1' && cpio_header[5] != '2')
 	) {
-		bb_error_msg_and_die("unsupported cpio format, use newc or crc");
+		bb_simple_error_msg_and_die("unsupported cpio format, use newc or crc");
 	}
 
 	if (sscanf(cpio_header + 6,
@@ -50,7 +50,7 @@
 			&inode, &mode, &uid, &gid,
 			&nlink, &mtime, &size,
 			&major, &minor, &namesize) != 10)
-		bb_error_msg_and_die("damaged cpio file");
+		bb_simple_error_msg_and_die("damaged cpio file");
 	file_header->mode = mode;
 	/* "cpio -R USER:GRP" support: */
 	if (archive_handle->cpio__owner.uid != (uid_t)-1L)
diff -Naur busybox-1.31.1/archival/libarchive/get_header_tar.c busybox-be5a505d/archival/libarchive/get_header_tar.c
--- busybox-1.31.1/archival/libarchive/get_header_tar.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/get_header_tar.c	2019-10-24 07:26:55.000000000 -0700
@@ -32,7 +32,7 @@
 	if (*end != '\0' && *end != ' ') {
 		int8_t first = str[0];
 		if (!(first & 0x80))
-			bb_error_msg_and_die("corrupted octal value in tar header");
+			bb_simple_error_msg_and_die("corrupted octal value in tar header");
 		/*
 		 * GNU tar uses "base-256 encoding" for very large numbers.
 		 * Encoding is binary, with highest bit always set as a marker
@@ -100,7 +100,7 @@
 		 || errno != EINVAL
 		 || *end != ' '
 		) {
-			bb_error_msg("malformed extended header, skipped");
+			bb_simple_error_msg("malformed extended header, skipped");
 			// More verbose version:
 			//bb_error_msg("malformed extended header at %"OFF_FMT"d, skipped",
 			//		archive_handle->offset - (sz + len));
@@ -194,13 +194,13 @@
 		 * the very first read fails. Grrr.
 		 */
 		if (archive_handle->offset == 0)
-			bb_error_msg("short read");
+			bb_simple_error_msg("short read");
 		/* this merely signals end of archive, not exit(1): */
 		return EXIT_FAILURE;
 	}
 	if (i != 512) {
 		IF_FEATURE_TAR_AUTODETECT(goto autodetect;)
-		bb_error_msg_and_die("short read");
+		bb_simple_error_msg_and_die("short read");
 	}
 
 #else
@@ -243,11 +243,11 @@
 			goto err;
 		if (setup_unzip_on_fd(archive_handle->src_fd, /*fail_if_not_compressed:*/ 0) != 0)
  err:
-			bb_error_msg_and_die("invalid tar magic");
+			bb_simple_error_msg_and_die("invalid tar magic");
 		archive_handle->offset = 0;
 		goto again_after_align;
 #endif
-		bb_error_msg_and_die("invalid tar magic");
+		bb_simple_error_msg_and_die("invalid tar magic");
 	}
 
 	/* Do checksum on headers.
@@ -282,7 +282,7 @@
 	if (sum_u != sum
 	    IF_FEATURE_TAR_OLDSUN_COMPATIBILITY(&& sum_s != sum)
 	) {
-		bb_error_msg_and_die("invalid tar header checksum");
+		bb_simple_error_msg_and_die("invalid tar header checksum");
 	}
 
 	/* GET_OCTAL trashes subsequent field, therefore we call it
diff -Naur busybox-1.31.1/archival/libarchive/open_transformer.c busybox-be5a505d/archival/libarchive/open_transformer.c
--- busybox-1.31.1/archival/libarchive/open_transformer.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/open_transformer.c	2019-10-24 07:26:55.000000000 -0700
@@ -15,7 +15,7 @@
 	if (!xstate->signature_skipped) {
 		uint16_t magic2;
 		if (full_read(xstate->src_fd, &magic2, 2) != 2 || magic2 != magic16) {
-			bb_error_msg("invalid magic");
+			bb_simple_error_msg("invalid magic");
 			return -1;
 		}
 		xstate->signature_skipped = 2;
@@ -46,7 +46,7 @@
 	} else {
 		nwrote = full_write(xstate->dst_fd, buf, bufsize);
 		if (nwrote != (ssize_t)bufsize) {
-			bb_perror_msg("write");
+			bb_simple_perror_msg("write");
 			nwrote = -1;
 			goto ret;
 		}
@@ -205,7 +205,7 @@
 
 	/* No known magic seen */
 	if (fail_if_not_compressed)
-		bb_error_msg_and_die("no gzip"
+		bb_simple_error_msg_and_die("no gzip"
 			IF_FEATURE_SEAMLESS_BZ2("/bzip2")
 			IF_FEATURE_SEAMLESS_XZ("/xz")
 			" magic");
diff -Naur busybox-1.31.1/archival/libarchive/seek_by_jump.c busybox-be5a505d/archival/libarchive/seek_by_jump.c
--- busybox-1.31.1/archival/libarchive/seek_by_jump.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/seek_by_jump.c	2019-10-24 07:26:55.000000000 -0700
@@ -13,6 +13,6 @@
 		if (errno == ESPIPE)
 			seek_by_read(fd, amount);
 		else
-			bb_perror_msg_and_die("seek failure");
+			bb_simple_perror_msg_and_die("seek failure");
 	}
 }
diff -Naur busybox-1.31.1/archival/libarchive/unpack_ar_archive.c busybox-be5a505d/archival/libarchive/unpack_ar_archive.c
--- busybox-1.31.1/archival/libarchive/unpack_ar_archive.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/libarchive/unpack_ar_archive.c	2019-10-24 07:26:55.000000000 -0700
@@ -12,7 +12,7 @@
 
 	xread(ar_archive->src_fd, magic, AR_MAGIC_LEN);
 	if (!is_prefixed_with(magic, AR_MAGIC)) {
-		bb_error_msg_and_die("invalid ar magic");
+		bb_simple_error_msg_and_die("invalid ar magic");
 	}
 	ar_archive->offset += AR_MAGIC_LEN;
 
diff -Naur busybox-1.31.1/archival/lzop.c busybox-be5a505d/archival/lzop.c
--- busybox-1.31.1/archival/lzop.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/lzop.c	2019-10-24 07:26:55.000000000 -0700
@@ -752,7 +752,7 @@
 	 */
 	uint32_t c = fn(init, buf, len);
 	if (c != ref)
-		bb_error_msg_and_die("checksum error");
+		bb_simple_error_msg_and_die("checksum error");
 }
 
 /**********************************************************************/
@@ -785,15 +785,15 @@
 		/* error if split file */
 		if (dst_len == 0xffffffffL)
 			/* should not happen - not yet implemented */
-			bb_error_msg_and_die("this file is a split lzop file");
+			bb_simple_error_msg_and_die("this file is a split lzop file");
 
 		if (dst_len > MAX_BLOCK_SIZE)
-			bb_error_msg_and_die("corrupted data");
+			bb_simple_error_msg_and_die("corrupted data");
 
 		/* read compressed block size */
 		src_len = read32();
 		if (src_len <= 0 || src_len > dst_len)
-			bb_error_msg_and_die("corrupted data");
+			bb_simple_error_msg_and_die("corrupted data");
 
 		if (dst_len > block_size) {
 			if (b2) {
@@ -846,7 +846,7 @@
 				r = lzo1x_decompress_safe(b1, src_len, b2, &d /*, NULL*/);
 
 			if (r != 0 /*LZO_E_OK*/ || dst_len != d) {
-				bb_error_msg_and_die("corrupted data");
+				bb_simple_error_msg_and_die("corrupted data");
 			}
 			dst = b2;
 		} else {
@@ -913,7 +913,7 @@
 	unsigned char magic[sizeof(lzop_magic)];
 	xread(0, magic, sizeof(magic));
 	if (memcmp(magic, lzop_magic, sizeof(lzop_magic)) != 0)
-		bb_error_msg_and_die("bad magic number");
+		bb_simple_error_msg_and_die("bad magic number");
 }
 
 /**********************************************************************/
@@ -1049,7 +1049,7 @@
 		else if (option_mask32 & OPT_8)
 			level = 8;
 #else
-		bb_error_msg_and_die("high compression not compiled in");
+		bb_simple_error_msg_and_die("high compression not compiled in");
 #endif
 	}
 
diff -Naur busybox-1.31.1/archival/rpm.c busybox-be5a505d/archival/rpm.c
--- busybox-1.31.1/archival/rpm.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/rpm.c	2019-10-24 07:26:55.000000000 -0700
@@ -543,7 +543,7 @@
 	}
 
 	if (bb_copyfd_eof(rpm_fd, STDOUT_FILENO) < 0)
-		bb_error_msg_and_die("error unpacking");
+		bb_simple_error_msg_and_die("error unpacking");
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		close(rpm_fd);
diff -Naur busybox-1.31.1/archival/tar.c busybox-be5a505d/archival/tar.c
--- busybox-1.31.1/archival/tar.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/tar.c	2019-10-24 07:26:55.000000000 -0700
@@ -232,7 +232,7 @@
 }
 
 /* Put an octal string into the specified buffer.
- * The number is zero padded and possibly null terminated.
+ * The number is zero padded and possibly NUL terminated.
  * Stores low-order bits only if whole value does not fit. */
 static void putOctal(char *cp, int len, off_t value)
 {
@@ -283,31 +283,32 @@
 # if ENABLE_FEATURE_TAR_GNU_EXTENSIONS
 static void writeLongname(int fd, int type, const char *name, int dir)
 {
-	static const struct {
+	struct prefilled {
 		char mode[8];             /* 100-107 */
 		char uid[8];              /* 108-115 */
 		char gid[8];              /* 116-123 */
 		char size[12];            /* 124-135 */
 		char mtime[12];           /* 136-147 */
-	} prefilled = {
-		"0000000",
-		"0000000",
-		"0000000",
-		"00000000000",
-		"00000000000",
 	};
 	struct tar_header_t header;
 	int size;
 
+	memset(&header, 0, sizeof(header));
+	header.typeflag = type;
+	strcpy(header.name, "././@LongLink");
+	/* This sets mode/uid/gid/mtime to "00...00<NUL>" strings */
+	memset(header.mode, '0', sizeof(struct prefilled));
+	header.mode [sizeof(header.mode ) - 1] = '\0';
+	header.uid  [sizeof(header.uid  ) - 1] = '\0';
+	header.gid  [sizeof(header.gid  ) - 1] = '\0';
+	/* header.size is filled by '0' now, will be corrected below */
+	header.mtime[sizeof(header.mtime) - 1] = '\0';
+
 	dir = !!dir; /* normalize: 0/1 */
 	size = strlen(name) + 1 + dir; /* GNU tar uses strlen+1 */
 	/* + dir: account for possible '/' */
 
-	memset(&header, 0, sizeof(header));
-	strcpy(header.name, "././@LongLink");
-	memcpy(header.mode, prefilled.mode, sizeof(prefilled));
 	PUT_OCTAL(header.size, size);
-	header.typeflag = type;
 	chksum_and_xwrite(fd, &header);
 
 	/* Write filename[/] and pad the block. */
@@ -369,7 +370,7 @@
 		/* If it is larger than 100 bytes, bail out */
 		if (header.linkname[sizeof(header.linkname)-1]) {
 			free(lpath);
-			bb_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
+			bb_simple_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
 			return FALSE;
 		}
 # endif
@@ -542,7 +543,7 @@
 
 # if !ENABLE_FEATURE_TAR_GNU_EXTENSIONS
 	if (strlen(header_name) >= NAME_SIZE) {
-		bb_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
+		bb_simple_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
 		return TRUE;
 	}
 # endif
@@ -636,8 +637,14 @@
 		}
 		xmove_fd(data.rd, 0);
 		xmove_fd(tfd, 1);
-		/* exec gzip/bzip2 program/applet */
-		BB_EXECLP(gzip, gzip, "-f", (char *)0);
+
+		/* exec gzip/bzip2/... program */
+		//BB_EXECLP(gzip, gzip, "-f", (char *)0); - WRONG for "xz",
+		// if xz is an enabled applet, it'll be a version which
+		// can only decompress. We do need to execute external
+		// program, not applet.
+		execlp(gzip, gzip, "-f", (char *)0);
+
 		vfork_exec_errno = errno;
 		_exit(EXIT_FAILURE);
 	}
@@ -715,13 +722,13 @@
 		freeHardLinkInfo(&tbInfo->hlInfoHead);
 
 	if (errorFlag)
-		bb_error_msg("error exit delayed from previous errors");
+		bb_simple_error_msg("error exit delayed from previous errors");
 
 # if SEAMLESS_COMPRESSION
 	if (gzip) {
 		int status;
 		if (safe_waitpid(-1, &status, 0) == -1)
-			bb_perror_msg("waitpid");
+			bb_simple_perror_msg("waitpid");
 		else if (!WIFEXITED(status) || WEXITSTATUS(status))
 			/* gzip was killed or has exited with nonzero! */
 			errorFlag = TRUE;
@@ -761,7 +768,7 @@
 //usage:	IF_FEATURE_SEAMLESS_GZ("z")
 //usage:	IF_FEATURE_SEAMLESS_XZ("J")
 //usage:	IF_FEATURE_SEAMLESS_BZ2("j")
-//usage:	IF_FEATURE_SEAMLESS_LZMA("a")
+//usage:	"a"
 //usage:	IF_FEATURE_TAR_CREATE("h")
 //usage:	IF_FEATURE_TAR_NOPRESERVE_TIME("m")
 //usage:	"vokO] "
@@ -800,9 +807,7 @@
 //usage:	IF_FEATURE_SEAMLESS_BZ2(
 //usage:     "\n	-j	(De)compress using bzip2"
 //usage:	)
-//usage:	IF_FEATURE_SEAMLESS_LZMA(
-//usage:     "\n	-a	(De)compress using lzma"
-//usage:	)
+//usage:     "\n	-a	(De)compress based on extension"
 //usage:	IF_FEATURE_TAR_CREATE(
 //usage:     "\n	-h	Follow symlinks"
 //usage:	)
@@ -819,6 +824,7 @@
 //usage:       "$ tar -cf /tmp/tarball.tar /usr/local\n"
 
 // Supported but aren't in --help:
+//	lzma
 //	no-recursion
 //	numeric-owner
 //	no-same-permissions
@@ -832,15 +838,16 @@
 	IF_FEATURE_TAR_CREATE(   OPTBIT_CREATE      ,)
 	IF_FEATURE_TAR_CREATE(   OPTBIT_DEREFERENCE ,)
 	IF_FEATURE_SEAMLESS_BZ2( OPTBIT_BZIP2       ,)
-	IF_FEATURE_SEAMLESS_LZMA(OPTBIT_LZMA        ,)
 	IF_FEATURE_TAR_FROM(     OPTBIT_INCLUDE_FROM,)
 	IF_FEATURE_TAR_FROM(     OPTBIT_EXCLUDE_FROM,)
 	IF_FEATURE_SEAMLESS_GZ(  OPTBIT_GZIP        ,)
-	IF_FEATURE_SEAMLESS_XZ(  OPTBIT_XZ          ,) // 16th bit
-	IF_FEATURE_SEAMLESS_Z(   OPTBIT_COMPRESS    ,)
+	IF_FEATURE_SEAMLESS_XZ(  OPTBIT_XZ          ,)
+	IF_FEATURE_SEAMLESS_Z(   OPTBIT_COMPRESS    ,) // 16th bit
+	OPTBIT_AUTOCOMPRESS_BY_EXT,
 	IF_FEATURE_TAR_NOPRESERVE_TIME(OPTBIT_NOPRESERVE_TIME,)
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS
 	OPTBIT_STRIP_COMPONENTS,
+	IF_FEATURE_SEAMLESS_LZMA(OPTBIT_LZMA        ,)
 	OPTBIT_NORECURSION,
 	IF_FEATURE_TAR_TO_COMMAND(OPTBIT_2COMMAND   ,)
 	OPTBIT_NUMERIC_OWNER,
@@ -859,14 +866,15 @@
 	OPT_CREATE       = IF_FEATURE_TAR_CREATE(   (1 << OPTBIT_CREATE      )) + 0, // c
 	OPT_DEREFERENCE  = IF_FEATURE_TAR_CREATE(   (1 << OPTBIT_DEREFERENCE )) + 0, // h
 	OPT_BZIP2        = IF_FEATURE_SEAMLESS_BZ2( (1 << OPTBIT_BZIP2       )) + 0, // j
-	OPT_LZMA         = IF_FEATURE_SEAMLESS_LZMA((1 << OPTBIT_LZMA        )) + 0, // a
 	OPT_INCLUDE_FROM = IF_FEATURE_TAR_FROM(     (1 << OPTBIT_INCLUDE_FROM)) + 0, // T
 	OPT_EXCLUDE_FROM = IF_FEATURE_TAR_FROM(     (1 << OPTBIT_EXCLUDE_FROM)) + 0, // X
 	OPT_GZIP         = IF_FEATURE_SEAMLESS_GZ(  (1 << OPTBIT_GZIP        )) + 0, // z
 	OPT_XZ           = IF_FEATURE_SEAMLESS_XZ(  (1 << OPTBIT_XZ          )) + 0, // J
 	OPT_COMPRESS     = IF_FEATURE_SEAMLESS_Z(   (1 << OPTBIT_COMPRESS    )) + 0, // Z
+	OPT_AUTOCOMPRESS_BY_EXT = 1 << OPTBIT_AUTOCOMPRESS_BY_EXT,                   // a
 	OPT_NOPRESERVE_TIME  = IF_FEATURE_TAR_NOPRESERVE_TIME((1 << OPTBIT_NOPRESERVE_TIME)) + 0, // m
 	OPT_STRIP_COMPONENTS = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_STRIP_COMPONENTS)) + 0, // strip-components
+	OPT_LZMA             = IF_FEATURE_TAR_LONG_OPTIONS(IF_FEATURE_SEAMLESS_LZMA((1 << OPTBIT_LZMA))) + 0, // lzma
 	OPT_NORECURSION      = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NORECURSION    )) + 0, // no-recursion
 	OPT_2COMMAND         = IF_FEATURE_TAR_TO_COMMAND(  (1 << OPTBIT_2COMMAND       )) + 0, // to-command
 	OPT_NUMERIC_OWNER    = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NUMERIC_OWNER  )) + 0, // numeric-owner
@@ -896,9 +904,6 @@
 # if ENABLE_FEATURE_SEAMLESS_BZ2
 	"bzip2\0"               No_argument       "j"
 # endif
-# if ENABLE_FEATURE_SEAMLESS_LZMA
-	"lzma\0"                No_argument       "a"
-# endif
 # if ENABLE_FEATURE_TAR_FROM
 	"files-from\0"          Required_argument "T"
 	"exclude-from\0"        Required_argument "X"
@@ -912,10 +917,14 @@
 # if ENABLE_FEATURE_SEAMLESS_Z
 	"compress\0"            No_argument       "Z"
 # endif
+	"auto-compress\0"       No_argument       "a"
 # if ENABLE_FEATURE_TAR_NOPRESERVE_TIME
 	"touch\0"               No_argument       "m"
 # endif
-	"strip-components\0"	Required_argument "\xf9"
+	"strip-components\0"	Required_argument "\xf8"
+# if ENABLE_FEATURE_SEAMLESS_LZMA
+	"lzma\0"                No_argument       "\xf9"
+# endif
 	"no-recursion\0"	No_argument       "\xfa"
 # if ENABLE_FEATURE_TAR_TO_COMMAND
 	"to-command\0"		Required_argument "\xfb"
@@ -1004,13 +1013,13 @@
 		"txC:f:Oopvk"
 		IF_FEATURE_TAR_CREATE(   "ch"    )
 		IF_FEATURE_SEAMLESS_BZ2( "j"     )
-		IF_FEATURE_SEAMLESS_LZMA("a"     )
 		IF_FEATURE_TAR_FROM(     "T:*X:*")
 		IF_FEATURE_SEAMLESS_GZ(  "z"     )
 		IF_FEATURE_SEAMLESS_XZ(  "J"     )
 		IF_FEATURE_SEAMLESS_Z(   "Z"     )
+		"a"
 		IF_FEATURE_TAR_NOPRESERVE_TIME("m")
-		IF_FEATURE_TAR_LONG_OPTIONS("\xf9:") // --strip-components
+		IF_FEATURE_TAR_LONG_OPTIONS("\xf8:") // --strip-components
 		"\0"
 		"tt:vv:" // count -t,-v
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS && ENABLE_FEATURE_TAR_FROM
@@ -1039,7 +1048,7 @@
 		);
 #if DBG_OPTION_PARSING
 	bb_error_msg("opt: 0x%08x", opt);
-# define showopt(o) bb_error_msg("opt & %s(%x): %x", #o, o, opt & o);
+# define showopt(o) bb_error_msg("opt & %s(%x):\t%x", #o, o, opt & o);
 	showopt(OPT_TEST            );
 	showopt(OPT_EXTRACT         );
 	showopt(OPT_BASEDIR         );
@@ -1052,14 +1061,15 @@
 	showopt(OPT_CREATE          );
 	showopt(OPT_DEREFERENCE     );
 	showopt(OPT_BZIP2           );
-	showopt(OPT_LZMA            );
 	showopt(OPT_INCLUDE_FROM    );
 	showopt(OPT_EXCLUDE_FROM    );
 	showopt(OPT_GZIP            );
 	showopt(OPT_XZ              );
 	showopt(OPT_COMPRESS        );
+	showopt(OPT_AUTOCOMPRESS_BY_EXT);
 	showopt(OPT_NOPRESERVE_TIME );
 	showopt(OPT_STRIP_COMPONENTS);
+	showopt(OPT_LZMA            );
 	showopt(OPT_NORECURSION     );
 	showopt(OPT_2COMMAND        );
 	showopt(OPT_NUMERIC_OWNER   );
@@ -1150,7 +1160,7 @@
 		if (opt & OPT_CREATE) {
 			/* Make sure there is at least one file to tar up */
 			if (tar_handle->accept == NULL)
-				bb_error_msg_and_die("empty archive");
+				bb_simple_error_msg_and_die("empty archive");
 
 			tar_fd = STDOUT_FILENO;
 			/* Mimicking GNU tar 1.15.1: */
@@ -1178,6 +1188,21 @@
 				bb_perror_msg_and_die("can't open '%s'", tar_filename);
 		} else {
 			tar_handle->src_fd = xopen(tar_filename, flags);
+#if ENABLE_FEATURE_TAR_CREATE
+			if ((OPT_GZIP | OPT_BZIP2 | OPT_XZ | OPT_LZMA) != 0 /* at least one is config-enabled */
+			 && (opt & OPT_AUTOCOMPRESS_BY_EXT)
+			 && flags != O_RDONLY
+			) {
+				if (OPT_GZIP != 0 && is_suffixed_with(tar_filename, "gz"))
+					opt |= OPT_GZIP;
+				if (OPT_BZIP2 != 0 && is_suffixed_with(tar_filename, "bz2"))
+					opt |= OPT_BZIP2;
+				if (OPT_XZ != 0 && is_suffixed_with(tar_filename, "xz"))
+					opt |= OPT_XZ;
+				if (OPT_LZMA != 0 && is_suffixed_with(tar_filename, "lzma"))
+					opt |= OPT_LZMA;
+			}
+#endif
 		}
 	}
 
diff -Naur busybox-1.31.1/archival/unzip.c busybox-be5a505d/archival/unzip.c
--- busybox-1.31.1/archival/unzip.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/archival/unzip.c	2019-10-24 07:26:55.000000000 -0700
@@ -322,7 +322,7 @@
 static void die_if_bad_fnamesize(unsigned sz)
 {
 	if (sz > 0xfff) /* more than 4k?! no funny business please */
-		bb_error_msg_and_die("bad archive");
+		bb_simple_error_msg_and_die("bad archive");
 }
 
 static void unzip_skip(off_t skip)
@@ -359,7 +359,7 @@
 		xread(zip_fd, target, zip->fmt.ucmpsize);
 	} else {
 #if 1
-		bb_error_msg_and_die("compressed symlink is not supported");
+		bb_simple_error_msg_and_die("compressed symlink is not supported");
 #else
 		transformer_state_t xstate;
 		init_transformer_state(&xstate);
@@ -399,10 +399,10 @@
 	if (zip->fmt.method == 8) {
 		/* Method 8 - inflate */
 		if (inflate_unzip(&xstate) < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 		/* Validate decompression - crc */
 		if (zip->fmt.crc32 != (xstate.crc32 ^ 0xffffffffL)) {
-			bb_error_msg_and_die("crc error");
+			bb_simple_error_msg_and_die("crc error");
 		}
 	}
 #if ENABLE_FEATURE_UNZIP_BZIP2
@@ -412,7 +412,7 @@
 		 */
 		xstate.bytes_out = unpack_bz2_stream(&xstate);
 		if (xstate.bytes_out < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 	}
 #endif
 #if ENABLE_FEATURE_UNZIP_LZMA
@@ -420,7 +420,7 @@
 		/* Not tested yet */
 		xstate.bytes_out = unpack_lzma_stream(&xstate);
 		if (xstate.bytes_out < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 	}
 #endif
 #if ENABLE_FEATURE_UNZIP_XZ
@@ -428,7 +428,7 @@
 		/* Not tested yet */
 		xstate.bytes_out = unpack_xz_stream(&xstate);
 		if (xstate.bytes_out < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 	}
 #endif
 	else {
@@ -439,7 +439,7 @@
 	if (zip->fmt.ucmpsize != xstate.bytes_out) {
 		/* Don't die. Who knows, maybe len calculation
 		 * was botched somewhere. After all, crc matched! */
-		bb_error_msg("bad length");
+		bb_simple_error_msg("bad length");
 	}
 }
 
@@ -447,7 +447,7 @@
 {
 	fflush_all();
 	if (!fgets(buf80, 80, stdin)) {
-		bb_perror_msg_and_die("can't read standard input");
+		bb_simple_perror_msg_and_die("can't read standard input");
 	}
 }
 
diff -Naur busybox-1.31.1/Config.in busybox-be5a505d/Config.in
--- busybox-1.31.1/Config.in	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/Config.in	2019-10-24 07:26:55.000000000 -0700
@@ -156,12 +156,13 @@
 config PID_FILE_PATH
 	string "Directory for pidfiles"
 	default "/var/run"
-	depends on FEATURE_PIDFILE
+	depends on FEATURE_PIDFILE || FEATURE_CROND_SPECIAL_TIMES
 	help
 	This is the default path where pidfiles are created.  Applets which
 	allow you to set the pidfile path on the command line will override
 	this value.  The option has no effect on applets that require you to
-	specify a pidfile path.
+	specify a pidfile path.  When crond has the 'Support special times'
+	option enabled, the 'crond.reboot' file is also stored here.
 
 config BUSYBOX
 	bool "Include busybox applet"
@@ -661,6 +662,19 @@
 
 	Most people should answer N.
 
+config WARN_SIMPLE_MSG
+	bool "Warn about single parameter bb_xx_msg calls"
+	default n
+	help
+	This will cause warnings to be shown for any instances of
+	bb_error_msg(), bb_error_msg_and_die(), bb_perror_msg(),
+	bb_perror_msg_and_die(), bb_herror_msg() or bb_herror_msg_and_die()
+	being called with a single parameter. In these cases the equivalent
+	bb_simple_xx_msg function should be used instead.
+	Note that use of STRERROR_FMT may give false positives.
+
+	If you aren't developing busybox, say N here.
+
 choice
 	prompt "Additional debugging library"
 	default NO_DEBUG_LIB
diff -Naur busybox-1.31.1/console-tools/loadfont.c busybox-be5a505d/console-tools/loadfont.c
--- busybox-1.31.1/console-tools/loadfont.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/console-tools/loadfont.c	2019-10-24 07:26:55.000000000 -0700
@@ -225,7 +225,7 @@
 				if (unicode == PSF2_SEPARATOR) {
 					break;
 				} else if (unicode == PSF2_STARTSEQ) {
-					bb_error_msg_and_die("unicode sequences not implemented");
+					bb_simple_error_msg_and_die("unicode sequences not implemented");
 				} else if (unicode >= 0xC0) {
 					if (unicode >= 0xFC)
 						unicode &= 0x01, maxct = 5;
@@ -239,12 +239,12 @@
 						unicode &= 0x1F, maxct = 1;
 					do {
 						if (tailsz <= 0 || *inbuf < 0x80 || *inbuf > 0xBF)
-							bb_error_msg_and_die("illegal UTF-8 character");
+							bb_simple_error_msg_and_die("illegal UTF-8 character");
 						--tailsz;
 						unicode = (unicode << 6) + (*inbuf++ & 0x3F);
 					} while (--maxct > 0);
 				} else if (unicode >= 0x80) {
-					bb_error_msg_and_die("illegal UTF-8 character");
+					bb_simple_error_msg_and_die("illegal UTF-8 character");
 				}
 #else
 				return;
@@ -281,7 +281,7 @@
 
 	if (len >= sizeof(struct psf1_header) && PSF1_MAGIC_OK(psf1h(buffer))) {
 		if (psf1h(buffer)->mode > PSF1_MAXMODE)
-			bb_error_msg_and_die("unsupported psf file mode");
+			bb_simple_error_msg_and_die("unsupported psf file mode");
 		if (psf1h(buffer)->mode & PSF1_MODE512)
 			fontsize = 512;
 		if (psf1h(buffer)->mode & PSF1_MODEHASTAB)
@@ -292,7 +292,7 @@
 #if ENABLE_FEATURE_LOADFONT_PSF2
 	if (len >= sizeof(struct psf2_header) && PSF2_MAGIC_OK(psf2h(buffer))) {
 		if (psf2h(buffer)->version > PSF2_MAXVERSION)
-			bb_error_msg_and_die("unsupported psf file version");
+			bb_simple_error_msg_and_die("unsupported psf file version");
 		fontsize = psf2h(buffer)->length;
 		if (psf2h(buffer)->flags & PSF2_HAS_UNICODE_TABLE)
 			has_table = 2;
@@ -311,19 +311,19 @@
 	} else
 #endif
 	{
-		bb_error_msg_and_die("input file: bad length or unsupported font type");
+		bb_simple_error_msg_and_die("input file: bad length or unsupported font type");
 	}
 
 #if !defined(PIO_FONTX) || defined(__sparc__)
 	if (fontsize != 256)
-		bb_error_msg_and_die("only fontsize 256 supported");
+		bb_simple_error_msg_and_die("only fontsize 256 supported");
 #endif
 
 	table = font + fontsize * charsize;
 	buffer += len;
 
 	if (table > buffer || (!has_table && table != buffer))
-		bb_error_msg_and_die("input file: bad length");
+		bb_simple_error_msg_and_die("input file: bad length");
 
 	do_loadfont(fd, font, height, width, charsize, fontsize);
 
@@ -361,7 +361,7 @@
 	buffer = xmalloc_read(STDIN_FILENO, &len);
 	// xmalloc_open_zipped_read_close(filename, &len);
 	if (!buffer)
-		bb_perror_msg_and_die("error reading input font");
+		bb_simple_perror_msg_and_die("error reading input font");
 	do_load(get_console_fd_or_die(), buffer, len);
 
 	return EXIT_SUCCESS;
@@ -502,7 +502,7 @@
 				if (a < 0 || a >= E_TABSZ
 				 || b < 0 || b > 65535
 				) {
-					bb_error_msg_and_die("map format");
+					bb_simple_error_msg_and_die("map format");
 				}
 				// patch map
 				unicodes[a] = b;
diff -Naur busybox-1.31.1/console-tools/loadkmap.c busybox-be5a505d/console-tools/loadkmap.c
--- busybox-1.31.1/console-tools/loadkmap.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/console-tools/loadkmap.c	2019-10-24 07:26:55.000000000 -0700
@@ -69,7 +69,7 @@
 
 	xread(STDIN_FILENO, flags, 7);
 	if (!is_prefixed_with(flags, BINARY_KEYMAP_MAGIC))
-		bb_error_msg_and_die("not a valid binary keymap");
+		bb_simple_error_msg_and_die("not a valid binary keymap");
 
 	xread(STDIN_FILENO, flags, MAX_NR_KEYMAPS);
 
diff -Naur busybox-1.31.1/console-tools/openvt.c busybox-be5a505d/console-tools/openvt.c
--- busybox-1.31.1/console-tools/openvt.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/console-tools/openvt.c	2019-10-24 07:26:55.000000000 -0700
@@ -87,7 +87,7 @@
 	fd = open(DEV_CONSOLE, O_RDONLY | O_NONBLOCK);
 	if (fd >= 0 && !not_vt_fd(fd))
 		return fd;
-	bb_error_msg_and_die("can't find open VT");
+	bb_simple_error_msg_and_die("can't find open VT");
 }
 
 static int find_free_vtno(void)
@@ -98,7 +98,7 @@
 	errno = 0;
 	/*xfunc_error_retval = 3; - do we need compat? */
 	if (ioctl(fd, VT_OPENQRY, &vtno) != 0 || vtno <= 0)
-		bb_perror_msg_and_die("can't find open VT");
+		bb_simple_perror_msg_and_die("can't find open VT");
 // Not really needed, grep for DAEMON_CLOSE_EXTRA_FDS
 //	if (fd > 2)
 //		close(fd);
diff -Naur busybox-1.31.1/console-tools/showkey.c busybox-be5a505d/console-tools/showkey.c
--- busybox-1.31.1/console-tools/showkey.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/console-tools/showkey.c	2019-10-24 07:26:55.000000000 -0700
@@ -56,7 +56,7 @@
 {
 	int ret = tcsetattr(STDIN_FILENO, TCSAFLUSH, t);
 	if (ret) {
-		bb_perror_msg("can't tcsetattr for stdin");
+		bb_simple_perror_msg("can't tcsetattr for stdin");
 	}
 }
 
diff -Naur busybox-1.31.1/coreutils/cp.c busybox-be5a505d/coreutils/cp.c
--- busybox-1.31.1/coreutils/cp.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/cp.c	2019-10-24 07:26:55.000000000 -0700
@@ -217,7 +217,7 @@
 		//	flags, FILEUTILS_RMDEST, OPT_parents);
 		if (flags & OPT_parents) {
 			if (!(d_flags & 2)) {
-				bb_error_msg_and_die("with --parents, the destination must be a directory");
+				bb_simple_error_msg_and_die("with --parents, the destination must be a directory");
 			}
 		}
 		if (flags & FILEUTILS_RMDEST) {
@@ -236,7 +236,7 @@
 			goto DO_COPY; /* NB: argc==2 -> *++argv==last */
 		}
 	} else if (flags & FILEUTILS_NO_TARGET_DIR) {
-		bb_error_msg_and_die("too many arguments");
+		bb_simple_error_msg_and_die("too many arguments");
 	}
 
 	while (1) {
diff -Naur busybox-1.31.1/coreutils/cut.c busybox-be5a505d/coreutils/cut.c
--- busybox-1.31.1/coreutils/cut.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/cut.c	2019-10-24 07:26:55.000000000 -0700
@@ -209,11 +209,11 @@
 //	argc -= optind;
 	argv += optind;
 	if (!(opt & (CUT_OPT_BYTE_FLGS | CUT_OPT_CHAR_FLGS | CUT_OPT_FIELDS_FLGS)))
-		bb_error_msg_and_die("expected a list of bytes, characters, or fields");
+		bb_simple_error_msg_and_die("expected a list of bytes, characters, or fields");
 
 	if (opt & CUT_OPT_DELIM_FLGS) {
 		if (ltok[0] && ltok[1]) { /* more than 1 char? */
-			bb_error_msg_and_die("the delimiter must be a single character");
+			bb_simple_error_msg_and_die("the delimiter must be a single character");
 		}
 		delim = ltok[0];
 	}
@@ -288,7 +288,7 @@
 
 		/* make sure we got some cut positions out of all that */
 		if (nlists == 0)
-			bb_error_msg_and_die("missing list of positions");
+			bb_simple_error_msg_and_die("missing list of positions");
 
 		/* now that the lists are parsed, we need to sort them to make life
 		 * easier on us when it comes time to print the chars / fields / lines
diff -Naur busybox-1.31.1/coreutils/date.c busybox-be5a505d/coreutils/date.c
--- busybox-1.31.1/coreutils/date.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/date.c	2019-10-24 07:26:55.000000000 -0700
@@ -33,10 +33,9 @@
 //config:	Enable option (-I) to output an ISO-8601 compliant
 //config:	date/time string.
 //config:
-//config:# defaults to "no": stat's nanosecond field is a bit non-portable
 //config:config FEATURE_DATE_NANO
 //config:	bool "Support %[num]N nanosecond format specifier"
-//config:	default n  # syscall(__NR_clock_gettime)
+//config:	default n # stat's nanosecond field is a bit non-portable
 //config:	depends on DATE
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -272,9 +271,7 @@
 #endif
 	} else {
 #if ENABLE_FEATURE_DATE_NANO
-		/* libc has incredibly messy way of doing this,
-		 * typically requiring -lrt. We just skip all this mess */
-		syscall(__NR_clock_gettime, CLOCK_REALTIME, &ts);
+		clock_gettime(CLOCK_REALTIME, &ts);
 #else
 		time(&ts.tv_sec);
 #endif
@@ -304,7 +301,7 @@
 
 		/* if setting time, set it */
 		if ((opt & OPT_SET) && stime(&ts.tv_sec) < 0) {
-			bb_perror_msg("can't set date");
+			bb_simple_perror_msg("can't set date");
 		}
 	}
 
diff -Naur busybox-1.31.1/coreutils/df.c busybox-be5a505d/coreutils/df.c
--- busybox-1.31.1/coreutils/df.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/df.c	2019-10-24 07:26:55.000000000 -0700
@@ -178,7 +178,7 @@
 	if (!argv[0]) {
 		mount_table = setmntent(bb_path_mtab_file, "r");
 		if (!mount_table)
-			bb_perror_msg_and_die(bb_path_mtab_file);
+			bb_simple_perror_msg_and_die(bb_path_mtab_file);
 	}
 
 	while (1) {
diff -Naur busybox-1.31.1/coreutils/echo.c busybox-be5a505d/coreutils/echo.c
--- busybox-1.31.1/coreutils/echo.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/echo.c	2019-10-24 07:26:55.000000000 -0700
@@ -188,7 +188,7 @@
 	/*r =*/ full_write(STDOUT_FILENO, buffer, out - buffer);
 	free(buffer);
 	if (/*WRONG:r < 0*/ errno) {
-		bb_perror_msg(bb_msg_write_error);
+		bb_simple_perror_msg(bb_msg_write_error);
 		return 1;
 	}
 	return 0;
diff -Naur busybox-1.31.1/coreutils/env.c busybox-be5a505d/coreutils/env.c
--- busybox-1.31.1/coreutils/env.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/env.c	2019-10-24 07:26:55.000000000 -0700
@@ -79,7 +79,7 @@
 
 	while (*argv && (strchr(*argv, '=') != NULL)) {
 		if (putenv(*argv) < 0) {
-			bb_perror_msg_and_die("putenv");
+			bb_simple_perror_msg_and_die("putenv");
 		}
 		++argv;
 	}
diff -Naur busybox-1.31.1/coreutils/expand.c busybox-be5a505d/coreutils/expand.c
--- busybox-1.31.1/coreutils/expand.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/expand.c	2019-10-24 07:26:55.000000000 -0700
@@ -247,7 +247,7 @@
 	/* Now close stdin also */
 	/* (if we didn't read from it, it's a no-op) */
 	if (fclose(stdin))
-		bb_perror_msg_and_die(bb_msg_standard_input);
+		bb_simple_perror_msg_and_die(bb_msg_standard_input);
 
 	fflush_stdout_and_exit(exit_status);
 }
diff -Naur busybox-1.31.1/coreutils/expr.c busybox-be5a505d/coreutils/expr.c
--- busybox-1.31.1/coreutils/expr.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/expr.c	2019-10-24 07:26:55.000000000 -0700
@@ -249,7 +249,7 @@
 	arith_t li, ri;
 
 	if (!toarith(l) || !toarith(r))
-		bb_error_msg_and_die("non-numeric argument");
+		bb_simple_error_msg_and_die("non-numeric argument");
 	li = l->u.i;
 	ri = r->u.i;
 	if (op == '+')
@@ -259,7 +259,7 @@
 	if (op == '*')
 		return li * ri;
 	if (ri == 0)
-		bb_error_msg_and_die("division by zero");
+		bb_simple_error_msg_and_die("division by zero");
 	if (op == '/')
 		return li / ri;
 	return li % ri;
@@ -319,19 +319,19 @@
 	VALUE *v;
 
 	if (!*G.args)
-		bb_error_msg_and_die("syntax error");
+		bb_simple_error_msg_and_die("syntax error");
 
 	if (nextarg("(")) {
 		G.args++;
 		v = eval();
 		if (!nextarg(")"))
-			bb_error_msg_and_die("syntax error");
+			bb_simple_error_msg_and_die("syntax error");
 		G.args++;
 		return v;
 	}
 
 	if (nextarg(")"))
-		bb_error_msg_and_die("syntax error");
+		bb_simple_error_msg_and_die("syntax error");
 
 	return str_value(*G.args++);
 }
@@ -353,7 +353,7 @@
 	G.args++; /* We have a valid token, so get the next argument.  */
 	if (key == 1) { /* quote */
 		if (!*G.args)
-			bb_error_msg_and_die("syntax error");
+			bb_simple_error_msg_and_die("syntax error");
 		return str_value(*G.args++);
 	}
 	if (key == 2) { /* length */
@@ -546,11 +546,11 @@
 	xfunc_error_retval = 2; /* coreutils compat */
 	G.args = argv + 1;
 	if (*G.args == NULL) {
-		bb_error_msg_and_die("too few arguments");
+		bb_simple_error_msg_and_die("too few arguments");
 	}
 	v = eval();
 	if (*G.args)
-		bb_error_msg_and_die("syntax error");
+		bb_simple_error_msg_and_die("syntax error");
 	if (v->type == INTEGER)
 		printf("%" PF_REZ "d\n", PF_REZ_TYPE v->u.i);
 	else
diff -Naur busybox-1.31.1/coreutils/id.c busybox-be5a505d/coreutils/id.c
--- busybox-1.31.1/coreutils/id.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/id.c	2019-10-24 07:26:55.000000000 -0700
@@ -231,7 +231,7 @@
 			}
 		} else if (n < 0) { /* error in get_groups() */
 			if (ENABLE_DESKTOP)
-				bb_error_msg_and_die("can't get groups");
+				bb_simple_error_msg_and_die("can't get groups");
 			return EXIT_FAILURE;
 		}
 		if (ENABLE_FEATURE_CLEAN_UP)
diff -Naur busybox-1.31.1/coreutils/install.c busybox-be5a505d/coreutils/install.c
--- busybox-1.31.1/coreutils/install.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/install.c	2019-10-24 07:26:55.000000000 -0700
@@ -238,7 +238,7 @@
 				args[2] = dest;
 				args[3] = NULL;
 				if (spawn_and_wait(args)) {
-					bb_perror_msg("strip");
+					bb_simple_perror_msg("strip");
 					ret = EXIT_FAILURE;
 				}
 			}
diff -Naur busybox-1.31.1/coreutils/ln.c busybox-be5a505d/coreutils/ln.c
--- busybox-1.31.1/coreutils/ln.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/ln.c	2019-10-24 07:26:55.000000000 -0700
@@ -41,7 +41,6 @@
 
 /* This is a NOEXEC applet. Be very careful! */
 
-
 #define LN_SYMLINK          (1 << 0)
 #define LN_FORCE            (1 << 1)
 #define LN_NODEREFERENCE    (1 << 2)
@@ -63,13 +62,28 @@
 	int (*link_func)(const char *, const char *);
 
 	opts = getopt32(argv, "^" "sfnbS:vT" "\0" "-1", &suffix);
-
+/*
+	-s, --symbolic		make symbolic links instead of hard links
+	-f, --force		remove existing destination files
+	-n, --no-dereference	treat LINK_NAME as a normal file if it is a symbolic link to a directory
+	-b			like --backup but does not accept an argument
+	--backup[=CONTROL]	make a backup of each existing destination file
+	-S, --suffix=SUFFIX	override the usual backup suffix
+	-v, --verbose
+	-T, --no-target-directory
+	-d, -F, --directory	allow the superuser to attempt to hard link directories
+	-i, --interactive	prompt whether to remove destinations
+	-L, --logical		dereference TARGETs that are symbolic links
+	-P, --physical		make hard links directly to symbolic links
+	-r, --relative		create symbolic links relative to link location
+	-t, --target-directory=DIRECTORY	specify the DIRECTORY in which to create the links
+ */
 	last = argv[argc - 1];
 	argv += optind;
 	argc -= optind;
 
 	if ((opts & LN_LINKFILE) && argc > 2) {
-		bb_error_msg_and_die("-T accepts 2 args max");
+		bb_simple_error_msg_and_die("-T accepts 2 args max");
 	}
 
 	if (!argv[1]) {
@@ -86,8 +100,11 @@
 		src = last;
 
 		if (is_directory(src,
-		                (opts & LN_NODEREFERENCE) ^ LN_NODEREFERENCE
-		                )
+				/*followlinks:*/ !(opts & (LN_NODEREFERENCE|LN_LINKFILE))
+				/* Why LN_LINKFILE does not follow links:
+				 * -T/--no-target-directory implies -n/--no-dereference
+				 */
+				)
 		) {
 			if (opts & LN_LINKFILE) {
 				bb_error_msg_and_die("'%s' is a directory", src);
diff -Naur busybox-1.31.1/coreutils/logname.c busybox-be5a505d/coreutils/logname.c
--- busybox-1.31.1/coreutils/logname.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/logname.c	2019-10-24 07:26:55.000000000 -0700
@@ -56,5 +56,5 @@
 		return fflush_all();
 	}
 
-	bb_perror_msg_and_die("getlogin");
+	bb_simple_perror_msg_and_die("getlogin");
 }
diff -Naur busybox-1.31.1/coreutils/md5_sha1_sum.c busybox-be5a505d/coreutils/md5_sha1_sum.c
--- busybox-1.31.1/coreutils/md5_sha1_sum.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/md5_sha1_sum.c	2019-10-24 07:26:55.000000000 -0700
@@ -300,7 +300,7 @@
 				}
 				if (filename_ptr == NULL) {
 					if (flags & FLAG_WARN) {
-						bb_error_msg("invalid format");
+						bb_simple_error_msg("invalid format");
 					}
 					count_failed++;
 					return_value = EXIT_FAILURE;
diff -Naur busybox-1.31.1/coreutils/od_bloaty.c busybox-be5a505d/coreutils/od_bloaty.c
--- busybox-1.31.1/coreutils/od_bloaty.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/od_bloaty.c	2019-10-24 07:26:55.000000000 -0700
@@ -536,7 +536,7 @@
 	}
 
 	if (ferror(stdout)) {
-		bb_error_msg_and_die(bb_msg_write_error);
+		bb_simple_error_msg_and_die(bb_msg_write_error);
 	}
 }
 
@@ -841,7 +841,7 @@
 	}
 
 	if (n_skip)
-		bb_error_msg_and_die("can't skip past end of combined input");
+		bb_simple_error_msg_and_die("can't skip past end of combined input");
 }
 
 
@@ -1308,10 +1308,10 @@
 					pseudo_start = o2;
 					argv[1] = NULL;
 				} else {
-					bb_error_msg_and_die("the last two arguments must be offsets");
+					bb_simple_error_msg_and_die("the last two arguments must be offsets");
 				}
 			} else { /* >3 args */
-				bb_error_msg_and_die("too many arguments");
+				bb_simple_error_msg_and_die("too many arguments");
 			}
 
 			if (pseudo_start >= 0) {
@@ -1332,7 +1332,7 @@
 	if (option_mask32 & OPT_N) {
 		end_offset = n_bytes_to_skip + max_bytes_to_format;
 		if (end_offset < n_bytes_to_skip)
-			bb_error_msg_and_die("SKIP + SIZE is too large");
+			bb_simple_error_msg_and_die("SKIP + SIZE is too large");
 	}
 
 	if (G.n_specs == 0) {
@@ -1389,7 +1389,7 @@
 		dump(n_bytes_to_skip, end_offset);
 
 	if (fclose(stdin))
-		bb_perror_msg_and_die(bb_msg_standard_input);
+		bb_simple_perror_msg_and_die(bb_msg_standard_input);
 
 	return G.exit_code;
 }
diff -Naur busybox-1.31.1/coreutils/paste.c busybox-be5a505d/coreutils/paste.c
--- busybox-1.31.1/coreutils/paste.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/paste.c	2019-10-24 07:26:55.000000000 -0700
@@ -116,7 +116,7 @@
 
 	if (opt & PASTE_OPT_DELIMITERS) {
 		if (!delims[0])
-			bb_error_msg_and_die("-d '' is not supported");
+			bb_simple_error_msg_and_die("-d '' is not supported");
 		/* unknown mappings are not changed: "\z" -> '\\' 'z' */
 		/* trailing backslash, if any, is preserved */
 		del_cnt = strcpy_and_process_escape_sequences(delims, delims) - delims;
diff -Naur busybox-1.31.1/coreutils/printf.c busybox-be5a505d/coreutils/printf.c
--- busybox-1.31.1/coreutils/printf.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/printf.c	2019-10-24 07:26:55.000000000 -0700
@@ -430,7 +430,7 @@
 		if (ENABLE_ASH_PRINTF
 		 && applet_name[0] != 'p'
 		) {
-			bb_error_msg("usage: printf FORMAT [ARGUMENT...]");
+			bb_simple_error_msg("usage: printf FORMAT [ARGUMENT...]");
 			return 2; /* bash compat */
 		}
 		bb_show_usage();
diff -Naur busybox-1.31.1/coreutils/rm.c busybox-be5a505d/coreutils/rm.c
--- busybox-1.31.1/coreutils/rm.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/rm.c	2019-10-24 07:26:55.000000000 -0700
@@ -62,7 +62,7 @@
 			const char *base = bb_get_last_path_component_strip(*argv);
 
 			if (DOT_OR_DOTDOT(base)) {
-				bb_error_msg("can't remove '.' or '..'");
+				bb_simple_error_msg("can't remove '.' or '..'");
 			} else if (remove_file(*argv, flags) >= 0) {
 				continue;
 			}
diff -Naur busybox-1.31.1/coreutils/sort.c busybox-be5a505d/coreutils/sort.c
--- busybox-1.31.1/coreutils/sort.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/sort.c	2019-10-24 07:26:55.000000000 -0700
@@ -277,7 +277,7 @@
 		/* Perform actual comparison */
 		switch (flags & (FLAG_n | FLAG_g | FLAG_M | FLAG_V)) {
 		default:
-			bb_error_msg_and_die("unknown sort type");
+			bb_simple_error_msg_and_die("unknown sort type");
 			break;
 #if defined(HAVE_STRVERSCMP) && HAVE_STRVERSCMP == 1
 		case FLAG_V:
@@ -398,10 +398,10 @@
 {
 	unsigned long lu;
 	if (!isdigit((*str)[0]))
-		bb_error_msg_and_die("bad field specification");
+		bb_simple_error_msg_and_die("bad field specification");
 	lu = strtoul(*str, str, 10);
 	if ((sizeof(long) > sizeof(int) && lu > INT_MAX) || !lu)
-		bb_error_msg_and_die("bad field specification");
+		bb_simple_error_msg_and_die("bad field specification");
 	return lu;
 }
 #endif
@@ -461,7 +461,7 @@
 #if ENABLE_FEATURE_SORT_BIG
 	if (opts & FLAG_t) {
 		if (!str_t[0] || str_t[1])
-			bb_error_msg_and_die("bad -t parameter");
+			bb_simple_error_msg_and_die("bad -t parameter");
 		key_separator = str_t[0];
 	}
 	/* note: below this point we use option_mask32, not opts,
@@ -504,10 +504,10 @@
 					because comma isn't in OPT_STR */
 				idx = strchr(OPT_STR, *str_k);
 				if (!idx)
-					bb_error_msg_and_die("unknown key option");
+					bb_simple_error_msg_and_die("unknown key option");
 				flag = 1 << (idx - OPT_STR);
 				if (flag & ~FLAG_allowed_for_k)
-					bb_error_msg_and_die("unknown sort type");
+					bb_simple_error_msg_and_die("unknown sort type");
 				/* b after ',' means strip _trailing_ space */
 				if (i && flag == FLAG_b)
 					flag = FLAG_bb;
diff -Naur busybox-1.31.1/coreutils/split.c busybox-be5a505d/coreutils/split.c
--- busybox-1.31.1/coreutils/split.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/split.c	2019-10-24 07:26:55.000000000 -0700
@@ -127,7 +127,7 @@
 	}
 
 	if (NAME_MAX < strlen(sfx) + suffix_len)
-		bb_error_msg_and_die("suffix too long");
+		bb_simple_error_msg_and_die("suffix too long");
 
 	{
 		char *char_p = xzalloc(suffix_len + 1);
@@ -147,7 +147,7 @@
 		do {
 			if (!remaining) {
 				if (!pfx)
-					bb_error_msg_and_die("suffixes exhausted");
+					bb_simple_error_msg_and_die("suffixes exhausted");
 				xmove_fd(xopen(pfx, O_WRONLY | O_CREAT | O_TRUNC), 1);
 				pfx = next_file(pfx, suffix_len);
 				remaining = cnt;
diff -Naur busybox-1.31.1/coreutils/stat.c busybox-be5a505d/coreutils/stat.c
--- busybox-1.31.1/coreutils/stat.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/stat.c	2019-10-24 07:26:55.000000000 -0700
@@ -150,20 +150,16 @@
 	return "weird file";
 }
 
-static const char *human_time(time_t t)
+static const char *human_time(struct timespec *ts)
 {
-	/* Old
-	static char *str;
-	str = ctime(&t);
-	str[strlen(str)-1] = '\0';
-	return str;
-	*/
-	/* coreutils 6.3 compat: */
+	char fmt[sizeof("%Y-%m-%d %H:%M:%S.123456789 %z") + /*paranoia*/ 8];
 
-	/*static char buf[sizeof("YYYY-MM-DD HH:MM:SS.000000000")] ALIGN1;*/
+	/* coreutils 6.3 compat */
 #define buf bb_common_bufsiz1
 	setup_common_bufsiz();
-	strcpy(strftime_YYYYMMDDHHMMSS(buf, COMMON_BUFSIZE, &t), ".000000000");
+
+	sprintf(stpcpy(fmt, "%Y-%m-%d %H:%M:%S"), ".%09u %%z", (unsigned)ts->tv_nsec);
+	strftime(buf, COMMON_BUFSIZE, fmt, localtime(&ts->tv_sec));
 	return buf;
 #undef buf
 }
@@ -384,19 +380,19 @@
 		strcat(pformat, "lu");
 		printf(pformat, (unsigned long) statbuf->st_blksize);
 	} else if (m == 'x') {
-		printfs(pformat, human_time(statbuf->st_atime));
+		printfs(pformat, human_time(&statbuf->st_atim));
 	} else if (m == 'X') {
 		strcat(pformat, TYPE_SIGNED(time_t) ? "ld" : "lu");
 		/* note: (unsigned long) would be wrong:
 		 * imagine (unsigned long64)int32 */
 		printf(pformat, (long) statbuf->st_atime);
 	} else if (m == 'y') {
-		printfs(pformat, human_time(statbuf->st_mtime));
+		printfs(pformat, human_time(&statbuf->st_mtim));
 	} else if (m == 'Y') {
 		strcat(pformat, TYPE_SIGNED(time_t) ? "ld" : "lu");
 		printf(pformat, (long) statbuf->st_mtime);
 	} else if (m == 'z') {
-		printfs(pformat, human_time(statbuf->st_ctime));
+		printfs(pformat, human_time(&statbuf->st_ctim));
 	} else if (m == 'Z') {
 		strcat(pformat, TYPE_SIGNED(time_t) ? "ld" : "lu");
 		printf(pformat, (long) statbuf->st_ctime);
@@ -501,7 +497,7 @@
 	if (format == NULL) {
 # if !ENABLE_SELINUX
 		format = (option_mask32 & OPT_TERSE
-			? "%n %i %l %t %s %b %f %a %c %d\n"
+			? "%n %i %l %t %s %b %f %a %c %d"
 			: "  File: \"%n\"\n"
 			  "    ID: %-8i Namelen: %-7l Type: %T\n"
 			  "Block size: %-10s\n"
@@ -509,25 +505,26 @@
 			  "Inodes: Total: %-10c Free: %d");
 # else
 		format = (option_mask32 & OPT_TERSE
-			? (option_mask32 & OPT_SELINUX ? "%n %i %l %t %s %b %f %a %c %d %C\n":
-			"%n %i %l %t %s %b %f %a %c %d\n")
-			: (option_mask32 & OPT_SELINUX ?
-			"  File: \"%n\"\n"
-			"    ID: %-8i Namelen: %-7l Type: %T\n"
-			"Block size: %-10s\n"
-			"Blocks: Total: %-10b Free: %-10f Available: %a\n"
-			"Inodes: Total: %-10c Free: %d"
-			"  S_context: %C\n":
-			"  File: \"%n\"\n"
-			"    ID: %-8i Namelen: %-7l Type: %T\n"
-			"Block size: %-10s\n"
-			"Blocks: Total: %-10b Free: %-10f Available: %a\n"
-			"Inodes: Total: %-10c Free: %d\n")
+			? (option_mask32 & OPT_SELINUX
+				? "%n %i %l %t %s %b %f %a %c %d %C"
+				: "%n %i %l %t %s %b %f %a %c %d")
+			: (option_mask32 & OPT_SELINUX
+				? "  File: \"%n\"\n"
+				"    ID: %-8i Namelen: %-7l Type: %T\n"
+				"Block size: %-10s\n"
+				"Blocks: Total: %-10b Free: %-10f Available: %a\n"
+				"Inodes: Total: %-10c Free: %d"
+				"  S_context: %C"
+				: "  File: \"%n\"\n"
+				"    ID: %-8i Namelen: %-7l Type: %T\n"
+				"Block size: %-10s\n"
+				"Blocks: Total: %-10b Free: %-10f Available: %a\n"
+				"Inodes: Total: %-10c Free: %d")
 			);
 # endif /* SELINUX */
 	}
 	print_it(format, filename, print_statfs, &statfsbuf IF_SELINUX(, scontext));
-#else /* FEATURE_STAT_FORMAT */
+#else /* !FEATURE_STAT_FORMAT */
 	format = (option_mask32 & OPT_TERSE
 		? "%s %llx %lu "
 		: "  File: \"%s\"\n"
@@ -624,14 +621,14 @@
 					"Device: %Dh/%dd\tInode: %-10i  Links: %-5h"
 					" Device type: %t,%T\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n";
+					"Access: %x\n" "Modify: %y\n" "Change: %z";
 			} else {
 				format =
 					"  File: %N\n"
 					"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
 					"Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n";
+					"Access: %x\n" "Modify: %y\n" "Change: %z";
 			}
 		}
 # else
@@ -650,14 +647,14 @@
 					" Device type: %t,%T\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
 					"   S_Context: %C\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n"
+					"Access: %x\n" "Modify: %y\n" "Change: %z"
 					:
 					"  File: %N\n"
 					"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
 					"Device: %Dh/%dd\tInode: %-10i  Links: %-5h"
 					" Device type: %t,%T\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n"
+					"Access: %x\n" "Modify: %y\n" "Change: %z"
 					);
 			} else {
 				format = (option_mask32 & OPT_SELINUX ?
@@ -666,13 +663,13 @@
 					"Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
 					"S_Context: %C\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n"
+					"Access: %x\n" "Modify: %y\n" "Change: %z"
 					:
 					"  File: %N\n"
 					"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
 					"Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
 					"Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
-					"Access: %x\n" "Modify: %y\n" "Change: %z\n"
+					"Access: %x\n" "Modify: %y\n" "Change: %z"
 					);
 			}
 		}
@@ -749,9 +746,9 @@
 		if (option_mask32 & OPT_SELINUX)
 			printf("   S_Context: %s\n", scontext);
 # endif
-		printf("Access: %s\n", human_time(statbuf.st_atime));
-		printf("Modify: %s\n", human_time(statbuf.st_mtime));
-		printf("Change: %s\n", human_time(statbuf.st_ctime));
+		printf("Access: %s\n", human_time(&statbuf.st_atim));
+		printf("Modify: %s\n", human_time(&statbuf.st_mtim));
+		printf("Change: %s\n", human_time(&statbuf.st_ctim));
 	}
 #endif  /* FEATURE_STAT_FORMAT */
 	return 1;
diff -Naur busybox-1.31.1/coreutils/stty.c busybox-be5a505d/coreutils/stty.c
--- busybox-1.31.1/coreutils/stty.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/stty.c	2019-10-24 07:26:55.000000000 -0700
@@ -1320,7 +1320,7 @@
 					break;
 				case 'F':
 					if (file_name)
-						bb_error_msg_and_die("only one device may be specified");
+						bb_simple_error_msg_and_die("only one device may be specified");
 					file_name = &arg[i+1]; /* "-Fdevice" ? */
 					if (!file_name[0]) { /* nope, "-F device" */
 						int p = k+1; /* argv[p] is argnext */
@@ -1405,13 +1405,13 @@
 	if ((stty_state & (STTY_verbose_output | STTY_recoverable_output)) ==
 		(STTY_verbose_output | STTY_recoverable_output)
 	) {
-		bb_error_msg_and_die("-a and -g are mutually exclusive");
+		bb_simple_error_msg_and_die("-a and -g are mutually exclusive");
 	}
 	/* Specifying -a or -g with non-options is an error */
 	if ((stty_state & (STTY_verbose_output | STTY_recoverable_output))
 	 && !(stty_state & STTY_noargs)
 	) {
-		bb_error_msg_and_die("modes may not be set when -a or -g is used");
+		bb_simple_error_msg_and_die("modes may not be set when -a or -g is used");
 	}
 
 	/* Now it is safe to start doing things */
diff -Naur busybox-1.31.1/coreutils/tail.c busybox-be5a505d/coreutils/tail.c
--- busybox-1.31.1/coreutils/tail.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/tail.c	2019-10-24 07:26:55.000000000 -0700
@@ -89,7 +89,7 @@
 
 	r = full_read(fd, buf, count);
 	if (r < 0) {
-		bb_perror_msg(bb_msg_read_error);
+		bb_simple_perror_msg(bb_msg_read_error);
 		G.exitcode = EXIT_FAILURE;
 	}
 
@@ -186,7 +186,7 @@
 	} while (++i < argc);
 
 	if (!nfiles)
-		bb_error_msg_and_die("no files");
+		bb_simple_error_msg_and_die("no files");
 
 	/* prepare the buffer */
 	tailbufsize = BUFSIZ;
diff -Naur busybox-1.31.1/coreutils/tee.c busybox-be5a505d/coreutils/tee.c
--- busybox-1.31.1/coreutils/tee.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/tee.c	2019-10-24 07:26:55.000000000 -0700
@@ -39,6 +39,19 @@
 //usage:       "$ cat /tmp/foo\n"
 //usage:       "Hello\n"
 
+// Bare "tee" with no below options does not install SIGPIPE handler - just dies on it.
+// TODO:
+//	--output-error[=MODE]
+//		'warn'		diagnose errors writing to any output
+//		'warn-nopipe'	diagnose errors writing to any output not a pipe
+//		'exit'		exit on error writing to any output
+//		'exit-nopipe'	exit on error writing to any output not a pipe
+// ^^^ all of these should set SIGPIPE to SIG_IGN.
+// Because "exit" mode should print error message and exit1(1) - not die on SIGPIPE.
+// "exit-nopipe" does not exit on EPIPE and does not set exitcode to 1 too.
+//	-p	diagnose errors writing to non pipes
+// ^^^^ this should set SIGPIPE to SIG_IGN. EPIPE is ignored (same as "warn-nopipe")
+
 #include "libbb.h"
 #include "common_bufsiz.h"
 
@@ -66,12 +79,12 @@
 	mode += (retval & 2);	/* Since 'a' is the 2nd option... */
 
 	if (retval & 1) {
-		signal(SIGINT, SIG_IGN); /* TODO - switch to sigaction. (why?) */
+		signal(SIGINT, SIG_IGN);
 	}
 	retval = EXIT_SUCCESS;
-	/* gnu tee ignores SIGPIPE in case one of the output files is a pipe
-	 * that doesn't consume all its input.  Good idea... */
-	signal(SIGPIPE, SIG_IGN);
+	/* if (opt_p || opt_output_error)
+		signal(SIGPIPE, SIG_IGN);
+	 */
 
 	/* Allocate an array of FILE *'s, with one extra for a sentinel. */
 	fp = files = xzalloc(sizeof(FILE *) * (argc + 2));
@@ -79,6 +92,7 @@
 
 	files[0] = stdout;
 	goto GOT_NEW_FILE;
+
 	do {
 		*fp = stdout;
 		if (NOT_LONE_DASH(*argv)) {
@@ -102,6 +116,7 @@
 		fp = files;
 		do
 			fwrite(buf, 1, c, *fp);
+			/* if (opt_p && fwrite() != c && !EPIPE) bb_error_msg("..."); */
 		while (*++fp);
 	}
 	if (c < 0) {		/* Make sure read errors are signaled. */
@@ -113,6 +128,7 @@
 		fp = files;
 		do
 			putc(c, *fp);
+			/* if (opt_p && putc() == EOF && !EPIPE) bb_error_msg("..."); */
 		while (*++fp);
 	}
 #endif
diff -Naur busybox-1.31.1/coreutils/test.c busybox-be5a505d/coreutils/test.c
--- busybox-1.31.1/coreutils/test.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/test.c	2019-10-24 07:26:55.000000000 -0700
@@ -832,12 +832,12 @@
 		--argc;
 		if (!arg0[1]) { /* "[" ? */
 			if (NOT_LONE_CHAR(argv[argc], ']')) {
-				bb_error_msg("missing ]");
+				bb_simple_error_msg("missing ]");
 				return 2;
 			}
 		} else { /* assuming "[[" */
 			if (strcmp(argv[argc], "]]") != 0) {
-				bb_error_msg("missing ]]");
+				bb_simple_error_msg("missing ]]");
 				return 2;
 			}
 		}
diff -Naur busybox-1.31.1/coreutils/tr.c busybox-be5a505d/coreutils/tr.c
--- busybox-1.31.1/coreutils/tr.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/tr.c	2019-10-24 07:26:55.000000000 -0700
@@ -308,7 +308,7 @@
 		str1_length = complement(str1, str1_length);
 	if (*argv) {
 		if (argv[0][0] == '\0')
-			bb_error_msg_and_die("STRING2 cannot be empty");
+			bb_simple_error_msg_and_die("STRING2 cannot be empty");
 		str2_length = expand(*argv, &str2);
 		map(vector, str1, str1_length,
 				str2, str2_length);
@@ -333,7 +333,7 @@
 			read_chars = safe_read(STDIN_FILENO, str1, TR_BUFSIZ);
 			if (read_chars <= 0) {
 				if (read_chars < 0)
-					bb_perror_msg_and_die(bb_msg_read_error);
+					bb_simple_perror_msg_and_die(bb_msg_read_error);
 				break;
 			}
 			in_index = 0;
diff -Naur busybox-1.31.1/coreutils/uudecode.c busybox-be5a505d/coreutils/uudecode.c
--- busybox-1.31.1/coreutils/uudecode.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/uudecode.c	2019-10-24 07:26:55.000000000 -0700
@@ -82,7 +82,7 @@
 			continue;
 		}
 		if (encoded_len > 60) {
-			bb_error_msg_and_die("line too long");
+			bb_simple_error_msg_and_die("line too long");
 		}
 
 		dst = line;
@@ -108,7 +108,7 @@
 		fwrite(line, 1, dst - line, dst_stream);
 		free(line);
 	}
-	bb_error_msg_and_die("short file");
+	bb_simple_error_msg_and_die("short file");
 }
 #endif
 
@@ -166,7 +166,7 @@
 		/* fclose_if_not_stdin(src_stream); - redundant */
 		return EXIT_SUCCESS;
 	}
-	bb_error_msg_and_die("no 'begin' line");
+	bb_simple_error_msg_and_die("no 'begin' line");
 }
 #endif
 
@@ -216,7 +216,7 @@
 			if (!size)
 				break;
 			if ((ssize_t)size < 0)
-				bb_perror_msg_and_die(bb_msg_read_error);
+				bb_simple_perror_msg_and_die(bb_msg_read_error);
 			/* Encode the buffer we just read in */
 			bb_uuencode(dst_buf, src_buf, size, bb_uuenc_tbl_base64);
 			xwrite(STDOUT_FILENO, dst_buf, 4 * ((size + 2) / 3));
diff -Naur busybox-1.31.1/coreutils/uuencode.c busybox-be5a505d/coreutils/uuencode.c
--- busybox-1.31.1/coreutils/uuencode.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/coreutils/uuencode.c	2019-10-24 07:26:55.000000000 -0700
@@ -66,7 +66,7 @@
 		if (!size)
 			break;
 		if ((ssize_t)size < 0)
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		/* Encode the buffer we just read in */
 		bb_uuencode(dst_buf, src_buf, size, tbl);
 		bb_putchar('\n');
diff -Naur busybox-1.31.1/debianutils/start_stop_daemon.c busybox-be5a505d/debianutils/start_stop_daemon.c
--- busybox-1.31.1/debianutils/start_stop_daemon.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/debianutils/start_stop_daemon.c	2019-10-24 07:26:55.000000000 -0700
@@ -317,7 +317,7 @@
 	}
 	closedir(procdir);
 	if (!pid)
-		bb_error_msg_and_die("nothing in /proc - not mounted?");
+		bb_simple_error_msg_and_die("nothing in /proc - not mounted?");
 }
 
 static int do_stop(void)
@@ -337,7 +337,7 @@
 	} else if (userspec) {
 		what = xasprintf("process(es) owned by '%s'", userspec);
 	} else {
-		bb_error_msg_and_die("internal error, please report");
+		bb_simple_error_msg_and_die("internal error, please report");
 	}
 
 	if (!G.found_procs) {
diff -Naur busybox-1.31.1/docs/.gitignore busybox-be5a505d/docs/.gitignore
--- busybox-1.31.1/docs/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ busybox-be5a505d/docs/.gitignore	2019-10-24 07:26:55.000000000 -0700
@@ -0,0 +1,5 @@
+/busybox.1
+/BusyBox.html
+/busybox.net
+/BusyBox.txt
+/busybox.pod
diff -Naur busybox-1.31.1/e2fsprogs/chattr.c busybox-be5a505d/e2fsprogs/chattr.c
--- busybox-1.31.1/e2fsprogs/chattr.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/e2fsprogs/chattr.c	2019-10-24 07:26:55.000000000 -0700
@@ -196,11 +196,11 @@
 
 	/* run sanity checks on all the arguments given us */
 	if ((g.flags & OPT_SET) && (g.flags & (OPT_ADD|OPT_REM)))
-		bb_error_msg_and_die("= is incompatible with - and +");
+		bb_simple_error_msg_and_die("= is incompatible with - and +");
 	if (g.rf & g.af)
-		bb_error_msg_and_die("can't set and unset a flag");
+		bb_simple_error_msg_and_die("can't set and unset a flag");
 	if (!g.flags)
-		bb_error_msg_and_die("must use '-v', =, - or +");
+		bb_simple_error_msg_and_die("must use '-v', =, - or +");
 
 	/* now run chattr on all the files passed to us */
 	do change_attributes(*argv, &g); while (*++argv);
diff -Naur busybox-1.31.1/e2fsprogs/fsck.c busybox-be5a505d/e2fsprogs/fsck.c
--- busybox-1.31.1/e2fsprogs/fsck.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/e2fsprogs/fsck.c	2019-10-24 07:26:55.000000000 -0700
@@ -431,10 +431,10 @@
 			if (errno == EINTR)
 				continue;
 			if (errno == ECHILD) { /* paranoia */
-				bb_error_msg("wait: no more children");
+				bb_simple_error_msg("wait: no more children");
 				return -1;
 			}
-			bb_perror_msg("wait");
+			bb_simple_perror_msg("wait");
 			continue;
 		}
 		prev = NULL;
@@ -919,7 +919,7 @@
 			if (G.fs_type_negated == -1)
 				G.fs_type_negated = negate;
 			if (G.fs_type_negated != negate)
-				bb_error_msg_and_die(
+				bb_simple_error_msg_and_die(
 "either all or none of the filesystem types passed to -t must be prefixed "
 "with 'no' or '!'");
 		}
diff -Naur busybox-1.31.1/editors/awk.c busybox-be5a505d/editors/awk.c
--- busybox-1.31.1/editors/awk.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/editors/awk.c	2019-10-24 07:26:55.000000000 -0700
@@ -2633,7 +2633,7 @@
 					if (opn == '|') {
 						rsm->F = popen(R.s, "w");
 						if (rsm->F == NULL)
-							bb_perror_msg_and_die("popen");
+							bb_simple_perror_msg_and_die("popen");
 						rsm->is_pipe = 1;
 					} else {
 						rsm->F = xfopen(R.s, opn=='w' ? "w" : "a");
@@ -3246,7 +3246,7 @@
 	argv += optind;
 	//argc -= optind;
 	if (opt & OPT_W)
-		bb_error_msg("warning: option -W is ignored");
+		bb_simple_error_msg("warning: option -W is ignored");
 	if (opt & OPT_F) {
 		unescape_string_in_place(opt_F);
 		setvar_s(intvar[FS], opt_F);
diff -Naur busybox-1.31.1/editors/diff.c busybox-be5a505d/editors/diff.c
--- busybox-1.31.1/editors/diff.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/editors/diff.c	2019-10-24 07:26:55.000000000 -0700
@@ -1006,7 +1006,7 @@
 	xfunc_error_retval = 1;
 
 	if (gotstdin && (S_ISDIR(stb[0].st_mode) || S_ISDIR(stb[1].st_mode)))
-		bb_error_msg_and_die("can't compare stdin to a directory");
+		bb_simple_error_msg_and_die("can't compare stdin to a directory");
 
 	/* Compare metadata to check if the files are the same physical file.
 	 *
@@ -1037,7 +1037,7 @@
 #if ENABLE_FEATURE_DIFF_DIR
 		diffdir(file, s_start);
 #else
-		bb_error_msg_and_die("no support for directory comparison");
+		bb_simple_error_msg_and_die("no support for directory comparison");
 #endif
 	} else {
 		bool dirfile = S_ISDIR(stb[0].st_mode) || S_ISDIR(stb[1].st_mode);
diff -Naur busybox-1.31.1/editors/ed.c busybox-be5a505d/editors/ed.c
--- busybox-1.31.1/editors/ed.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/editors/ed.c	2019-10-24 07:26:55.000000000 -0700
@@ -165,7 +165,7 @@
 
 	if (*str == '\0') {
 		if (searchString[0] == '\0') {
-			bb_error_msg("no previous search string");
+			bb_simple_error_msg("no previous search string");
 			return 0;
 		}
 		str = searchString;
@@ -228,7 +228,7 @@
 			case '\'':
 				cp++;
 				if ((unsigned)(*cp - 'a') >= 26) {
-					bb_error_msg("bad mark name");
+					bb_simple_error_msg("bad mark name");
 					return NULL;
 				}
 				haveNum = TRUE;
@@ -314,7 +314,7 @@
 	LINE *newLp, *lp;
 
 	if ((num < 1) || (num > lastNum + 1)) {
-		bb_error_msg("inserting at bad line number");
+		bb_simple_error_msg("inserting at bad line number");
 		return FALSE;
 	}
 
@@ -384,7 +384,7 @@
 	char *cp;
 
 	if ((num < 1) || (num > lastNum + 1)) {
-		bb_error_msg("bad line for read");
+		bb_simple_error_msg("bad line for read");
 		return FALSE;
 	}
 
@@ -629,7 +629,7 @@
 	cp = buf;
 
 	if (isblank(*cp) || (*cp == '\0')) {
-		bb_error_msg("bad delimiter for substitute");
+		bb_simple_error_msg("bad delimiter for substitute");
 		return;
 	}
 
@@ -638,7 +638,7 @@
 
 	cp = strchr(cp, delim);
 	if (cp == NULL) {
-		bb_error_msg("missing 2nd delimiter for substitute");
+		bb_simple_error_msg("missing 2nd delimiter for substitute");
 		return;
 	}
 
@@ -660,13 +660,13 @@
 			printFlag = TRUE;
 			break;
 		default:
-			bb_error_msg("unknown option for substitute");
+			bb_simple_error_msg("unknown option for substitute");
 			return;
 	}
 
 	if (*oldStr == '\0') {
 		if (searchString[0] == '\0') {
-			bb_error_msg("no previous search string");
+			bb_simple_error_msg("no previous search string");
 			return;
 		}
 		oldStr = searchString;
@@ -846,7 +846,7 @@
 
 		case 'f':
 			if (*cp != '\0' && *cp != ' ') {
-				bb_error_msg("bad file command");
+				bb_simple_error_msg("bad file command");
 				break;
 			}
 			cp = skip_whitespace(cp);
@@ -870,7 +870,7 @@
 		case 'k':
 			cp = skip_whitespace(cp);
 			if ((unsigned)(*cp - 'a') >= 26 || cp[1]) {
-				bb_error_msg("bad mark name");
+				bb_simple_error_msg("bad mark name");
 				break;
 			}
 			marks[(unsigned)(*cp - 'a')] = num2;
@@ -887,7 +887,7 @@
 		case 'q':
 			cp = skip_whitespace(cp);
 			if (have1 || *cp) {
-				bb_error_msg("bad quit command");
+				bb_simple_error_msg("bad quit command");
 				break;
 			}
 			if (!dirty)
@@ -903,12 +903,12 @@
 
 		case 'r':
 			if (*cp != '\0' && *cp != ' ') {
-				bb_error_msg("bad read command");
+				bb_simple_error_msg("bad read command");
 				break;
 			}
 			cp = skip_whitespace(cp);
 			if (*cp == '\0') {
-				bb_error_msg("no file name");
+				bb_simple_error_msg("no file name");
 				break;
 			}
 			if (!have1)
@@ -925,14 +925,14 @@
 
 		case 'w':
 			if (*cp != '\0' && *cp != ' ') {
-				bb_error_msg("bad write command");
+				bb_simple_error_msg("bad write command");
 				break;
 			}
 			cp = skip_whitespace(cp);
 			if (*cp == '\0') {
 				cp = fileName;
 				if (!cp) {
-					bb_error_msg("no file name specified");
+					bb_simple_error_msg("no file name specified");
 					break;
 				}
 			}
@@ -960,7 +960,7 @@
 
 		case '.':
 			if (have1) {
-				bb_error_msg("no arguments allowed");
+				bb_simple_error_msg("no arguments allowed");
 				break;
 			}
 			printLines(curNum, curNum, FALSE);
@@ -984,7 +984,7 @@
 			break;
 
 		default:
-			bb_error_msg("unimplemented command");
+			bb_simple_error_msg("unimplemented command");
 			break;
 		}
 	}
diff -Naur busybox-1.31.1/editors/patch_bbox.c busybox-be5a505d/editors/patch_bbox.c
--- busybox-1.31.1/editors/patch_bbox.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/editors/patch_bbox.c	2019-10-24 07:26:55.000000000 -0700
@@ -30,7 +30,7 @@
 			break;
 		}
 		if (fputs(line, dst_stream) == EOF) {
-			bb_perror_msg_and_die("error writing to new file");
+			bb_simple_perror_msg_and_die("error writing to new file");
 		}
 		free(line);
 		lines_count--;
@@ -148,7 +148,7 @@
 
 		new_filename = extract_filename(patch_line, patch_level, "+++ ");
 		if (!new_filename) {
-			bb_error_msg_and_die("invalid patch");
+			bb_simple_error_msg_and_die("invalid patch");
 		}
 
 		/* Get access rights from the file to be patched */
@@ -209,7 +209,7 @@
 				/* src_beg_line will be 0 if it's a new file */
 				count = src_beg_line - src_cur_line;
 				if (copy_lines(src_stream, dst_stream, count)) {
-					bb_error_msg_and_die("bad src file");
+					bb_simple_error_msg_and_die("bad src file");
 				}
 				src_cur_line += count;
 				dst_cur_line += count;
diff -Naur busybox-1.31.1/editors/patch_toybox.c busybox-be5a505d/editors/patch_toybox.c
--- busybox-1.31.1/editors/patch_toybox.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/editors/patch_toybox.c	2019-10-24 07:26:55.000000000 -0700
@@ -200,7 +200,7 @@
 
 	*tempname = xasprintf("%sXXXXXX", name);
 	fd = mkstemp(*tempname);
-	if(-1 == fd) bb_perror_msg_and_die("no temp file");
+	if(-1 == fd) bb_simple_perror_msg_and_die("no temp file");
 
 	// Set permissions of output file
 	fstat(fdin, &statbuf);
diff -Naur busybox-1.31.1/editors/sed.c busybox-be5a505d/editors/sed.c
--- busybox-1.31.1/editors/sed.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/editors/sed.c	2019-10-24 07:26:55.000000000 -0700
@@ -315,7 +315,7 @@
 	/* verify that the 's' or 'y' is followed by something.  That something
 	 * (typically a 'slash') is now our regexp delimiter... */
 	if (*cmdstr == '\0')
-		bb_error_msg_and_die("bad format in substitution expression");
+		bb_simple_error_msg_and_die("bad format in substitution expression");
 	delimiter = *cmdstr_ptr++;
 
 	/* save the match string */
@@ -360,7 +360,7 @@
 		} else {
 			*regex = G.previous_regex_ptr;
 			if (!G.previous_regex_ptr)
-				bb_error_msg_and_die("no previous regexp");
+				bb_simple_error_msg_and_die("no previous regexp");
 		}
 		/* Move position to next character after last delimiter */
 		pos += (next+1);
@@ -378,7 +378,7 @@
 	start = skip_whitespace(filecmdstr);
 	eol = strchrnul(start, '\n');
 	if (eol == start)
-		bb_error_msg_and_die("empty filename");
+		bb_simple_error_msg_and_die("empty filename");
 
 	if (*eol) {
 		/* If lines glued together, put backslash back. */
@@ -468,7 +468,7 @@
 			goto out;
 		default:
 			dbg("s bad flags:'%s'", substr + idx);
-			bb_error_msg_and_die("bad option in substitution expression");
+			bb_simple_error_msg_and_die("bad option in substitution expression");
 		}
 	}
  out:
@@ -688,7 +688,7 @@
 				idx--; /* if 0, trigger error check below */
 			}
 			if (idx < 0)
-				bb_error_msg_and_die("no address after comma");
+				bb_simple_error_msg_and_die("no address after comma");
 			sed_cmd->end_line_orig = sed_cmd->end_line;
 		}
 
@@ -706,7 +706,7 @@
 
 		/* last part (mandatory) will be a command */
 		if (!*cmdstr)
-			bb_error_msg_and_die("missing command");
+			bb_simple_error_msg_and_die("missing command");
 		sed_cmd->cmd = *cmdstr++;
 		cmdstr = parse_cmd_args(sed_cmd, cmdstr);
 
@@ -791,7 +791,7 @@
 	if (!current_regex) {
 		current_regex = G.previous_regex_ptr;
 		if (!current_regex)
-			bb_error_msg_and_die("no previous regexp");
+			bb_simple_error_msg_and_die("no previous regexp");
 	}
 	G.previous_regex_ptr = current_regex;
 
@@ -962,7 +962,7 @@
 
 	if (ferror(file)) {
 		xfunc_error_retval = 4;  /* It's what gnu sed exits with... */
-		bb_error_msg_and_die(bb_msg_write_error);
+		bb_simple_error_msg_and_die(bb_msg_write_error);
 	}
 	*last_puts_char = lpc;
 }
@@ -1192,7 +1192,7 @@
 					}
 					sed_cmd = sed_cmd->next;
 					if (!sed_cmd)
-						bb_error_msg_and_die("unterminated {");
+						bb_simple_error_msg_and_die("unterminated {");
 				}
 			}
 			continue;
diff -Naur busybox-1.31.1/editors/vi.c busybox-be5a505d/editors/vi.c
--- busybox-1.31.1/editors/vi.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/editors/vi.c	2019-10-24 07:26:55.000000000 -0700
@@ -1042,7 +1042,7 @@
 			goto again;
 		go_bottom_and_clear_to_eol();
 		cookmode(); // terminal to "cooked"
-		bb_error_msg_and_die("can't read user input");
+		bb_simple_error_msg_and_die("can't read user input");
 	}
 	return c;
 }
diff -Naur busybox-1.31.1/examples/udhcp/simple.script busybox-be5a505d/examples/udhcp/simple.script
--- busybox-1.31.1/examples/udhcp/simple.script	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/examples/udhcp/simple.script	2019-10-24 07:26:55.000000000 -0700
@@ -16,9 +16,10 @@
 
 case "$1" in
 	deconfig)
-		echo "Setting IP address 0.0.0.0 on $interface"
+		echo "Clearing IP addresses on $interface, upping it"
 		if command -v ip >/dev/null; then
 			ip addr flush dev $interface
+			ip link set dev $interface up
 		else
 			ifconfig $interface 0.0.0.0
 		fi
@@ -52,7 +53,6 @@
 			done
 		fi
 
-		echo "Recreating $RESOLV_CONF"
 		# If the file is a symlink somewhere (like /etc/resolv.conf
 		# pointing to /run/resolv.conf), make sure things work.
 		if test -L "$RESOLV_CONF"; then
@@ -60,6 +60,7 @@
 			test -e "$RESOLV_CONF" || touch "$RESOLV_CONF"
 		fi
 		realconf=$(readlink -f "$RESOLV_CONF" 2>/dev/null || echo "$RESOLV_CONF")
+		echo "Recreating $realconf"
 		tmpfile="$realconf-$$"
 		> "$tmpfile"
 		[ -n "$domain" ] && echo "search $domain" >> "$tmpfile"
diff -Naur busybox-1.31.1/findutils/find.c busybox-be5a505d/findutils/find.c
--- busybox-1.31.1/findutils/find.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/findutils/find.c	2019-10-24 07:26:55.000000000 -0700
@@ -203,6 +203,14 @@
 //config:	WARNING: This option can do much harm if used wrong. Busybox will not
 //config:	try to protect the user from doing stupid things. Use with care.
 //config:
+//config:config FEATURE_FIND_EMPTY
+//config:	bool "Enable -empty: match empty files or directories"
+//config:	default y
+//config:	depends on FIND
+//config:	help
+//config:	Support the 'find -empty' option to find empty regular files
+//config:	or directories.
+//config:
 //config:config FEATURE_FIND_PATH
 //config:	bool "Enable -path: match pathname with shell pattern"
 //config:	default y
@@ -315,6 +323,9 @@
 //usage:	IF_FEATURE_FIND_CONTEXT(
 //usage:     "\n	-context CTX	File has specified security context"
 //usage:	)
+//usage:	IF_FEATURE_FIND_EMPTY(
+//usage:     "\n	-empty		Match empty file/directory"
+//usage:	)
 //usage:	IF_FEATURE_FIND_PRUNE(
 //usage:     "\n	-prune		If current file is directory, don't descend into it"
 //usage:	)
@@ -396,6 +407,7 @@
 IF_FEATURE_FIND_PRUNE(  ACTS(prune))
 IF_FEATURE_FIND_QUIT(   ACTS(quit))
 IF_FEATURE_FIND_DELETE( ACTS(delete))
+IF_FEATURE_FIND_EMPTY(  ACTS(empty))
 IF_FEATURE_FIND_EXEC(   ACTS(exec,
 				char **exec_argv; /* -exec ARGS */
 				unsigned *subst_count;
@@ -824,6 +836,30 @@
 	return TRUE;
 }
 #endif
+#if ENABLE_FEATURE_FIND_EMPTY
+ACTF(empty)
+{
+	if (S_ISDIR(statbuf->st_mode)) {
+		DIR *dir;
+		struct dirent *dent;
+
+		dir = opendir(fileName);
+		if (!dir) {
+			bb_simple_perror_msg(fileName);
+			return FALSE;
+		}
+
+		while ((dent = readdir(dir)) != NULL
+		 && DOT_OR_DOTDOT(dent->d_name)
+		) {
+			continue;
+		}
+		closedir(dir);
+		return dent == NULL;
+	}
+	return S_ISREG(statbuf->st_mode) && statbuf->st_size == 0;
+}
+#endif
 #if ENABLE_FEATURE_FIND_CONTEXT
 ACTF(context)
 {
@@ -989,6 +1025,7 @@
 	IF_FEATURE_FIND_PRUNE(  PARM_prune     ,)
 	IF_FEATURE_FIND_QUIT(   PARM_quit      ,)
 	IF_FEATURE_FIND_DELETE( PARM_delete    ,)
+	IF_FEATURE_FIND_EMPTY(	PARM_empty     ,)
 	IF_FEATURE_FIND_EXEC(   PARM_exec      ,)
 	IF_FEATURE_FIND_EXECUTABLE(PARM_executable,)
 	IF_FEATURE_FIND_PAREN(  PARM_char_brace,)
@@ -1034,6 +1071,7 @@
 	IF_FEATURE_FIND_PRUNE(  "-prune\0"  )
 	IF_FEATURE_FIND_QUIT(   "-quit\0"  )
 	IF_FEATURE_FIND_DELETE( "-delete\0" )
+	IF_FEATURE_FIND_EMPTY(	"-empty\0"  )
 	IF_FEATURE_FIND_EXEC(   "-exec\0"   )
 	IF_FEATURE_FIND_EXECUTABLE("-executable\0")
 	IF_FEATURE_FIND_PAREN(  "(\0"       )
@@ -1203,6 +1241,12 @@
 			(void) ALLOC_ACTION(delete);
 		}
 #endif
+#if ENABLE_FEATURE_FIND_EMPTY
+		else if (parm == PARM_empty) {
+			dbg("%d", __LINE__);
+			(void) ALLOC_ACTION(empty);
+		}
+#endif
 #if ENABLE_FEATURE_FIND_EXEC
 		else if (parm == PARM_exec) {
 			int i;
@@ -1245,7 +1289,7 @@
 			 * coreutils expects {} to appear only once in "-exec +"
 			 */
 			if (all_subst != 1 && ap->filelist)
-				bb_error_msg_and_die("only one '{}' allowed for -exec +");
+				bb_simple_error_msg_and_die("only one '{}' allowed for -exec +");
 # endif
 		}
 #endif
@@ -1259,7 +1303,7 @@
 			endarg = argv;
 			while (1) {
 				if (!*++endarg)
-					bb_error_msg_and_die("unpaired '('");
+					bb_simple_error_msg_and_die("unpaired '('");
 				if (LONE_CHAR(*endarg, '('))
 					nested++;
 				else if (LONE_CHAR(*endarg, ')') && !--nested) {
diff -Naur busybox-1.31.1/findutils/xargs.c busybox-be5a505d/findutils/xargs.c
--- busybox-1.31.1/findutils/xargs.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/findutils/xargs.c	2019-10-24 07:26:55.000000000 -0700
@@ -665,7 +665,7 @@
 	}
 	/* Sanity check */
 	if (n_max_chars <= 0) {
-		bb_error_msg_and_die("can't fit single argument within argument list size limit");
+		bb_simple_error_msg_and_die("can't fit single argument within argument list size limit");
 	}
 
 	buf = xzalloc(n_max_chars + 1);
@@ -716,7 +716,7 @@
 
 		if (!G.args[initial_idx]) { /* not even one ARG was added? */
 			if (*rem != '\0')
-				bb_error_msg_and_die("argument line too long");
+				bb_simple_error_msg_and_die("argument line too long");
 			if (opt & OPT_NO_EMPTY)
 				break;
 		}
diff -Naur busybox-1.31.1/.gitignore busybox-be5a505d/.gitignore
--- busybox-1.31.1/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ busybox-be5a505d/.gitignore	2019-10-24 07:26:55.000000000 -0700
@@ -0,0 +1,63 @@
+#
+# Kbuild ignores
+#
+.*
+*.o
+*.o.*
+*.a
+*.s
+Kbuild
+Config.in
+
+#
+# Never ignore these
+#
+!.gitignore
+
+#
+# Normal output
+#
+/busybox
+/busybox_old
+/busybox_unstripped*
+
+#
+# Backups / patches
+#
+*~
+*.orig
+*.rej
+/*.patch
+
+#
+# debugging stuff
+#
+core
+.gdb_history
+.gdbinit
+
+#
+# testing output
+#
+/busybox.links
+/runtest-tempdir-links
+/testsuite/echo-ne
+
+#
+# cscope output
+#
+cscope.files
+cscope.in.out
+cscope.out
+cscope.po.out
+
+#
+# ctags output
+#
+tags
+TAGS
+
+#
+# user-supplied scripts
+#
+/embed
diff -Naur busybox-1.31.1/include/.gitignore busybox-be5a505d/include/.gitignore
--- busybox-1.31.1/include/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ busybox-be5a505d/include/.gitignore	2019-10-24 07:26:55.000000000 -0700
@@ -0,0 +1,12 @@
+/config
+
+/applets.h
+/applet_tables.h
+/autoconf.h
+/bbconfigopts_bz2.h
+/bbconfigopts.h
+/embedded_scripts.h
+/NUM_APPLETS.h
+/usage_compressed.h
+/usage.h
+/common_bufsiz.h*
diff -Naur busybox-1.31.1/include/libbb.h busybox-be5a505d/include/libbb.h
--- busybox-1.31.1/include/libbb.h	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/include/libbb.h	2019-10-24 07:26:55.000000000 -0700
@@ -1137,7 +1137,7 @@
 ({ \
 	pid_t bb__xvfork_pid = vfork(); \
 	if (bb__xvfork_pid < 0) \
-		bb_perror_msg_and_die("vfork"); \
+		bb_simple_perror_msg_and_die("vfork"); \
 	bb__xvfork_pid; \
 })
 #if BB_MMU
@@ -1324,13 +1324,17 @@
 void xfunc_die(void) NORETURN FAST_FUNC;
 void bb_show_usage(void) NORETURN FAST_FUNC;
 void bb_error_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_error_msg(const char *s) FAST_FUNC;
 void bb_error_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_error_msg_and_die(const char *s) NORETURN FAST_FUNC;
 void bb_perror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
 void bb_simple_perror_msg(const char *s) FAST_FUNC;
 void bb_perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
 void bb_simple_perror_msg_and_die(const char *s) NORETURN FAST_FUNC;
 void bb_herror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_herror_msg(const char *s) FAST_FUNC;
 void bb_herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_herror_msg_and_die(const char *s) NORETURN FAST_FUNC;
 void bb_perror_nomsg_and_die(void) NORETURN FAST_FUNC;
 void bb_perror_nomsg(void) FAST_FUNC;
 void bb_verror_msg(const char *s, va_list p, const char *strerr) FAST_FUNC;
@@ -1339,12 +1343,51 @@
 
 #if ENABLE_FEATURE_SYSLOG_INFO
 void bb_info_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_info_msg(const char *s) FAST_FUNC;
 void bb_vinfo_msg(const char *s, va_list p) FAST_FUNC;
 #else
 #define bb_info_msg bb_error_msg
+#define bb_simple_info_msg bb_simple_error_msg
 #define bb_vinfo_msg(s,p) bb_verror_msg(s,p,NULL)
 #endif
 
+#if ENABLE_WARN_SIMPLE_MSG
+/* If enabled, cause calls to bb_error_msg() et al that only take a single
+ * parameter to generate a warning.
+ */
+static inline void __attribute__ ((deprecated("use bb_simple_error_msg instead")))
+	bb_not_simple_error_msg(const char *s) { bb_simple_error_msg(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_error_msg_and_die instead"))) NORETURN
+	bb_not_simple_error_msg_and_die(const char *s) { bb_simple_error_msg_and_die(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_perror_msg instead")))
+	bb_not_simple_perror_msg(const char *s) { bb_simple_perror_msg(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_perror_msg_and_die instead"))) NORETURN
+	bb_not_simple_perror_msg_and_die(const char *s) { bb_simple_perror_msg_and_die(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_herror_msg instead")))
+	bb_not_simple_herror_msg(const char *s) { bb_simple_herror_msg(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_herror_msg_and_die instead"))) NORETURN
+	bb_not_simple_herror_msg_and_die(const char *s) { bb_simple_herror_msg_and_die(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_info_msg instead")))
+	bb_not_simple_info_msg(const char *s) { bb_simple_info_msg(s); }
+/* Override bb_error_msg() and related functions with macros that will
+ * substitute them for the equivalent bb_not_simple_error_msg() function when
+ * they are used with only a single parameter. Macro approach inspired by
+ * https://gustedt.wordpress.com/2010/06/08/detect-empty-macro-arguments and
+ * https://gustedt.wordpress.com/2010/06/03/default-arguments-for-c99
+ */
+#define _ARG18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, ...) _17
+#define BB_MSG_KIND(...)           _ARG18(__VA_ARGS__, , , , , , , , , , , , , , , , , _not_simple)
+#define _BB_MSG(name, kind, ...)   bb##kind##name(__VA_ARGS__)
+#define BB_MSG(name, kind, ...)    _BB_MSG(name, kind, __VA_ARGS__)
+#define bb_error_msg(...)          BB_MSG(_error_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_error_msg_and_die(...)  BB_MSG(_error_msg_and_die, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_perror_msg(...)         BB_MSG(_perror_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_perror_msg_and_die(...) BB_MSG(_perror_msg_and_die, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_herror_msg(...)         BB_MSG(_herror_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_herror_msg_and_die(...) BB_MSG(_herror_msg_and_die, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_info_msg(...)           BB_MSG(_info_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#endif
+
 /* We need to export XXX_main from libbusybox
  * only if we build "individual" binaries
  */
diff -Naur busybox-1.31.1/init/bootchartd.c busybox-be5a505d/init/bootchartd.c
--- busybox-1.31.1/init/bootchartd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/init/bootchartd.c	2019-10-24 07:26:55.000000000 -0700
@@ -208,7 +208,7 @@
 			bb_perror_msg_and_die("can't %smount tmpfs", "un");
 		}
 #else
-		bb_perror_msg_and_die("can't create temporary directory");
+		bb_simple_perror_msg_and_die("can't create temporary directory");
 #endif
 	} else {
 		xchdir(tempdir);
diff -Naur busybox-1.31.1/init/init.c busybox-be5a505d/init/init.c
--- busybox-1.31.1/init/init.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/init/init.c	2019-10-24 07:26:55.000000000 -0700
@@ -1086,7 +1086,7 @@
 		if (getpid() != 1
 		 && (!ENABLE_LINUXRC || applet_name[0] != 'l') /* not linuxrc? */
 		) {
-			bb_error_msg_and_die("must be run as PID 1");
+			bb_simple_error_msg_and_die("must be run as PID 1");
 		}
 #ifdef RB_DISABLE_CAD
 		/* Turn off rebooting via CTL-ALT-DEL - we get a
diff -Naur busybox-1.31.1/libbb/appletlib.c busybox-be5a505d/libbb/appletlib.c
--- busybox-1.31.1/libbb/appletlib.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/appletlib.c	2019-10-24 07:26:55.000000000 -0700
@@ -631,7 +631,7 @@
 			/* same group / in group */
 			m >>= 3;
 		if (!(m & S_IXOTH)) /* is x bit not set? */
-			bb_error_msg_and_die("you have no permission to run this applet");
+			bb_simple_error_msg_and_die("you have no permission to run this applet");
 
 		/* We set effective AND saved ids. If saved-id is not set
 		 * like we do below, seteuid(0) can still later succeed! */
@@ -643,7 +643,7 @@
 			rgid = sct->m_ugid.gid;
 		/* else: we will set egid = rgid, thus dropping sgid effect */
 		if (setresgid(-1, rgid, rgid))
-			bb_perror_msg_and_die("setresgid");
+			bb_simple_perror_msg_and_die("setresgid");
 
 		/* Are we directed to change uid
 		 * (APPLET = s** USER.GROUP or APPLET = S** USER.GROUP)?
@@ -653,7 +653,7 @@
 			uid = sct->m_ugid.uid;
 		/* else: we will set euid = ruid, thus dropping suid effect */
 		if (setresuid(-1, uid, uid))
-			bb_perror_msg_and_die("setresuid");
+			bb_simple_perror_msg_and_die("setresuid");
 
 		goto ret;
 	}
@@ -663,7 +663,7 @@
 
 		if (!onetime) {
 			onetime = 1;
-			bb_error_msg("using fallback suid method");
+			bb_simple_error_msg("using fallback suid method");
 		}
 	}
 #   endif
@@ -673,7 +673,7 @@
 		/* Real uid is not 0. If euid isn't 0 too, suid bit
 		 * is most probably not set on our executable */
 		if (geteuid())
-			bb_error_msg_and_die("must be suid to work properly");
+			bb_simple_error_msg_and_die("must be suid to work properly");
 	} else if (APPLET_SUID(applet_no) == BB_SUID_DROP) {
 		/*
 		 * Drop all privileges.
diff -Naur busybox-1.31.1/libbb/bb_getgroups.c busybox-be5a505d/libbb/bb_getgroups.c
--- busybox-1.31.1/libbb/bb_getgroups.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/bb_getgroups.c	2019-10-24 07:26:55.000000000 -0700
@@ -38,7 +38,7 @@
 			continue;
 		}
 		/* Some other error (should never happen on Linux) */
-		bb_perror_msg_and_die("getgroups");
+		bb_simple_perror_msg_and_die("getgroups");
 	}
 
 	if (ngroups)
diff -Naur busybox-1.31.1/libbb/bbunit.c busybox-be5a505d/libbb/bbunit.c
--- busybox-1.31.1/libbb/bbunit.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/bbunit.c	2019-10-24 07:26:55.000000000 -0700
@@ -60,6 +60,6 @@
 		return EXIT_FAILURE;
 	}
 
-	bb_error_msg("All tests passed");
+	bb_simple_error_msg("All tests passed");
 	return EXIT_SUCCESS;
 }
diff -Naur busybox-1.31.1/libbb/capability.c busybox-be5a505d/libbb/capability.c
--- busybox-1.31.1/libbb/capability.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/capability.c	2019-10-24 07:26:55.000000000 -0700
@@ -119,7 +119,7 @@
 			caps->u32s = _LINUX_CAPABILITY_U32S_3;
 			break;
 		default:
-			bb_error_msg_and_die("unsupported capability version");
+			bb_simple_error_msg_and_die("unsupported capability version");
 	}
 
 	if (capget(&caps->header, caps->data) != 0)
diff -Naur busybox-1.31.1/libbb/change_identity.c busybox-be5a505d/libbb/change_identity.c
--- busybox-1.31.1/libbb/change_identity.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/change_identity.c	2019-10-24 07:26:55.000000000 -0700
@@ -51,7 +51,7 @@
 			return;
 		}
 
-		bb_perror_msg_and_die("can't set groups");
+		bb_simple_perror_msg_and_die("can't set groups");
 	}
 
 	xsetgid(pw->pw_gid);
diff -Naur busybox-1.31.1/libbb/copyfd.c busybox-be5a505d/libbb/copyfd.c
--- busybox-1.31.1/libbb/copyfd.c	2019-10-21 07:54:40.000000000 -0700
+++ busybox-be5a505d/libbb/copyfd.c	2019-10-24 07:26:55.000000000 -0700
@@ -90,7 +90,7 @@
 		rd = safe_read(src_fd, buffer,
 			size > buffer_size ? buffer_size : size);
 		if (rd < 0) {
-			bb_perror_msg(bb_msg_read_error);
+			bb_simple_perror_msg(bb_msg_read_error);
 			break;
 		}
  read_ok:
@@ -103,7 +103,7 @@
 			ssize_t wr = full_write(dst_fd, buffer, rd);
 			if (wr < rd) {
 				if (!continue_on_write_error) {
-					bb_perror_msg(bb_msg_write_error);
+					bb_simple_perror_msg(bb_msg_write_error);
 					break;
 				}
 				dst_fd = -1;
@@ -154,7 +154,7 @@
 	if (sz == (size >= 0 ? size : -size))
 		return;
 	if (sz != -1)
-		bb_error_msg_and_die("short read");
+		bb_simple_error_msg_and_die("short read");
 	/* if sz == -1, bb_copyfd_XX already complained */
 	xfunc_die();
 }
diff -Naur busybox-1.31.1/libbb/copy_file.c busybox-be5a505d/libbb/copy_file.c
--- busybox-1.31.1/libbb/copy_file.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/copy_file.c	2019-10-24 07:26:55.000000000 -0700
@@ -327,7 +327,7 @@
 		) {
 			security_context_t con;
 			if (getfscreatecon(&con) == -1) {
-				bb_perror_msg("getfscreatecon");
+				bb_simple_perror_msg("getfscreatecon");
 				return -1;
 			}
 			if (con) {
diff -Naur busybox-1.31.1/libbb/die_if_bad_username.c busybox-be5a505d/libbb/die_if_bad_username.c
--- busybox-1.31.1/libbb/die_if_bad_username.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/die_if_bad_username.c	2019-10-24 07:26:55.000000000 -0700
@@ -57,5 +57,5 @@
 	 * including the terminating null byte.
 	 */
 	if (name - start >= LOGIN_NAME_MAX)
-		bb_error_msg_and_die("name is too long");
+		bb_simple_error_msg_and_die("name is too long");
 }
diff -Naur busybox-1.31.1/libbb/dump.c busybox-be5a505d/libbb/dump.c
--- busybox-1.31.1/libbb/dump.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/dump.c	2019-10-24 07:26:55.000000000 -0700
@@ -199,7 +199,7 @@
 				pr->bcnt = fu->bcnt;
 				if (fu->bcnt == 0) {
 					if (!prec)
-						bb_error_msg_and_die("%%s needs precision or byte count");
+						bb_simple_error_msg_and_die("%%s needs precision or byte count");
 					pr->bcnt = atoi(prec);
 				}
 			} else
@@ -266,7 +266,7 @@
 
 			/* only one conversion character if byte count */
 			if (!(pr->flags & F_ADDRESS) && fu->bcnt && nconv++) {
-				bb_error_msg_and_die("byte count with multiple conversion characters");
+				bb_simple_error_msg_and_die("byte count with multiple conversion characters");
 			}
 		}
 		/*
diff -Naur busybox-1.31.1/libbb/fflush_stdout_and_exit.c busybox-be5a505d/libbb/fflush_stdout_and_exit.c
--- busybox-1.31.1/libbb/fflush_stdout_and_exit.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/fflush_stdout_and_exit.c	2019-10-24 07:26:55.000000000 -0700
@@ -15,7 +15,7 @@
 {
 	xfunc_error_retval = retval;
 	if (fflush(stdout))
-		bb_perror_msg_and_die(bb_msg_standard_output);
+		bb_simple_perror_msg_and_die(bb_msg_standard_output);
 	/* In case we are in NOFORK applet. Do not exit() directly,
 	 * but use xfunc_die() */
 	xfunc_die();
diff -Naur busybox-1.31.1/libbb/find_pid_by_name.c busybox-be5a505d/libbb/find_pid_by_name.c
--- busybox-1.31.1/libbb/find_pid_by_name.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/find_pid_by_name.c	2019-10-24 07:26:55.000000000 -0700
@@ -90,7 +90,11 @@
 		/* or we require argv0 to match (essential for matching reexeced /proc/self/exe)*/
 		 || (p->argv0 && strcmp(bb_basename(p->argv0), procName) == 0)
 		/* or we require /proc/PID/exe link to match */
-		 || (p->exe && strcmp(bb_basename(p->exe), procName) == 0)
+		 || (p->exe && strcmp(
+					procName[0] == '/' ? p->exe /* support "pidof /path/to/binary" case too */
+							: bb_basename(p->exe),
+					procName
+					) == 0)
 		) {
 			pidList = xrealloc_vector(pidList, 2, i);
 			pidList[i++] = p->pid;
diff -Naur busybox-1.31.1/libbb/get_console.c busybox-be5a505d/libbb/get_console.c
--- busybox-1.31.1/libbb/get_console.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/get_console.c	2019-10-24 07:26:55.000000000 -0700
@@ -62,7 +62,7 @@
 		}
 	}
 
-	bb_error_msg_and_die("can't open console");
+	bb_simple_error_msg_and_die("can't open console");
 }
 
 /* From <linux/vt.h> */
diff -Naur busybox-1.31.1/libbb/getpty.c busybox-be5a505d/libbb/getpty.c
--- busybox-1.31.1/libbb/getpty.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/getpty.c	2019-10-24 07:26:55.000000000 -0700
@@ -23,14 +23,14 @@
 			const char *name;
 			name = ptsname(p); /* find out the name of slave pty */
 			if (!name) {
-				bb_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
+				bb_simple_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
 			}
 			safe_strncpy(line, name, GETPTY_BUFSIZE);
 		}
 # else
 		/* find out the name of slave pty */
 		if (ptsname_r(p, line, GETPTY_BUFSIZE-1) != 0) {
-			bb_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
+			bb_simple_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
 		}
 		line[GETPTY_BUFSIZE-1] = '\0';
 # endif
@@ -61,5 +61,5 @@
 		}
 	}
 #endif /* FEATURE_DEVPTS */
-	bb_error_msg_and_die("can't find free pty");
+	bb_simple_error_msg_and_die("can't find free pty");
 }
diff -Naur busybox-1.31.1/libbb/get_volsize.c busybox-be5a505d/libbb/get_volsize.c
--- busybox-1.31.1/libbb/get_volsize.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/get_volsize.c	2019-10-24 07:26:55.000000000 -0700
@@ -18,7 +18,7 @@
 	if (override) {
 		result = XATOOFF(override);
 		if (result >= (uoff_t)(MAXINT(off_t)) / override_units)
-			bb_error_msg_and_die("image size is too big");
+			bb_simple_error_msg_and_die("image size is too big");
 		result *= override_units;
 		/* seek past end fails on block devices but works on files */
 		if (lseek(fd, result - 1, SEEK_SET) != (off_t)-1) {
@@ -42,7 +42,7 @@
 	 *
 	 * Picked 16k arbitrarily: */
 	if (result < 16*1024)
-		bb_error_msg_and_die("image is too small");
+		bb_simple_error_msg_and_die("image is too small");
 
 	return result;
 }
diff -Naur busybox-1.31.1/libbb/herror_msg.c busybox-be5a505d/libbb/herror_msg.c
--- busybox-1.31.1/libbb/herror_msg.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/herror_msg.c	2019-10-24 07:26:55.000000000 -0700
@@ -26,3 +26,13 @@
 	va_end(p);
 	xfunc_die();
 }
+
+void FAST_FUNC bb_simple_herror_msg(const char *s)
+{
+	bb_herror_msg("%s", s);
+}
+
+void FAST_FUNC bb_simple_herror_msg_and_die(const char *s)
+{
+	bb_herror_msg_and_die("%s", s);
+}
diff -Naur busybox-1.31.1/libbb/mtab.c busybox-be5a505d/libbb/mtab.c
--- busybox-1.31.1/libbb/mtab.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/mtab.c	2019-10-24 07:26:55.000000000 -0700
@@ -21,7 +21,7 @@
 	/* Bummer. Fall back on trying the /proc filesystem */
 	if (!mountTable) mountTable = setmntent("/proc/mounts", "r");
 	if (!mountTable) {
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 		return;
 	}
 
@@ -49,6 +49,6 @@
 		}
 		endmntent(mountTable);
 	} else if (errno != EROFS)
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 }
 #endif
diff -Naur busybox-1.31.1/libbb/perror_nomsg_and_die.c busybox-be5a505d/libbb/perror_nomsg_and_die.c
--- busybox-1.31.1/libbb/perror_nomsg_and_die.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/perror_nomsg_and_die.c	2019-10-24 07:26:55.000000000 -0700
@@ -12,11 +12,11 @@
  * instead of including libbb.h */
 //#include "libbb.h"
 #include "platform.h"
-extern void bb_perror_msg_and_die(const char *s, ...) FAST_FUNC;
+extern void bb_simple_perror_msg_and_die(const char *s) FAST_FUNC;
 
 /* suppress gcc "no previous prototype" warning */
 void FAST_FUNC bb_perror_nomsg_and_die(void);
 void FAST_FUNC bb_perror_nomsg_and_die(void)
 {
-	bb_perror_msg_and_die(0);
+	bb_simple_perror_msg_and_die(0);
 }
diff -Naur busybox-1.31.1/libbb/perror_nomsg.c busybox-be5a505d/libbb/perror_nomsg.c
--- busybox-1.31.1/libbb/perror_nomsg.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/perror_nomsg.c	2019-10-24 07:26:55.000000000 -0700
@@ -12,11 +12,11 @@
  * instead of including libbb.h */
 //#include "libbb.h"
 #include "platform.h"
-extern void bb_perror_msg(const char *s, ...) FAST_FUNC;
+extern void bb_simple_perror_msg(const char *s) FAST_FUNC;
 
 /* suppress gcc "no previous prototype" warning */
 void FAST_FUNC bb_perror_nomsg(void);
 void FAST_FUNC bb_perror_nomsg(void)
 {
-	bb_perror_msg(0);
+	bb_simple_perror_msg(0);
 }
diff -Naur busybox-1.31.1/libbb/pw_encrypt.c busybox-be5a505d/libbb/pw_encrypt.c
--- busybox-1.31.1/libbb/pw_encrypt.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/pw_encrypt.c	2019-10-24 07:26:55.000000000 -0700
@@ -6,7 +6,9 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+#if !ENABLE_USE_BB_CRYPT
 #include <crypt.h>
+#endif
 #include "libbb.h"
 
 /* static const uint8_t ascii64[] ALIGN1 =
diff -Naur busybox-1.31.1/libbb/read.c busybox-be5a505d/libbb/read.c
--- busybox-1.31.1/libbb/read.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/read.c	2019-10-24 07:26:55.000000000 -0700
@@ -12,9 +12,17 @@
 {
 	ssize_t n;
 
-	do {
+	for (;;) {
 		n = read(fd, buf, count);
-	} while (n < 0 && errno == EINTR);
+		if (n >= 0 || errno != EINTR)
+			break;
+		/* Some callers set errno=0, are upset when they see EINTR.
+		 * Returning EINTR is wrong since we retry read(),
+		 * the "error" was transient.
+		 */
+		errno = 0;
+		/* repeat the read() */
+	}
 
 	return n;
 }
diff -Naur busybox-1.31.1/libbb/read_printf.c busybox-be5a505d/libbb/read_printf.c
--- busybox-1.31.1/libbb/read_printf.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/read_printf.c	2019-10-24 07:26:55.000000000 -0700
@@ -217,7 +217,7 @@
 	if (count) {
 		ssize_t size = full_read(fd, buf, count);
 		if ((size_t)size != count)
-			bb_error_msg_and_die("short read");
+			bb_simple_error_msg_and_die("short read");
 	}
 }
 
diff -Naur busybox-1.31.1/libbb/replace.c busybox-be5a505d/libbb/replace.c
--- busybox-1.31.1/libbb/replace.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/replace.c	2019-10-24 07:26:55.000000000 -0700
@@ -15,6 +15,10 @@
 	size_t sub_len = strlen(sub);
 	unsigned count = 0;
 
+	/* If sub is empty, avoid an infinite loop */
+	if (sub_len == 0)
+		return strlen(str) + 1;
+
 	while ((str = strstr(str, sub)) != NULL) {
 		count++;
 		str += sub_len;
diff -Naur busybox-1.31.1/libbb/safe_poll.c busybox-be5a505d/libbb/safe_poll.c
--- busybox-1.31.1/libbb/safe_poll.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/safe_poll.c	2019-10-24 07:26:55.000000000 -0700
@@ -27,7 +27,7 @@
 		/* I doubt many callers would handle this correctly! */
 		if (errno == ENOMEM)
 			continue;
-		bb_perror_msg("poll");
+		bb_simple_perror_msg("poll");
 		return n;
 	}
 }
diff -Naur busybox-1.31.1/libbb/selinux_common.c busybox-be5a505d/libbb/selinux_common.c
--- busybox-1.31.1/libbb/selinux_common.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/selinux_common.c	2019-10-24 07:26:55.000000000 -0700
@@ -48,7 +48,7 @@
 	if (fgetfilecon(fdesc, &context) < 0) {
 		if (errno == ENODATA || errno == ENOTSUP)
 			return;
-		bb_perror_msg_and_die("fgetfilecon failed");
+		bb_simple_perror_msg_and_die("fgetfilecon failed");
 	}
 	setfscreatecon_or_die(context);
 	freecon(context);
diff -Naur busybox-1.31.1/libbb/time.c busybox-be5a505d/libbb/time.c
--- busybox-1.31.1/libbb/time.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/time.c	2019-10-24 07:26:55.000000000 -0700
@@ -253,12 +253,10 @@
 #define CLOCK_MONOTONIC 1
 #endif
 
-/* libc has incredibly messy way of doing this,
- * typically requiring -lrt. We just skip all this mess */
 static void get_mono(struct timespec *ts)
 {
-	if (syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts))
-		bb_error_msg_and_die("clock_gettime(MONOTONIC) failed");
+	if (clock_gettime(CLOCK_MONOTONIC, ts))
+		bb_simple_error_msg_and_die("clock_gettime(MONOTONIC) failed");
 }
 unsigned long long FAST_FUNC monotonic_ns(void)
 {
diff -Naur busybox-1.31.1/libbb/unicode.c busybox-be5a505d/libbb/unicode.c
--- busybox-1.31.1/libbb/unicode.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/unicode.c	2019-10-24 07:26:55.000000000 -0700
@@ -674,14 +674,20 @@
 		(  (/*ucs >= 0x1100 &&*/ ucs <= 0x115f) /* Hangul Jamo init. consonants */
 		|| ucs == 0x2329 /* left-pointing angle bracket; also CJK punct. char */
 		|| ucs == 0x232a /* right-pointing angle bracket; also CJK punct. char */
+#   if CONFIG_LAST_SUPPORTED_WCHAR >= 0x2e80
 		|| (ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f) /* CJK ... Yi */
+#   endif
 #   if CONFIG_LAST_SUPPORTED_WCHAR >= 0xac00
 		|| (ucs >= 0xac00 && ucs <= 0xd7a3) /* Hangul Syllables */
+#   endif
+#   if CONFIG_LAST_SUPPORTED_WCHAR >= 0xf900
 		|| (ucs >= 0xf900 && ucs <= 0xfaff) /* CJK Compatibility Ideographs */
 		|| (ucs >= 0xfe10 && ucs <= 0xfe19) /* Vertical forms */
 		|| (ucs >= 0xfe30 && ucs <= 0xfe6f) /* CJK Compatibility Forms */
 		|| (ucs >= 0xff00 && ucs <= 0xff60) /* Fullwidth Forms */
 		|| (ucs >= 0xffe0 && ucs <= 0xffe6)
+#   endif
+#   if CONFIG_LAST_SUPPORTED_WCHAR >= 0x20000
 		|| ((ucs >> 17) == (2 >> 1)) /* 20000..3ffff: Supplementary and Tertiary Ideographic Planes */
 #   endif
 		);
diff -Naur busybox-1.31.1/libbb/update_passwd.c busybox-be5a505d/libbb/update_passwd.c
--- busybox-1.31.1/libbb/update_passwd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/update_passwd.c	2019-10-24 07:26:55.000000000 -0700
@@ -25,7 +25,7 @@
 		return;  /* No need to check */
 
 	if (getprevcon_raw(&context) < 0)
-		bb_perror_msg_and_die("getprevcon failed");
+		bb_simple_perror_msg_and_die("getprevcon failed");
 	seuser = strtok(context, ":");
 	if (!seuser)
 		bb_error_msg_and_die("invalid context '%s'", context);
@@ -42,7 +42,7 @@
 
 		if (selinux_check_passwd_access(av) != 0)
  die:
-			bb_error_msg_and_die("SELinux: access denied");
+			bb_simple_error_msg_and_die("SELinux: access denied");
 	}
 	if (ENABLE_FEATURE_CLEAN_UP)
 		freecon(context);
diff -Naur busybox-1.31.1/libbb/uuencode.c busybox-be5a505d/libbb/uuencode.c
--- busybox-1.31.1/libbb/uuencode.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/uuencode.c	2019-10-24 07:26:55.000000000 -0700
@@ -213,7 +213,7 @@
 			if (*in_tail == '\0')
 				return;
 			/* No */
-			bb_error_msg_and_die("truncated base64 input");
+			bb_simple_error_msg_and_die("truncated base64 input");
 		}
 
 		/* It was partial decode */
diff -Naur busybox-1.31.1/libbb/verror_msg.c busybox-be5a505d/libbb/verror_msg.c
--- busybox-1.31.1/libbb/verror_msg.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/verror_msg.c	2019-10-24 07:26:55.000000000 -0700
@@ -197,4 +197,19 @@
 	bb_vinfo_msg(s, p);
 	va_end(p);
 }
+
+void FAST_FUNC bb_simple_info_msg(const char *s)
+{
+	bb_info_msg("%s", s);
+}
 #endif
+
+void FAST_FUNC bb_simple_error_msg(const char *s)
+{
+	bb_error_msg("%s", s);
+}
+
+void FAST_FUNC bb_simple_error_msg_and_die(const char *s)
+{
+	bb_error_msg_and_die("%s", s);
+}
diff -Naur busybox-1.31.1/libbb/warn_ignoring_args.c busybox-be5a505d/libbb/warn_ignoring_args.c
--- busybox-1.31.1/libbb/warn_ignoring_args.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/warn_ignoring_args.c	2019-10-24 07:26:55.000000000 -0700
@@ -12,7 +12,7 @@
 void FAST_FUNC bb_warn_ignoring_args(char *arg)
 {
 	if (arg) {
-		bb_error_msg("ignoring all arguments");
+		bb_simple_error_msg("ignoring all arguments");
 	}
 }
 #endif
diff -Naur busybox-1.31.1/libbb/xconnect.c busybox-be5a505d/libbb/xconnect.c
--- busybox-1.31.1/libbb/xconnect.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/xconnect.c	2019-10-24 07:26:55.000000000 -0700
@@ -66,7 +66,7 @@
 int FAST_FUNC setsockopt_bindtodevice(int fd UNUSED_PARAM,
 		const char *iface UNUSED_PARAM)
 {
-	bb_error_msg("SO_BINDTODEVICE is not supported on this system");
+	bb_simple_error_msg("SO_BINDTODEVICE is not supported on this system");
 	return -1;
 }
 #endif
@@ -109,7 +109,7 @@
 			bb_perror_msg_and_die("%s (%s)",
 				"can't connect to remote host",
 				inet_ntoa(((struct sockaddr_in *)s_addr)->sin_addr));
-		bb_perror_msg_and_die("can't connect to remote host");
+		bb_simple_perror_msg_and_die("can't connect to remote host");
 	}
 }
 
diff -Naur busybox-1.31.1/libbb/xfuncs.c busybox-be5a505d/libbb/xfuncs.c
--- busybox-1.31.1/libbb/xfuncs.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/xfuncs.c	2019-10-24 07:26:55.000000000 -0700
@@ -426,6 +426,6 @@
 
 	n = safe_waitpid(pid, &exit_status, 0);
 	if (n < 0)
-		bb_perror_msg_and_die("waitpid");
+		bb_simple_perror_msg_and_die("waitpid");
 	return exit_status;
 }
diff -Naur busybox-1.31.1/libbb/xfuncs_printf.c busybox-be5a505d/libbb/xfuncs_printf.c
--- busybox-1.31.1/libbb/xfuncs_printf.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/xfuncs_printf.c	2019-10-24 07:26:55.000000000 -0700
@@ -27,7 +27,7 @@
 
 void FAST_FUNC bb_die_memory_exhausted(void)
 {
-	bb_error_msg_and_die(bb_msg_memory_exhausted);
+	bb_simple_error_msg_and_die(bb_msg_memory_exhausted);
 }
 
 #ifndef DMALLOC
@@ -40,7 +40,7 @@
 {
 	void *ptr = malloc(size);
 	if (ptr == NULL && size != 0)
-		bb_error_msg(bb_msg_memory_exhausted);
+		bb_simple_error_msg(bb_msg_memory_exhausted);
 	return ptr;
 }
 
@@ -97,7 +97,7 @@
 	char *t;
 
 	if (ENABLE_DEBUG && s == NULL)
-		bb_error_msg_and_die("xstrndup bug");
+		bb_simple_error_msg_and_die("xstrndup bug");
 
 	/* We can just xmalloc(n+1) and strncpy into it, */
 	/* but think about xstrndup("abc", 10000) wastage! */
@@ -215,13 +215,13 @@
 void FAST_FUNC xpipe(int filedes[2])
 {
 	if (pipe(filedes))
-		bb_perror_msg_and_die("can't create pipe");
+		bb_simple_perror_msg_and_die("can't create pipe");
 }
 
 void FAST_FUNC xdup2(int from, int to)
 {
 	if (dup2(from, to) != to)
-		bb_perror_msg_and_die("can't duplicate file descriptor");
+		bb_simple_perror_msg_and_die("can't duplicate file descriptor");
 		//		" %d to %d", from, to);
 }
 
@@ -245,7 +245,7 @@
 			 * or some writes succeeded, then we hit an error.
 			 * In either case, errno is set.
 			 */
-			bb_perror_msg_and_die(
+			bb_simple_perror_msg_and_die(
 				size >= 0 ? "short write" : "write error"
 			);
 		}
@@ -259,7 +259,7 @@
 void FAST_FUNC xclose(int fd)
 {
 	if (close(fd))
-		bb_perror_msg_and_die("close failed");
+		bb_simple_perror_msg_and_die("close failed");
 }
 
 // Die with an error message if we can't lseek to the right spot.
@@ -267,9 +267,7 @@
 {
 	off_t off = lseek(fd, offset, whence);
 	if (off == (off_t)-1) {
-		if (whence == SEEK_SET)
-			bb_perror_msg_and_die("lseek(%"OFF_FMT"u)", offset);
-		bb_perror_msg_and_die("lseek");
+		bb_perror_msg_and_die("lseek(%"OFF_FMT"u, %d)", offset, whence);
 	}
 	return off;
 }
@@ -384,23 +382,23 @@
 // setgid() will fail and we'll _still_be_root_, which is bad.)
 void FAST_FUNC xsetgid(gid_t gid)
 {
-	if (setgid(gid)) bb_perror_msg_and_die("setgid");
+	if (setgid(gid)) bb_simple_perror_msg_and_die("setgid");
 }
 
 // Die with an error message if we can't set uid.  (See xsetgid() for why.)
 void FAST_FUNC xsetuid(uid_t uid)
 {
-	if (setuid(uid)) bb_perror_msg_and_die("setuid");
+	if (setuid(uid)) bb_simple_perror_msg_and_die("setuid");
 }
 
 void FAST_FUNC xsetegid(gid_t egid)
 {
-	if (setegid(egid)) bb_perror_msg_and_die("setegid");
+	if (setegid(egid)) bb_simple_perror_msg_and_die("setegid");
 }
 
 void FAST_FUNC xseteuid(uid_t euid)
 {
-	if (seteuid(euid)) bb_perror_msg_and_die("seteuid");
+	if (seteuid(euid)) bb_simple_perror_msg_and_die("seteuid");
 }
 
 // Die if we can't chdir to a new path.
@@ -413,7 +411,7 @@
 void FAST_FUNC xfchdir(int fd)
 {
 	if (fchdir(fd))
-		bb_perror_msg_and_die("fchdir");
+		bb_simple_perror_msg_and_die("fchdir");
 }
 
 void FAST_FUNC xchroot(const char *path)
@@ -463,7 +461,7 @@
 IF_FEATURE_IPV6(if (domain == AF_INET6) s = "INET6";)
 		bb_perror_msg_and_die("socket(AF_%s,%d,%d)", s, type, protocol);
 #else
-		bb_perror_msg_and_die("socket");
+		bb_simple_perror_msg_and_die("socket");
 #endif
 	}
 
@@ -473,13 +471,13 @@
 // Die with an error message if we can't bind a socket to an address.
 void FAST_FUNC xbind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen)
 {
-	if (bind(sockfd, my_addr, addrlen)) bb_perror_msg_and_die("bind");
+	if (bind(sockfd, my_addr, addrlen)) bb_simple_perror_msg_and_die("bind");
 }
 
 // Die with an error message if we can't listen for connections on a socket.
 void FAST_FUNC xlisten(int s, int backlog)
 {
-	if (listen(s, backlog)) bb_perror_msg_and_die("listen");
+	if (listen(s, backlog)) bb_simple_perror_msg_and_die("listen");
 }
 
 /* Die with an error message if sendto failed.
@@ -491,7 +489,7 @@
 	if (ret < 0) {
 		if (ENABLE_FEATURE_CLEAN_UP)
 			close(s);
-		bb_perror_msg_and_die("sendto");
+		bb_simple_perror_msg_and_die("sendto");
 	}
 	return ret;
 }
@@ -519,12 +517,12 @@
 #if ENABLE_SELINUX
 	int rc = is_selinux_enabled();
 	if (rc == 0) {
-		bb_error_msg_and_die("SELinux is disabled");
+		bb_simple_error_msg_and_die("SELinux is disabled");
 	} else if (rc < 0) {
-		bb_error_msg_and_die("is_selinux_enabled() failed");
+		bb_simple_error_msg_and_die("is_selinux_enabled() failed");
 	}
 #else
-	bb_error_msg_and_die("SELinux support is disabled");
+	bb_simple_error_msg_and_die("SELinux support is disabled");
 #endif
 }
 
@@ -675,7 +673,7 @@
 	pid_t pid;
 	pid = fork();
 	if (pid < 0) /* wtf? */
-		bb_perror_msg_and_die("vfork"+1);
+		bb_simple_perror_msg_and_die("vfork"+1);
 	return pid;
 }
 #endif
diff -Naur busybox-1.31.1/libbb/xgetcwd.c busybox-be5a505d/libbb/xgetcwd.c
--- busybox-1.31.1/libbb/xgetcwd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/xgetcwd.c	2019-10-24 07:26:55.000000000 -0700
@@ -33,7 +33,7 @@
 			if (errno == ERANGE)
 				continue;
 			free(cwd);
-			bb_perror_msg("getcwd");
+			bb_simple_perror_msg("getcwd");
 			return NULL;
 		}
 		cwd = xrealloc(cwd, strlen(cwd) + 1);
diff -Naur busybox-1.31.1/libbb/xgethostbyname.c busybox-be5a505d/libbb/xgethostbyname.c
--- busybox-1.31.1/libbb/xgethostbyname.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/xgethostbyname.c	2019-10-24 07:26:55.000000000 -0700
@@ -12,6 +12,6 @@
 {
 	struct hostent *retval = gethostbyname(name);
 	if (!retval)
-		bb_herror_msg_and_die("%s", name);
+		bb_simple_herror_msg_and_die(name);
 	return retval;
 }
diff -Naur busybox-1.31.1/libbb/xreadlink.c busybox-be5a505d/libbb/xreadlink.c
--- busybox-1.31.1/libbb/xreadlink.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/libbb/xreadlink.c	2019-10-24 07:26:55.000000000 -0700
@@ -147,6 +147,35 @@
 				buf[len++] = '/';
 				strcpy(buf + len, last_slash);
 			}
+		} else {
+			char *target = xmalloc_readlink(path);
+			if (target) {
+				char *cwd;
+				if (target[0] == '/') {
+					/*
+					 * $ ln -s /bin/qwe symlink  # note: /bin is a link to /usr/bin
+					 * $ readlink -f symlink
+					 * /usr/bin/qwe/target_does_not_exist
+					 * $ realpath symlink
+					 * /usr/bin/qwe/target_does_not_exist
+					 */
+					buf = xmalloc_realpath_coreutils(target);
+					free(target);
+					return buf;
+				}
+				/*
+				 * $ ln -s target_does_not_exist symlink
+				 * $ readlink -f symlink
+				 * /CURDIR/target_does_not_exist
+				 * $ realpath symlink
+				 * /CURDIR/target_does_not_exist
+				 */
+				cwd = xrealloc_getcwd_or_warn(NULL);
+				buf = concat_path_file(cwd, target);
+				free(cwd);
+				free(target);
+				return buf;
+			}
 		}
 	}
 
diff -Naur busybox-1.31.1/loginutils/addgroup.c busybox-be5a505d/loginutils/addgroup.c
--- busybox-1.31.1/loginutils/addgroup.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/loginutils/addgroup.c	2019-10-24 07:26:55.000000000 -0700
@@ -149,7 +149,7 @@
 
 	/* need to be root */
 	if (geteuid()) {
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 	}
 	/* Syntax:
 	 *  addgroup group
diff -Naur busybox-1.31.1/loginutils/adduser.c busybox-be5a505d/loginutils/adduser.c
--- busybox-1.31.1/loginutils/adduser.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/loginutils/adduser.c	2019-10-24 07:26:55.000000000 -0700
@@ -159,7 +159,7 @@
 static void passwd_wrapper(const char *login_name)
 {
 	BB_EXECLP("passwd", "passwd", "--", login_name, NULL);
-	bb_error_msg_and_die("can't execute passwd, you must set password manually");
+	bb_simple_error_msg_and_die("can't execute passwd, you must set password manually");
 }
 
 //FIXME: upstream adduser has no short options! NOT COMPATIBLE!
@@ -193,7 +193,7 @@
 
 	/* got root? */
 	if (geteuid()) {
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 	}
 
 	pw.pw_gecos = (char *)"Linux User,,,";
diff -Naur busybox-1.31.1/loginutils/chpasswd.c busybox-be5a505d/loginutils/chpasswd.c
--- busybox-1.31.1/loginutils/chpasswd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/loginutils/chpasswd.c	2019-10-24 07:26:55.000000000 -0700
@@ -63,7 +63,7 @@
 	int opt;
 
 	if (getuid() != 0)
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 
 	opt = getopt32long(argv, "^" "emc:R:" "\0" "m--ec:e--mc:c--em",
 			chpasswd_longopts,
@@ -81,7 +81,7 @@
 
 		pass = strchr(name, ':');
 		if (!pass)
-			bb_error_msg_and_die("missing new password");
+			bb_simple_error_msg_and_die("missing new password");
 		*pass++ = '\0';
 
 		xuname2uid(name); /* dies if there is no such user */
diff -Naur busybox-1.31.1/loginutils/deluser.c busybox-be5a505d/loginutils/deluser.c
--- busybox-1.31.1/loginutils/deluser.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/loginutils/deluser.c	2019-10-24 07:26:55.000000000 -0700
@@ -76,7 +76,7 @@
 #endif
 
 	if (geteuid() != 0)
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 
 	name = argv[1];
 	member = NULL;
diff -Naur busybox-1.31.1/loginutils/getty.c busybox-be5a505d/loginutils/getty.c
--- busybox-1.31.1/loginutils/getty.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/loginutils/getty.c	2019-10-24 07:26:55.000000000 -0700
@@ -168,7 +168,7 @@
 		/* note: arg "0" turns into speed B0 */
 		G.numspeed++;
 		if (G.numspeed > MAX_SPEED)
-			bb_error_msg_and_die("too many alternate speeds");
+			bb_simple_error_msg_and_die("too many alternate speeds");
 	}
 	debug("exiting parse_speeds\n");
 }
@@ -230,7 +230,7 @@
 		 * Make sure it is open for read/write.
 		 */
 		if ((fcntl(0, F_GETFL) & (O_RDWR|O_RDONLY|O_WRONLY)) != O_RDWR)
-			bb_error_msg_and_die("stdin is not open for read/write");
+			bb_simple_error_msg_and_die("stdin is not open for read/write");
 
 		/* Try to get real tty name instead of "-" */
 		n = xmalloc_ttyname(0);
@@ -243,7 +243,7 @@
 static void set_tty_attrs(void)
 {
 	if (tcsetattr_stdin_TCSANOW(&G.tty_attrs) < 0)
-		bb_perror_msg_and_die("tcsetattr");
+		bb_simple_perror_msg_and_die("tcsetattr");
 }
 
 /* We manipulate tty_attrs this way:
@@ -485,7 +485,7 @@
 				finalize_tty_attrs();
 				if (errno == EINTR || errno == EIO)
 					exit(EXIT_SUCCESS);
-				bb_perror_msg_and_die(bb_msg_read_error);
+				bb_simple_perror_msg_and_die(bb_msg_read_error);
 			}
 
 			switch (c) {
@@ -582,7 +582,7 @@
 			//	" sid %d pgid %d",
 			//	pid, getppid(),
 			//	getsid(0), getpgid(0));
-			bb_perror_msg_and_die("setsid");
+			bb_simple_perror_msg_and_die("setsid");
 			/*
 			 * When we can end up here?
 			 * Example: setsid() fails when run alone in interactive shell:
@@ -651,13 +651,13 @@
 	tsid = tcgetsid(STDIN_FILENO);
 	if (tsid < 0 || pid != tsid) {
 		if (ioctl(STDIN_FILENO, TIOCSCTTY, /*force:*/ (long)1) < 0)
-			bb_perror_msg_and_die("TIOCSCTTY");
+			bb_simple_perror_msg_and_die("TIOCSCTTY");
 	}
 
 #ifdef __linux__
 	/* Make ourself a foreground process group within our session */
 	if (tcsetpgrp(STDIN_FILENO, pid) < 0)
-		bb_perror_msg_and_die("tcsetpgrp");
+		bb_simple_perror_msg_and_die("tcsetpgrp");
 #endif
 
 	/*
@@ -669,7 +669,7 @@
 	 * 5 seconds seems to be a good value.
 	 */
 	if (tcgetattr(STDIN_FILENO, &G.tty_attrs) < 0)
-		bb_perror_msg_and_die("tcgetattr");
+		bb_simple_perror_msg_and_die("tcgetattr");
 
 	/* Update the utmp file. This tty is ours now! */
 	update_utmp(pid, LOGIN_PROCESS, G.tty_name, "LOGIN", G.fakehost);
diff -Naur busybox-1.31.1/loginutils/login.c busybox-be5a505d/loginutils/login.c
--- busybox-1.31.1/loginutils/login.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/loginutils/login.c	2019-10-24 07:26:55.000000000 -0700
@@ -358,7 +358,7 @@
 	opt = getopt32(argv, "f:h:p", &opt_user, &opt_host);
 	if (opt & LOGIN_OPT_f) {
 		if (!run_by_root)
-			bb_error_msg_and_die("-f is for root only");
+			bb_simple_error_msg_and_die("-f is for root only");
 		safe_strncpy(username, opt_user, sizeof(username));
 	}
 	argv += optind;
@@ -529,7 +529,7 @@
 	child_pid = vfork();
 	if (child_pid != 0) {
 		if (child_pid < 0)
-			bb_perror_msg("vfork");
+			bb_simple_perror_msg("vfork");
 		else {
 			wait_for_exitstatus(child_pid);
 			update_utmp_DEAD_PROCESS(child_pid);
diff -Naur busybox-1.31.1/loginutils/su.c busybox-be5a505d/loginutils/su.c
--- busybox-1.31.1/loginutils/su.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/loginutils/su.c	2019-10-24 07:26:55.000000000 -0700
@@ -147,7 +147,7 @@
 			syslog(LOG_NOTICE, "%c %s %s:%s",
 				'-', tty, old_user, opt_username);
 		bb_do_delay(LOGIN_FAIL_DELAY);
-		bb_error_msg_and_die("incorrect password");
+		bb_simple_error_msg_and_die("incorrect password");
 	}
 
 	if (ENABLE_FEATURE_CLEAN_UP && ENABLE_FEATURE_SU_SYSLOG) {
@@ -165,7 +165,7 @@
 		 * probably a uucp account or has restricted access.  Don't
 		 * compromise the account by allowing access with a standard
 		 * shell.  */
-		bb_error_msg("using restricted shell");
+		bb_simple_error_msg("using restricted shell");
 		opt_shell = NULL; /* ignore -s PROG */
 	}
 	/* else: user can run whatever he wants via "su -s PROG USER".
diff -Naur busybox-1.31.1/loginutils/sulogin.c busybox-be5a505d/loginutils/sulogin.c
--- busybox-1.31.1/loginutils/sulogin.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/loginutils/sulogin.c	2019-10-24 07:26:55.000000000 -0700
@@ -56,7 +56,7 @@
 
 	pwd = getpwuid(0);
 	if (!pwd) {
-		bb_error_msg_and_die("no password entry for root");
+		bb_simple_error_msg_and_die("no password entry for root");
 	}
 
 	while (1) {
@@ -68,17 +68,17 @@
 		);
 		if (r < 0) {
 			/* ^D, ^C, timeout, or read error */
-			bb_info_msg("normal startup");
+			bb_simple_info_msg("normal startup");
 			return 0;
 		}
 		if (r > 0) {
 			break;
 		}
 		bb_do_delay(LOGIN_FAIL_DELAY);
-		bb_info_msg("Login incorrect");
+		bb_simple_info_msg("Login incorrect");
 	}
 
-	bb_info_msg("starting shell for system maintenance");
+	bb_simple_info_msg("starting shell for system maintenance");
 
 	IF_SELINUX(renew_current_security_context());
 
diff -Naur busybox-1.31.1/mailutils/mail.c busybox-be5a505d/mailutils/mail.c
--- busybox-1.31.1/mailutils/mail.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/mailutils/mail.c	2019-10-24 07:26:55.000000000 -0700
@@ -15,7 +15,7 @@
 {
 #define err signo
 	if (SIGALRM == signo) {
-		bb_error_msg_and_die("timed out");
+		bb_simple_error_msg_and_die("timed out");
 	}
 
 	// SIGCHLD. reap zombies
@@ -128,7 +128,7 @@
 		if (fname) {
 			size = fread((char *)src_buf, 1, SRC_BUF_SIZE, fp);
 			if ((ssize_t)size < 0)
-				bb_perror_msg_and_die(bb_msg_read_error);
+				bb_simple_perror_msg_and_die(bb_msg_read_error);
 		} else {
 			size = len;
 			if (len > SRC_BUF_SIZE)
@@ -179,5 +179,5 @@
 		G.pass = xmalloc_reads(fd, /* maxsize: */ NULL);
 	}
 	if (!G.user || !*G.user || !G.pass)
-		bb_error_msg_and_die("no username or password");
+		bb_simple_error_msg_and_die("no username or password");
 }
diff -Naur busybox-1.31.1/mailutils/popmaildir.c busybox-be5a505d/mailutils/popmaildir.c
--- busybox-1.31.1/mailutils/popmaildir.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/mailutils/popmaildir.c	2019-10-24 07:26:55.000000000 -0700
@@ -222,7 +222,7 @@
 			fp = popen(delivery, "w");
 			unsetenv("FILENAME");
 			if (!fp) {
-				bb_perror_msg("delivery helper");
+				bb_simple_perror_msg("delivery helper");
 				break;
 			}
 		} else
diff -Naur busybox-1.31.1/mailutils/sendmail.c busybox-be5a505d/mailutils/sendmail.c
--- busybox-1.31.1/mailutils/sendmail.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/mailutils/sendmail.c	2019-10-24 07:26:55.000000000 -0700
@@ -338,7 +338,7 @@
 			smtp_check(NULL, 250);
 		else
 		if (code != 250)
-			bb_error_msg_and_die("SMTP init failed");
+			bb_simple_error_msg_and_die("SMTP init failed");
 	} else {
 		// vanilla connection
 		int fd;
diff -Naur busybox-1.31.1/Makefile busybox-be5a505d/Makefile
--- busybox-1.31.1/Makefile	2019-10-25 01:44:52.000000000 -0700
+++ busybox-be5a505d/Makefile	2019-10-24 07:26:55.000000000 -0700
@@ -1,7 +1,7 @@
 VERSION = 1
-PATCHLEVEL = 31
-SUBLEVEL = 1
-EXTRAVERSION =
+PATCHLEVEL = 32
+SUBLEVEL = 0
+EXTRAVERSION = .git
 NAME = Unnamed
 
 # *DOCUMENTATION*
diff -Naur busybox-1.31.1/Makefile.flags busybox-be5a505d/Makefile.flags
--- busybox-1.31.1/Makefile.flags	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/Makefile.flags	2019-10-24 07:26:55.000000000 -0700
@@ -129,10 +129,12 @@
 # fall back to using a temp file:
 CRYPT_AVAILABLE := $(shell echo 'int main(void){return 0;}' >crypttest.c; $(CC) $(CFLAGS) -lcrypt -o /dev/null crypttest.c >/dev/null 2>&1 && echo "y"; rm crypttest.c)
 ifeq ($(CRYPT_AVAILABLE),y)
-LDLIBS += m crypt
+LDLIBS += m rt crypt
 else
-LDLIBS += m
+LDLIBS += m rt
 endif
+# libm may be needed for dc, awk, ntpd
+# librt may be needed for clock_gettime()
 
 # libpam may use libpthread, libdl and/or libaudit.
 # On some platforms that requires an explicit -lpthread, -ldl, -laudit.
diff -Naur busybox-1.31.1/miscutils/bc.c busybox-be5a505d/miscutils/bc.c
--- busybox-1.31.1/miscutils/bc.c	2019-10-21 07:54:40.000000000 -0700
+++ busybox-be5a505d/miscutils/bc.c	2019-10-24 07:26:55.000000000 -0700
@@ -844,10 +844,10 @@
 # error Strange INT_MAX
 #endif
 
-#if UINT_MAX == 4294967295
+#if UINT_MAX == 4294967295U
 # define BC_MAX_SCALE_STR  "4294967295"
 # define BC_MAX_STRING_STR "4294967294"
-#elif UINT_MAX == 18446744073709551615
+#elif UINT_MAX == 18446744073709551615U
 # define BC_MAX_SCALE_STR  "18446744073709551615"
 # define BC_MAX_STRING_STR "18446744073709551614"
 #else
@@ -893,7 +893,7 @@
 {
 	fflush_all();
 	if (ferror(stdout) || ferror(stderr))
-		bb_perror_msg_and_die("output error");
+		bb_simple_perror_msg_and_die("output error");
 }
 
 #if ENABLE_FEATURE_CLEAN_UP
@@ -908,7 +908,7 @@
 static void quit(void)
 {
 	if (ferror(stdin))
-		bb_perror_msg_and_die("input error");
+		bb_simple_perror_msg_and_die("input error");
 	fflush_and_check();
 	dbg_exec("quit(): exiting with exitcode SUCCESS");
 	exit(0);
@@ -2576,7 +2576,7 @@
 				goto get_char;
 			if (c == EOF) {
 				if (ferror(fp))
-					bb_perror_msg_and_die("input error");
+					bb_simple_perror_msg_and_die("input error");
 				// Note: EOF does not append '\n'
 				break;
 			}
@@ -6934,9 +6934,9 @@
 		ip = (void*)G.prog.exestack.v;
 #if SANITY_CHECKS
 		if (G.prog.exestack.len != 1) // should have only main's IP
-			bb_error_msg_and_die("BUG:call stack");
+			bb_simple_error_msg_and_die("BUG:call stack");
 		if (ip->func != BC_PROG_MAIN)
-			bb_error_msg_and_die("BUG:not MAIN");
+			bb_simple_error_msg_and_die("BUG:not MAIN");
 #endif
 		f = xc_program_func_BC_PROG_MAIN();
 		// bc discards strings, constants and code after each
@@ -6952,7 +6952,7 @@
 		if (IS_BC) {
 #if SANITY_CHECKS
 			if (G.prog.results.len != 0) // should be empty
-				bb_error_msg_and_die("BUG:data stack");
+				bb_simple_error_msg_and_die("BUG:data stack");
 #endif
 			IF_BC(bc_vec_pop_all(&f->strs);)
 			IF_BC(bc_vec_pop_all(&f->consts);)
diff -Naur busybox-1.31.1/miscutils/chat.c busybox-be5a505d/miscutils/chat.c
--- busybox-1.31.1/miscutils/chat.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/chat.c	2019-10-24 07:26:55.000000000 -0700
@@ -307,7 +307,7 @@
 			} else if (DIR_SAY == key) {
 				// just print argument verbatim
 				// TODO: should we use full_write() to avoid unistd/stdio conflict?
-				bb_error_msg("%s", arg);
+				bb_simple_error_msg(arg);
 			}
 			// next, please!
 			argv++;
diff -Naur busybox-1.31.1/miscutils/crond.c busybox-be5a505d/miscutils/crond.c
--- busybox-1.31.1/miscutils/crond.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/crond.c	2019-10-24 07:26:55.000000000 -0700
@@ -731,7 +731,7 @@
 	logmode = sv_logmode;
 
 	if (pid < 0) {
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
  err:
 		pid = 0;
 	} /* else: PARENT, FORK SUCCESS */
@@ -861,7 +861,7 @@
 		bb_error_msg_and_die("can't execute '%s' for user %s", shell, user);
 	}
 	if (pid < 0) {
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
  err:
 		pid = 0;
 	}
diff -Naur busybox-1.31.1/miscutils/crontab.c busybox-be5a505d/miscutils/crontab.c
--- busybox-1.31.1/miscutils/crontab.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/crontab.c	2019-10-24 07:26:55.000000000 -0700
@@ -107,7 +107,7 @@
 	if (sanitize_env_if_suid()) { /* Clears dangerous stuff, sets PATH */
 		/* Run by non-root */
 		if (opt_ler & (OPT_u|OPT_c))
-			bb_error_msg_and_die(bb_msg_you_must_be_root);
+			bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 	}
 
 	if (opt_ler & OPT_u) {
diff -Naur busybox-1.31.1/miscutils/dc.c busybox-be5a505d/miscutils/dc.c
--- busybox-1.31.1/miscutils/dc.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/dc.c	2019-10-24 07:26:55.000000000 -0700
@@ -39,14 +39,14 @@
 {
 	unsigned p = pointer;
 	if (p == 0)
-		bb_error_msg_and_die("stack underflow");
+		bb_simple_error_msg_and_die("stack underflow");
 	return p - 1;
 }
 
 static void push(double a)
 {
 	if (pointer >= STACK_SIZE)
-		bb_error_msg_and_die("stack overflow");
+		bb_simple_error_msg_and_die("stack overflow");
 	stack[pointer++] = a;
 }
 
diff -Naur busybox-1.31.1/miscutils/devfsd.c busybox-be5a505d/miscutils/devfsd.c
--- busybox-1.31.1/miscutils/devfsd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/devfsd.c	2019-10-24 07:26:55.000000000 -0700
@@ -344,14 +344,19 @@
 /* Busybox stuff */
 #if ENABLE_DEVFSD_VERBOSE || ENABLE_DEBUG
 #define info_logger(p, fmt, args...)                 bb_info_msg(fmt, ## args)
+#define simple_info_logger(p, msg)                   bb_simple_info_msg(msg)
 #define msg_logger(p, fmt, args...)                  bb_error_msg(fmt, ## args)
+#define simple_msg_logger(p, msg)                    bb_simple_error_msg(msg)
 #define msg_logger_and_die(p, fmt, args...)          bb_error_msg_and_die(fmt, ## args)
+#define simple_msg_logger_and_die(p, msg)            bb_simple_error_msg_and_die(msg)
 #define error_logger(p, fmt, args...)                bb_perror_msg(fmt, ## args)
 #define error_logger_and_die(p, fmt, args...)        bb_perror_msg_and_die(fmt, ## args)
 #else
 #define info_logger(p, fmt, args...)
 #define msg_logger(p, fmt, args...)
+#define simple_msg_logger(p, msg)
 #define msg_logger_and_die(p, fmt, args...)           exit(EXIT_FAILURE)
+#define simple_msg_logger_and_die(p, msg)             exit(EXIT_FAILURE)
 #define error_logger(p, fmt, args...)
 #define error_logger_and_die(p, fmt, args...)         exit(EXIT_FAILURE)
 #endif
@@ -727,7 +732,7 @@
 		caught_sighup = FALSE;
 		return c_sighup;
 	}
-	msg_logger_and_die(LOG_ERR, "read error on control file");
+	simple_msg_logger_and_die(LOG_ERR, "read error on control file");
 }   /*  End Function do_servicing  */
 
 static void service_name(const struct devfsd_notify_struct *info)
@@ -786,7 +791,7 @@
 				action_compat(info, entry->action.what);
 				break;
 			default:
-				msg_logger_and_die(LOG_ERR, "Unknown action");
+				simple_msg_logger_and_die(LOG_ERR, "Unknown action");
 		}
 	}
 }   /*  End Function service_name  */
@@ -1691,7 +1696,7 @@
 	}
 	return FALSE;
 st_expr_expand_out:
-	info_logger(LOG_INFO, bb_msg_small_buffer);
+	simple_info_logger(LOG_INFO, bb_msg_small_buffer);
 	return FALSE;
 }   /*  End Function st_expr_expand  */
 
@@ -1775,7 +1780,7 @@
 		return input + len;
 	}
 	if (ch != ':' || ptr[1] != '-') {
-		info_logger(LOG_INFO, "illegal char in var name");
+		simple_info_logger(LOG_INFO, "illegal char in var name");
 		return NULL;
 	}
 	/*  It's that handy "${var:-word}" expression. Check if var is defined  */
@@ -1838,7 +1843,7 @@
 	*out_pos += len;
 	return input;
 expand_variable_out:
-	info_logger(LOG_INFO, bb_msg_small_buffer);
+	simple_info_logger(LOG_INFO, bb_msg_small_buffer);
 	return NULL;
 }   /*  End Function expand_variable  */
 
diff -Naur busybox-1.31.1/miscutils/devmem.c busybox-be5a505d/miscutils/devmem.c
--- busybox-1.31.1/miscutils/devmem.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/devmem.c	2019-10-24 07:26:55.000000000 -0700
@@ -89,7 +89,7 @@
 			fd,
 			target & ~(off_t)(page_size - 1));
 	if (map_base == MAP_FAILED)
-		bb_perror_msg_and_die("mmap");
+		bb_simple_perror_msg_and_die("mmap");
 
 //	printf("Memory mapped at address %p.\n", map_base);
 
@@ -110,7 +110,7 @@
 			read_result = *(volatile uint64_t*)virt_addr;
 			break;
 		default:
-			bb_error_msg_and_die("bad width");
+			bb_simple_error_msg_and_die("bad width");
 		}
 //		printf("Value at address 0x%"OFF_FMT"X (%p): 0x%llX\n",
 //			target, virt_addr,
@@ -136,7 +136,7 @@
 //			read_result = *(volatile uint64_t*)virt_addr;
 			break;
 		default:
-			bb_error_msg_and_die("bad width");
+			bb_simple_error_msg_and_die("bad width");
 		}
 //		printf("Written 0x%llX; readback 0x%llX\n",
 //				(unsigned long long)writeval,
@@ -145,7 +145,7 @@
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		if (munmap(map_base, mapped_size) == -1)
-			bb_perror_msg_and_die("munmap");
+			bb_simple_perror_msg_and_die("munmap");
 		close(fd);
 	}
 
diff -Naur busybox-1.31.1/miscutils/fbsplash.c busybox-be5a505d/miscutils/fbsplash.c
--- busybox-1.31.1/miscutils/fbsplash.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/fbsplash.c	2019-10-24 07:26:55.000000000 -0700
@@ -183,7 +183,7 @@
 			(G.scr_var.yres_virtual ?: G.scr_var.yres) * G.scr_fix.line_length,
 			PROT_WRITE, MAP_SHARED, fbfd, 0);
 	if (G.addr == MAP_FAILED)
-		bb_perror_msg_and_die("mmap");
+		bb_simple_perror_msg_and_die("mmap");
 
 	// point to the start of the visible screen
 	G.addr += G.scr_var.yoffset * G.scr_fix.line_length + G.scr_var.xoffset * G.bytes_per_pixel;
diff -Naur busybox-1.31.1/miscutils/flash_eraseall.c busybox-be5a505d/miscutils/flash_eraseall.c
--- busybox-1.31.1/miscutils/flash_eraseall.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/flash_eraseall.c	2019-10-24 07:26:55.000000000 -0700
@@ -120,7 +120,7 @@
 				if (clmlen > 8)
 					clmlen = 8;
 				if (clmlen == 0)
-					bb_error_msg_and_die("autoplacement selected and no empty space in oob");
+					bb_simple_error_msg_and_die("autoplacement selected and no empty space in oob");
 			} else {
 				/* Legacy mode */
 				switch (meminfo.oobsize) {
@@ -168,9 +168,9 @@
 				if (errno == EOPNOTSUPP) {
 					flags |= OPTION_N;
 					if (flags & IS_NAND)
-						bb_error_msg_and_die("bad block check not available");
+						bb_simple_error_msg_and_die("bad block check not available");
 				} else {
-					bb_perror_msg_and_die("MEMGETBADBLOCK error");
+					bb_simple_perror_msg_and_die("MEMGETBADBLOCK error");
 				}
 			}
 		}
diff -Naur busybox-1.31.1/miscutils/hdparm.c busybox-be5a505d/miscutils/hdparm.c
--- busybox-1.31.1/miscutils/hdparm.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/hdparm.c	2019-10-24 07:26:55.000000000 -0700
@@ -810,7 +810,7 @@
 		like_std = 3;
 	} else
 		/* "Unknown device type:\n\tbits 15&14 of general configuration word 0 both set to 1.\n" */
-		bb_error_msg_and_die("unknown device type");
+		bb_simple_error_msg_and_die("unknown device type");
 
 	printf("%sremovable media\n", !(val[GEN_CONFIG] & MEDIA_REMOVABLE) ? "non-" : "");
 	/* Info from the specific configuration word says whether or not the
@@ -1440,7 +1440,7 @@
 	sleep(1);
 	if (ioctl(fd, HDIO_DRIVE_CMD, NULL) && errno != EINVAL) {	/* await completion */
 		if (ENABLE_IOCTL_HEX2STR_ERROR) /* To be coherent with ioctl_or_warn */
-			bb_perror_msg("HDIO_DRIVE_CMD");
+			bb_simple_perror_msg("HDIO_DRIVE_CMD");
 		else
 			bb_perror_msg("ioctl %#x failed", HDIO_DRIVE_CMD);
 	}
@@ -1506,7 +1506,7 @@
 	char *buf = xmalloc(TIMING_BUF_BYTES);
 
 	if (mlock(buf, TIMING_BUF_BYTES))
-		bb_perror_msg_and_die("mlock");
+		bb_simple_perror_msg_and_die("mlock");
 
 	/* Clear out the device request queues & give them time to complete.
 	 * NB: *small* delay. User is expected to have a clue and to not run
@@ -1857,7 +1857,7 @@
 		char buf[512];
 		flush_buffer_cache();
 		if (-1 == read(fd, buf, sizeof(buf)))
-			bb_perror_msg("read of 512 bytes failed");
+			bb_simple_perror_msg("read of 512 bytes failed");
 	}
 #endif  /* HDIO_DRIVE_CMD */
 	if (getset_mult || get_identity) {
@@ -1865,7 +1865,7 @@
 		if (ioctl(fd, HDIO_GET_MULTCOUNT, &multcount)) {
 			/* To be coherent with ioctl_or_warn. */
 			if (getset_mult && ENABLE_IOCTL_HEX2STR_ERROR)
-				bb_perror_msg("HDIO_GET_MULTCOUNT");
+				bb_simple_perror_msg("HDIO_GET_MULTCOUNT");
 			else
 				bb_perror_msg("ioctl %#x failed", HDIO_GET_MULTCOUNT);
 		} else if (getset_mult) {
@@ -1985,7 +1985,7 @@
 		} else if (errno == -ENOMSG)
 			puts(" no identification info available");
 		else if (ENABLE_IOCTL_HEX2STR_ERROR)  /* To be coherent with ioctl_or_warn */
-			bb_perror_msg("HDIO_GET_IDENTITY");
+			bb_simple_perror_msg("HDIO_GET_IDENTITY");
 		else
 			bb_perror_msg("ioctl %#x failed", HDIO_GET_IDENTITY);
 	}
diff -Naur busybox-1.31.1/miscutils/hexedit.c busybox-be5a505d/miscutils/hexedit.c
--- busybox-1.31.1/miscutils/hexedit.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/hexedit.c	2019-10-24 07:26:55.000000000 -0700
@@ -193,7 +193,7 @@
 	);
 	if (G.baseaddr == MAP_FAILED) {
 		restore_term();
-		bb_perror_msg_and_die("mmap");
+		bb_simple_perror_msg_and_die("mmap");
 	}
 
 	G.current_byte = G.baseaddr + cur_pos;
diff -Naur busybox-1.31.1/miscutils/i2c_tools.c busybox-be5a505d/miscutils/i2c_tools.c
--- busybox-1.31.1/miscutils/i2c_tools.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/i2c_tools.c	2019-10-24 07:26:55.000000000 -0700
@@ -344,7 +344,7 @@
 static void check_funcs_test_end(int funcs, int pec, const char *err)
 {
 	if (pec && !(funcs & (I2C_FUNC_SMBUS_PEC | I2C_FUNC_I2C)))
-		bb_error_msg("warning: adapter does not support PEC");
+		bb_simple_error_msg("warning: adapter does not support PEC");
 
 	if (err)
 		bb_error_msg_and_die(
@@ -392,7 +392,7 @@
 		break;
 #endif /* ENABLE_I2CDUMP */
 	default:
-		bb_error_msg_and_die("internal error");
+		bb_simple_error_msg_and_die("internal error");
 	}
 	check_funcs_test_end(funcs, pec, err);
 }
@@ -438,7 +438,7 @@
 {
 	fprintf(stderr, "Continue? [y/N] ");
 	if (!bb_ask_y_confirmation())
-		bb_error_msg_and_die("aborting");
+		bb_simple_error_msg_and_die("aborting");
 }
 
 /*
@@ -449,20 +449,20 @@
  */
 static void confirm_action(int bus_addr, int mode, int data_addr, int pec)
 {
-	bb_error_msg("WARNING! This program can confuse your I2C bus");
+	bb_simple_error_msg("WARNING! This program can confuse your I2C bus");
 
 	/* Don't let the user break his/her EEPROMs */
 	if (bus_addr >= 0x50 && bus_addr <= 0x57 && pec) {
-		bb_error_msg_and_die("this is I2C not smbus - using PEC on I2C "
+		bb_simple_error_msg_and_die("this is I2C not smbus - using PEC on I2C "
 			"devices may result in data loss, aborting");
 	}
 
 	if (mode == I2C_SMBUS_BYTE && data_addr >= 0 && pec)
-		bb_error_msg("WARNING! May interpret a write byte command "
+		bb_simple_error_msg("WARNING! May interpret a write byte command "
 			"with PEC as a write byte data command");
 
 	if (pec)
-		bb_error_msg("PEC checking enabled");
+		bb_simple_error_msg("PEC checking enabled");
 
 	confirm_or_abort();
 }
@@ -507,7 +507,7 @@
 			case 'w':	mode = I2C_SMBUS_WORD_DATA;	break;
 			case 'c':	mode = I2C_SMBUS_BYTE;		break;
 			default:
-				bb_error_msg("invalid mode");
+				bb_simple_error_msg("invalid mode");
 				bb_show_usage();
 			}
 			pec = argv[3][1] == 'p';
@@ -529,7 +529,7 @@
 		if (data_addr >= 0) {
 			status = i2c_smbus_write_byte(fd, data_addr);
 			if (status < 0)
-				bb_error_msg("warning - write failed");
+				bb_simple_error_msg("warning - write failed");
 		}
 		status = i2c_smbus_read_byte(fd);
 		break;
@@ -542,7 +542,7 @@
 	close(fd);
 
 	if (status < 0)
-		bb_perror_msg_and_die("read failed");
+		bb_simple_perror_msg_and_die("read failed");
 
 	printf("0x%0*x\n", mode == I2C_SMBUS_WORD_DATA ? 4 : 2, status);
 
@@ -611,7 +611,7 @@
 			case 'i': mode = I2C_SMBUS_I2C_BLOCK_DATA;
 				break;
 			default:
-				bb_error_msg("invalid mode");
+				bb_simple_error_msg("invalid mode");
 				bb_show_usage();
 			}
 
@@ -620,11 +620,11 @@
 			 || mode == I2C_SMBUS_I2C_BLOCK_DATA
 			) {
 				if (pec && mode == I2C_SMBUS_I2C_BLOCK_DATA)
-					bb_error_msg_and_die(
+					bb_simple_error_msg_and_die(
 						"PEC not supported for I2C "
 						"block writes");
 				if (opts & opt_m)
-					bb_error_msg_and_die(
+					bb_simple_error_msg_and_die(
 						"mask not supported for block "
 						"writes");
 			}
@@ -685,7 +685,7 @@
 		}
 
 		if (tmpval < 0)
-			bb_perror_msg_and_die("can't read old value");
+			bb_simple_perror_msg_and_die("can't read old value");
 
 		val = (val & mask) | (tmpval & ~mask);
 
@@ -724,7 +724,7 @@
 		break;
 	}
 	if (status < 0)
-		bb_perror_msg_and_die("write failed");
+		bb_simple_perror_msg_and_die("write failed");
 
 	if (pec)
 		i2c_set_pec(fd, 0); /* Clear PEC. */
@@ -978,12 +978,12 @@
 		case 's': mode = I2C_SMBUS_BLOCK_DATA;		break;
 		case 'i': mode = I2C_SMBUS_I2C_BLOCK_DATA;	break;
 		default:
-			bb_error_msg_and_die("invalid mode");
+			bb_simple_error_msg_and_die("invalid mode");
 		}
 
 		if (argv[2][1] == 'p') {
 			if (argv[2][0] == 'W' || argv[2][0] == 'i') {
-				bb_error_msg_and_die(
+				bb_simple_error_msg_and_die(
 					"pec not supported for -W and -i");
 			} else {
 				pec = 1;
@@ -994,7 +994,7 @@
 	if (opts & opt_r) {
 		first = strtol(opt_r_str, &dash, 0);
 		if (dash == opt_r_str || *dash != '-' || first > 0xff)
-			bb_error_msg_and_die("invalid range");
+			bb_simple_error_msg_and_die("invalid range");
 		last = xstrtou_range(++dash, 0, first, 0xff);
 
 		/* Range is not available for every mode. */
@@ -1007,7 +1007,7 @@
 				break;
 			/* Fall through */
 		default:
-			bb_error_msg_and_die(
+			bb_simple_error_msg_and_die(
 				"range not compatible with selected mode");
 		}
 	}
@@ -1032,7 +1032,7 @@
 		if (mode == I2C_SMBUS_BYTE) {
 			res = i2c_smbus_write_byte(fd, first);
 			if (res < 0)
-				bb_perror_msg_and_die("write start address");
+				bb_simple_perror_msg_and_die("write start address");
 		}
 
 		dump_data(fd, mode, first, last, block, blen);
@@ -1398,7 +1398,7 @@
 	get_funcs_matrix(fd, &funcs);
 
 	if (!(funcs & I2C_FUNC_I2C))
-		bb_error_msg_and_die("adapter does not support I2C transfers");
+		bb_simple_error_msg_and_die("adapter does not support I2C transfers");
 }
 
 //usage:#define i2ctransfer_trivial_usage
@@ -1451,7 +1451,7 @@
 		char *end;
 
 		if (nmsgs >= I2C_RDWR_IOCTL_MAX_MSGS)
-			bb_error_msg_and_die("too many messages, max: "I2C_RDWR_IOCTL_MAX_MSGS_STR);
+			bb_simple_error_msg_and_die("too many messages, max: "I2C_RDWR_IOCTL_MAX_MSGS_STR);
 
 		flags = 0;
 		arg_ptr = *argv;
diff -Naur busybox-1.31.1/miscutils/inotifyd.c busybox-be5a505d/miscutils/inotifyd.c
--- busybox-1.31.1/miscutils/inotifyd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/inotifyd.c	2019-10-24 07:26:55.000000000 -0700
@@ -117,7 +117,7 @@
 	// open inotify
 	pfd.fd = inotify_init();
 	if (pfd.fd < 0)
-		bb_perror_msg_and_die("no kernel support");
+		bb_simple_perror_msg_and_die("no kernel support");
 
 	// setup watches
 	while (*++argv) {
diff -Naur busybox-1.31.1/miscutils/nandwrite.c busybox-be5a505d/miscutils/nandwrite.c
--- busybox-1.31.1/miscutils/nandwrite.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/nandwrite.c	2019-10-24 07:26:55.000000000 -0700
@@ -101,7 +101,7 @@
 
 		if (block_offset >= meminfo->size) {
 			if (IS_NANDWRITE)
-				bb_error_msg_and_die("not enough space in MTD device");
+				bb_simple_error_msg_and_die("not enough space in MTD device");
 			return block_offset; /* let the caller exit */
 		}
 		offs = block_offset;
@@ -174,7 +174,7 @@
 	meminfo_writesize = meminfo.writesize;
 
 	if (mtdoffset & (meminfo_writesize - 1))
-		bb_error_msg_and_die("start address is not page aligned");
+		bb_simple_error_msg_and_die("start address is not page aligned");
 
 	filebuf = xmalloc(meminfo_writesize);
 	oobbuf = xmalloc(meminfo.oobsize);
@@ -248,9 +248,9 @@
 		}
 		if (cnt < meminfo_writesize) {
 			if (IS_NANDDUMP)
-				bb_error_msg_and_die("short read");
+				bb_simple_error_msg_and_die("short read");
 			if (!(opts & OPT_p))
-				bb_error_msg_and_die("input size is not rounded up to page size, "
+				bb_simple_error_msg_and_die("input size is not rounded up to page size, "
 						"use -p to zero pad");
 			/* zero pad to end of write block */
 			memset(filebuf + cnt, 0, meminfo_writesize - cnt);
@@ -273,7 +273,7 @@
 		/* We filled entire MTD, but did we reach EOF on input? */
 		if (full_read(STDIN_FILENO, filebuf, meminfo_writesize) != 0) {
 			/* no */
-			bb_error_msg_and_die("not enough space in MTD device");
+			bb_simple_error_msg_and_die("not enough space in MTD device");
 		}
 	}
 
diff -Naur busybox-1.31.1/miscutils/rfkill.c busybox-be5a505d/miscutils/rfkill.c
--- busybox-1.31.1/miscutils/rfkill.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/rfkill.c	2019-10-24 07:26:55.000000000 -0700
@@ -88,7 +88,7 @@
 
 	rf_fd = device_open("/dev/rfkill", mode);
 	if (rf_fd < 0)
-		bb_perror_msg_and_die("/dev/rfkill");
+		bb_simple_perror_msg_and_die("/dev/rfkill");
 
 	if (rf_opt & OPT_l) {
 		while (full_read(rf_fd, &event, sizeof(event)) == RFKILL_EVENT_SIZE_V1) {
diff -Naur busybox-1.31.1/miscutils/rx.c busybox-be5a505d/miscutils/rx.c
--- busybox-1.31.1/miscutils/rx.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/rx.c	2019-10-24 07:26:55.000000000 -0700
@@ -120,7 +120,7 @@
 		/* Write previously received block */
 		errno = 0;
 		if (full_write(file_fd, blockBuf, blockLength) != blockLength) {
-			bb_perror_msg(bb_msg_write_error);
+			bb_simple_perror_msg(bb_msg_write_error);
 			goto fatal;
 		}
 
@@ -150,7 +150,7 @@
 			goto timeout;
 
 		if (blockNo != (255 - blockNoOnesCompl)) {
-			bb_error_msg("bad block ones compl");
+			bb_simple_error_msg("bad block ones compl");
 			goto error;
 		}
 
@@ -229,7 +229,7 @@
 				do_crc = 0;
 				goto timeout;
 			}
-			bb_error_msg("too many errors; giving up");
+			bb_simple_error_msg("too many errors; giving up");
  fatal:
 			/* 5 CAN followed by 5 BS. Don't try too hard... */
 			safe_write(write_fd, "\030\030\030\030\030\010\010\010\010\010", 10);
diff -Naur busybox-1.31.1/miscutils/time.c busybox-be5a505d/miscutils/time.c
--- busybox-1.31.1/miscutils/time.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/time.c	2019-10-24 07:26:55.000000000 -0700
@@ -88,7 +88,7 @@
 	 * returns the child process, set the time the command finished. */
 	while ((caught = wait3(&resp->waitstatus, 0, &resp->ru)) != pid) {
 		if (caught == -1 && errno != EINTR) {
-			bb_perror_msg("wait");
+			bb_simple_perror_msg("wait");
 			return;
 		}
 	}
diff -Naur busybox-1.31.1/miscutils/ubirename.c busybox-be5a505d/miscutils/ubirename.c
--- busybox-1.31.1/miscutils/ubirename.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/ubirename.c	2019-10-24 07:26:55.000000000 -0700
@@ -72,7 +72,7 @@
 	rnvol = xzalloc(sizeof(*rnvol));
 	rnvol->count = --argc;
 	if (argc > ARRAY_SIZE(rnvol->ents))
-		bb_error_msg_and_die("too many renames requested");
+		bb_simple_error_msg_and_die("too many renames requested");
 
 	ubi_devname = argv[1];
 	ubi_devnum = ubi_devnum_from_devname(ubi_devname);
diff -Naur busybox-1.31.1/miscutils/ubi_tools.c busybox-be5a505d/miscutils/ubi_tools.c
--- busybox-1.31.1/miscutils/ubi_tools.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/miscutils/ubi_tools.c	2019-10-24 07:26:55.000000000 -0700
@@ -234,10 +234,10 @@
 			//	bb_error_msg_and_die("%s invalid maximum size calculated", "UBI");
 		} else
 		if (!(opts & OPTION_s))
-			bb_error_msg_and_die("size not specified");
+			bb_simple_error_msg_and_die("size not specified");
 
 		if (!(opts & OPTION_N))
-			bb_error_msg_and_die("name not specified");
+			bb_simple_error_msg_and_die("name not specified");
 
 		/* the structure is memset(0) above */
 		mkvol_req.vol_id = vol_id;
@@ -264,7 +264,7 @@
 //usage:     "\n	-N VOLNAME	Volume name"
 	if (do_rmvol) {
 		if (!(opts & (OPTION_n|OPTION_N)))
-			bb_error_msg_and_die("volume id not specified");
+			bb_simple_error_msg_and_die("volume id not specified");
 
 		if (opts & OPTION_N) {
 			unsigned num = ubi_devnum_from_devname(ubi_ctrl);
@@ -288,9 +288,9 @@
 //usage:     "\n	-s SIZE		Size in bytes"
 	if (do_rsvol) {
 		if (!(opts & OPTION_s))
-			bb_error_msg_and_die("size not specified");
+			bb_simple_error_msg_and_die("size not specified");
 		if (!(opts & OPTION_n))
-			bb_error_msg_and_die("volume id not specified");
+			bb_simple_error_msg_and_die("volume id not specified");
 
 		rsvol_req.bytes = size_bytes; /* signed int64_t */
 		rsvol_req.vol_id = vol_id;
diff -Naur busybox-1.31.1/modutils/modutils-24.c busybox-be5a505d/modutils/modutils-24.c
--- busybox-1.31.1/modutils/modutils-24.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/modutils/modutils-24.c	2019-10-24 07:26:55.000000000 -0700
@@ -2600,7 +2600,7 @@
 			module_names = xrealloc(module_names, bufsize);
 			goto retry_modules_load;
 		}
-		bb_perror_msg_and_die("QM_MODULES");
+		bb_simple_perror_msg_and_die("QM_MODULES");
 	}
 
 	n_ext_modules = nmod = ret;
@@ -2661,7 +2661,7 @@
 			syms = xrealloc(syms, bufsize);
 			goto retry_kern_sym_load;
 		}
-		bb_perror_msg_and_die("kernel: QM_SYMBOLS");
+		bb_simple_perror_msg_and_die("kernel: QM_SYMBOLS");
 	}
 	nksyms = nsyms = ret;
 	ksyms = syms;
@@ -3247,21 +3247,21 @@
 	f->load_order_search_start = &f->load_order;
 
 	if (image_size < sizeof(f->header))
-		bb_error_msg_and_die("error while loading ELF header");
+		bb_simple_error_msg_and_die("error while loading ELF header");
 	memcpy(&f->header, image, sizeof(f->header));
 
 	if (*(aliased_uint32_t*)(&f->header.e_ident) != ELFMAG_U32) {
-		bb_error_msg_and_die("not an ELF file");
+		bb_simple_error_msg_and_die("not an ELF file");
 	}
 	if (f->header.e_ident[EI_CLASS] != ELFCLASSM
 	 || f->header.e_ident[EI_DATA] != (BB_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB)
 	 || f->header.e_ident[EI_VERSION] != EV_CURRENT
 	 || !MATCH_MACHINE(f->header.e_machine)
 	) {
-		bb_error_msg_and_die("ELF file not for this architecture");
+		bb_simple_error_msg_and_die("ELF file not for this architecture");
 	}
 	if (f->header.e_type != ET_REL) {
-		bb_error_msg_and_die("ELF file not a relocatable object");
+		bb_simple_error_msg_and_die("ELF file not a relocatable object");
 	}
 
 	/* Read the section headers.  */
@@ -3280,7 +3280,7 @@
 
 	section_headers = alloca(sizeof(ElfW(Shdr)) * shnum);
 	if (image_size < f->header.e_shoff + sizeof(ElfW(Shdr)) * shnum)
-		bb_error_msg_and_die("error while loading section headers");
+		bb_simple_error_msg_and_die("error while loading section headers");
 	memcpy(section_headers, image + f->header.e_shoff, sizeof(ElfW(Shdr)) * shnum);
 
 	/* Read the section data.  */
@@ -3317,16 +3317,16 @@
 				if (sec->header.sh_size > 0) {
 					sec->contents = xmalloc(sec->header.sh_size);
 					if (image_size < (sec->header.sh_offset + sec->header.sh_size))
-						bb_error_msg_and_die("error while loading section data");
+						bb_simple_error_msg_and_die("error while loading section data");
 					memcpy(sec->contents, image + sec->header.sh_offset, sec->header.sh_size);
 				}
 				break;
 #if SHT_RELM == SHT_REL
 			case SHT_RELA:
-				bb_error_msg_and_die("RELA relocations not supported on this architecture");
+				bb_simple_error_msg_and_die("RELA relocations not supported on this architecture");
 #else
 			case SHT_REL:
-				bb_error_msg_and_die("REL relocations not supported on this architecture");
+				bb_simple_error_msg_and_die("REL relocations not supported on this architecture");
 #endif
 			default:
 				if (sec->header.sh_type >= SHT_LOPROC) {
@@ -3447,7 +3447,7 @@
 			continue;
 		sec->contents = imagebase + (sec->header.sh_addr - base);
 		if (image_size < (sec->header.sh_offset + sec->header.sh_size)) {
-			bb_error_msg("error reading ELF section data");
+			bb_simple_error_msg("error reading ELF section data");
 			return 0; /* need to delete half-loaded module! */
 		}
 		memcpy(sec->contents, image + sec->header.sh_offset, sec->header.sh_size);
@@ -3845,7 +3845,7 @@
 		if (m_has_modinfo) {
 			int m_version = new_get_module_version(f, m_strversion);
 			if (m_version == -1) {
-				bb_error_msg_and_die("can't find the kernel version "
+				bb_simple_error_msg_and_die("can't find the kernel version "
 					"the module was compiled for");
 			}
 		}
@@ -3864,7 +3864,7 @@
 #endif
 
 	if (query_module(NULL, 0, NULL, 0, NULL))
-		bb_error_msg_and_die("old (unsupported) kernel");
+		bb_simple_error_msg_and_die("old (unsupported) kernel");
 	new_get_kernel_symbols();
 	k_crcs = new_is_kernel_checksummed();
 
diff -Naur busybox-1.31.1/modutils/rmmod.c busybox-be5a505d/modutils/rmmod.c
--- busybox-1.31.1/modutils/rmmod.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/modutils/rmmod.c	2019-10-24 07:26:55.000000000 -0700
@@ -52,7 +52,7 @@
 		/* Unload _all_ unused modules via NULL delete_module() call */
 		err = bb_delete_module(NULL, flags);
 		if (err && err != EFAULT)
-			bb_perror_msg_and_die("rmmod");
+			bb_simple_perror_msg_and_die("rmmod");
 		return EXIT_SUCCESS;
 	}
 
diff -Naur busybox-1.31.1/networking/arp.c busybox-be5a505d/networking/arp.c
--- busybox-1.31.1/networking/arp.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/arp.c	2019-10-24 07:26:55.000000000 -0700
@@ -116,7 +116,7 @@
 	/* Resolve the host name. */
 	host = *args;
 	if (ap->input(host, &sa) < 0) {
-		bb_herror_msg_and_die("%s", host);
+		bb_simple_herror_msg_and_die(host);
 	}
 
 	/* If a host has more than one address, use the correct one! */
@@ -149,7 +149,7 @@
 #ifdef HAVE_ATF_DONTPUB
 			req.arp_flags |= ATF_DONTPUB;
 #else
-			bb_error_msg("feature ATF_DONTPUB is not supported");
+			bb_simple_error_msg("feature ATF_DONTPUB is not supported");
 #endif
 			args++;
 			break;
@@ -157,7 +157,7 @@
 #ifdef HAVE_ATF_MAGIC
 			req.arp_flags |= ATF_MAGIC;
 #else
-			bb_error_msg("feature ATF_MAGIC is not supported");
+			bb_simple_error_msg("feature ATF_MAGIC is not supported");
 #endif
 			args++;
 			break;
@@ -173,7 +173,7 @@
 			if (strcmp(*args, "255.255.255.255") != 0) {
 				host = *args;
 				if (ap->input(host, &sa) < 0) {
-					bb_herror_msg_and_die("%s", host);
+					bb_simple_herror_msg_and_die(host);
 				}
 				memcpy(&req.arp_netmask, &sa, sizeof(struct sockaddr));
 				req.arp_flags |= ATF_NETMASK;
@@ -195,7 +195,7 @@
 	/* Call the kernel. */
 	if (flags & 2) {
 		if (option_mask32 & ARP_OPT_v)
-			bb_error_msg("SIOCDARP(nopub)");
+			bb_simple_error_msg("SIOCDARP(nopub)");
 		err = ioctl(sockfd, SIOCDARP, &req);
 		if (err < 0) {
 			if (errno == ENXIO) {
@@ -204,20 +204,20 @@
 				printf("No ARP entry for %s\n", host);
 				return -1;
 			}
-			bb_perror_msg_and_die("SIOCDARP(priv)");
+			bb_simple_perror_msg_and_die("SIOCDARP(priv)");
 		}
 	}
 	if ((flags & 1) && err) {
  nopub:
 		req.arp_flags |= ATF_PUBL;
 		if (option_mask32 & ARP_OPT_v)
-			bb_error_msg("SIOCDARP(pub)");
+			bb_simple_error_msg("SIOCDARP(pub)");
 		if (ioctl(sockfd, SIOCDARP, &req) < 0) {
 			if (errno == ENXIO) {
 				printf("No ARP entry for %s\n", host);
 				return -1;
 			}
-			bb_perror_msg_and_die("SIOCDARP(pub)");
+			bb_simple_perror_msg_and_die("SIOCDARP(pub)");
 		}
 	}
 	return 0;
@@ -233,7 +233,7 @@
 	ioctl_or_perror_and_die(sockfd, SIOCGIFHWADDR, &ifr,
 					"can't get HW-Address for '%s'", ifname);
 	if (hw_set && (ifr.ifr_hwaddr.sa_family != hw->type)) {
-		bb_error_msg_and_die("protocol type mismatch");
+		bb_simple_error_msg_and_die("protocol type mismatch");
 	}
 	memcpy(sa, &(ifr.ifr_hwaddr), sizeof(struct sockaddr));
 
@@ -261,20 +261,20 @@
 
 	host = *args++;
 	if (ap->input(host, &sa) < 0) {
-		bb_herror_msg_and_die("%s", host);
+		bb_simple_herror_msg_and_die(host);
 	}
 	/* If a host has more than one address, use the correct one! */
 	memcpy(&req.arp_pa, &sa, sizeof(struct sockaddr));
 
 	/* Fetch the hardware address. */
 	if (*args == NULL) {
-		bb_error_msg_and_die("need hardware address");
+		bb_simple_error_msg_and_die("need hardware address");
 	}
 	if (option_mask32 & ARP_OPT_D) {
 		arp_getdevhw(*args++, &req.arp_ha);
 	} else {
 		if (hw->input(*args++, &req.arp_ha) < 0) {
-			bb_error_msg_and_die("invalid hardware address");
+			bb_simple_error_msg_and_die("invalid hardware address");
 		}
 	}
 
@@ -302,7 +302,7 @@
 #ifdef HAVE_ATF_DONTPUB
 			flags |= ATF_DONTPUB;
 #else
-			bb_error_msg("feature ATF_DONTPUB is not supported");
+			bb_simple_error_msg("feature ATF_DONTPUB is not supported");
 #endif
 			args++;
 			break;
@@ -310,7 +310,7 @@
 #ifdef HAVE_ATF_MAGIC
 			flags |= ATF_MAGIC;
 #else
-			bb_error_msg("feature ATF_MAGIC is not supported");
+			bb_simple_error_msg("feature ATF_MAGIC is not supported");
 #endif
 			args++;
 			break;
@@ -326,7 +326,7 @@
 			if (strcmp(*args, "255.255.255.255") != 0) {
 				host = *args;
 				if (ap->input(host, &sa) < 0) {
-					bb_herror_msg_and_die("%s", host);
+					bb_simple_herror_msg_and_die(host);
 				}
 				memcpy(&req.arp_netmask, &sa, sizeof(struct sockaddr));
 				flags |= ATF_NETMASK;
@@ -346,7 +346,7 @@
 
 	/* Call the kernel. */
 	if (option_mask32 & ARP_OPT_v)
-		bb_error_msg("SIOCSARP()");
+		bb_simple_error_msg("SIOCSARP()");
 	xioctl(sockfd, SIOCSARP, &req);
 	return 0;
 }
@@ -422,7 +422,7 @@
 	if (name != NULL) {
 		/* Resolve the host name. */
 		if (ap->input(name, &sa) < 0) {
-			bb_herror_msg_and_die("%s", name);
+			bb_simple_herror_msg_and_die(name);
 		}
 		host = xstrdup(ap->sprint(&sa, 1));
 	}
@@ -530,7 +530,7 @@
 	/* Now see what we have to do here... */
 	if (opts & (ARP_OPT_d | ARP_OPT_s)) {
 		if (argv[0] == NULL)
-			bb_error_msg_and_die("need host name");
+			bb_simple_error_msg_and_die("need host name");
 		if (opts & ARP_OPT_s)
 			return arp_set(argv);
 		return arp_del(argv);
diff -Naur busybox-1.31.1/networking/arping.c busybox-be5a505d/networking/arping.c
--- busybox-1.31.1/networking/arping.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/arping.c	2019-10-24 07:26:55.000000000 -0700
@@ -375,7 +375,7 @@
 			xconnect(probe_fd, (struct sockaddr *) &G.probe_saddr, sizeof(G.probe_saddr));
 			bb_getsockname(probe_fd, (struct sockaddr *) &G.probe_saddr, sizeof(G.probe_saddr));
 			if (G.probe_saddr.sin_family != AF_INET)
-				bb_error_msg_and_die("no IP address configured");
+				bb_simple_error_msg_and_die("no IP address configured");
 			src = G.probe_saddr.sin_addr;
 		}
 		close(probe_fd);
@@ -430,7 +430,7 @@
 		/* Don't allow SIGALRMs while we process the reply */
 		sigprocmask(SIG_BLOCK, &G.sset, NULL);
 		if (cc < 0) {
-			bb_perror_msg("recvfrom");
+			bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		recv_pack(G.packet, cc, &from);
diff -Naur busybox-1.31.1/networking/brctl.c busybox-be5a505d/networking/brctl.c
--- busybox-1.31.1/networking/brctl.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/brctl.c	2019-10-24 07:26:55.000000000 -0700
@@ -53,7 +53,9 @@
 //usage:     "\n	addif BRIDGE IFACE	Add IFACE to BRIDGE"
 //usage:     "\n	delif BRIDGE IFACE	Delete IFACE from BRIDGE"
 //usage:	IF_FEATURE_BRCTL_FANCY(
-//usage:     "\n	stp BRIDGE 1/yes/on|0/no/off	STP on/off"
+//usage:     "\n	showmacs BRIDGE			List MAC addresses"
+//usage:     "\n	showstp	BRIDGE			Show STP info"
+//usage:     "\n	stp BRIDGE 1/yes/on|0/no/off	Set STP on/off"
 //usage:     "\n	setageing BRIDGE SECONDS	Set ageing time"
 //usage:     "\n	setfd BRIDGE SECONDS		Set bridge forward delay"
 //usage:     "\n	sethello BRIDGE SECONDS		Set hello time"
@@ -63,9 +65,7 @@
 //usage:     "\n	setpathcost BRIDGE IFACE COST	Set path cost"
 //usage:	)
 // Not yet implemented:
-//			hairpin BRIDGE IFACE on|off	Hairpin on/off
-//			showmacs BRIDGE			List mac addrs
-//			showstp	BRIDGE			Show stp info
+//			hairpin BRIDGE IFACE on|off	Set hairpin on/off
 
 #include "libbb.h"
 #include "common_bufsiz.h"
@@ -129,7 +129,7 @@
  *bridge name	bridge id		STP enabled	interfaces
  *br0		8000.000000000000	no		eth0
  */
-	char pathbuf[IFNAMSIZ + sizeof("/bridge/bridge_id") + 32];
+	char pathbuf[IFNAMSIZ + sizeof("/bridge/bridge_id") + 8];
 	int tabs;
 	DIR *ifaces;
 	struct dirent *ent;
@@ -146,8 +146,7 @@
 
 	if (need_hdr)
 		puts("bridge name\tbridge id\t\tSTP enabled\tinterfaces");
-	printf("%s\t\t", name);
-	printf("%s\t", filedata);
+	printf("%s\t\t%s\t", name, filedata);
 
 	strcpy(sfx, "stp_state");
 	read_file(pathbuf);
@@ -158,7 +157,8 @@
 		strcpy(filedata, "yes");
 	fputs(filedata, stdout);
 
-	strcpy(sfx - (sizeof("bridge/")-1), "brif");
+	/* sfx points past "BR/bridge/", turn it into "BR/brif": */
+	sfx[-4] = 'f'; sfx[-3] = '\0';
 	tabs = 0;
 	ifaces = opendir(pathbuf);
 	if (ifaces) {
@@ -194,7 +194,299 @@
 	n = sprintf(filedata, "%u\n", val);
 	if (write(fd, filedata, n) < 0)
 		bb_simple_perror_msg_and_die(name);
-	close(fd);
+	/* So far all callers exit very soon after calling us.
+	 * Do not bother closing fd (unless debugging):
+	 */
+	if (ENABLE_FEATURE_CLEAN_UP)
+		close(fd);
+}
+
+struct fdb_entry {
+	uint8_t mac_addr[6];
+	uint8_t port_no;
+	uint8_t is_local;
+	uint32_t ageing_timer_value;
+	uint8_t port_hi;
+	uint8_t pad0;
+	uint16_t unused;
+};
+
+static int compare_fdbs(const void *_f0, const void *_f1)
+{
+	const struct fdb_entry *f0 = _f0;
+	const struct fdb_entry *f1 = _f1;
+
+	return memcmp(f0->mac_addr, f1->mac_addr, 6);
+}
+
+static size_t read_bridge_forward_db(const char *name, struct fdb_entry **_fdb)
+{
+	char pathbuf[IFNAMSIZ + sizeof("/brforward") + 8];
+	struct fdb_entry *fdb;
+	size_t nentries;
+	int fd;
+	ssize_t cc;
+
+#if IFNAMSIZ == 16
+	sprintf(pathbuf, "%.16s/brforward", name);
+#else
+	sprintf(pathbuf, "%.*s/brforward", (int)IFNAMSIZ, name);
+#endif
+	fd = open(pathbuf, O_RDONLY);
+	if (fd < 0)
+		bb_error_msg_and_die("bridge %s does not exist", name);
+
+	fdb = NULL;
+	nentries = 0;
+	for (;;) {
+		fdb = xrealloc_vector(fdb, 4, nentries);
+		cc = full_read(fd, &fdb[nentries], sizeof(*fdb));
+		if (cc == 0) {
+			break;
+		}
+		if (cc != sizeof(*fdb)) {
+			bb_perror_msg_and_die("can't read bridge %s forward db", name);
+		}
+		++nentries;
+	}
+
+	if (ENABLE_FEATURE_CLEAN_UP)
+		close(fd);
+
+	qsort(fdb, nentries, sizeof(*fdb), compare_fdbs);
+
+	*_fdb = fdb;
+	return nentries;
+}
+
+static void show_bridge_macs(const char *name)
+{
+	struct fdb_entry *fdb;
+	size_t nentries;
+	size_t i;
+
+	nentries = read_bridge_forward_db(name, &fdb);
+
+	printf("port no\tmac addr\t\tis local?\tageing timer\n");
+	for (i = 0; i < nentries; ++i) {
+		const struct fdb_entry *f = &fdb[i];
+		unsigned tv_sec = f->ageing_timer_value / 100;
+		unsigned tv_csec = f->ageing_timer_value % 100;
+		printf("%3u\t"
+			"%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\t"
+			"%s\t\t"
+			"%4u.%.2u\n",
+			f->port_no,
+			f->mac_addr[0], f->mac_addr[1], f->mac_addr[2],
+			f->mac_addr[3], f->mac_addr[4], f->mac_addr[5],
+			(f->is_local ? "yes" : "no"),
+			tv_sec, tv_csec
+		);
+	}
+
+	if (ENABLE_FEATURE_CLEAN_UP)
+		free(fdb);
+}
+
+static void show_bridge_timer(const char *msg)
+{
+	unsigned long long centisec = xstrtoull(filedata, 0);
+	unsigned tv_sec = centisec / 100;
+	unsigned tv_csec = centisec % 100;
+	printf("%s%4u.%.2u", msg, tv_sec, tv_csec);
+}
+
+static const char *show_bridge_state(unsigned state)
+{
+	/* See linux/if_bridge.h, BR_STATE_ constants */
+	static const char state_names[] ALIGN1 =
+		"disabled\0"	//BR_STATE_DISABLED   0
+		"listening\0"   //BR_STATE_LISTENING  1
+		"learning\0"    //BR_STATE_LEARNING   2
+		"forwarding\0"  //BR_STATE_FORWARDING 3
+		"blocking"      //BR_STATE_BLOCKING   4
+	;
+	if (state < 5)
+		return nth_string(state_names, state);
+	return utoa(state);
+}
+
+static void printf_xstrtou(const char *fmt)
+{
+	printf(fmt, xstrtou(filedata, 0));
+}
+
+static void show_bridge_port(const char *name)
+{
+	char pathbuf[IFNAMSIZ + sizeof("/brport/forward_delay_timer") + 8];
+	char *sfx;
+
+#if IFNAMSIZ == 16
+	sfx = pathbuf + sprintf(pathbuf, "%.16s/brport/", name);
+#else
+	sfx = pathbuf + sprintf(pathbuf, "%.*s/brport/", (int)IFNAMSIZ, name);
+#endif
+
+	strcpy(sfx, "port_no");
+	read_file(pathbuf);
+	printf("%s (%u)\n", name, xstrtou(filedata, 0));
+
+	strcpy(sfx + 5, "id"); // "port_id"
+	read_file(pathbuf);
+	printf_xstrtou(" port id\t\t%.4x");
+
+	strcpy(sfx, "state");
+	read_file(pathbuf);
+	printf("\t\t\tstate\t\t%15s\n", show_bridge_state(xstrtou(filedata, 0)));
+
+	strcpy(sfx, "designated_root");
+	read_file(pathbuf);
+	printf(" designated root\t%s", filedata);
+
+	strcpy(sfx, "path_cost");
+	read_file(pathbuf);
+	printf_xstrtou("\tpath cost\t\t%4u\n");
+
+	strcpy(sfx, "designated_bridge");
+	read_file(pathbuf);
+	printf(" designated bridge\t%s", filedata);
+
+	strcpy(sfx, "message_age_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\tmessage age timer\t");
+
+	strcpy(sfx, "designated_port");
+	read_file(pathbuf);
+	printf_xstrtou("\n designated port\t%.4x");
+
+	strcpy(sfx, "forward_delay_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\t\t\tforward delay timer\t");
+
+	strcpy(sfx, "designated_cost");
+	read_file(pathbuf);
+	printf_xstrtou("\n designated cost\t%4u");
+
+	strcpy(sfx, "hold_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\t\t\thold timer\t\t");
+
+	printf("\n flags\t\t\t");
+
+	strcpy(sfx, "config_pending");
+	read_file(pathbuf);
+	if (!LONE_CHAR(filedata, '0'))
+		printf("CONFIG_PENDING ");
+
+	strcpy(sfx, "change_ack");
+	read_file(pathbuf);
+	if (!LONE_CHAR(filedata, '0'))
+		printf("TOPOLOGY_CHANGE_ACK ");
+
+	strcpy(sfx, "hairpin_mode");
+	read_file(pathbuf);
+	if (!LONE_CHAR(filedata, '0'))
+		printf_xstrtou("\n hairpin mode\t\t%4u");
+
+	printf("\n\n");
+}
+
+static void show_bridge_stp(const char *name)
+{
+	char pathbuf[IFNAMSIZ + sizeof("/bridge/topology_change_timer") + 8];
+	char *sfx;
+
+#if IFNAMSIZ == 16
+	sfx = pathbuf + sprintf(pathbuf, "%.16s/bridge/", name);
+#else
+	sfx = pathbuf + sprintf(pathbuf, "%.*s/bridge/", (int)IFNAMSIZ, name);
+#endif
+
+	strcpy(sfx, "bridge_id");
+	if (read_file(pathbuf) < 0)
+		bb_error_msg_and_die("bridge %s does not exist", name);
+
+	printf("%s\n"
+		" bridge id\t\t%s", name, filedata);
+
+	strcpy(sfx, "root_id");
+	read_file(pathbuf);
+	printf("\n designated root\t%s", filedata);
+
+	strcpy(sfx + 5, "port"); // "root_port"
+	read_file(pathbuf);
+	printf_xstrtou("\n root port\t\t%4u\t\t\t");
+
+	strcpy(sfx + 6, "ath_cost"); // "root_path_cost"
+	read_file(pathbuf);
+	printf_xstrtou("path cost\t\t%4u\n");
+
+	strcpy(sfx, "max_age");
+	read_file(pathbuf);
+	show_bridge_timer(" max age\t\t");
+	show_bridge_timer("\t\t\tbridge max age\t\t");
+
+	strcpy(sfx, "hello_time");
+	read_file(pathbuf);
+	show_bridge_timer("\n hello time\t\t");
+	show_bridge_timer("\t\t\tbridge hello time\t");
+
+	strcpy(sfx, "forward_delay");
+	read_file(pathbuf);
+	show_bridge_timer("\n forward delay\t\t");
+	show_bridge_timer("\t\t\tbridge forward delay\t");
+
+	strcpy(sfx, "ageing_time");
+	read_file(pathbuf);
+	show_bridge_timer("\n ageing time\t\t");
+
+	strcpy(sfx, "hello_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\n hello timer\t\t");
+
+	strcpy(sfx, "tcn_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\t\t\ttcn timer\t\t");
+
+	strcpy(sfx, "topology_change_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\n topology change timer\t");
+
+	strcpy(sfx, "gc_timer");
+	read_file(pathbuf);
+	show_bridge_timer("\t\t\tgc timer\t\t");
+
+	printf("\n flags\t\t\t");
+
+	strcpy(sfx, "topology_change");
+	read_file(pathbuf);
+	if (!LONE_CHAR(filedata, '0'))
+		printf("TOPOLOGY_CHANGE ");
+
+	strcpy(sfx, "topology_change_detected");
+	read_file(pathbuf);
+	if (!LONE_CHAR(filedata, '0'))
+		printf("TOPOLOGY_CHANGE_DETECTED ");
+	printf("\n\n\n");
+
+	/* Show bridge ports */
+	{
+		DIR *ifaces;
+
+		/* sfx points past "BR/bridge/", turn it into "BR/brif": */
+		sfx[-4] = 'f'; sfx[-3] = '\0';
+		ifaces = opendir(pathbuf);
+		if (ifaces) {
+			struct dirent *ent;
+			while ((ent = readdir(ifaces)) != NULL) {
+				if (DOT_OR_DOTDOT(ent->d_name))
+					continue; /* . or .. */
+				show_bridge_port(ent->d_name);
+			}
+			if (ENABLE_FEATURE_CLEAN_UP)
+				closedir(ifaces);
+		}
+	}
 }
 #endif
 
@@ -205,20 +497,26 @@
 		"addbr\0" "delbr\0" "addif\0" "delif\0"
 	IF_FEATURE_BRCTL_FANCY(
 		"stp\0"
+		"showstp\0"
 		"setageing\0" "setfd\0" "sethello\0" "setmaxage\0"
 		"setpathcost\0" "setportprio\0"
 		"setbridgeprio\0"
+		"showmacs\0"
 	)
 	IF_FEATURE_BRCTL_SHOW("show\0");
 	enum { ARG_addbr = 0, ARG_delbr, ARG_addif, ARG_delif
 		IF_FEATURE_BRCTL_FANCY(,
 			ARG_stp,
+			ARG_showstp,
 			ARG_setageing, ARG_setfd, ARG_sethello, ARG_setmaxage,
 			ARG_setpathcost, ARG_setportprio,
-			ARG_setbridgeprio
+			ARG_setbridgeprio,
+			ARG_showmacs
 		)
 		IF_FEATURE_BRCTL_SHOW(, ARG_show)
 	};
+	int key;
+	char *br;
 
 	argv++;
 	if (!*argv) {
@@ -228,185 +526,157 @@
 
 	xchdir("/sys/class/net");
 
-//	while (*argv)
-	{
-		smallint key;
-		char *br;
-
-		key = index_in_strings(keywords, *argv);
-		if (key == -1) /* no match found in keywords array, bail out. */
-			bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, applet_name);
-		argv++;
+	key = index_in_strings(keywords, *argv);
+	if (key == -1) /* no match found in keywords array, bail out. */
+		bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, applet_name);
+	argv++;
 
 #if ENABLE_FEATURE_BRCTL_SHOW
-		if (key == ARG_show) { /* show [BR]... */
-			DIR *net;
-			struct dirent *ent;
-			int need_hdr = 1;
-			int exitcode = EXIT_SUCCESS;
-
-			if (*argv) {
-				/* "show BR1 BR2 BR3" */
-				do {
-					if (show_bridge(*argv, need_hdr) >= 0) {
-						need_hdr = 0;
-					} else {
-						bb_error_msg("bridge %s does not exist", *argv);
+	if (key == ARG_show) { /* show [BR]... */
+		DIR *net;
+		struct dirent *ent;
+		int need_hdr = 1;
+		int exitcode = EXIT_SUCCESS;
+
+		if (*argv) {
+			/* "show BR1 BR2 BR3" */
+			do {
+				if (show_bridge(*argv, need_hdr) >= 0) {
+					need_hdr = 0;
+				} else {
+					bb_error_msg("bridge %s does not exist", *argv);
 //TODO: if device exists, but is not a BR, brctl from bridge-utils 1.6
 //says this instead: "device eth0 is not a bridge"
-						exitcode = EXIT_FAILURE;
-					}
-				} while (*++argv != NULL);
-				return exitcode;
-			}
-
-			/* "show" (if no ifaces, shows nothing, not even header) */
-			net = xopendir(".");
-			while ((ent = readdir(net)) != NULL) {
-				if (DOT_OR_DOTDOT(ent->d_name))
-					continue; /* . or .. */
-				if (show_bridge(ent->d_name, need_hdr) >= 0)
-					need_hdr = 0;
-			}
-			if (ENABLE_FEATURE_CLEAN_UP)
-				closedir(net);
+					exitcode = EXIT_FAILURE;
+				}
+			} while (*++argv != NULL);
 			return exitcode;
 		}
+
+		/* "show" (if no ifaces, shows nothing, not even header) */
+		net = xopendir(".");
+		while ((ent = readdir(net)) != NULL) {
+			if (DOT_OR_DOTDOT(ent->d_name))
+				continue; /* . or .. */
+			if (show_bridge(ent->d_name, need_hdr) >= 0)
+				need_hdr = 0;
+		}
+		if (ENABLE_FEATURE_CLEAN_UP)
+			closedir(net);
+		return exitcode;
+	}
 #endif
 
-		if (!*argv) /* all but 'show' need at least one argument */
-			bb_show_usage();
+	if (!*argv) /* All of the below need at least one argument */
+		bb_show_usage();
 
-		br = *argv++;
+	br = *argv++;
 
-		if (key == ARG_addbr || key == ARG_delbr) {
-			/* addbr or delbr */
-			/* brctl from bridge-utils 1.6 still uses ioctl
-			 * for SIOCBRADDBR / SIOCBRDELBR, not /sys accesses
-			 */
-			int fd = xsocket(AF_INET, SOCK_STREAM, 0);
-			ioctl_or_perror_and_die(fd,
-				key == ARG_addbr ? SIOCBRADDBR : SIOCBRDELBR,
-				br, "bridge %s", br
-			);
-			//close(fd);
-			//goto done;
-			/* bridge-utils 1.6 simply ignores trailing args:
-			 * "brctl addbr BR1 ARGS" ignores ARGS
-			 */
-			if (ENABLE_FEATURE_CLEAN_UP)
-				close(fd);
-			return EXIT_SUCCESS;
-		}
+	if (key == ARG_addbr || key == ARG_delbr) {
+		/* brctl from bridge-utils 1.6 still uses ioctl
+		 * for SIOCBRADDBR / SIOCBRDELBR, not /sys accesses
+		 */
+		int fd = xsocket(AF_INET, SOCK_STREAM, 0);
+		ioctl_or_perror_and_die(fd,
+			key == ARG_addbr ? SIOCBRADDBR : SIOCBRDELBR,
+			br, "bridge %s", br
+		);
+		//close(fd);
+		//goto done;
+		/* bridge-utils 1.6 simply ignores trailing args:
+		 * "brctl addbr BR1 ARGS" ignores ARGS
+		 */
+		if (ENABLE_FEATURE_CLEAN_UP)
+			close(fd);
+		return EXIT_SUCCESS;
+	}
 
-		if (!*argv) /* all but 'addbr/delbr' need at least two arguments */
-			bb_show_usage();
+	if (key == ARG_showmacs) {
+		show_bridge_macs(br);
+		return EXIT_SUCCESS;
+	}
+	if (key == ARG_showstp) {
+		show_bridge_stp(br);
+		return EXIT_SUCCESS;
+	}
 
-#if ENABLE_FEATURE_BRCTL_FANCY
-		if (key == ARG_stp) { /* stp */
-			static const char no_yes[] ALIGN1 =
-				"0\0" "off\0" "n\0" "no\0"   /* 0 .. 3 */
-				"1\0" "on\0"  "y\0" "yes\0"; /* 4 .. 7 */
-			int onoff = index_in_strings(no_yes, *argv);
-			if (onoff < 0)
-				bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, applet_name);
-			onoff = (unsigned)onoff / 4;
-			write_uint(br, "bridge/stp_state", onoff);
-			//goto done_next_argv;
-			return EXIT_SUCCESS;
-		}
+	if (!*argv) /* All of the below need at least two arguments */
+		bb_show_usage();
 
-		if ((unsigned)(key - ARG_setageing) < 4) { /* time related ops */
-			/* setageing BR N: "N*100\n" to /sys/class/net/BR/bridge/ageing_time
-			 * setfd BR N:     "N*100\n" to /sys/class/net/BR/bridge/forward_delay
-			 * sethello BR N:  "N*100\n" to /sys/class/net/BR/bridge/hello_time
-			 * setmaxage BR N: "N*100\n" to /sys/class/net/BR/bridge/max_age
-			 */
-			write_uint(br,
-				nth_string(
-					"bridge/ageing_time"  "\0" /* ARG_setageing */
-					"bridge/forward_delay""\0" /* ARG_setfd     */
-					"bridge/hello_time"   "\0" /* ARG_sethello  */
-					"bridge/max_age",          /* ARG_setmaxage */
-					key - ARG_setageing
-				),
-				str_to_jiffies(*argv)
-			);
-			//goto done_next_argv;
-			return EXIT_SUCCESS;
-		}
+#if ENABLE_FEATURE_BRCTL_FANCY
+	if (key == ARG_stp) {
+		static const char no_yes[] ALIGN1 =
+			"0\0" "off\0" "n\0" "no\0"   /* 0 .. 3 */
+			"1\0" "on\0"  "y\0" "yes\0"; /* 4 .. 7 */
+		int onoff = index_in_strings(no_yes, *argv);
+		if (onoff < 0)
+			bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, applet_name);
+		onoff = (unsigned)onoff / 4;
+		write_uint(br, "bridge/stp_state", onoff);
+		return EXIT_SUCCESS;
+	}
 
-		if (key == ARG_setbridgeprio) {
-			write_uint(br, "bridge/priority", xatoi_positive(*argv));
-			//goto done_next_argv;
-			return EXIT_SUCCESS;
-		}
+	if ((unsigned)(key - ARG_setageing) < 4) { /* time related ops */
+		/* setageing BR N: "N*100\n" to /sys/class/net/BR/bridge/ageing_time
+		 * setfd BR N:     "N*100\n" to /sys/class/net/BR/bridge/forward_delay
+		 * sethello BR N:  "N*100\n" to /sys/class/net/BR/bridge/hello_time
+		 * setmaxage BR N: "N*100\n" to /sys/class/net/BR/bridge/max_age
+		 */
+		write_uint(br,
+			nth_string(
+				"bridge/ageing_time"  "\0" /* ARG_setageing */
+				"bridge/forward_delay""\0" /* ARG_setfd     */
+				"bridge/hello_time"   "\0" /* ARG_sethello  */
+				"bridge/max_age",          /* ARG_setmaxage */
+				key - ARG_setageing
+			),
+			str_to_jiffies(*argv)
+		);
+		return EXIT_SUCCESS;
+	}
 
-		if (key == ARG_setpathcost
-		 || key == ARG_setportprio
-		) {
-			if (!argv[1])
-				bb_show_usage();
-			/* BR is not used (and ignored!) for these commands:
-			 * "setpathcost BR PORT N" writes "N\n" to
-			 * /sys/class/net/PORT/brport/path_cost
-			 * "setportprio BR PORT N" writes "N\n" to
-			 * /sys/class/net/PORT/brport/priority
-			 */
-			write_uint(argv[0],
-				nth_string(
-					"brport/path_cost" "\0" /* ARG_setpathcost */
-					"brport/priority",      /* ARG_setportprio */
-					key - ARG_setpathcost
-				),
-				xatoi_positive(argv[1])
-			);
-			//argv++;
-			//goto done_next_argv;
-			return EXIT_SUCCESS;
-		}
+	if (key == ARG_setbridgeprio) {
+		write_uint(br, "bridge/priority", xatoi_positive(*argv));
+		return EXIT_SUCCESS;
+	}
 
-/* TODO: "showmacs BR"
- *	port no\tmac addr\t\tis local?\tageing timer
- *	<sp><sp>1\txx:xx:xx:xx:xx:xx\tno\t\t<sp><sp><sp>1.31
- *	port no	mac addr		is local?	ageing timer
- *	  1	xx:xx:xx:xx:xx:xx	no		   1.31
- * Read fixed-sized records from /sys/class/net/BR/brforward:
- *	struct __fdb_entry {
- *		uint8_t  mac_addr[ETH_ALEN];
- *		uint8_t  port_no; //lsb
- *		uint8_t  is_local;
- *		uint32_t ageing_timer_value;
- *		uint8_t  port_hi;
- *		uint8_t  pad0;
- *		uint16_t unused;
- *	};
- */
+	if (key == ARG_setpathcost
+	 || key == ARG_setportprio
+	) {
+		if (!argv[1])
+			bb_show_usage();
+		/* BR is not used (and ignored!) for these commands:
+		 * "setpathcost BR PORT N" writes "N\n" to
+		 * /sys/class/net/PORT/brport/path_cost
+		 * "setportprio BR PORT N" writes "N\n" to
+		 * /sys/class/net/PORT/brport/priority
+		 */
+		write_uint(argv[0],
+			nth_string(
+				"brport/path_cost" "\0" /* ARG_setpathcost */
+				"brport/priority",      /* ARG_setportprio */
+				key - ARG_setpathcost
+			),
+			xatoi_positive(argv[1])
+		);
+		return EXIT_SUCCESS;
+	}
 #endif
-		/* always true: if (key == ARG_addif || key == ARG_delif) */ {
-			/* addif or delif */
-			struct ifreq ifr;
-			int fd = xsocket(AF_INET, SOCK_STREAM, 0);
-
-			strncpy_IFNAMSIZ(ifr.ifr_name, br);
-			ifr.ifr_ifindex = if_nametoindex(*argv);
-			if (ifr.ifr_ifindex == 0) {
-				bb_perror_msg_and_die("iface %s", *argv);
-			}
-			ioctl_or_perror_and_die(fd,
-				key == ARG_addif ? SIOCBRADDIF : SIOCBRDELIF,
-				&ifr, "bridge %s", br
-			);
-			//close(fd);
-			//goto done_next_argv;
-			if (ENABLE_FEATURE_CLEAN_UP)
-				close(fd);
-			return EXIT_SUCCESS;
+	/* always true: if (key == ARG_addif || key == ARG_delif) */ {
+		struct ifreq ifr;
+		int fd = xsocket(AF_INET, SOCK_STREAM, 0);
+
+		strncpy_IFNAMSIZ(ifr.ifr_name, br);
+		ifr.ifr_ifindex = if_nametoindex(*argv);
+		if (ifr.ifr_ifindex == 0) {
+			bb_perror_msg_and_die("iface %s", *argv);
 		}
-
-// done_next_argv:
-//		argv++;
-// done:
+		ioctl_or_perror_and_die(fd,
+			key == ARG_addif ? SIOCBRADDIF : SIOCBRDELIF,
+			&ifr, "bridge %s", br
+		);
+		if (ENABLE_FEATURE_CLEAN_UP)
+			close(fd);
 	}
 
 	return EXIT_SUCCESS;
diff -Naur busybox-1.31.1/networking/dnsd.c busybox-be5a505d/networking/dnsd.c
--- busybox-1.31.1/networking/dnsd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/dnsd.c	2019-10-24 07:26:55.000000000 -0700
@@ -395,11 +395,11 @@
 
 	head = (struct dns_head *)buf;
 	if (head->nquer == 0) {
-		bb_error_msg("packet has 0 queries, ignored");
+		bb_simple_error_msg("packet has 0 queries, ignored");
 		return 0; /* don't reply */
 	}
 	if (head->flags & htons(0x8000)) { /* QR bit */
-		bb_error_msg("response packet, ignored");
+		bb_simple_error_msg("response packet, ignored");
 		return 0; /* don't reply */
 	}
 	/* QR = 1 "response", RCODE = 4 "Not Implemented" */
@@ -474,7 +474,7 @@
 	 * RCODE = 0 "success"
 	 */
 	if (OPT_verbose)
-		bb_info_msg("returning positive reply");
+		bb_simple_info_msg("returning positive reply");
 	outr_flags = htons(0x8000 | 0x0400 | 0);
 	/* we have one answer */
 	head->nansw = htons(1);
@@ -557,7 +557,7 @@
 			continue;
 		}
 		if (OPT_verbose)
-			bb_info_msg("got UDP packet");
+			bb_simple_info_msg("got UDP packet");
 		buf[r] = '\0'; /* paranoia */
 		r = process_packet(conf_data, conf_ttl, buf);
 		if (r <= 0)
diff -Naur busybox-1.31.1/networking/ether-wake.c busybox-be5a505d/networking/ether-wake.c
--- busybox-1.31.1/networking/ether-wake.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/ether-wake.c	2019-10-24 07:26:55.000000000 -0700
@@ -182,7 +182,7 @@
 		byte_cnt = sscanf(ethoptarg, "%u.%u.%u.%u",
 		                  &passwd[0], &passwd[1], &passwd[2], &passwd[3]);
 	if (byte_cnt < 4) {
-		bb_error_msg("can't read Wake-On-LAN pass");
+		bb_simple_error_msg("can't read Wake-On-LAN pass");
 		return 0;
 	}
 // TODO: check invalid numbers >255??
@@ -266,7 +266,7 @@
 	/* This is necessary for broadcasts to work */
 	if (flags /* & 1 OPT_BROADCAST */) {
 		if (setsockopt_broadcast(s) != 0)
-			bb_perror_msg("SO_BROADCAST");
+			bb_simple_perror_msg("SO_BROADCAST");
 	}
 
 #if defined(PF_PACKET)
diff -Naur busybox-1.31.1/networking/ftpgetput.c busybox-be5a505d/networking/ftpgetput.c
--- busybox-1.31.1/networking/ftpgetput.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/ftpgetput.c	2019-10-24 07:26:55.000000000 -0700
@@ -214,7 +214,7 @@
 		struct stat sbuf;
 		/* lstat would be wrong here! */
 		if (stat(local_path, &sbuf) < 0) {
-			bb_perror_msg_and_die("stat");
+			bb_simple_perror_msg_and_die("stat");
 		}
 		if (sbuf.st_size > 0) {
 			beg_range = sbuf.st_size;
diff -Naur busybox-1.31.1/networking/hostname.c busybox-be5a505d/networking/hostname.c
--- busybox-1.31.1/networking/hostname.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/hostname.c	2019-10-24 07:26:55.000000000 -0700
@@ -61,7 +61,7 @@
 	} else if (sethostname(s, strlen(s))) {
 //		if (errno == EPERM)
 //			bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
-		bb_perror_msg_and_die("sethostname");
+		bb_simple_perror_msg_and_die("sethostname");
 	}
 }
 
diff -Naur busybox-1.31.1/networking/httpd.c busybox-be5a505d/networking/httpd.c
--- busybox-1.31.1/networking/httpd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/httpd.c	2019-10-24 07:26:55.000000000 -0700
@@ -1025,7 +1025,7 @@
 	*/
 
 	if (verbose > 2)
-		bb_error_msg("closed");
+		bb_simple_error_msg("closed");
 	_exit(xfunc_error_retval);
 }
 
@@ -1220,7 +1220,7 @@
 	}
 	if (full_write(STDOUT_FILENO, iobuf, len) != len) {
 		if (verbose > 1)
-			bb_perror_msg("error");
+			bb_simple_perror_msg("error");
 		log_and_exit();
 	}
 }
@@ -1838,7 +1838,7 @@
 	if (count < 0) {
  IF_FEATURE_USE_SENDFILE(fin:)
 		if (verbose > 1)
-			bb_perror_msg("error");
+			bb_simple_perror_msg("error");
 	}
 	log_and_exit();
 }
@@ -2149,7 +2149,7 @@
 		if (rmt_ip_str)
 			applet_name = rmt_ip_str;
 		if (verbose > 2)
-			bb_error_msg("connected");
+			bb_simple_error_msg("connected");
 	}
 	if_ip_denied_send_HTTP_FORBIDDEN_and_exit(remote_ip);
 
@@ -2746,7 +2746,7 @@
 		if (opt & OPT_SETUID) {
 			if (ugid.gid != (gid_t)-1) {
 				if (setgroups(1, &ugid.gid) == -1)
-					bb_perror_msg_and_die("setgroups");
+					bb_simple_perror_msg_and_die("setgroups");
 				xsetgid(ugid.gid);
 			}
 			xsetuid(ugid.uid);
diff -Naur busybox-1.31.1/networking/ifconfig.c busybox-be5a505d/networking/ifconfig.c
--- busybox-1.31.1/networking/ifconfig.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/ifconfig.c	2019-10-24 07:26:55.000000000 -0700
@@ -361,7 +361,7 @@
 #if ENABLE_FEATURE_IFCONFIG_STATUS
 		return display_interfaces(argv[0] ? argv[0] : show_all_param);
 #else
-		bb_error_msg_and_die("no support for status display");
+		bb_simple_error_msg_and_die("no support for status display");
 #endif
 	}
 
diff -Naur busybox-1.31.1/networking/ifplugd.c busybox-be5a505d/networking/ifplugd.c
--- busybox-1.31.1/networking/ifplugd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/ifplugd.c	2019-10-24 07:26:55.000000000 -0700
@@ -365,7 +365,7 @@
 	if (!(ifrequest.ifr_flags & IFF_UP)) {
 		ifrequest.ifr_flags |= IFF_UP;
 		/* Let user know we mess up with interface */
-		bb_info_msg("upping interface");
+		bb_simple_info_msg("upping interface");
 		if (network_ioctl(SIOCSIFFLAGS, &ifrequest, "setting interface flags") < 0) {
 			if (errno != ENODEV && errno != EADDRNOTAVAIL)
 				xfunc_die();
@@ -461,7 +461,7 @@
 		else if (option_mask32 & FLAG_IGNORE_FAIL_POSITIVE)
 			status = IFSTATUS_UP;
 		else if (G.api_mode[0] == 'a')
-			bb_error_msg("can't detect link status");
+			bb_simple_error_msg("can't detect link status");
 	}
 
 	if (status != G.iface_last_status) {
@@ -493,14 +493,14 @@
 				goto ret;
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg("netlink: recv");
+			bb_simple_perror_msg("netlink: recv");
 			return -1;
 		}
 
 		mhdr = (struct nlmsghdr*)replybuf;
 		while (bytes > 0) {
 			if (!NLMSG_OK(mhdr, bytes)) {
-				bb_error_msg("netlink packet too small or truncated");
+				bb_simple_error_msg("netlink packet too small or truncated");
 				return -1;
 			}
 
@@ -509,7 +509,7 @@
 				int attr_len;
 
 				if (mhdr->nlmsg_len < NLMSG_LENGTH(sizeof(struct ifinfomsg))) {
-					bb_error_msg("netlink packet too small or truncated");
+					bb_simple_error_msg("netlink packet too small or truncated");
 					return -1;
 				}
 
@@ -591,7 +591,7 @@
 	}
 
 	if (pid_from_pidfile > 0 && kill(pid_from_pidfile, 0) == 0)
-		bb_error_msg_and_die("daemon already running");
+		bb_simple_error_msg_and_die("daemon already running");
 #endif
 
 	api_mode_found = strchr(api_modes, G.api_mode[0]);
@@ -690,7 +690,7 @@
 		) {
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg("poll");
+			bb_simple_perror_msg("poll");
 			goto exiting;
 		}
 
@@ -763,5 +763,5 @@
 
  exiting:
 	remove_pidfile(pidfile_name);
-	bb_error_msg_and_die("exiting");
+	bb_simple_error_msg_and_die("exiting");
 }
diff -Naur busybox-1.31.1/networking/ifupdown.c busybox-be5a505d/networking/ifupdown.c
--- busybox-1.31.1/networking/ifupdown.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/ifupdown.c	2019-10-24 07:26:55.000000000 -0700
@@ -665,7 +665,7 @@
 		if (executable_exists(ext_dhcp_clients[i].name))
 			return execute(ext_dhcp_clients[i].startcmd, ifd, exec);
 	}
-	bb_error_msg("no dhcp clients found");
+	bb_simple_error_msg("no dhcp clients found");
 	return 0;
 }
 # elif ENABLE_UDHCPC
@@ -707,7 +707,7 @@
 	}
 
 	if (!result)
-		bb_error_msg("warning: no dhcp clients found and stopped");
+		bb_simple_error_msg("warning: no dhcp clients found and stopped");
 
 	/* Sleep a bit, otherwise static_down tries to bring down interface too soon,
 	   and it may come back up because udhcpc is still shutting down */
diff -Naur busybox-1.31.1/networking/inetd.c busybox-be5a505d/networking/inetd.c
--- busybox-1.31.1/networking/inetd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/inetd.c	2019-10-24 07:26:55.000000000 -0700
@@ -504,7 +504,7 @@
 
 	if (bb_getsockname(sep->se_fd, (struct sockaddr *) &ir_sin, sizeof(ir_sin)) < 0) {
 //TODO: verify that such failure is even possible in Linux kernel
-		bb_perror_msg("getsockname");
+		bb_simple_perror_msg("getsockname");
 		return;
 	}
 
@@ -544,7 +544,7 @@
 	}
 
 	if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
-		bb_perror_msg("setrlimit");
+		bb_simple_perror_msg("setrlimit");
 		return;
 	}
 
@@ -599,7 +599,7 @@
 
 	fd = socket(sep->se_family, sep->se_socktype, 0);
 	if (fd < 0) {
-		bb_perror_msg("socket");
+		bb_simple_perror_msg("socket");
 		return;
 	}
 	setsockopt_reuseaddr(fd);
@@ -815,7 +815,7 @@
 			n = bb_strtou(p, &p, 10);
 			if (n > INT_MAX) {
  bad_ver_spec:
-				bb_error_msg("bad rpc version");
+				bb_simple_error_msg("bad rpc version");
 				goto parse_err;
 			}
 			sep->se_rpcver_lo = sep->se_rpcver_hi = n;
@@ -829,7 +829,7 @@
 			if (*p != '\0')
 				goto bad_ver_spec;
 #else
-			bb_error_msg("no support for rpc services");
+			bb_simple_error_msg("no support for rpc services");
 			goto parse_err;
 #endif
 		}
@@ -1235,7 +1235,7 @@
 	if (argv[0])
 		config_filename = argv[0];
 	if (config_filename == NULL)
-		bb_error_msg_and_die("non-root must specify config file");
+		bb_simple_error_msg_and_die("non-root must specify config file");
 	if (!(opt & 2))
 		bb_daemonize_or_rexec(0, argv - optind);
 	else
@@ -1304,7 +1304,7 @@
 		ready_fd_cnt = select(maxsock + 1, &readable, NULL, NULL, NULL);
 		if (ready_fd_cnt < 0) {
 			if (errno != EINTR) {
-				bb_perror_msg("select");
+				bb_simple_perror_msg("select");
 				sleep(1);
 			}
 			continue;
@@ -1405,7 +1405,7 @@
 					pid = vfork();
 
 				if (pid < 0) { /* fork error */
-					bb_perror_msg("vfork"+1);
+					bb_simple_perror_msg("vfork"+1);
 					sleep(1);
 					restore_sigmask(&omask);
 					maybe_close(new_udp_fd);
@@ -1488,7 +1488,7 @@
 			}
 			if (real_uid != 0 && real_uid != pwd->pw_uid) {
 				/* a user running private inetd */
-				bb_error_msg("non-root must run services as himself");
+				bb_simple_error_msg("non-root must run services as himself");
 				goto do_exit1;
 			}
 			if (pwd->pw_uid != real_uid) {
@@ -1502,7 +1502,7 @@
 			}
 			if (rlim_ofile.rlim_cur != rlim_ofile_cur)
 				if (setrlimit(RLIMIT_NOFILE, &rlim_ofile) < 0)
-					bb_perror_msg("setrlimit");
+					bb_simple_perror_msg("setrlimit");
 
 			/* closelog(); - WRONG. we are after vfork,
 			 * this may confuse syslog() internal state.
diff -Naur busybox-1.31.1/networking/ipcalc.c busybox-be5a505d/networking/ipcalc.c
--- busybox-1.31.1/networking/ipcalc.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/ipcalc.c	2019-10-24 07:26:55.000000000 -0700
@@ -183,7 +183,7 @@
 
 	if (argv[1]) {
 		if (ENABLE_FEATURE_IPCALC_FANCY && have_netmask) {
-			bb_error_msg_and_die("use prefix or netmask, not both");
+			bb_simple_error_msg_and_die("use prefix or netmask, not both");
 		}
 		if (inet_aton(argv[1], &s_netmask) == 0) {
 			bb_error_msg_and_die("bad netmask: %s", argv[1]);
diff -Naur busybox-1.31.1/networking/isrv.c busybox-be5a505d/networking/isrv.c
--- busybox-1.31.1/networking/isrv.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/isrv.c	2019-10-24 07:26:55.000000000 -0700
@@ -185,7 +185,7 @@
 		/* Most probably someone gave us wrong fd type
 		 * (for example, non-socket). Don't want
 		 * to loop forever. */
-		bb_perror_msg_and_die("accept");
+		bb_simple_perror_msg_and_die("accept");
 	}
 
 	DPRINTF("new_peer(%d)", newfd);
@@ -311,7 +311,7 @@
 
 		if (n < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("select");
+				bb_simple_perror_msg("select");
 			continue;
 		}
 
diff -Naur busybox-1.31.1/networking/libiproute/ipaddress.c busybox-be5a505d/networking/libiproute/ipaddress.c
--- busybox-1.31.1/networking/libiproute/ipaddress.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/libiproute/ipaddress.c	2019-10-24 07:26:55.000000000 -0700
@@ -119,7 +119,7 @@
 	//memset(tb, 0, sizeof(tb)); - parse_rtattr does this
 	parse_rtattr(tb, IFLA_MAX, IFLA_RTA(ifi), len);
 	if (tb[IFLA_IFNAME] == NULL) {
-		bb_error_msg("nil ifname");
+		bb_simple_error_msg("nil ifname");
 		return -1;
 	}
 	if (G_filter.label
@@ -205,7 +205,7 @@
 static int flush_update(void)
 {
 	if (rtnl_send_check(G_filter.rth, G_filter.flushb, G_filter.flushp) < 0) {
-		bb_perror_msg("can't send flush request");
+		bb_simple_perror_msg("can't send flush request");
 		return -1;
 	}
 	G_filter.flushp = 0;
@@ -439,7 +439,7 @@
 			bb_error_msg_and_die(bb_msg_requires_arg, "flush");
 		}
 		if (G_filter.family == AF_PACKET) {
-			bb_error_msg_and_die("can't flush link addresses");
+			bb_simple_error_msg_and_die("can't flush link addresses");
 		}
 	}
 
@@ -700,7 +700,7 @@
 
 	if (!d) {
 		/* There was no "dev IFACE", but we need that */
-		bb_error_msg_and_die("need \"dev IFACE\"");
+		bb_simple_error_msg_and_die("need \"dev IFACE\"");
 	}
 	if (l && !is_prefixed_with(l, d)) {
 		bb_error_msg_and_die("\"dev\" (%s) must match \"label\" (%s)", d, l);
@@ -717,7 +717,7 @@
 		inet_prefix brd;
 		int i;
 		if (req.ifa.ifa_family != AF_INET) {
-			bb_error_msg_and_die("broadcast can be set only for IPv4 addresses");
+			bb_simple_error_msg_and_die("broadcast can be set only for IPv4 addresses");
 		}
 		brd = peer;
 		if (brd.bitlen <= 30) {
diff -Naur busybox-1.31.1/networking/libiproute/ipneigh.c busybox-be5a505d/networking/libiproute/ipneigh.c
--- busybox-1.31.1/networking/libiproute/ipneigh.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/libiproute/ipneigh.c	2019-10-24 07:26:55.000000000 -0700
@@ -49,7 +49,7 @@
 static int flush_update(void)
 {
 	if (rtnl_send_check(G_filter.rth, G_filter.flushb, G_filter.flushp) < 0) {
-		bb_perror_msg("can't send flush request");
+		bb_simple_perror_msg("can't send flush request");
 		return -1;
 	}
 	G_filter.flushp = 0;
@@ -305,7 +305,7 @@
 			xrtnl_wilddump_request(&rth, G_filter.family, RTM_GETNEIGH);
 			G_filter.flushed = 0;
 			if (xrtnl_dump_filter(&rth, print_neigh, NULL) < 0) {
-				bb_perror_msg_and_die("flush terminated");
+				bb_simple_perror_msg_and_die("flush terminated");
 			}
 			if (G_filter.flushed == 0) {
 				if (round == 0)
@@ -325,11 +325,11 @@
 	ndm.ndm_family = G_filter.family;
 
 	if (rtnl_dump_request(&rth, RTM_GETNEIGH, &ndm, sizeof(struct ndmsg)) < 0) {
-		bb_perror_msg_and_die("can't send dump request");
+		bb_simple_perror_msg_and_die("can't send dump request");
 	}
 
 	if (xrtnl_dump_filter(&rth, print_neigh, NULL) < 0) {
-		bb_error_msg_and_die("dump terminated");
+		bb_simple_error_msg_and_die("dump terminated");
 	}
 
 	return 0;
diff -Naur busybox-1.31.1/networking/libiproute/iproute.c busybox-be5a505d/networking/libiproute/iproute.c
--- busybox-1.31.1/networking/libiproute/iproute.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/libiproute/iproute.c	2019-10-24 07:26:55.000000000 -0700
@@ -57,7 +57,7 @@
 static int flush_update(void)
 {
 	if (rtnl_send_check(G_filter.rth, G_filter.flushb, G_filter.flushp) < 0) {
-		bb_perror_msg("can't send flush request");
+		bb_simple_perror_msg("can't send flush request");
 		return -1;
 	}
 	G_filter.flushp = 0;
@@ -756,7 +756,7 @@
 	}
 
 	if (write(flush_fd, "-1", 2) < 2) {
-		bb_perror_msg("can't flush routing cache");
+		bb_simple_perror_msg("can't flush routing cache");
 		return;
 	}
 	close(flush_fd);
@@ -948,7 +948,7 @@
 	if (G_filter.tb != -1) {
 		xrtnl_wilddump_request(&rth, do_ipv6, RTM_GETROUTE);
 	} else if (rtnl_rtcache_request(&rth, do_ipv6) < 0) {
-		bb_perror_msg_and_die("can't send dump request");
+		bb_simple_perror_msg_and_die("can't send dump request");
 	}
 	xrtnl_dump_filter(&rth, print_route, NULL);
 
@@ -1041,7 +1041,7 @@
 	}
 
 	if (req.r.rtm_dst_len == 0) {
-		bb_error_msg_and_die("need at least destination address");
+		bb_simple_error_msg_and_die("need at least destination address");
 	}
 
 	xrtnl_open(&rth);
@@ -1077,7 +1077,7 @@
 		print_route(NULL, &req.n, NULL);
 
 		if (req.n.nlmsg_type != RTM_NEWROUTE) {
-			bb_error_msg_and_die("not a route?");
+			bb_simple_error_msg_and_die("not a route?");
 		}
 		len -= NLMSG_LENGTH(sizeof(*r));
 		if (len < 0) {
@@ -1091,7 +1091,7 @@
 			tb[RTA_PREFSRC]->rta_type = RTA_SRC;
 			r->rtm_src_len = 8*RTA_PAYLOAD(tb[RTA_PREFSRC]);
 		} else if (!tb[RTA_SRC]) {
-			bb_error_msg_and_die("can't connect the route");
+			bb_simple_error_msg_and_die("can't connect the route");
 		}
 		if (!odev && tb[RTA_OIF]) {
 			tb[RTA_OIF]->rta_type = 0;
diff -Naur busybox-1.31.1/networking/libiproute/iptunnel.c busybox-be5a505d/networking/libiproute/iptunnel.c
--- busybox-1.31.1/networking/libiproute/iptunnel.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/libiproute/iptunnel.c	2019-10-24 07:26:55.000000000 -0700
@@ -338,7 +338,7 @@
 
 	if (p->iph.protocol == IPPROTO_IPIP || p->iph.protocol == IPPROTO_IPV6) {
 		if ((p->i_flags & GRE_KEY) || (p->o_flags & GRE_KEY)) {
-			bb_error_msg_and_die("keys are not allowed with ipip and sit");
+			bb_simple_error_msg_and_die("keys are not allowed with ipip and sit");
 		}
 	}
 
@@ -355,7 +355,7 @@
 		p->o_flags |= GRE_KEY;
 	}
 	if (IN_MULTICAST(ntohl(p->iph.daddr)) && !p->iph.saddr) {
-		bb_error_msg_and_die("broadcast tunnel requires a source address");
+		bb_simple_error_msg_and_die("broadcast tunnel requires a source address");
 	}
 }
 
@@ -367,7 +367,7 @@
 	parse_args(argv, cmd, &p);
 
 	if (p.iph.ttl && p.iph.frag_off == 0) {
-		bb_error_msg_and_die("ttl != 0 and noptmudisc are incompatible");
+		bb_simple_error_msg_and_die("ttl != 0 and noptmudisc are incompatible");
 	}
 
 	switch (p.iph.protocol) {
@@ -378,7 +378,7 @@
 	case IPPROTO_IPV6:
 		return do_add_ioctl(cmd, "sit0", &p);
 	default:
-		bb_error_msg_and_die("can't determine tunnel mode (ipip, gre or sit)");
+		bb_simple_error_msg_and_die("can't determine tunnel mode (ipip, gre or sit)");
 	}
 }
 
@@ -485,7 +485,7 @@
 		if (ptr == NULL ||
 		    (*ptr++ = 0, sscanf(buf, "%s", name) != 1)
 		) {
-			bb_error_msg("wrong format of /proc/net/dev");
+			bb_simple_error_msg("wrong format of /proc/net/dev");
 			return;
 		}
 		if (sscanf(ptr, "%lu%lu%lu%lu%lu%lu%lu%*d%lu%lu%lu%lu%lu%lu%lu",
diff -Naur busybox-1.31.1/networking/libiproute/libnetlink.c busybox-be5a505d/networking/libiproute/libnetlink.c
--- busybox-1.31.1/networking/libiproute/libnetlink.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/libiproute/libnetlink.c	2019-10-24 07:26:55.000000000 -0700
@@ -79,7 +79,7 @@
 		if (h->nlmsg_type == NLMSG_ERROR) {
 			struct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);
 			if (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr)))
-				bb_error_msg("ERROR truncated");
+				bb_simple_error_msg("ERROR truncated");
 			else
 				errno = -err->error;
 			return -1;
@@ -149,11 +149,11 @@
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg("OVERRUN");
+			bb_simple_perror_msg("OVERRUN");
 			continue;
 		}
 		if (status == 0) {
-			bb_error_msg("EOF on netlink");
+			bb_simple_error_msg("EOF on netlink");
 			goto ret;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
@@ -184,10 +184,10 @@
 			if (h->nlmsg_type == NLMSG_ERROR) {
 				struct nlmsgerr *l_err = (struct nlmsgerr*)NLMSG_DATA(h);
 				if (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {
-					bb_error_msg("ERROR truncated");
+					bb_simple_error_msg("ERROR truncated");
 				} else {
 					errno = -l_err->error;
-					bb_perror_msg("RTNETLINK answers");
+					bb_simple_perror_msg("RTNETLINK answers");
 				}
 				goto ret;
 			}
@@ -201,7 +201,7 @@
 			h = NLMSG_NEXT(h, status);
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
-			bb_error_msg("message truncated");
+			bb_simple_error_msg("message truncated");
 			continue;
 		}
 		if (status) {
@@ -221,7 +221,7 @@
 {
 	int ret = rtnl_dump_filter(rth, filter, arg1/*, NULL, NULL*/);
 	if (ret < 0)
-		bb_error_msg_and_die("dump terminated");
+		bb_simple_error_msg_and_die("dump terminated");
 	return ret;
 }
 
@@ -266,7 +266,7 @@
 	status = sendmsg(rtnl->fd, &msg, 0);
 
 	if (status < 0) {
-		bb_perror_msg("can't talk to rtnetlink");
+		bb_simple_perror_msg("can't talk to rtnetlink");
 		goto ret;
 	}
 
@@ -280,11 +280,11 @@
 			if (errno == EINTR) {
 				continue;
 			}
-			bb_perror_msg("OVERRUN");
+			bb_simple_perror_msg("OVERRUN");
 			continue;
 		}
 		if (status == 0) {
-			bb_error_msg("EOF on netlink");
+			bb_simple_error_msg("EOF on netlink");
 			goto ret;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
@@ -297,7 +297,7 @@
 
 			if (l < 0 || len > status) {
 				if (msg.msg_flags & MSG_TRUNC) {
-					bb_error_msg("truncated message");
+					bb_simple_error_msg("truncated message");
 					goto ret;
 				}
 				bb_error_msg_and_die("malformed message: len=%d!", len);
@@ -320,7 +320,7 @@
 			if (h->nlmsg_type == NLMSG_ERROR) {
 				struct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);
 				if (l < (int)sizeof(struct nlmsgerr)) {
-					bb_error_msg("ERROR truncated");
+					bb_simple_error_msg("ERROR truncated");
 				} else {
 					errno = - err->error;
 					if (errno == 0) {
@@ -329,7 +329,7 @@
 						}
 						goto ret_0;
 					}
-					bb_perror_msg("RTNETLINK answers");
+					bb_simple_perror_msg("RTNETLINK answers");
 				}
 				goto ret;
 			}
@@ -338,13 +338,13 @@
 				goto ret_0;
 			}
 
-			bb_error_msg("unexpected reply!");
+			bb_simple_error_msg("unexpected reply!");
 
 			status -= NLMSG_ALIGN(len);
 			h = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
-			bb_error_msg("message truncated");
+			bb_simple_error_msg("message truncated");
 			continue;
 		}
 		if (status) {
diff -Naur busybox-1.31.1/networking/libiproute/utils.c busybox-be5a505d/networking/libiproute/utils.c
--- busybox-1.31.1/networking/libiproute/utils.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/libiproute/utils.c	2019-10-24 07:26:55.000000000 -0700
@@ -230,7 +230,7 @@
 char** FAST_FUNC next_arg(char **argv)
 {
 	if (!*++argv)
-		bb_error_msg_and_die("command line is not complete, try \"help\"");
+		bb_simple_error_msg_and_die("command line is not complete, try \"help\"");
 	return argv;
 }
 
diff -Naur busybox-1.31.1/networking/nbd-client.c busybox-be5a505d/networking/nbd-client.c
--- busybox-1.31.1/networking/nbd-client.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/nbd-client.c	2019-10-24 07:26:55.000000000 -0700
@@ -179,7 +179,7 @@
 		if (memcmp(&nbd_header.magic1, "NBDMAGIC",
 				sizeof(nbd_header.magic1)) != 0
 		) {
-			bb_error_msg_and_die("login failed");
+			bb_simple_error_msg_and_die("login failed");
 		}
 		if (memcmp(&nbd_header.magic2,
 				"\x00\x00\x42\x02\x81\x86\x12\x53",
@@ -189,7 +189,7 @@
 		} else if (memcmp(&nbd_header.magic2, "IHAVEOPT", 8) == 0) {
 			proto_new = 1;
 		} else {
-			bb_error_msg_and_die("login failed");
+			bb_simple_error_msg_and_die("login failed");
 		}
 
 		if (!proto_new) {
@@ -240,17 +240,17 @@
 		}
 
 		if (ioctl(nbd, BLKROSET, &ro) < 0) {
-			bb_perror_msg_and_die("BLKROSET");
+			bb_simple_perror_msg_and_die("BLKROSET");
 		}
 
 		if (timeout) {
 			if (ioctl(nbd, NBD_SET_TIMEOUT, (unsigned long) timeout)) {
-				bb_perror_msg_and_die("NBD_SET_TIMEOUT");
+				bb_simple_perror_msg_and_die("NBD_SET_TIMEOUT");
 			}
 		}
 
 		if (ioctl(nbd, NBD_SET_SOCK, sock)) {
-			bb_perror_msg_and_die("NBD_SET_SOCK");
+			bb_simple_perror_msg_and_die("NBD_SET_SOCK");
 		}
 
 		//if (swap) mlockall(MCL_CURRENT|MCL_FUTURE);
diff -Naur busybox-1.31.1/networking/nc_bloaty.c busybox-be5a505d/networking/nc_bloaty.c
--- busybox-1.31.1/networking/nc_bloaty.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/nc_bloaty.c	2019-10-24 07:26:55.000000000 -0700
@@ -198,8 +198,8 @@
 #define Debug(...) do { } while (0)
 #endif
 
-#define holler_error(...)  do { if (o_verbose) bb_error_msg(__VA_ARGS__); } while (0)
-#define holler_perror(...) do { if (o_verbose) bb_perror_msg(__VA_ARGS__); } while (0)
+#define holler_error(msg)  do { if (o_verbose) bb_simple_error_msg(msg); } while (0)
+#define holler_perror(msg) do { if (o_verbose) bb_simple_perror_msg(msg); } while (0)
 
 /* catch: no-brainer interrupt handler */
 static void catch(int sig)
@@ -361,10 +361,10 @@
 			rr = recv_from_to(netfd, NULL, 0, MSG_PEEK, /*was bigbuf_net, BIGSIZ*/
 				&remend.u.sa, &ouraddr->u.sa, ouraddr->len);
 			if (rr < 0)
-				bb_perror_msg_and_die("recvfrom");
+				bb_simple_perror_msg_and_die("recvfrom");
 			unarm();
 		} else
-			bb_error_msg_and_die("timeout");
+			bb_simple_error_msg_and_die("timeout");
 /* Now we learned *to which IP* peer has connected, and we want to anchor
 our socket on it, so that our outbound packets will have correct local IP.
 Unfortunately, bind() on already bound socket will fail now (EINVAL):
@@ -382,7 +382,7 @@
 			remend.len = LSA_SIZEOF_SA;
 			rr = accept(netfd, &remend.u.sa, &remend.len);
 			if (rr < 0)
-				bb_perror_msg_and_die("accept");
+				bb_simple_perror_msg_and_die("accept");
 			if (themaddr) {
 				int sv_port, port, r;
 
@@ -409,7 +409,7 @@
 			}
 			unarm();
 		} else
-			bb_error_msg_and_die("timeout");
+			bb_simple_error_msg_and_die("timeout");
 
 		if (is_persistent && proggie) {
 			/* -l -k -e PROG */
@@ -494,7 +494,7 @@
 
 	rr = write(netfd, bigbuf_in, 1);
 	if (rr != 1)
-		bb_perror_msg("udptest first write");
+		bb_simple_perror_msg("udptest first write");
 
 	if (o_wait)
 		sleep(o_wait); // can be interrupted! while (t) nanosleep(&t)?
@@ -644,7 +644,7 @@
 			if (rr <= 0) {
 				if (rr < 0 && o_verbose > 1) {
 					/* nc 1.10 doesn't do this */
-					bb_perror_msg("net read");
+					bb_simple_perror_msg("net read");
 				}
 				pfds[1].fd = -1;                   /* don't poll for netfd anymore */
 				fds_open--;
@@ -869,7 +869,7 @@
 		/* apparently UDP can listen ON "port 0",
 		 but that's not useful */
 		if (!o_lport)
-			bb_error_msg_and_die("UDP listen needs nonzero -p port");
+			bb_simple_error_msg_and_die("UDP listen needs nonzero -p port");
 	}
 #endif
 
diff -Naur busybox-1.31.1/networking/nc.c busybox-be5a505d/networking/nc.c
--- busybox-1.31.1/networking/nc.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/nc.c	2019-10-24 07:26:55.000000000 -0700
@@ -112,7 +112,7 @@
 
 static void timeout(int signum UNUSED_PARAM)
 {
-	bb_error_msg_and_die("timed out");
+	bb_simple_error_msg_and_die("timed out");
 }
 
 int nc_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -211,7 +211,7 @@
  accept_again:
 			cfd = accept(sfd, NULL, 0);
 			if (cfd < 0)
-				bb_perror_msg_and_die("accept");
+				bb_simple_perror_msg_and_die("accept");
 			if (!execparam)
 				close(sfd);
 		} else {
@@ -260,7 +260,7 @@
 		int nread;
 
 		if (safe_poll(pfds, 2, -1) < 0)
-			bb_perror_msg_and_die("poll");
+			bb_simple_perror_msg_and_die("poll");
 
 		fdidx = 0;
 		while (1) {
diff -Naur busybox-1.31.1/networking/netstat.c busybox-be5a505d/networking/netstat.c
--- busybox-1.31.1/networking/netstat.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/netstat.c	2019-10-24 07:26:55.000000000 -0700
@@ -343,9 +343,9 @@
 		return;
 
 	if (prg_cache_loaded == 1)
-		bb_error_msg("can't scan /proc - are you root?");
+		bb_simple_error_msg("can't scan /proc - are you root?");
 	else
-		bb_error_msg("showing only processes with your user ID");
+		bb_simple_error_msg("showing only processes with your user ID");
 }
 
 #else
diff -Naur busybox-1.31.1/networking/nslookup.c busybox-be5a505d/networking/nslookup.c
--- busybox-1.31.1/networking/nslookup.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/nslookup.c	2019-10-24 07:26:55.000000000 -0700
@@ -549,7 +549,7 @@
 
 		recvlen = read(pfd.fd, reply, sizeof(reply));
 		if (recvlen < 0) {
-			bb_perror_msg("read");
+			bb_simple_perror_msg("read");
  next:
 			tcur = monotonic_ms();
 			continue;
diff -Naur busybox-1.31.1/networking/ntpd.c busybox-be5a505d/networking/ntpd.c
--- busybox-1.31.1/networking/ntpd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/ntpd.c	2019-10-24 07:26:55.000000000 -0700
@@ -905,7 +905,7 @@
 		ret = send_to_from(fd, msg, len, MSG_DONTWAIT, to, from, addrlen);
 	}
 	if (ret != len) {
-		bb_perror_msg("send failed");
+		bb_simple_perror_msg("send failed");
 		return -1;
 	}
 	return 0;
@@ -1121,7 +1121,7 @@
 	dtime = tvc.tv_sec + (1.0e-6 * tvc.tv_usec) + offset;
 	d_to_tv(dtime, &tvn);
 	if (settimeofday(&tvn, NULL) == -1)
-		bb_perror_msg_and_die("settimeofday");
+		bb_simple_perror_msg_and_die("settimeofday");
 
 	VERB2 {
 		tval = tvc.tv_sec;
@@ -1494,7 +1494,7 @@
 		/* Starting from 1 is ok here */
 		for (i = 1; i < num_survivors; i++) {
 			if (G.last_update_peer == survivor[i].p) {
-				VERB5 bb_error_msg("keeping old synced peer");
+				VERB5 bb_simple_error_msg("keeping old synced peer");
 				p = G.last_update_peer;
 				goto keep_old;
 			}
@@ -1702,7 +1702,7 @@
 #else
 			set_new_values(STATE_SYNC, offset, recv_time);
 #endif
-			VERB4 bb_error_msg("transitioning to FREQ, datapoint ignored");
+			VERB4 bb_simple_error_msg("transitioning to FREQ, datapoint ignored");
 			return 0; /* "leave poll interval as is" */
 
 #if 0 /* this is dead code for now */
@@ -1796,7 +1796,7 @@
 	VERB4 {
 		memset(&tmx, 0, sizeof(tmx));
 		if (adjtimex(&tmx) < 0)
-			bb_perror_msg_and_die("adjtimex");
+			bb_simple_perror_msg_and_die("adjtimex");
 		bb_error_msg("p adjtimex freq:%ld offset:%+ld status:0x%x tc:%ld",
 				tmx.freq, tmx.offset, tmx.status, tmx.constant);
 	}
@@ -1906,7 +1906,7 @@
 	//tmx.maxerror = (uint32_t)((sys_rootdelay / 2 + sys_rootdisp) * 1e6);
 	rc = adjtimex(&tmx);
 	if (rc < 0)
-		bb_perror_msg_and_die("adjtimex");
+		bb_simple_perror_msg_and_die("adjtimex");
 	/* NB: here kernel returns constant == G.poll_exp, not == G.poll_exp - 4.
 	 * Not sure why. Perhaps it is normal.
 	 */
@@ -2018,7 +2018,7 @@
 
 #if ENABLE_FEATURE_NTP_AUTH
 	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE_MD5_AUTH && size != NTP_MSGSIZE_SHA1_AUTH) {
-		bb_error_msg("malformed packet received from %s", p->p_dotted);
+		bb_error_msg("malformed packet received from %s: size %u", p->p_dotted, (int)size);
 		return;
 	}
 	if (p->key_entry && hashes_differ(p, &msg)) {
@@ -2027,7 +2027,7 @@
 	}
 #else
 	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE_MD5_AUTH) {
-		bb_error_msg("malformed packet received from %s", p->p_dotted);
+		bb_error_msg("malformed packet received from %s: size %u", p->p_dotted, (int)size);
 		return;
 	}
 #endif
@@ -2238,6 +2238,13 @@
 	from = xzalloc(to->len);
 
 	size = recv_from_to(G_listen_fd, &msg, sizeof(msg), MSG_DONTWAIT, from, &to->u.sa, to->len);
+
+	/* "ntpq -p" (4.2.8p13) sends a 12-byte NTPv2 request:
+	 * m_status is 0x16: leap:0 version:2 mode:6(reserved1)
+	 *  https://docs.ntpsec.org/latest/mode6.html
+	 * We don't support this.
+	 */
+
 #if ENABLE_FEATURE_NTP_AUTH
 	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE_MD5_AUTH && size != NTP_MSGSIZE_SHA1_AUTH)
 #else
@@ -2248,7 +2255,7 @@
 		if (size < 0) {
 			if (errno == EAGAIN)
 				goto bail;
-			bb_perror_msg_and_die("recv");
+			bb_simple_perror_msg_and_die("recv");
 		}
 		addr = xmalloc_sockaddr2dotted_noport(from);
 		bb_error_msg("malformed packet received from %s: size %u", addr, (int)size);
@@ -2415,7 +2422,7 @@
 	srand(getpid());
 
 	if (getuid())
-		bb_error_msg_and_die(bb_msg_you_must_be_root);
+		bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 
 	/* Set some globals */
 	G.discipline_jitter = G_precision_sec;
@@ -2436,7 +2443,8 @@
 			"d" /* compat */
 			"46aAbgL" /* compat, ignored */
 				"\0"
-				"dd:wn"  /* -d: counter; -p: list; -w implies -n */
+				"=0"      /* should have no arguments */
+				":dd:wn"  /* -d: counter; -p: list; -w implies -n */
 				IF_FEATURE_NTPD_SERVER(":Il") /* -I implies -l */
 			IF_FEATURE_NTP_AUTH(, &key_file_path)
 			, &peers, &G.script_name
@@ -2490,7 +2498,7 @@
 				/* supports 'sha' and 'sha1' formats */
 				hash_type = HASH_SHA1;
 			else
-				bb_error_msg_and_die("only MD5 and SHA1 keys supported");
+				bb_simple_error_msg_and_die("only MD5 and SHA1 keys supported");
 /* man ntp.keys:
  *  MD5    The key is 1 to 16 printable characters terminated by an EOL,
  *         whitespace, or a # (which is the "start of comment" character).
@@ -2673,7 +2681,7 @@
 				if (p->p_fd == -1) {
 					/* Time to send new req */
 					if (--cnt == 0) {
-						VERB4 bb_error_msg("disabling burst mode");
+						VERB4 bb_simple_error_msg("disabling burst mode");
 						G.polladj_count = 0;
 						G.poll_exp = MINPOLL;
 					}
diff -Naur busybox-1.31.1/networking/ping.c busybox-be5a505d/networking/ping.c
--- busybox-1.31.1/networking/ping.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/ping.c	2019-10-24 07:26:55.000000000 -0700
@@ -184,8 +184,8 @@
 		sock = socket(AF_INET, SOCK_RAW, 1); /* 1 == ICMP */
 	if (sock < 0) {
 		if (errno == EPERM)
-			bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
-		bb_perror_msg_and_die(bb_msg_can_not_create_raw_socket);
+			bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_perror_msg_and_die(bb_msg_can_not_create_raw_socket);
 	}
 
 	xmove_fd(sock, pingsock);
@@ -235,7 +235,7 @@
 #endif
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		if (c >= 76) {			/* ip + icmp */
@@ -280,7 +280,7 @@
 #endif
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		if (c >= ICMP_MINLEN) {	/* icmp6_hdr */
@@ -482,7 +482,7 @@
 	 * it doesn't matter */
 	sz = xsendto(pingsock, G.snd_packet, size_pkt, &pingaddr.sa, sizeof(pingaddr));
 	if (sz != size_pkt)
-		bb_error_msg_and_die(bb_msg_write_error);
+		bb_simple_error_msg_and_die(bb_msg_write_error);
 
 	if (pingcount == 0 || G.ntransmitted < pingcount) {
 		/* Didn't send all pings yet - schedule next in -i SEC interval */
@@ -723,7 +723,7 @@
 	if (source_lsa) {
 		if (setsockopt(pingsock, IPPROTO_IP, IP_MULTICAST_IF,
 				&source_lsa->u.sa, source_lsa->len))
-			bb_error_msg_and_die("can't set multicast source interface");
+			bb_simple_error_msg_and_die("can't set multicast source interface");
 		xbind(pingsock, &source_lsa->u.sa, source_lsa->len);
 	}
 
@@ -757,7 +757,7 @@
 				(struct sockaddr *) &from, &fromlen);
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		c = unpack4(G.rcv_packet, c, &from);
@@ -838,7 +838,7 @@
 		c = recvmsg(pingsock, &msg, 0);
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		for (mp = CMSG_FIRSTHDR(&msg); mp; mp = CMSG_NXTHDR(&msg, mp)) {
diff -Naur busybox-1.31.1/networking/route.c busybox-be5a505d/networking/route.c
--- busybox-1.31.1/networking/route.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/route.c	2019-10-24 07:26:55.000000000 -0700
@@ -336,7 +336,7 @@
 		}
 		mask = ((struct sockaddr_in *) &rt->rt_dst)->sin_addr.s_addr;
 		if (mask & ~(uint32_t)mask_in_addr(*rt)) {
-			bb_error_msg_and_die("netmask and route address conflict");
+			bb_simple_error_msg_and_die("netmask and route address conflict");
 		}
 	}
 
@@ -532,7 +532,7 @@
 			if ((r < 0) && feof(fp)) { /* EOF with no (nonspace) chars read. */
 				break;
 			}
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		}
 
 		if (!(flgs & RTF_UP)) { /* Skip interfaces that are down. */
@@ -598,7 +598,7 @@
 				break;
 			}
  ERROR:
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		}
 
 		/* Do the addr6x shift-and-insert changes to ':'-delimit addresses.
@@ -628,6 +628,7 @@
 
 		r = 0;
 		while (1) {
+			memset(&snaddr6, 0, sizeof(snaddr6));
 			inet_pton(AF_INET6, addr6x + r,
 					  (struct sockaddr *) &snaddr6.sin6_addr);
 			snaddr6.sin6_family = AF_INET6;
diff -Naur busybox-1.31.1/networking/slattach.c busybox-be5a505d/networking/slattach.c
--- busybox-1.31.1/networking/slattach.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/slattach.c	2019-10-24 07:26:55.000000000 -0700
@@ -56,7 +56,7 @@
 
 	ret = tcsetattr(serial_fd, TCSANOW, state);
 	if (ret != 0) {
-		bb_perror_msg("tcsetattr");
+		bb_simple_perror_msg("tcsetattr");
 		return 1; /* used as exitcode */
 	}
 	return ret; /* 0 */
@@ -159,7 +159,7 @@
 
 	/* Save current tty state */
 	if (tcgetattr(serial_fd, &G.saved_state) != 0)
-		bb_perror_msg_and_die("tcgetattr");
+		bb_simple_perror_msg_and_die("tcgetattr");
 	/* Save line discipline */
 	xioctl(serial_fd, TIOCGETD, &G.saved_disc);
 
diff -Naur busybox-1.31.1/networking/tcpudp.c busybox-be5a505d/networking/tcpudp.c
--- busybox-1.31.1/networking/tcpudp.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/tcpudp.c	2019-10-24 07:26:55.000000000 -0700
@@ -325,7 +325,7 @@
 	client = 0;
 	if ((getuid() == 0) && !(opts & OPT_u)) {
 		xfunc_error_retval = 100;
-		bb_error_msg_and_die(bb_msg_you_must_be_root);
+		bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 	}
 	if (opts & OPT_u)
 		if (!uidgid_get(&sslugid, ssluser, 1)) {
@@ -419,7 +419,7 @@
 	sig_block(SIGCHLD);
 	if (conn < 0) {
 		if (errno != EINTR)
-			bb_perror_msg(tcp ? "accept" : "recv");
+			bb_simple_perror_msg(tcp ? "accept" : "recv");
 		goto again2;
 	}
 	xmove_fd(tcp ? conn : sock, 0);
@@ -484,7 +484,7 @@
 
 	pid = vfork();
 	if (pid == -1) {
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
 		goto again;
 	}
 
diff -Naur busybox-1.31.1/networking/telnet.c busybox-be5a505d/networking/telnet.c
--- busybox-1.31.1/networking/telnet.c	2019-10-21 07:54:40.000000000 -0700
+++ busybox-be5a505d/networking/telnet.c	2019-10-24 07:26:55.000000000 -0700
@@ -238,6 +238,18 @@
 			*dst = '\r'; /* Enter -> CR LF */
 			*++dst = '\n';
 		}
+#if 0
+/* putty's "special commands" mode does this: */
+/* Korenix 3005 switch needs at least the backspace tweak */
+		if (c == 0x08 || c == 0x7f) { /* ctrl+h || backspace */
+			*dst = IAC;
+			*++dst = EC;
+		}
+		if (c == 0x03) { /* ctrl+c */
+			*dst = IAC;
+			*++dst = IP;
+		}
+#endif
 		dst++;
 	}
 	if (dst - outbuf != 0)
diff -Naur busybox-1.31.1/networking/telnetd.c busybox-be5a505d/networking/telnetd.c
--- busybox-1.31.1/networking/telnetd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/telnetd.c	2019-10-24 07:26:55.000000000 -0700
@@ -495,7 +495,7 @@
 		free(ts);
 		close(fd);
 		/* sock will be closed by caller */
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
 		return NULL;
 	}
 	if (pid > 0) {
diff -Naur busybox-1.31.1/networking/tftp.c busybox-be5a505d/networking/tftp.c
--- busybox-1.31.1/networking/tftp.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/tftp.c	2019-10-24 07:26:55.000000000 -0700
@@ -453,7 +453,7 @@
 		/* fill in packet if the filename fits into xbuf */
 		len = strlen(remote_file) + 1;
 		if (2 + len + sizeof("octet") >= io_bufsize) {
-			bb_error_msg("remote filename is too long");
+			bb_simple_error_msg("remote filename is too long");
 			goto ret;
 		}
 		strcpy(cp, remote_file);
@@ -468,7 +468,7 @@
 
 		/* Need to add option to pkt */
 		if ((&xbuf[io_bufsize - 1] - cp) < sizeof("blksize NNNNN tsize ") + sizeof(off_t)*3) {
-			bb_error_msg("remote filename is too long");
+			bb_simple_error_msg("remote filename is too long");
 			goto ret;
 		}
 		expect_OACK = 1;
@@ -569,7 +569,7 @@
 			retries--;
 			if (retries == 0) {
 				tftp_progress_done();
-				bb_error_msg("timeout");
+				bb_simple_error_msg("timeout");
 				goto ret; /* no err packet sent */
 			}
 
@@ -674,7 +674,7 @@
 			 * must be ignored by the client and server
 			 * as if it were never requested." */
 			if (blksize != TFTP_BLKSIZE_DEFAULT)
-				bb_error_msg("falling back to blocksize "TFTP_BLKSIZE_DEFAULT_STR);
+				bb_simple_error_msg("falling back to blocksize "TFTP_BLKSIZE_DEFAULT_STR);
 			blksize = TFTP_BLKSIZE_DEFAULT;
 			io_bufsize = TFTP_BLKSIZE_DEFAULT + 4;
 		}
@@ -739,7 +739,7 @@
 	strcpy(G_error_pkt_str, bb_msg_read_error);
  send_err_pkt:
 	if (G_error_pkt_str[0])
-		bb_error_msg("%s", G_error_pkt_str);
+		bb_simple_error_msg(G_error_pkt_str);
 	G.error_pkt[1] = TFTP_ERROR;
 	xsendto(socket_fd, G.error_pkt, 4 + 1 + strlen(G_error_pkt_str),
 			&peer_lsa->u.sa, peer_lsa->len);
diff -Naur busybox-1.31.1/networking/tls.c busybox-be5a505d/networking/tls.c
--- busybox-1.31.1/networking/tls.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/tls.c	2019-10-24 07:26:55.000000000 -0700
@@ -446,7 +446,7 @@
 	// than INSIZE bytes will first hash the key using H and then use the
 	// resultant OUTSIZE byte string as the actual key to HMAC."
 	if (key_size > SHA_INSIZE) {
-		bb_error_msg_and_die("HMAC key>64"); //does not happen (yet?)
+		bb_simple_error_msg_and_die("HMAC key>64"); //does not happen (yet?)
 //		md5sha_ctx_t ctx;
 //		begin(&ctx);
 //		md5sha_hash(&ctx, key, key_size);
@@ -1132,7 +1132,7 @@
 		}
 	}
 	if (sz < 0)
-		bb_error_msg_and_die("encrypted data too short");
+		bb_simple_error_msg_and_die("encrypted data too short");
 
 	//dump_hex("<< %s\n", tls->inbuf, RECHDR_LEN + sz);
 
@@ -1411,7 +1411,7 @@
 			dbg("ECDSA key\n");
 			//UNUSED: tls->flags |= GOT_CERT_ECDSA_KEY_ALG;
 		} else
-			bb_error_msg_and_die("not RSA or ECDSA cert");
+			bb_simple_error_msg_and_die("not RSA or ECDSA cert");
 	}
 
 	if (tls->flags & GOT_CERT_RSA_KEY_ALG) {
@@ -1882,7 +1882,7 @@
 	/* So far we only support curve_x25519 */
 	move_from_unaligned32(t32, keybuf);
 	if (t32 != htonl(0x03001d20))
-		bb_error_msg_and_die("elliptic curve is not x25519");
+		bb_simple_error_msg_and_die("elliptic curve is not x25519");
 
 	memcpy(tls->hsd->ecc_pub_key32, keybuf + 4, 32);
 	tls->flags |= GOT_EC_KEY;
@@ -1929,7 +1929,7 @@
 	if (!(tls->flags & NEED_EC_KEY)) {
 		/* RSA */
 		if (!(tls->flags & GOT_CERT_RSA_KEY_ALG))
-			bb_error_msg("server cert is not RSA");
+			bb_simple_error_msg("server cert is not RSA");
 
 		tls_get_random(rsa_premaster, sizeof(rsa_premaster));
 		if (TLS_DEBUG_FIXED_SECRETS)
@@ -1959,7 +1959,7 @@
 		uint8_t privkey[CURVE25519_KEYSIZE]; //[32]
 
 		if (!(tls->flags & GOT_EC_KEY))
-			bb_error_msg("server did not provide EC key");
+			bb_simple_error_msg("server did not provide EC key");
 
 		/* Generate random private key, see RFC 7748 */
 		tls_get_random(privkey, sizeof(privkey));
@@ -2322,7 +2322,7 @@
 		int nread;
 
 		if (safe_poll(pfds, 2, -1) < 0)
-			bb_perror_msg_and_die("poll");
+			bb_simple_perror_msg_and_die("poll");
 
 		if (pfds[0].revents) {
 			void *buf;
diff -Naur busybox-1.31.1/networking/tls.h busybox-be5a505d/networking/tls.h
--- busybox-1.31.1/networking/tls.h	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/tls.h	2019-10-24 07:26:55.000000000 -0700
@@ -90,7 +90,7 @@
 #define matrixCryptoGetPrngData(buf, len, userPtr) (tls_get_random(buf, len), PS_SUCCESS)
 
 #define psFree(p, pool)    free(p)
-#define psTraceCrypto(...) bb_error_msg_and_die(__VA_ARGS__)
+#define psTraceCrypto(msg) bb_simple_error_msg_and_die(msg)
 
 /* Secure zerofill */
 #define memset_s(A,B,C,D) memset((A),(C),(D))
diff -Naur busybox-1.31.1/networking/traceroute.c busybox-be5a505d/networking/traceroute.c
--- busybox-1.31.1/networking/traceroute.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/traceroute.c	2019-10-24 07:26:55.000000000 -0700
@@ -875,7 +875,7 @@
 		 * probe (e.g., on a multi-homed host).
 		 */
 		if (getuid() != 0)
-			bb_error_msg_and_die(bb_msg_you_must_be_root);
+			bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 	}
 	if (op & OPT_WAITTIME)
 		waittime = xatou_range(waittime_str, 1, 24 * 60 * 60);
@@ -1003,7 +1003,7 @@
 		if (af == AF_INET)
 			if (setsockopt(sndsock, IPPROTO_IP, IP_MULTICAST_IF,
 					&source_lsa->u.sa, source_lsa->len))
-				bb_error_msg_and_die("can't set multicast source interface");
+				bb_simple_error_msg_and_die("can't set multicast source interface");
 //TODO: we can query source port we bound to,
 // and check it in replies... if we care enough
 		xbind(sndsock, &source_lsa->u.sa, source_lsa->len);
@@ -1025,7 +1025,7 @@
 		/* read IP and port */
 		source_lsa = get_sock_lsa(probe_fd);
 		if (source_lsa == NULL)
-			bb_error_msg_and_die("can't get probe addr");
+			bb_simple_error_msg_and_die("can't get probe addr");
 
 		close(probe_fd);
 
diff -Naur busybox-1.31.1/networking/udhcp/arpping.c busybox-be5a505d/networking/udhcp/arpping.c
--- busybox-1.31.1/networking/udhcp/arpping.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/arpping.c	2019-10-24 07:26:55.000000000 -0700
@@ -53,12 +53,12 @@
 
 	s = socket(PF_PACKET, SOCK_PACKET, htons(ETH_P_ARP));
 	if (s == -1) {
-		bb_perror_msg(bb_msg_can_not_create_raw_socket);
+		bb_simple_perror_msg(bb_msg_can_not_create_raw_socket);
 		return -1;
 	}
 
 	if (setsockopt_broadcast(s) == -1) {
-		bb_perror_msg("can't enable bcast on raw socket");
+		bb_simple_perror_msg("can't enable bcast on raw socket");
 		goto ret;
 	}
 
diff -Naur busybox-1.31.1/networking/udhcp/common.c busybox-be5a505d/networking/udhcp/common.c
--- busybox-1.31.1/networking/udhcp/common.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/common.c	2019-10-24 07:26:55.000000000 -0700
@@ -240,7 +240,7 @@
 	while (1) {
 		if (rem <= 0) {
  complain:
-			bb_error_msg("bad packet, malformed option field");
+			bb_simple_error_msg("bad packet, malformed option field");
 			return NULL;
 		}
 
@@ -539,7 +539,7 @@
 
 		if (optflag->flags == OPTION_BIN) {
 			val = strtok(NULL, ""); /* do not split "'q w e'" */
-			trim(val);
+			if (val) trim(val);
 		} else
 			val = strtok(NULL, ", \t");
 		if (!val)
diff -Naur busybox-1.31.1/networking/udhcp/common.h busybox-be5a505d/networking/udhcp/common.h
--- busybox-1.31.1/networking/udhcp/common.h	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/common.h	2019-10-24 07:26:55.000000000 -0700
@@ -267,26 +267,45 @@
 # define IF_UDHCP_VERBOSE(...) __VA_ARGS__
 extern unsigned dhcp_verbose;
 # define log1(...) do { if (dhcp_verbose >= 1) bb_info_msg(__VA_ARGS__); } while (0)
+# define log1s(msg) do { if (dhcp_verbose >= 1) bb_simple_info_msg(msg); } while (0)
 # if CONFIG_UDHCP_DEBUG >= 2
 void udhcp_dump_packet(struct dhcp_packet *packet) FAST_FUNC;
 #  define log2(...) do { if (dhcp_verbose >= 2) bb_info_msg(__VA_ARGS__); } while (0)
+#  define log2s(msg) do { if (dhcp_verbose >= 2) bb_simple_info_msg(msg); } while (0)
 # else
 #  define udhcp_dump_packet(...) ((void)0)
 #  define log2(...) ((void)0)
+#  define log2s(msg) ((void)0)
 # endif
 # if CONFIG_UDHCP_DEBUG >= 3
 #  define log3(...) do { if (dhcp_verbose >= 3) bb_info_msg(__VA_ARGS__); } while (0)
+#  define log3s(msg) do { if (dhcp_verbose >= 3) bb_simple_info_msg(msg); } while (0)
 # else
 #  define log3(...) ((void)0)
+#  define log3s(msg) ((void)0)
 # endif
 #else
 # define IF_UDHCP_VERBOSE(...)
 # define udhcp_dump_packet(...) ((void)0)
 # define log1(...) ((void)0)
+# define log1s(msg) ((void)0)
 # define log2(...) ((void)0)
+# define log2s(msg) ((void)0)
 # define log3(...) ((void)0)
+# define log3s(msg) ((void)0)
 #endif
 
+#if defined(__mips__)
+/*
+ * The 'simple' message functions have a negative impact on the size of the
+ * DHCP code when compiled for MIPS, so don't use them in this case.
+ */
+#define bb_simple_info_msg bb_info_msg
+#define bb_simple_error_msg bb_error_msg
+#define bb_simple_perror_msg_and_die bb_perror_msg_and_die
+#undef log1s
+#define log1s log1
+#endif
 
 /*** Other shared functions ***/
 
diff -Naur busybox-1.31.1/networking/udhcp/d6_common.h busybox-be5a505d/networking/udhcp/d6_common.h
--- busybox-1.31.1/networking/udhcp/d6_common.h	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/d6_common.h	2019-10-24 07:26:55.000000000 -0700
@@ -34,7 +34,7 @@
 		uint8_t d6_msg_type;
 		uint32_t d6_xid32;
 	} d6_u;
-	uint8_t d6_options[576 - sizeof(struct iphdr) - sizeof(struct udphdr) - 4
+	uint8_t d6_options[576 - sizeof(struct ip6_hdr) - sizeof(struct udphdr) - 4
 			+ CONFIG_UDHCPC_SLACK_FOR_BUGGY_SERVERS];
 } PACKED;
 #define d6_msg_type d6_u.d6_msg_type
diff -Naur busybox-1.31.1/networking/udhcp/d6_dhcpc.c busybox-be5a505d/networking/udhcp/d6_dhcpc.c
--- busybox-1.31.1/networking/udhcp/d6_dhcpc.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/d6_dhcpc.c	2019-10-24 07:26:55.000000000 -0700
@@ -123,6 +123,7 @@
 	"request-option\0" Required_argument "O"
 	"no-default-options\0" No_argument   "o"
 	"foreground\0"     No_argument       "f"
+	"stateless\0"      No_argument       "l"
 	USE_FOR_MMU(
 	"background\0"     No_argument       "b"
 	)
@@ -147,9 +148,10 @@
 	OPT_o = 1 << 12,
 	OPT_x = 1 << 13,
 	OPT_f = 1 << 14,
-	OPT_d = 1 << 15,
+	OPT_l = 1 << 15,
+	OPT_d = 1 << 16,
 /* The rest has variable bit positions, need to be clever */
-	OPTBIT_d = 15,
+	OPTBIT_d = 16,
 	USE_FOR_MMU(             OPTBIT_b,)
 	///IF_FEATURE_UDHCPC_ARPING(OPTBIT_a,)
 	IF_FEATURE_UDHCP_PORT(   OPTBIT_P,)
@@ -235,7 +237,7 @@
  found:
 	val_len = (option[2] << 8) | option[3];
 	if (val_len + &option[D6_OPT_DATA] > option_end) {
-		bb_error_msg("option data exceeds option length");
+		bb_simple_error_msg("option data exceeds option length");
 		return NULL;
 	}
 	return xasprintf("%s=%.*s", name, val_len, (char*)option + 4);
@@ -479,15 +481,31 @@
 /* Initialize the packet with the proper defaults */
 static uint8_t *init_d6_packet(struct d6_packet *packet, char type, uint32_t xid)
 {
+	uint8_t *ptr;
 	struct d6_option *clientid;
+	unsigned secs;
 
 	memset(packet, 0, sizeof(*packet));
 
 	packet->d6_xid32 = xid;
 	packet->d6_msg_type = type;
 
+	/* ELAPSED_TIME option is required to be present by the RFC,
+	 * and some servers do check for its presense. [which?]
+	 */
+	ptr = packet->d6_options; /* NB: it is 32-bit aligned */
+	*((uint32_t*)ptr) = htonl((D6_OPT_ELAPSED_TIME << 16) + 2);
+	ptr += 4;
+	client_data.last_secs = monotonic_sec();
+	if (client_data.first_secs == 0)
+		client_data.first_secs = client_data.last_secs;
+	secs = client_data.last_secs - client_data.first_secs;
+	*((uint16_t*)ptr) = (secs < 0xffff) ? htons(secs) : 0xffff;
+	ptr += 2;
+
+	/* add CLIENTID option */
 	clientid = (void*)client_data.clientid;
-	return mempcpy(packet->d6_options, clientid, clientid->len + 2+2);
+	return mempcpy(ptr, clientid, clientid->len + 2+2);
 }
 
 static uint8_t *add_d6_client_options(uint8_t *ptr)
@@ -544,6 +562,46 @@
 	);
 }
 
+/* RFC 3315 18.1.5. Creation and Transmission of Information-request Messages
+ *
+ * The client uses an Information-request message to obtain
+ * configuration information without having addresses assigned to it.
+ *
+ * The client sets the "msg-type" field to INFORMATION-REQUEST.  The
+ * client generates a transaction ID and inserts this value in the
+ * "transaction-id" field.
+ *
+ * The client SHOULD include a Client Identifier option to identify
+ * itself to the server.  If the client does not include a Client
+ * Identifier option, the server will not be able to return any client-
+ * specific options to the client, or the server may choose not to
+ * respond to the message at all.  The client MUST include a Client
+ * Identifier option if the Information-Request message will be
+ * authenticated.
+ *
+ * The client MUST include an Option Request option (see section 22.7)
+ * to indicate the options the client is interested in receiving.  The
+ * client MAY include options with data values as hints to the server
+ * about parameter values the client would like to have returned.
+ */
+/* NOINLINE: limit stack usage in caller */
+static NOINLINE int send_d6_info_request(uint32_t xid)
+{
+	struct d6_packet packet;
+	uint8_t *opt_ptr;
+
+	/* Fill in: msg type, client id */
+	opt_ptr = init_d6_packet(&packet, D6_MSG_INFORMATION_REQUEST, xid);
+
+	/* Add options:
+	 * "param req" option according to -O, options specified with -x
+	 */
+	opt_ptr = add_d6_client_options(opt_ptr);
+
+	bb_error_msg("sending %s", "info request");
+	return d6_mcast_from_client_data_ifindex(&packet, opt_ptr);
+}
+
 /* Milticast a DHCPv6 Solicit packet to the network, with an optionally requested IP.
  *
  * RFC 3315 17.1.1. Creation of Solicit Messages
@@ -643,7 +701,7 @@
 		client6_data.ia_na = xzalloc(len);
 		client6_data.ia_na->code = D6_OPT_IA_NA;
 		client6_data.ia_na->len = len - 4;
-		*(uint32_t*)client6_data.ia_na->data = rand(); /* IAID */
+		*(bb__aliased_uint32_t*)client6_data.ia_na->data = rand(); /* IAID */
 		if (requested_ipv6) {
 			struct d6_option *iaaddr = (void*)(client6_data.ia_na->data + 4+4+4);
 			iaaddr->code = D6_OPT_IAADDR;
@@ -661,7 +719,7 @@
 		client6_data.ia_pd = xzalloc(len);
 		client6_data.ia_pd->code = D6_OPT_IA_PD;
 		client6_data.ia_pd->len = len - 4;
-		*(uint32_t*)client6_data.ia_pd->data = rand(); /* IAID */
+		*(bb__aliased_uint32_t*)client6_data.ia_pd->data = rand(); /* IAID */
 		opt_ptr = mempcpy(opt_ptr, client6_data.ia_pd, len);
 	}
 
@@ -848,19 +906,19 @@
 
 	bytes = safe_read(fd, &packet, sizeof(packet));
 	if (bytes < 0) {
-		log1("packet read error, ignoring");
+		log1s("packet read error, ignoring");
 		/* NB: possible down interface, etc. Caller should pause. */
 		return bytes; /* returns -1 */
 	}
 
 	if (bytes < (int) (sizeof(packet.ip6) + sizeof(packet.udp))) {
-		log1("packet is too short, ignoring");
+		log1s("packet is too short, ignoring");
 		return -2;
 	}
 
 	if (bytes < sizeof(packet.ip6) + ntohs(packet.ip6.ip6_plen)) {
 		/* packet is bigger than sizeof(packet), we did partial read */
-		log1("oversized packet, ignoring");
+		log1s("oversized packet, ignoring");
 		return -2;
 	}
 
@@ -874,7 +932,7 @@
 	/* || bytes > (int) sizeof(packet) - can't happen */
 	 || packet.udp.len != packet.ip6.ip6_plen
 	) {
-		log1("unrelated/bogus packet, ignoring");
+		log1s("unrelated/bogus packet, ignoring");
 		return -2;
 	}
 
@@ -1003,7 +1061,7 @@
 	}
 #endif
 
-	log1("created raw socket");
+	log1s("created raw socket");
 
 	return fd;
 }
@@ -1031,7 +1089,7 @@
 /* Called only on SIGUSR1 */
 static void perform_renew(void)
 {
-	bb_info_msg("performing DHCP renew");
+	bb_simple_info_msg("performing DHCP renew");
 	switch (client_data.state) {
 	case BOUND:
 		change_listen_mode(LISTEN_KERNEL);
@@ -1059,10 +1117,10 @@
 	 || client_data.state == REBINDING
 	 || client_data.state == RENEW_REQUESTED
 	) {
-		bb_info_msg("unicasting a release");
+		bb_simple_info_msg("unicasting a release");
 		send_d6_release(server_ipv6, our_cur_ipv6); /* unicast */
 	}
-	bb_info_msg("entering released state");
+	bb_simple_info_msg("entering released state");
 /*
  * We can be here on: SIGUSR2,
  * or on exit (SIGTERM) and -R "release on quit" is specified.
@@ -1129,6 +1187,8 @@
 //usage:     "\n	-o		Don't request any options (unless -O is given)"
 //usage:     "\n	-r IPv6		Request this address ('no' to not request any IP)"
 //usage:     "\n	-d		Request prefix"
+//usage:     "\n	-l		Send 'information request' instead of 'solicit'"
+//usage:     "\n			(used for servers which do not assign IPv6 addresses)"
 //usage:     "\n	-x OPT:VAL	Include option OPT in sent packets (cumulative)"
 //usage:     "\n			Examples of string, numeric, and hex byte opts:"
 //usage:     "\n			-x hostname:bbox - option 12"
@@ -1181,7 +1241,7 @@
 	/* Parse command line */
 	opt = getopt32long(argv, "^"
 		/* O,x: list; -T,-t,-A take numeric param */
-		"i:np:qRr:s:T:+t:+SA:+O:*ox:*fd"
+		"i:np:qRr:s:T:+t:+SA:+O:*ox:*fld"
 		USE_FOR_MMU("b")
 		///IF_FEATURE_UDHCPC_ARPING("a")
 		IF_FEATURE_UDHCP_PORT("P:")
@@ -1198,15 +1258,20 @@
 	);
 	requested_ipv6 = NULL;
 	option_mask32 |= OPT_r;
-	if (opt & OPT_r) {
+	if (opt & OPT_l) {
+		/* for -l, do not require IPv6 assignment from server */
+		option_mask32 &= ~OPT_r;
+	} else if (opt & OPT_r) {
+		/* explicit "-r ARG" given */
 		if (strcmp(str_r, "no") == 0) {
-			option_mask32 -= OPT_r;
+			option_mask32 &= ~OPT_r;
 		} else {
 			if (inet_pton(AF_INET6, str_r, &ipv6_buf) <= 0)
 				bb_error_msg_and_die("bad IPv6 address '%s'", str_r);
 			requested_ipv6 = &ipv6_buf;
 		}
 	}
+
 #if ENABLE_FEATURE_UDHCP_PORT
 	if (opt & OPT_P) {
 		CLIENT_PORT6 = xatou16(str_P);
@@ -1275,7 +1340,7 @@
 	/* Create pidfile */
 	write_pidfile(client_data.pidfile);
 	/* Goes to stdout (unless NOMMU) and possibly syslog */
-	bb_info_msg("started, v"BB_VER);
+	bb_simple_info_msg("started, v"BB_VER);
 
 	client_data.state = INIT_SELECTING;
 	d6_run_script_no_option("deconfig");
@@ -1321,7 +1386,7 @@
 					continue;
 				}
 				/* Else: an error occured, panic! */
-				bb_perror_msg_and_die("poll");
+				bb_simple_perror_msg_and_die("poll");
 			}
 		}
 
@@ -1353,7 +1418,10 @@
 					if (packet_num == 0)
 						xid = random_xid();
 					/* multicast */
-					send_d6_discover(xid, requested_ipv6);
+					if (opt & OPT_l)
+						send_d6_info_request(xid);
+					else
+						send_d6_discover(xid, requested_ipv6);
 					timeout = discover_timeout;
 					packet_num++;
 					continue;
@@ -1362,7 +1430,7 @@
 				d6_run_script_no_option("leasefail");
 #if BB_MMU /* -b is not supported on NOMMU */
 				if (opt & OPT_b) { /* background if no lease */
-					bb_info_msg("no lease, forking to background");
+					bb_simple_info_msg("no lease, forking to background");
 					client_background();
 					/* do not background again! */
 					opt = ((opt & ~(OPT_b|OPT_n)) | OPT_f);
@@ -1375,7 +1443,7 @@
 				} else
 #endif
 				if (opt & OPT_n) { /* abort if no lease */
-					bb_info_msg("no lease, failing");
+					bb_simple_info_msg("no lease, failing");
 					retval = 1;
 					goto ret;
 				}
@@ -1403,7 +1471,7 @@
 				client_data.state = RENEWING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
 				change_listen_mode(LISTEN_KERNEL);
-				log1("entering renew state");
+				log1s("entering renew state");
 				/* fall right through */
 			case RENEW_REQUESTED: /* manual (SIGUSR1) renew */
 			case_RENEW_REQUESTED:
@@ -1418,12 +1486,15 @@
 			 * Anyway, it does recover by eventually failing through
 			 * into INIT_SELECTING state.
 			 */
-					send_d6_renew(xid, &srv6_buf, requested_ipv6);
+					if (opt & OPT_l)
+						send_d6_info_request(xid);
+					else
+						send_d6_renew(xid, &srv6_buf, requested_ipv6);
 					timeout >>= 1;
 					continue;
 				}
 				/* Timed out, enter rebinding state */
-				log1("entering rebinding state");
+				log1s("entering rebinding state");
 				client_data.state = REBINDING;
 				/* fall right through */
 			case REBINDING:
@@ -1432,13 +1503,15 @@
 				/* Lease is *really* about to run out,
 				 * try to find DHCP server using broadcast */
 				if (timeout > 0) {
-					/* send a broadcast renew request */
-					send_d6_renew(xid, /*server_ipv6:*/ NULL, requested_ipv6);
+					if (opt & OPT_l)
+						send_d6_info_request(xid);
+					else /* send a broadcast renew request */
+						send_d6_renew(xid, /*server_ipv6:*/ NULL, requested_ipv6);
 					timeout >>= 1;
 					continue;
 				}
 				/* Timed out, enter init state */
-				bb_info_msg("lease lost, entering init state");
+				bb_simple_info_msg("lease lost, entering init state");
 				d6_run_script_no_option("deconfig");
 				client_data.state = INIT_SELECTING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
@@ -1560,7 +1633,7 @@
 				}
 				option = d6_copy_option(packet.d6_options, packet_end, D6_OPT_SERVERID);
 				if (!option) {
-					bb_info_msg("no server ID, ignoring packet");
+					bb_simple_info_msg("no server ID, ignoring packet");
 					continue;
 					/* still selecting - this server looks bad */
 				}
@@ -1740,6 +1813,12 @@
 					prefix_timeout = address_timeout;
 				/* note: "int timeout" will not overflow even with 0xffffffff inputs here: */
 				timeout = (prefix_timeout < address_timeout ? prefix_timeout : address_timeout) / 2;
+				if (opt & OPT_l) {
+					/* TODO: request OPTION_INFORMATION_REFRESH_TIME (32)
+					 * and use its value instead of the default 1 day.
+					 */
+					timeout = 24 * 60 * 60;
+				}
 				/* paranoia: must not be too small */
 				/* timeout > 60 - ensures at least one unicast renew attempt */
 				if (timeout < 61)
diff -Naur busybox-1.31.1/networking/udhcp/d6_packet.c busybox-be5a505d/networking/udhcp/d6_packet.c
--- busybox-1.31.1/networking/udhcp/d6_packet.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/d6_packet.c	2019-10-24 07:26:55.000000000 -0700
@@ -35,12 +35,12 @@
 	memset(packet, 0, sizeof(*packet));
 	bytes = safe_read(fd, packet, sizeof(*packet));
 	if (bytes < 0) {
-		log1("packet read error, ignoring");
+		log1s("packet read error, ignoring");
 		return bytes; /* returns -1 */
 	}
 
 	if (bytes < offsetof(struct d6_packet, d6_options)) {
-		bb_info_msg("packet with bad magic, ignoring");
+		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
 	log1("received %s", "a packet");
diff -Naur busybox-1.31.1/networking/udhcp/d6_socket.c busybox-be5a505d/networking/udhcp/d6_socket.c
--- busybox-1.31.1/networking/udhcp/d6_socket.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/d6_socket.c	2019-10-24 07:26:55.000000000 -0700
@@ -115,7 +115,7 @@
 
 	setsockopt_reuseaddr(fd);
 	if (setsockopt_broadcast(fd) == -1)
-		bb_perror_msg_and_die("SO_BROADCAST");
+		bb_simple_perror_msg_and_die("SO_BROADCAST");
 
 	/* NB: bug 1032 says this doesn't work on ethernet aliases (ethN:M) */
 	if (setsockopt_bindtodevice(fd, inf))
diff -Naur busybox-1.31.1/networking/udhcp/dhcpc.c busybox-be5a505d/networking/udhcp/dhcpc.c
--- busybox-1.31.1/networking/udhcp/dhcpc.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/dhcpc.c	2019-10-24 07:26:55.000000000 -0700
@@ -449,15 +449,16 @@
 
 	memset(found_opts, 0, sizeof(found_opts));
 
-	/* We need 6 elements for:
+	/* We need 7 elements for:
 	 * "interface=IFACE"
 	 * "ip=N.N.N.N" from packet->yiaddr
+	 * "giaddr=IP" from packet->gateway_nip (unless 0)
 	 * "siaddr=IP" from packet->siaddr_nip (unless 0)
 	 * "boot_file=FILE" from packet->file (unless overloaded)
 	 * "sname=SERVER_HOSTNAME" from packet->sname (unless overloaded)
 	 * terminating NULL
 	 */
-	envc = 6;
+	envc = 7;
 	/* +1 element for each option, +2 for subnet option: */
 	if (packet) {
 		/* note: do not search for "pad" (0) and "end" (255) options */
@@ -493,9 +494,7 @@
 	 * uint16_t flags;  // only one flag so far: bcast. Never set by server
 	 * uint32_t ciaddr; // client IP (usually == yiaddr. can it be different
 	 *                  // if during renew server wants to give us different IP?)
-	 * uint32_t gateway_nip; // relay agent IP address
 	 * uint8_t chaddr[16]; // link-layer client hardware address (MAC)
-	 * TODO: export gateway_nip as $giaddr?
 	 */
 	/* Most important one: yiaddr as $ip */
 	*curr = xmalloc(sizeof("ip=255.255.255.255"));
@@ -507,6 +506,12 @@
 		sprint_nip(*curr, "siaddr=", (uint8_t *) &packet->siaddr_nip);
 		putenv(*curr++);
 	}
+	if (packet->gateway_nip) {
+		/* IP address of DHCP relay agent */
+		*curr = xmalloc(sizeof("giaddr=255.255.255.255"));
+		sprint_nip(*curr, "giaddr=", (uint8_t *) &packet->gateway_nip);
+		putenv(*curr++);
+	}
 	if (!(overload & FILE_FIELD) && packet->file[0]) {
 		/* watch out for invalid packets */
 		*curr = xasprintf("boot_file=%."DHCP_PKT_FILE_LEN_STR"s", packet->file);
@@ -601,7 +606,7 @@
 /* Initialize the packet with the proper defaults */
 static void init_packet(struct dhcp_packet *packet, char type)
 {
-	uint16_t secs;
+	unsigned secs;
 
 	/* Fill in: op, htype, hlen, cookie fields; message type option: */
 	udhcp_init_header(packet, type);
@@ -612,7 +617,7 @@
 	if (client_data.first_secs == 0)
 		client_data.first_secs = client_data.last_secs;
 	secs = client_data.last_secs - client_data.first_secs;
-	packet->secs = htons(secs);
+	packet->secs = (secs < 0xffff) ? htons(secs) : 0xffff;
 
 	memcpy(packet->chaddr, client_data.client_mac, 6);
 	if (client_data.clientid)
@@ -901,7 +906,7 @@
 		if (bytes < 0) {
 			if (errno == EINTR)
 				continue;
-			log1("packet read error, ignoring");
+			log1s("packet read error, ignoring");
 			/* NB: possible down interface, etc. Caller should pause. */
 			return bytes; /* returns -1 */
 		}
@@ -909,13 +914,13 @@
 	}
 
 	if (bytes < (int) (sizeof(packet.ip) + sizeof(packet.udp))) {
-		log1("packet is too short, ignoring");
+		log1s("packet is too short, ignoring");
 		return -2;
 	}
 
 	if (bytes < ntohs(packet.ip.tot_len)) {
 		/* packet is bigger than sizeof(packet), we did partial read */
-		log1("oversized packet, ignoring");
+		log1s("oversized packet, ignoring");
 		return -2;
 	}
 
@@ -930,7 +935,7 @@
 	/* || bytes > (int) sizeof(packet) - can't happen */
 	 || ntohs(packet.udp.len) != (uint16_t)(bytes - sizeof(packet.ip))
 	) {
-		log1("unrelated/bogus packet, ignoring");
+		log1s("unrelated/bogus packet, ignoring");
 		return -2;
 	}
 
@@ -938,7 +943,7 @@
 	check = packet.ip.check;
 	packet.ip.check = 0;
 	if (check != inet_cksum((uint16_t *)&packet.ip, sizeof(packet.ip))) {
-		log1("bad IP header checksum, ignoring");
+		log1s("bad IP header checksum, ignoring");
 		return -2;
 	}
 
@@ -963,13 +968,13 @@
 	check = packet.udp.check;
 	packet.udp.check = 0;
 	if (check && check != inet_cksum((uint16_t *)&packet, bytes)) {
-		log1("packet with bad UDP checksum received, ignoring");
+		log1s("packet with bad UDP checksum received, ignoring");
 		return -2;
 	}
  skip_udp_sum_check:
 
 	if (packet.data.cookie != htonl(DHCP_MAGIC)) {
-		bb_info_msg("packet with bad magic, ignoring");
+		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
 
@@ -1084,10 +1089,10 @@
 
 	if (setsockopt_1(fd, SOL_PACKET, PACKET_AUXDATA) != 0) {
 		if (errno != ENOPROTOOPT)
-			log1("can't set PACKET_AUXDATA on raw socket");
+			log1s("can't set PACKET_AUXDATA on raw socket");
 	}
 
-	log1("created raw socket");
+	log1s("created raw socket");
 
 	return fd;
 }
@@ -1115,7 +1120,7 @@
 /* Called only on SIGUSR1 */
 static void perform_renew(void)
 {
-	bb_info_msg("performing DHCP renew");
+	bb_simple_info_msg("performing DHCP renew");
 	switch (client_data.state) {
 	case BOUND:
 		change_listen_mode(LISTEN_KERNEL);
@@ -1153,7 +1158,7 @@
 				inet_ntoa(temp_addr), buffer);
 		send_release(server_addr, requested_ip); /* unicast */
 	}
-	bb_info_msg("entering released state");
+	bb_simple_info_msg("entering released state");
 /*
  * We can be here on: SIGUSR2,
  * or on exit (SIGTERM) and -R "release on quit" is specified.
@@ -1298,7 +1303,7 @@
 	);
 	if (opt & (OPT_h|OPT_H)) {
 		//msg added 2011-11
-		bb_error_msg("option -h NAME is deprecated, use -x hostname:NAME");
+		bb_simple_error_msg("option -h NAME is deprecated, use -x hostname:NAME");
 		client_data.hostname = alloc_dhcp_option(DHCP_HOST_NAME, str_h, 0);
 	}
 	if (opt & OPT_F) {
@@ -1392,7 +1397,7 @@
 	/* Create pidfile */
 	write_pidfile(client_data.pidfile);
 	/* Goes to stdout (unless NOMMU) and possibly syslog */
-	bb_info_msg("started, v"BB_VER);
+	bb_simple_info_msg("started, v"BB_VER);
 	/* We want random_xid to be random... */
 	srand(monotonic_us());
 
@@ -1439,7 +1444,7 @@
 					continue;
 				}
 				/* Else: an error occurred, panic! */
-				bb_perror_msg_and_die("poll");
+				bb_simple_perror_msg_and_die("poll");
 			}
 		}
 
@@ -1480,7 +1485,7 @@
 				udhcp_run_script(NULL, "leasefail");
 #if BB_MMU /* -b is not supported on NOMMU */
 				if (opt & OPT_b) { /* background if no lease */
-					bb_info_msg("no lease, forking to background");
+					bb_simple_info_msg("no lease, forking to background");
 					client_background();
 					/* do not background again! */
 					opt = ((opt & ~(OPT_b|OPT_n)) | OPT_f);
@@ -1493,7 +1498,7 @@
 				} else
 #endif
 				if (opt & OPT_n) { /* abort if no lease */
-					bb_info_msg("no lease, failing");
+					bb_simple_info_msg("no lease, failing");
 					retval = 1;
 					goto ret;
 				}
@@ -1521,7 +1526,7 @@
 				client_data.state = RENEWING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
 				change_listen_mode(LISTEN_KERNEL);
-				log1("entering renew state");
+				log1s("entering renew state");
 				/* fall right through */
 			case RENEW_REQUESTED: /* manual (SIGUSR1) renew */
 			case_RENEW_REQUESTED:
@@ -1554,7 +1559,7 @@
 					 */
 				}
 				/* Timed out or error, enter rebinding state */
-				log1("entering rebinding state");
+				log1s("entering rebinding state");
 				client_data.state = REBINDING;
 				/* fall right through */
 			case REBINDING:
@@ -1569,7 +1574,7 @@
 					continue;
 				}
 				/* Timed out, enter init state */
-				bb_info_msg("lease lost, entering init state");
+				bb_simple_info_msg("lease lost, entering init state");
 				udhcp_run_script(NULL, "deconfig");
 				client_data.state = INIT_SELECTING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
@@ -1655,13 +1660,13 @@
 		 || memcmp(packet.chaddr, client_data.client_mac, 6) != 0
 		) {
 //FIXME: need to also check that last 10 bytes are zero
-			log1("chaddr does not match, ignoring packet"); // log2?
+			log1("chaddr does not match%s", ", ignoring packet"); // log2?
 			continue;
 		}
 
 		message = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);
 		if (message == NULL) {
-			bb_info_msg("no message type option, ignoring packet");
+			bb_info_msg("no message type option%s", ", ignoring packet");
 			continue;
 		}
 
@@ -1698,7 +1703,7 @@
 				server_addr = 0;
 				temp = udhcp_get_option32(&packet, DHCP_SERVER_ID);
 				if (!temp) {
-					bb_info_msg("no server ID, using 0.0.0.0");
+					bb_simple_info_msg("no server ID, using 0.0.0.0");
 				} else {
 					/* it IS unaligned sometimes, don't "optimize" */
 					move_from_unaligned32(server_addr, temp);
@@ -1725,7 +1730,7 @@
 
 				temp = udhcp_get_option32(&packet, DHCP_LEASE_TIME);
 				if (!temp) {
-					bb_info_msg("no lease time with ACK, using 1 hour lease");
+					bb_simple_info_msg("no lease time with ACK, using 1 hour lease");
 					lease_seconds = 60 * 60;
 				} else {
 					/* it IS unaligned sometimes, don't "optimize" */
@@ -1758,7 +1763,7 @@
 							client_data.interface,
 							arpping_ms)
 					) {
-						bb_info_msg("offered address is in use "
+						bb_simple_info_msg("offered address is in use "
 							"(got ARP reply), declining");
 						send_decline(/*xid,*/ server_addr, packet.yiaddr);
 
@@ -1822,7 +1827,7 @@
 					if (!temp) {
  non_matching_svid:
 						log1("received DHCP NAK with wrong"
-							" server ID, ignoring packet");
+							" server ID%s", ", ignoring packet");
 						continue;
 					}
 					move_from_unaligned32(svid, temp);
diff -Naur busybox-1.31.1/networking/udhcp/dhcpc.h busybox-be5a505d/networking/udhcp/dhcpc.h
--- busybox-1.31.1/networking/udhcp/dhcpc.h	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/dhcpc.h	2019-10-24 07:26:55.000000000 -0700
@@ -22,8 +22,8 @@
 	uint8_t *hostname;              /* Optional hostname to use */
 	uint8_t *fqdn;                  /* Optional fully qualified domain name to use */
 
-	uint16_t first_secs;
-	uint16_t last_secs;
+	unsigned first_secs;
+	unsigned last_secs;
 
 	int sockfd;
 	smallint listen_mode;
diff -Naur busybox-1.31.1/networking/udhcp/dhcpd.c busybox-be5a505d/networking/udhcp/dhcpd.c
--- busybox-1.31.1/networking/udhcp/dhcpd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/dhcpd.c	2019-10-24 07:26:55.000000000 -0700
@@ -582,11 +582,11 @@
 	 || (dhcp_pkt->flags & htons(BROADCAST_FLAG))
 	 || dhcp_pkt->ciaddr == 0
 	) {
-		log1("broadcasting packet to client");
+		log1s("broadcasting packet to client");
 		ciaddr = INADDR_BROADCAST;
 		chaddr = MAC_BCAST_ADDR;
 	} else {
-		log1("unicasting packet to client ciaddr");
+		log1s("unicasting packet to client ciaddr");
 		ciaddr = dhcp_pkt->ciaddr;
 		chaddr = dhcp_pkt->chaddr;
 	}
@@ -600,7 +600,7 @@
 /* Send a packet to gateway_nip using the kernel ip stack */
 static void send_packet_to_relay(struct dhcp_packet *dhcp_pkt)
 {
-	log1("forwarding packet to relay");
+	log1s("forwarding packet to relay");
 
 	udhcp_send_kernel_packet(dhcp_pkt,
 			server_data.server_nip, SERVER_PORT,
@@ -754,7 +754,7 @@
 		}
 
 		if (!packet.yiaddr) {
-			bb_error_msg("no free IP addresses. OFFER abandoned");
+			bb_simple_error_msg("no free IP addresses. OFFER abandoned");
 			return;
 		}
 		/* Reserve the IP for a short time hoping to get DHCPREQUEST soon */
@@ -765,7 +765,7 @@
 				p_host_name ? (unsigned char)p_host_name[OPT_LEN - OPT_DATA] : 0
 		);
 		if (!lease) {
-			bb_error_msg("no free IP addresses. OFFER abandoned");
+			bb_simple_error_msg("no free IP addresses. OFFER abandoned");
 			return;
 		}
 	}
@@ -914,7 +914,7 @@
 	write_pidfile(server_data.pidfile);
 	/* if (!..) bb_perror_msg("can't create pidfile %s", pidfile); */
 
-	bb_info_msg("started, v"BB_VER);
+	bb_simple_info_msg("started, v"BB_VER);
 
 	option = udhcp_find_option(server_data.options, DHCP_LEASE_TIME);
 	server_data.max_lease_sec = DEFAULT_LEASE_TIME;
@@ -985,7 +985,7 @@
 			if (errno == EINTR)
 				goto new_tv;
 			/* < 0 and not EINTR: should not happen */
-			bb_perror_msg_and_die("poll");
+			bb_simple_perror_msg_and_die("poll");
 		}
 
 		if (pfds[0].revents) switch (udhcp_sp_read()) {
@@ -1019,16 +1019,16 @@
 			continue;
 		}
 		if (packet.hlen != 6) {
-			bb_info_msg("MAC length != 6, ignoring packet");
+			bb_info_msg("MAC length != 6%s", ", ignoring packet");
 			continue;
 		}
 		if (packet.op != BOOTREQUEST) {
-			bb_info_msg("not a REQUEST, ignoring packet");
+			bb_info_msg("not a REQUEST%s", ", ignoring packet");
 			continue;
 		}
 		state = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);
 		if (state == NULL || state[0] < DHCP_MINTYPE || state[0] > DHCP_MAXTYPE) {
-			bb_info_msg("no or bad message type option, ignoring packet");
+			bb_info_msg("no or bad message type option%s", ", ignoring packet");
 			continue;
 		}
 
@@ -1039,7 +1039,7 @@
 			move_from_unaligned32(server_id_network_order, server_id_opt);
 			if (server_id_network_order != server_data.server_nip) {
 				/* client talks to somebody else */
-				log1("server ID doesn't match, ignoring");
+				log1("server ID doesn't match%s", ", ignoring");
 				continue;
 			}
 		}
@@ -1162,7 +1162,7 @@
 			if (!requested_ip_opt) {
 				requested_nip = packet.ciaddr;
 				if (requested_nip == 0) {
-					log1("no requested IP and no ciaddr, ignoring");
+					log1("no requested IP and no ciaddr%s", ", ignoring");
 					break;
 				}
 			}
diff -Naur busybox-1.31.1/networking/udhcp/dhcprelay.c busybox-be5a505d/networking/udhcp/dhcprelay.c
--- busybox-1.31.1/networking/udhcp/dhcprelay.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/dhcprelay.c	2019-10-24 07:26:55.000000000 -0700
@@ -186,7 +186,7 @@
 	err = sendto(sock, msg, msg_len, 0, (struct sockaddr*) to, sizeof(*to));
 	err -= msg_len;
 	if (err)
-		bb_perror_msg("sendto");
+		bb_simple_perror_msg("sendto");
 	return err;
 }
 
@@ -273,7 +273,7 @@
 		bb_show_usage();
 	if (argv[3]) {
 		if (!inet_aton(argv[3], &server_addr.sin_addr))
-			bb_perror_msg_and_die("bad server IP");
+			bb_simple_perror_msg_and_die("bad server IP");
 	}
 
 	iface_list = make_iface_list(argv + 1, &num_sockets);
diff -Naur busybox-1.31.1/networking/udhcp/packet.c busybox-be5a505d/networking/udhcp/packet.c
--- busybox-1.31.1/networking/udhcp/packet.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/packet.c	2019-10-24 07:26:55.000000000 -0700
@@ -85,14 +85,14 @@
 	memset(packet, 0, sizeof(*packet));
 	bytes = safe_read(fd, packet, sizeof(*packet));
 	if (bytes < 0) {
-		log1("packet read error, ignoring");
+		log1s("packet read error, ignoring");
 		return bytes; /* returns -1 */
 	}
 
 	if (bytes < offsetof(struct dhcp_packet, options)
 	 || packet->cookie != htonl(DHCP_MAGIC)
 	) {
-		bb_info_msg("packet with bad magic, ignoring");
+		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
 	log1("received %s", "a packet");
diff -Naur busybox-1.31.1/networking/udhcp/signalpipe.c busybox-be5a505d/networking/udhcp/signalpipe.c
--- busybox-1.31.1/networking/udhcp/signalpipe.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/signalpipe.c	2019-10-24 07:26:55.000000000 -0700
@@ -28,7 +28,7 @@
 	int sv = errno;
 	unsigned char ch = sig; /* use char, avoid dealing with partial writes */
 	if (write(WRITE_FD, &ch, 1) != 1)
-		bb_perror_msg("can't send signal");
+		bb_simple_perror_msg("can't send signal");
 	errno = sv;
 }
 
diff -Naur busybox-1.31.1/networking/udhcp/socket.c busybox-be5a505d/networking/udhcp/socket.c
--- busybox-1.31.1/networking/udhcp/socket.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/udhcp/socket.c	2019-10-24 07:26:55.000000000 -0700
@@ -87,7 +87,7 @@
 
 	setsockopt_reuseaddr(fd);
 	if (setsockopt_broadcast(fd) == -1)
-		bb_perror_msg_and_die("SO_BROADCAST");
+		bb_simple_perror_msg_and_die("SO_BROADCAST");
 
 	/* SO_BINDTODEVICE doesn't work on ethernet aliases (ethN:M) */
 	colon = strrchr(inf, ':');
diff -Naur busybox-1.31.1/networking/wget.c busybox-be5a505d/networking/wget.c
--- busybox-1.31.1/networking/wget.c	2019-10-21 07:54:40.000000000 -0700
+++ busybox-be5a505d/networking/wget.c	2019-10-24 07:26:55.000000000 -0700
@@ -368,7 +368,7 @@
 {
 	/* This is theoretically unsafe (uses stdio and malloc in signal handler) */
 	if (G.die_if_timed_out)
-		bb_error_msg_and_die("download timed out");
+		bb_simple_error_msg_and_die("download timed out");
 }
 static void set_alarm(void)
 {
@@ -452,7 +452,7 @@
 
 	set_alarm();
 	if (fgets(G.wget_buf, sizeof(G.wget_buf), fp) == NULL)
-		bb_perror_msg_and_die("error getting response");
+		bb_simple_perror_msg_and_die("error getting response");
 	clear_alarm();
 
 	buf_ptr = strchrnul(G.wget_buf, '\n');
@@ -633,7 +633,7 @@
 
 static void reset_beg_range_to_zero(void)
 {
-	bb_error_msg("restart failed");
+	bb_simple_error_msg("restart failed");
 	G.beg_range = 0;
 	xlseek(G.output_fd, 0, SEEK_SET);
 	/* Done at the end instead: */
@@ -651,7 +651,7 @@
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) != 0)
 		/* Kernel can have AF_UNIX support disabled */
-		bb_perror_msg_and_die("socketpair");
+		bb_simple_perror_msg_and_die("socketpair");
 
 	if (!strchr(host, ':'))
 		host = allocated = xasprintf("%s:%u", host, port);
@@ -724,7 +724,7 @@
 
 	if (!(option_mask32 & WGET_OPT_NO_CHECK_CERT)) {
 		option_mask32 |= WGET_OPT_NO_CHECK_CERT;
-		bb_error_msg("note: TLS certificate validation not implemented");
+		bb_simple_error_msg("note: TLS certificate validation not implemented");
 	}
 
 	servername = xstrdup(host);
@@ -733,7 +733,7 @@
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) != 0)
 		/* Kernel can have AF_UNIX support disabled */
-		bb_perror_msg_and_die("socketpair");
+		bb_simple_perror_msg_and_die("socketpair");
 
 	fflush_all();
 	pid = BB_MMU ? xfork() : xvfork();
@@ -785,7 +785,7 @@
 #endif
 
 	if (ftpcmd(NULL, NULL, sfp) != 220)
-		bb_error_msg_and_die("%s", G.wget_buf);
+		bb_simple_error_msg_and_die(G.wget_buf);
 		/* note: ftpcmd() sanitizes G.wget_buf, ok to print */
 
 	/* Split username:password pair */
@@ -948,7 +948,7 @@
 			if (errno != EAGAIN) {
 				if (ferror(dfp)) {
 					progress_meter(PROGRESS_END);
-					bb_perror_msg_and_die(bb_msg_read_error);
+					bb_simple_perror_msg_and_die(bb_msg_read_error);
 				}
 				break; /* EOF, not error */
 			}
@@ -961,7 +961,7 @@
 # if ENABLE_FEATURE_WGET_TIMEOUT
 				if (second_cnt != 0 && --second_cnt == 0) {
 					progress_meter(PROGRESS_END);
-					bb_error_msg_and_die("download timed out");
+					bb_simple_error_msg_and_die("download timed out");
 				}
 # endif
 				/* We used to loop back to poll here,
@@ -1014,7 +1014,7 @@
 	G.got_clen = 1; /* makes it show 100% even for download of (formerly) unknown size */
 	progress_meter(PROGRESS_END);
 	if (G.content_len != 0) {
-		bb_perror_msg_and_die("connection closed prematurely");
+		bb_simple_perror_msg_and_die("connection closed prematurely");
 		/* GNU wget says "DATE TIME (NN MB/s) - Connection closed at byte NNN. Retrying." */
 	}
 
@@ -1348,7 +1348,7 @@
 			}
 			if (key == KEY_location && status >= 300) {
 				if (--redir_limit == 0)
-					bb_error_msg_and_die("too many redirections");
+					bb_simple_error_msg_and_die("too many redirections");
 				fclose(sfp);
 				if (str[0] == '/') {
 					free(redirected_path);
diff -Naur busybox-1.31.1/networking/zcip.c busybox-be5a505d/networking/zcip.c
--- busybox-1.31.1/networking/zcip.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/networking/zcip.c	2019-10-24 07:26:55.000000000 -0700
@@ -276,7 +276,7 @@
 		if (inet_aton(l_opt, &net) == 0
 		 || (net.s_addr & htonl(IN_CLASSB_NET)) != net.s_addr
 		) {
-			bb_error_msg_and_die("invalid network address");
+			bb_simple_error_msg_and_die("invalid network address");
 		}
 		G.localnet_ip = ntohl(net.s_addr);
 	}
@@ -285,7 +285,7 @@
 		if (inet_aton(r_opt, &ip) == 0
 		 || (ntohl(ip.s_addr) & IN_CLASSB_NET) != G.localnet_ip
 		) {
-			bb_error_msg_and_die("invalid link address");
+			bb_simple_error_msg_and_die("invalid link address");
 		}
 		chosen_nip = ip.s_addr;
 	}
@@ -473,7 +473,7 @@
 
 		// Read ARP packet
 		if (safe_read(sock_fd, &p, sizeof(p)) < 0) {
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		}
 
 		if (p.eth.ether_type != htons(ETHERTYPE_ARP))
diff -Naur busybox-1.31.1/printutils/lpr.c busybox-be5a505d/printutils/lpr.c
--- busybox-1.31.1/printutils/lpr.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/printutils/lpr.c	2019-10-24 07:26:55.000000000 -0700
@@ -167,7 +167,7 @@
 	// LPR ------------------------
 	//
 	if (opts & LPR_V)
-		bb_error_msg("connected to server");
+		bb_simple_error_msg("connected to server");
 
 	job = getpid() % 1000;
 	hostname = safe_gethostname();
@@ -206,7 +206,7 @@
 		 * Standard lpr works around it by refusing to send such jobs:
 		 */
 		if (st.st_size == 0) {
-			bb_error_msg("nothing to print");
+			bb_simple_error_msg("nothing to print");
 			continue;
 		}
 
@@ -246,7 +246,7 @@
 
 		// send control file
 		if (opts & LPR_V)
-			bb_error_msg("sending control file");
+			bb_simple_error_msg("sending control file");
 		/* "Acknowledgement processing must occur as usual
 		 * after the command is sent." */
 		cflen = (unsigned)strlen(controlfile);
@@ -262,12 +262,12 @@
 
 		// send data file, with name "dfaXXX"
 		if (opts & LPR_V)
-			bb_error_msg("sending data file");
+			bb_simple_error_msg("sending data file");
 		fdprintf(fd, "\x3" "%"OFF_FMT"u d%s\n", st.st_size, remote_filename);
 		get_response_or_say_and_die(fd, "sending data file");
 		if (bb_copyfd_size(dfd, fd, st.st_size) != st.st_size) {
 			// We're screwed. We sent less bytes than we advertised.
-			bb_error_msg_and_die("local file changed size?!");
+			bb_simple_error_msg_and_die("local file changed size?!");
 		}
 		write(fd, "", 1); // send ACK
 		get_response_or_say_and_die(fd, "sending data file");
@@ -283,7 +283,7 @@
 
 		// say job accepted
 		if (opts & LPR_V)
-			bb_error_msg("job accepted");
+			bb_simple_error_msg("job accepted");
 
 		// next, please!
 		job = (job + 1) % 1000;
diff -Naur busybox-1.31.1/procps/free.c busybox-be5a505d/procps/free.c
--- busybox-1.31.1/procps/free.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/procps/free.c	2019-10-24 07:26:55.000000000 -0700
@@ -44,6 +44,7 @@
 #else
 # define G_unit_steps 10
 #endif
+	unsigned long cached_kb, available_kb, reclaimable_kb;
 };
 /* Because of NOFORK, "globals" are not in global data */
 
@@ -53,27 +54,30 @@
 }
 
 /* NOINLINE reduces main() stack usage, which makes code smaller (on x86 at least) */
-static NOINLINE unsigned int parse_meminfo(unsigned long *cached_kb, unsigned long *available_kb)
+static NOINLINE unsigned int parse_meminfo(struct globals *g)
 {
 	char buf[60]; /* actual lines we expect are ~30 chars or less */
 	FILE *fp;
-	int seen_cached_and_available;
+	int seen_cached_and_available_and_reclaimable;
 
 	fp = xfopen_for_read("/proc/meminfo");
-	*cached_kb = *available_kb = 0;
-	seen_cached_and_available = 2;
+	g->cached_kb = g->available_kb = g->reclaimable_kb = 0;
+	seen_cached_and_available_and_reclaimable = 3;
 	while (fgets(buf, sizeof(buf), fp)) {
-		if (sscanf(buf, "Cached: %lu %*s\n", cached_kb) == 1)
-			if (--seen_cached_and_available == 0)
+		if (sscanf(buf, "Cached: %lu %*s\n", &g->cached_kb) == 1)
+			if (--seen_cached_and_available_and_reclaimable == 0)
 				break;
-		if (sscanf(buf, "MemAvailable: %lu %*s\n", available_kb) == 1)
-			if (--seen_cached_and_available == 0)
+		if (sscanf(buf, "MemAvailable: %lu %*s\n", &g->available_kb) == 1)
+			if (--seen_cached_and_available_and_reclaimable == 0)
+				break;
+		if (sscanf(buf, "SReclaimable: %lu %*s\n", &g->reclaimable_kb) == 1)
+			if (--seen_cached_and_available_and_reclaimable == 0)
 				break;
 	}
 	/* Have to close because of NOFORK */
 	fclose(fp);
 
-	return seen_cached_and_available == 0;
+	return seen_cached_and_available_and_reclaimable == 0;
 }
 
 int free_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -82,7 +86,6 @@
 	struct globals G;
 	struct sysinfo info;
 	unsigned long long cached, cached_plus_free, available;
-	unsigned long cached_kb, available_kb;
 	int seen_available;
 
 #if ENABLE_DESKTOP
@@ -118,10 +121,11 @@
 	/* Kernels prior to 2.4.x will return info.mem_unit==0, so cope... */
 	G.mem_unit = (info.mem_unit ? info.mem_unit : 1);
 	/* Extract cached and memavailable from /proc/meminfo and convert to mem_units */
-	seen_available = parse_meminfo(&cached_kb, &available_kb);
-	available = ((unsigned long long) available_kb * 1024) / G.mem_unit;
-	cached = ((unsigned long long) cached_kb * 1024) / G.mem_unit;
+	seen_available = parse_meminfo(&G);
+	available = ((unsigned long long) G.available_kb * 1024) / G.mem_unit;
+	cached = ((unsigned long long) G.cached_kb * 1024) / G.mem_unit;
 	cached += info.bufferram;
+	cached += ((unsigned long long) G.reclaimable_kb * 1024) / G.mem_unit;
 	cached_plus_free = cached + info.freeram;
 
 #define FIELDS_6 "%12llu %11llu %11llu %11llu %11llu %11llu\n"
diff -Naur busybox-1.31.1/procps/kill.c busybox-be5a505d/procps/kill.c
--- busybox-1.31.1/procps/kill.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/procps/kill.c	2019-10-24 07:26:55.000000000 -0700
@@ -268,7 +268,7 @@
 #if ENABLE_KILL || ENABLE_KILLALL
 	/* Pid or name is required for kill/killall */
 	if (!arg) {
-		bb_error_msg("you need to specify whom to kill");
+		bb_simple_error_msg("you need to specify whom to kill");
 		return EXIT_FAILURE;
 	}
 
diff -Naur busybox-1.31.1/procps/mpstat.c busybox-be5a505d/procps/mpstat.c
--- busybox-1.31.1/procps/mpstat.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/procps/mpstat.c	2019-10-24 07:26:55.000000000 -0700
@@ -931,7 +931,7 @@
 				/* Get CPU number */
 				unsigned n = xatoi_positive(t);
 				if (n >= G.cpu_nr)
-					bb_error_msg_and_die("not that many processors");
+					bb_simple_error_msg_and_die("not that many processors");
 				n++;
 				G.cpu_bitmap[n >> 3] |= 1 << (n & 7);
 			}
diff -Naur busybox-1.31.1/procps/nmeter.c busybox-be5a505d/procps/nmeter.c
--- busybox-1.31.1/procps/nmeter.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/procps/nmeter.c	2019-10-24 07:26:55.000000000 -0700
@@ -351,7 +351,7 @@
 enum { CPU_FIELDCNT = 7 };
 S_STAT(cpu_stat)
 	ullong old[CPU_FIELDCNT];
-	int bar_sz;
+	unsigned bar_sz;
 	char bar[1];
 S_STAT_END(cpu_stat)
 
@@ -360,8 +360,8 @@
 	ullong data[CPU_FIELDCNT] = { 0, 0, 0, 0, 0, 0, 0 };
 	unsigned frac[CPU_FIELDCNT] = { 0, 0, 0, 0, 0, 0, 0 };
 	ullong all = 0;
-	int norm_all = 0;
-	int bar_sz = s->bar_sz;
+	unsigned norm_all = 0;
+	unsigned bar_sz = s->bar_sz;
 	char *bar = s->bar;
 	int i;
 
@@ -420,8 +420,8 @@
 {
 	int sz;
 	cpu_stat *s;
-	sz = strtoul(param, NULL, 0); /* param can be "" */
-	if (sz < 10) sz = 10;
+	sz = param[0] ? strtoul(param, NULL, 0) : 10;
+	if (sz <= 0) sz = 1;
 	if (sz > 1000) sz = 1000;
 	s = xzalloc(sizeof(*s) + sz);
 	/*s->bar[sz] = '\0'; - xzalloc did it */
diff -Naur busybox-1.31.1/procps/powertop.c busybox-be5a505d/procps/powertop.c
--- busybox-1.31.1/procps/powertop.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/procps/powertop.c	2019-10-24 07:26:55.000000000 -0700
@@ -657,7 +657,7 @@
 		}
 	} else {
 		bb_putchar('\n');
-		bb_error_msg("no stats available; run as root or"
+		bb_simple_error_msg("no stats available; run as root or"
 				" enable the timer_stats module");
 	}
 }
@@ -707,7 +707,7 @@
 
 	/* Print warning when we don't have superuser privileges */
 	if (geteuid() != 0)
-		bb_error_msg("run as root to collect enough information");
+		bb_simple_error_msg("run as root to collect enough information");
 
 	/* Get number of CPUs */
 	G.total_cpus = get_cpu_count();
diff -Naur busybox-1.31.1/procps/pstree.c busybox-be5a505d/procps/pstree.c
--- busybox-1.31.1/procps/pstree.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/procps/pstree.c	2019-10-24 07:26:55.000000000 -0700
@@ -404,7 +404,7 @@
 	else {
 		dump_by_user(find_proc(1), uid);
 		if (!G.dumped) {
-			bb_error_msg_and_die("no processes found");
+			bb_simple_error_msg_and_die("no processes found");
 		}
 	}
 
diff -Naur busybox-1.31.1/procps/top.c busybox-be5a505d/procps/top.c
--- busybox-1.31.1/procps/top.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/procps/top.c	2019-10-24 07:26:55.000000000 -0700
@@ -979,6 +979,9 @@
 		IF_FEATURE_TOPMEM(&& scan_mask != TOPMEM_MASK)
 		) {
 			scan_mask ^= PSSCAN_TASKS;
+			free(prev_hist);
+			prev_hist = NULL;
+			prev_hist_count = 0;
 			continue;
 		}
 # endif
@@ -1000,10 +1003,10 @@
 #  if ENABLE_FEATURE_TOPMEM
 		if (c == 's') {
 			scan_mask = TOPMEM_MASK;
+			sort_field = (sort_field + 1) % NUM_SORT_FIELD;
 			free(prev_hist);
 			prev_hist = NULL;
 			prev_hist_count = 0;
-			sort_field = (sort_field + 1) % NUM_SORT_FIELD;
 			continue;
 		}
 #  endif
@@ -1229,7 +1232,7 @@
 #endif
 		} /* end of "while we read /proc" */
 		if (ntop == 0) {
-			bb_error_msg("no process info in /proc");
+			bb_simple_error_msg("no process info in /proc");
 			break;
 		}
 
diff -Naur busybox-1.31.1/runit/chpst.c busybox-be5a505d/runit/chpst.c
--- busybox-1.31.1/runit/chpst.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/runit/chpst.c	2019-10-24 07:26:55.000000000 -0700
@@ -270,7 +270,7 @@
 	else
 		r.rlim_cur = l;
 	if (setrlimit(what, &r) == -1)
-		bb_perror_msg_and_die("setrlimit");
+		bb_simple_perror_msg_and_die("setrlimit");
 }
 
 int chpst_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -467,12 +467,12 @@
 	if (opt & OPT_n) {
 		errno = 0;
 		if (nice(xatoi(nicestr)) == -1)
-			bb_perror_msg_and_die("nice");
+			bb_simple_perror_msg_and_die("nice");
 	}
 
 	if (opt & OPT_u) {
 		if (setgroups(1, &ugid.gid) == -1)
-			bb_perror_msg_and_die("setgroups");
+			bb_simple_perror_msg_and_die("setgroups");
 		xsetgid(ugid.gid);
 		xsetuid(ugid.uid);
 	}
diff -Naur busybox-1.31.1/runit/runsv.c busybox-be5a505d/runit/runsv.c
--- busybox-1.31.1/runit/runsv.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/runit/runsv.c	2019-10-24 07:26:55.000000000 -0700
@@ -51,11 +51,9 @@
 #if ENABLE_MONOTONIC_SYSCALL
 #include <sys/syscall.h>
 
-/* libc has incredibly messy way of doing this,
- * typically requiring -lrt. We just skip all this mess */
 static void gettimeofday_ns(struct timespec *ts)
 {
-	syscall(__NR_clock_gettime, CLOCK_REALTIME, ts);
+	clock_gettime(CLOCK_REALTIME, ts);
 }
 #else
 static void gettimeofday_ns(struct timespec *ts)
diff -Naur busybox-1.31.1/runit/svlogd.c busybox-be5a505d/runit/svlogd.c
--- busybox-1.31.1/runit/svlogd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/runit/svlogd.c	2019-10-24 07:26:55.000000000 -0700
@@ -274,7 +274,7 @@
 }
 static void pause_nomem(void)
 {
-	bb_error_msg(PAUSE"out of memory");
+	bb_simple_error_msg(PAUSE"out of memory");
 	sleep(3);
 }
 static void pause1cannot(const char *m0)
diff -Naur busybox-1.31.1/scripts/basic/.gitignore busybox-be5a505d/scripts/basic/.gitignore
--- busybox-1.31.1/scripts/basic/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ busybox-be5a505d/scripts/basic/.gitignore	2019-10-24 07:26:55.000000000 -0700
@@ -0,0 +1,4 @@
+hash
+fixdep
+docproc
+split-include
diff -Naur busybox-1.31.1/scripts/kconfig/.gitignore busybox-be5a505d/scripts/kconfig/.gitignore
--- busybox-1.31.1/scripts/kconfig/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ busybox-be5a505d/scripts/kconfig/.gitignore	2019-10-24 07:26:55.000000000 -0700
@@ -0,0 +1,19 @@
+#
+# Generated files
+#
+config*
+lex.*.c
+*.tab.c
+*.tab.h
+zconf.hash.c
+*.moc
+lkc_defs.h
+
+#
+# configuration programs
+#
+conf
+mconf
+qconf
+gconf
+kxgettext
diff -Naur busybox-1.31.1/scripts/kconfig/lxdialog/.gitignore busybox-be5a505d/scripts/kconfig/lxdialog/.gitignore
--- busybox-1.31.1/scripts/kconfig/lxdialog/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ busybox-be5a505d/scripts/kconfig/lxdialog/.gitignore	2019-10-24 07:26:55.000000000 -0700
@@ -0,0 +1,4 @@
+#
+# Generated files
+#
+lxdialog
diff -Naur busybox-1.31.1/selinux/chcon.c busybox-be5a505d/selinux/chcon.c
--- busybox-1.31.1/selinux/chcon.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/selinux/chcon.c	2019-10-24 07:26:55.000000000 -0700
@@ -107,7 +107,7 @@
 
 	context_string = context_str(context);
 	if (!context_string) {
-		bb_error_msg("can't obtain security context in text expression");
+		bb_simple_error_msg("can't obtain security context in text expression");
 		goto skip;
 	}
 
@@ -194,7 +194,7 @@
 		/* specified_context is never NULL -
 		 * "-1" in opt_complementary prevents this. */
 		if (!argv[0])
-			bb_error_msg_and_die("too few arguments");
+			bb_simple_error_msg_and_die("too few arguments");
 	}
 
 	for (i = 0; (fname = argv[i]) != NULL; i++) {
diff -Naur busybox-1.31.1/selinux/getenforce.c busybox-be5a505d/selinux/getenforce.c
--- busybox-1.31.1/selinux/getenforce.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/selinux/getenforce.c	2019-10-24 07:26:55.000000000 -0700
@@ -29,12 +29,12 @@
 
 	rc = is_selinux_enabled();
 	if (rc < 0)
-		bb_error_msg_and_die("is_selinux_enabled() failed");
+		bb_simple_error_msg_and_die("is_selinux_enabled() failed");
 
 	if (rc == 1) {
 		rc = security_getenforce();
 		if (rc < 0)
-			bb_error_msg_and_die("getenforce() failed");
+			bb_simple_error_msg_and_die("getenforce() failed");
 
 		if (rc)
 			puts("Enforcing");
diff -Naur busybox-1.31.1/selinux/getsebool.c busybox-be5a505d/selinux/getsebool.c
--- busybox-1.31.1/selinux/getsebool.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/selinux/getsebool.c	2019-10-24 07:26:55.000000000 -0700
@@ -40,7 +40,7 @@
 
 		rc = security_get_boolean_names(&names, &len);
 		if (rc)
-			bb_perror_msg_and_die("can't get boolean names");
+			bb_simple_perror_msg_and_die("can't get boolean names");
 
 		if (!len) {
 			puts("No booleans");
diff -Naur busybox-1.31.1/selinux/load_policy.c busybox-be5a505d/selinux/load_policy.c
--- busybox-1.31.1/selinux/load_policy.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/selinux/load_policy.c	2019-10-24 07:26:55.000000000 -0700
@@ -31,7 +31,7 @@
 
 	rc = selinux_mkload_policy(1);
 	if (rc < 0) {
-		bb_perror_msg_and_die("can't load policy");
+		bb_simple_perror_msg_and_die("can't load policy");
 	}
 
 	return 0;
diff -Naur busybox-1.31.1/selinux/runcon.c busybox-be5a505d/selinux/runcon.c
--- busybox-1.31.1/selinux/runcon.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/selinux/runcon.c	2019-10-24 07:26:55.000000000 -0700
@@ -65,7 +65,7 @@
 	security_context_t cur_context;
 
 	if (getcon(&cur_context))
-		bb_error_msg_and_die("can't get current context");
+		bb_simple_error_msg_and_die("can't get current context");
 
 	if (compute_trans) {
 		security_context_t file_context, new_context;
@@ -75,7 +75,7 @@
 					command);
 		if (security_compute_create(cur_context, file_context,
 					SECCLASS_PROCESS, &new_context))
-			bb_error_msg_and_die("unable to compute a new context");
+			bb_simple_error_msg_and_die("unable to compute a new context");
 		cur_context = new_context;
 	}
 
@@ -137,7 +137,7 @@
 	if (!(opts & OPTS_CONTEXT_COMPONENT)) {
 		context = *argv++;
 		if (!argv[0])
-			bb_error_msg_and_die("no command given");
+			bb_simple_error_msg_and_die("no command given");
 	}
 
 	if (context) {
diff -Naur busybox-1.31.1/selinux/sestatus.c busybox-be5a505d/selinux/sestatus.c
--- busybox-1.31.1/selinux/sestatus.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/selinux/sestatus.c	2019-10-24 07:26:55.000000000 -0700
@@ -216,5 +216,5 @@
 	return 0;
 
   error:
-	bb_perror_msg_and_die("libselinux returns unknown state");
+	bb_simple_perror_msg_and_die("libselinux returns unknown state");
 }
diff -Naur busybox-1.31.1/selinux/setenforce.c busybox-be5a505d/selinux/setenforce.c
--- busybox-1.31.1/selinux/setenforce.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/selinux/setenforce.c	2019-10-24 07:26:55.000000000 -0700
@@ -49,7 +49,7 @@
 			continue;
 		rc = security_setenforce(i & 1);
 		if (rc < 0)
-			bb_perror_msg_and_die("setenforce() failed");
+			bb_simple_perror_msg_and_die("setenforce() failed");
 		return 0;
 	}
 
diff -Naur busybox-1.31.1/selinux/setfiles.c busybox-be5a505d/selinux/setfiles.c
--- busybox-1.31.1/selinux/setfiles.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/selinux/setfiles.c	2019-10-24 07:26:55.000000000 -0700
@@ -182,7 +182,7 @@
 {
 	nerr++;
 	if (nerr > 9 && !FLAG_d_debug) {
-		bb_error_msg_and_die("exiting after 10 errors");
+		bb_simple_error_msg_and_die("exiting after 10 errors");
 	}
 }
 
diff -Naur busybox-1.31.1/selinux/setsebool.c busybox-be5a505d/selinux/setsebool.c
--- busybox-1.31.1/selinux/setsebool.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/selinux/setsebool.c	2019-10-24 07:26:55.000000000 -0700
@@ -46,7 +46,7 @@
 	}
 
 	if (security_set_boolean(argv[1], value) < 0)
-		bb_error_msg_and_die("can't set boolean");
+		bb_simple_error_msg_and_die("can't set boolean");
 
 	return 0;
 }
diff -Naur busybox-1.31.1/shell/ash.c busybox-be5a505d/shell/ash.c
--- busybox-1.31.1/shell/ash.c	2019-10-21 07:54:40.000000000 -0700
+++ busybox-be5a505d/shell/ash.c	2019-10-24 07:26:55.000000000 -0700
@@ -12393,7 +12393,13 @@
 		for (p = eofmark; STPUTC(c, out), *p; p++) {
 			if (c != *p)
 				goto more_heredoc;
-
+			/* FIXME: fails for backslash-newlined terminator:
+			 * cat <<EOF
+			 * ...
+			 * EO\
+			 * F
+			 * (see heredoc_bkslash_newline2.tests)
+			 */
 			c = pgetc_without_PEOA();
 		}
 
diff -Naur busybox-1.31.1/shell/ash_test/.gitignore busybox-be5a505d/shell/ash_test/.gitignore
--- busybox-1.31.1/shell/ash_test/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ busybox-be5a505d/shell/ash_test/.gitignore	2019-10-24 07:26:55.000000000 -0700
@@ -0,0 +1,7 @@
+/ash
+/printenv
+/recho
+/zecho
+
+/*.fail
+*.xx
diff -Naur busybox-1.31.1/shell/hush.c busybox-be5a505d/shell/hush.c
--- busybox-1.31.1/shell/hush.c	2019-10-21 07:54:40.000000000 -0700
+++ busybox-be5a505d/shell/hush.c	2019-10-24 07:26:55.000000000 -0700
@@ -1398,7 +1398,7 @@
 	if (msg)
 		bb_error_msg("syntax error: %s", msg);
 	else
-		bb_error_msg("syntax error");
+		bb_simple_error_msg("syntax error");
 	die_if_script();
 }
 
@@ -1637,7 +1637,7 @@
 	fp->cur = fp->buf;
 	n = safe_read(fp->fd, fp->buf, sizeof(fp->buf));
 	if (n < 0) {
-		bb_perror_msg("read error");
+		bb_simple_perror_msg("read error");
 		n = 0;
 	}
 	fp->end = fp->buf + n;
@@ -2282,7 +2282,7 @@
 
 	eq_sign = strchr(str, '=');
 	if (HUSH_DEBUG && !eq_sign)
-		bb_error_msg_and_die("BUG in setvar");
+		bb_simple_error_msg_and_die("BUG in setvar");
 
 	name_len = eq_sign - str + 1; /* including '=' */
 	cur_pp = &G.top_var;
@@ -2505,7 +2505,7 @@
 
 		eq = strchr(*s, '=');
 		if (HUSH_DEBUG && !eq)
-			bb_error_msg_and_die("BUG in varexp4");
+			bb_simple_error_msg_and_die("BUG in varexp4");
 		var_pp = get_ptr_to_local_var(*s, eq - *s);
 		if (var_pp) {
 			var_p = *var_pp;
@@ -4246,7 +4246,7 @@
 
 //TODO: this is the place to catch ">&file" bashism (redirect both fd 1 and 2)
 
-	bb_error_msg("ambiguous redirect");
+	bb_simple_error_msg("ambiguous redirect");
 	return REDIRFD_SYNTAX_ERR;
 }
 
@@ -6956,7 +6956,7 @@
 	} else {
 		if (HUSH_DEBUG)
 			if (list[1])
-				bb_error_msg_and_die("BUG in varexp2");
+				bb_simple_error_msg_and_die("BUG in varexp2");
 		/* actually, just move string 2*sizeof(char*) bytes back */
 		overlapping_strcpy((char*)list, list[0]);
 		if (do_unbackslash)
@@ -7217,7 +7217,7 @@
 	if (argv[0][0] == '/')
 		execve(argv[0], argv, pp);
 	xfunc_error_retval = 127;
-	bb_error_msg_and_die("can't re-execute the shell");
+	bb_simple_error_msg_and_die("can't re-execute the shell");
 }
 #endif  /* !BB_MMU */
 
@@ -7919,7 +7919,7 @@
 	G.var_nest_level--;
 	debug_printf_env("var_nest_level-- %u\n", G.var_nest_level);
 	if (HUSH_DEBUG && (int)G.var_nest_level < 0)
-		bb_error_msg_and_die("BUG: nesting underflow");
+		bb_simple_error_msg_and_die("BUG: nesting underflow");
 
 	remove_nested_vars();
 }
@@ -8776,7 +8776,7 @@
 		childpid = waitpid(-1, &status, attributes);
 		if (childpid <= 0) {
 			if (childpid && errno != ECHILD)
-				bb_perror_msg("waitpid");
+				bb_simple_perror_msg("waitpid");
 #if ENABLE_HUSH_FAST
 			else { /* Until next SIGCHLD, waitpid's are useless */
 				G.we_have_children = (childpid == 0);
@@ -9308,7 +9308,7 @@
 		argv_expanded = NULL;
 		if (command->pid < 0) { /* [v]fork failed */
 			/* Clearly indicate, was it fork or vfork */
-			bb_perror_msg(BB_MMU ? "vfork"+1 : "vfork");
+			bb_simple_perror_msg(BB_MMU ? "vfork"+1 : "vfork");
 		} else {
 			pi->alive_cmds++;
 #if ENABLE_HUSH_JOB
@@ -10618,7 +10618,7 @@
 	}
 
 	if ((uintptr_t)r > 1) {
-		bb_error_msg("%s", r);
+		bb_simple_error_msg(r);
 		r = (char*)(uintptr_t)1;
 	}
 
@@ -10863,7 +10863,7 @@
 	if (opts == (unsigned)-1)
 		return EXIT_FAILURE;
 	if (opts == 3) {
-		bb_error_msg("unset: -v and -f are exclusive");
+		bb_simple_error_msg("unset: -v and -f are exclusive");
 		return EXIT_FAILURE;
 	}
 	argv += optind;
@@ -11023,7 +11023,7 @@
 
 	optstring = *++argv;
 	if (!optstring || !(var = *++argv)) {
-		bb_error_msg("usage: getopts OPTSTRING VAR [ARGS]");
+		bb_simple_error_msg("usage: getopts OPTSTRING VAR [ARGS]");
 		return EXIT_FAILURE;
 	}
 
@@ -11252,7 +11252,7 @@
 	}
 
 	if (!argv[1]) { /* no second arg */
-		bb_error_msg("trap: invalid arguments");
+		bb_simple_error_msg("trap: invalid arguments");
 		return EXIT_FAILURE;
 	}
 
@@ -11293,7 +11293,7 @@
 		/* It is "%%", "%+" or "%" - current job */
 		jobnum = G.last_jobid;
 		if (jobnum == 0) {
-			bb_error_msg("no current job");
+			bb_simple_error_msg("no current job");
 			return NULL;
 		}
 	}
@@ -11370,7 +11370,7 @@
 			delete_finished_job(pi);
 			return EXIT_SUCCESS;
 		}
-		bb_perror_msg("kill (SIGCONT)");
+		bb_simple_perror_msg("kill (SIGCONT)");
 	}
 
 	if (argv[0][0] == 'f') {
diff -Naur busybox-1.31.1/shell/hush_test/.gitignore busybox-be5a505d/shell/hush_test/.gitignore
--- busybox-1.31.1/shell/hush_test/.gitignore	1969-12-31 16:00:00.000000000 -0800
+++ busybox-be5a505d/shell/hush_test/.gitignore	2019-10-24 07:26:55.000000000 -0700
@@ -0,0 +1,4 @@
+*.fail
+*.xx
+
+/hush
diff -Naur busybox-1.31.1/shell/math.c busybox-be5a505d/shell/math.c
--- busybox-1.31.1/shell/math.c	2019-10-21 07:54:40.000000000 -0700
+++ busybox-be5a505d/shell/math.c	2019-10-24 07:26:55.000000000 -0700
@@ -537,25 +537,23 @@
 	base = (unsigned)n;
 	n = 0;
 	nptr = *endptr + 1;
-	/* bash allows "N#" (empty "nnnn" part) */
 	for (;;) {
 		unsigned digit = (unsigned)*nptr - '0';
-		if (digit >= 10) {
-			/* *nptr is not 0..9 */
-			if (*nptr > 'z')
-				break; /* this rejects e.g. $((64#~)) */
+		if (digit >= 10 /* not 0..9 */
+		 && digit <= 'z' - '0' /* needed to reject e.g. $((64#~)) */
+		) {
 			/* in bases up to 36, case does not matter for a-z */
 			digit = (unsigned)(*nptr | 0x20) - ('a' - 10);
 			if (base > 36 && *nptr <= '_') {
-				/* otherwise, A-Z,@,_ are 36..61,62,63 */
-				if (*nptr == '@')
-					digit = 62;
-				else if (*nptr == '_')
+				/* otherwise, A-Z,@,_ are 36-61,62,63 */
+				if (*nptr == '_')
 					digit = 63;
+				else if (*nptr == '@')
+					digit = 62;
 				else if (digit < 36) /* A-Z */
 					digit += 36 - 10;
 				else
-					break; /* error, such as [ or \ */
+					break; /* error: one of [\]^ */
 			}
 			//bb_error_msg("ch:'%c'%d digit:%u", *nptr, *nptr, digit);
 			//if (digit < 10) - example where we need this?
@@ -567,6 +565,12 @@
 		n = n * base + digit;
 		nptr++;
 	}
+	/* Note: we do not set errno on bad chars, we just set a pointer
+	 * to the first invalid char. For example, this allows
+	 * "N#" (empty "nnnn" part): 64#+1 is a valid expression,
+	 * it means 64# + 1, whereas 64#~... is not, since ~ is not a valid
+	 * operator.
+	 */
 	*endptr = (char*)nptr;
 	return n;
 }
diff -Naur busybox-1.31.1/shell/shell_common.c busybox-be5a505d/shell/shell_common.c
--- busybox-1.31.1/shell/shell_common.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/shell/shell_common.c	2019-10-24 07:26:55.000000000 -0700
@@ -322,52 +322,91 @@
 struct limits {
 	uint8_t cmd;            /* RLIMIT_xxx fit into it */
 	uint8_t factor_shift;   /* shift by to get rlim_{cur,max} values */
-	const char *name;
 };
 
 static const struct limits limits_tbl[] = {
-	{ RLIMIT_CORE,		9,	"core file size (blocks)" }, // -c
-	{ RLIMIT_DATA,		10,	"data seg size (kb)" },      // -d
-	{ RLIMIT_NICE,		0,	"scheduling priority" },     // -e
-	{ RLIMIT_FSIZE,		9,	"file size (blocks)" },      // -f
+	{ RLIMIT_CORE,		9,	}, // -c
+	{ RLIMIT_DATA,		10,	}, // -d
+	{ RLIMIT_NICE,		0,	}, // -e
+	{ RLIMIT_FSIZE,		9,	}, // -f
 #define LIMIT_F_IDX     3
 #ifdef RLIMIT_SIGPENDING
-	{ RLIMIT_SIGPENDING,	0,	"pending signals" },         // -i
+	{ RLIMIT_SIGPENDING,	0,	}, // -i
 #endif
 #ifdef RLIMIT_MEMLOCK
-	{ RLIMIT_MEMLOCK,	10,	"max locked memory (kb)" },  // -l
+	{ RLIMIT_MEMLOCK,	10,	}, // -l
 #endif
 #ifdef RLIMIT_RSS
-	{ RLIMIT_RSS,		10,	"max memory size (kb)" },    // -m
+	{ RLIMIT_RSS,		10,	}, // -m
 #endif
 #ifdef RLIMIT_NOFILE
-	{ RLIMIT_NOFILE,	0,	"open files" },              // -n
+	{ RLIMIT_NOFILE,	0,	}, // -n
 #endif
 #ifdef RLIMIT_MSGQUEUE
-	{ RLIMIT_MSGQUEUE,	0,	"POSIX message queues (bytes)" }, // -q
+	{ RLIMIT_MSGQUEUE,	0,	}, // -q
 #endif
 #ifdef RLIMIT_RTPRIO
-	{ RLIMIT_RTPRIO,	0,	"real-time priority" },      // -r
+	{ RLIMIT_RTPRIO,	0,	}, // -r
 #endif
 #ifdef RLIMIT_STACK
-	{ RLIMIT_STACK,		10,	"stack size (kb)" },         // -s
+	{ RLIMIT_STACK,		10,	}, // -s
 #endif
 #ifdef RLIMIT_CPU
-	{ RLIMIT_CPU,		0,	"cpu time (seconds)" },      // -t
+	{ RLIMIT_CPU,		0,	}, // -t
 #endif
 #ifdef RLIMIT_NPROC
-	{ RLIMIT_NPROC,		0,	"max user processes" },      // -u
+	{ RLIMIT_NPROC,		0,	}, // -u
 #endif
 #ifdef RLIMIT_AS
-	{ RLIMIT_AS,		10,	"virtual memory (kb)" },     // -v
+	{ RLIMIT_AS,		10,	}, // -v
 #endif
 #ifdef RLIMIT_LOCKS
-	{ RLIMIT_LOCKS,		0,	"file locks" },              // -x
+	{ RLIMIT_LOCKS,		0,	}, // -x
 #endif
 };
 // bash also shows:
 //pipe size            (512 bytes, -p) 8
 
+static const char limits_help[] ALIGN1 =
+	"core file size (blocks)"          // -c
+	"\0""data seg size (kb)"           // -d
+	"\0""scheduling priority"          // -e
+	"\0""file size (blocks)"           // -f
+#ifdef RLIMIT_SIGPENDING
+	"\0""pending signals"              // -i
+#endif
+#ifdef RLIMIT_MEMLOCK
+	"\0""max locked memory (kb)"       // -l
+#endif
+#ifdef RLIMIT_RSS
+	"\0""max memory size (kb)"         // -m
+#endif
+#ifdef RLIMIT_NOFILE
+	"\0""open files"                   // -n
+#endif
+#ifdef RLIMIT_MSGQUEUE
+	"\0""POSIX message queues (bytes)" // -q
+#endif
+#ifdef RLIMIT_RTPRIO
+	"\0""real-time priority"           // -r
+#endif
+#ifdef RLIMIT_STACK
+	"\0""stack size (kb)"              // -s
+#endif
+#ifdef RLIMIT_CPU
+	"\0""cpu time (seconds)"           // -t
+#endif
+#ifdef RLIMIT_NPROC
+	"\0""max user processes"           // -u
+#endif
+#ifdef RLIMIT_AS
+	"\0""virtual memory (kb)"          // -v
+#endif
+#ifdef RLIMIT_LOCKS
+	"\0""file locks"                   // -x
+#endif
+;
+
 static const char limit_chars[] ALIGN1 =
 			"c"
 			"d"
@@ -558,10 +597,12 @@
 	if (!(opts & (OPT_hard | OPT_soft)))
 		opts |= (OPT_hard | OPT_soft);
 	if (opts & OPT_all) {
+		const char *help = limits_help;
 		for (i = 0; i < ARRAY_SIZE(limits_tbl); i++) {
 			getrlimit(limits_tbl[i].cmd, &limit);
-			printf("%-32s(-%c) ", limits_tbl[i].name, limit_chars[i]);
+			printf("%-32s(-%c) ", help, limit_chars[i]);
 			printlim(opts, &limit, &limits_tbl[i]);
+			help += strlen(help) + 1;
 		}
 		return EXIT_SUCCESS;
 	}
@@ -592,7 +633,7 @@
 		getrlimit(limits_tbl[i].cmd, &limit);
 		if (!val_str) {
 			if (opt_cnt > 1)
-				printf("%-32s(-%c) ", limits_tbl[i].name, limit_chars[i]);
+				printf("%-32s(-%c) ", nth_string(limits_help, i), limit_chars[i]);
 			printlim(opts, &limit, &limits_tbl[i]);
 		} else {
 			rlim_t val = RLIM_INFINITY;
@@ -619,7 +660,7 @@
 				limit.rlim_cur = val;
 //bb_error_msg("setrlimit(%d, %lld, %lld)", limits_tbl[i].cmd, (long long)limit.rlim_cur, (long long)limit.rlim_max);
 			if (setrlimit(limits_tbl[i].cmd, &limit) < 0) {
-				bb_perror_msg("error setting limit");
+				bb_simple_perror_msg("error setting limit");
 				return EXIT_FAILURE;
 			}
 		}
diff -Naur busybox-1.31.1/sysklogd/klogd.c busybox-be5a505d/sysklogd/klogd.c
--- busybox-1.31.1/sysklogd/klogd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/sysklogd/klogd.c	2019-10-24 07:26:55.000000000 -0700
@@ -244,7 +244,7 @@
 		if (n < 0) {
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg(READ_ERROR);
+			bb_simple_perror_msg(READ_ERROR);
 			break;
 		}
 		start[n] = '\0';
diff -Naur busybox-1.31.1/sysklogd/logread.c busybox-be5a505d/sysklogd/logread.c
--- busybox-1.31.1/sysklogd/logread.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/sysklogd/logread.c	2019-10-24 07:26:55.000000000 -0700
@@ -88,7 +88,7 @@
 }
 #else
 /* On Linux, shmdt is not mandatory on exit */
-# define error_exit(str) bb_perror_msg_and_die(str)
+# define error_exit(str) bb_simple_perror_msg_and_die(str)
 #endif
 
 /*
diff -Naur busybox-1.31.1/sysklogd/syslogd.c busybox-be5a505d/sysklogd/syslogd.c
--- busybox-1.31.1/sysklogd/syslogd.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/sysklogd/syslogd.c	2019-10-24 07:26:55.000000000 -0700
@@ -572,12 +572,12 @@
 
 	G.shmid = shmget(KEY_ID, G.shm_size, IPC_CREAT | 0644);
 	if (G.shmid == -1) {
-		bb_perror_msg_and_die("shmget");
+		bb_simple_perror_msg_and_die("shmget");
 	}
 
 	G.shbuf = shmat(G.shmid, NULL, 0);
 	if (G.shbuf == (void*) -1L) { /* shmat has bizarre error return */
-		bb_perror_msg_and_die("shmat");
+		bb_simple_perror_msg_and_die("shmat");
 	}
 
 	memset(G.shbuf, 0, G.shm_size);
@@ -592,7 +592,7 @@
 			if (G.s_semid != -1)
 				return;
 		}
-		bb_perror_msg_and_die("semget");
+		bb_simple_perror_msg_and_die("semget");
 	}
 }
 
@@ -603,7 +603,7 @@
 	int len;
 
 	if (semop(G.s_semid, G.SMwdn, 3) == -1) {
-		bb_perror_msg_and_die("SMwdn");
+		bb_simple_perror_msg_and_die("SMwdn");
 	}
 
 	/* Circular Buffer Algorithm:
@@ -631,7 +631,7 @@
 		goto again;
 	}
 	if (semop(G.s_semid, G.SMwup, 1) == -1) {
-		bb_perror_msg_and_die("SMwup");
+		bb_simple_perror_msg_and_die("SMwup");
 	}
 	if (DEBUG)
 		printf("tail:%d\n", G.shbuf->tail);
diff -Naur busybox-1.31.1/util-linux/acpid.c busybox-be5a505d/util-linux/acpid.c
--- busybox-1.31.1/util-linux/acpid.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/acpid.c	2019-10-24 07:26:55.000000000 -0700
@@ -148,7 +148,7 @@
 	const char *args[] = { "run-parts", handler, NULL };
 
 	// log the event
-	bb_error_msg("%s", event);
+	bb_simple_error_msg(event);
 
 	// spawn handler
 	// N.B. run-parts would require scripts to have #!/bin/sh
diff -Naur busybox-1.31.1/util-linux/dmesg.c busybox-be5a505d/util-linux/dmesg.c
--- busybox-1.31.1/util-linux/dmesg.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/dmesg.c	2019-10-24 07:26:55.000000000 -0700
@@ -74,7 +74,7 @@
 	opts = getopt32(argv, "cs:+n:+r", &len, &level);
 	if (opts & OPT_n) {
 		if (klogctl(8, NULL, (long) level))
-			bb_perror_msg_and_die("klogctl");
+			bb_simple_perror_msg_and_die("klogctl");
 		return EXIT_SUCCESS;
 	}
 
@@ -88,7 +88,7 @@
 	buf = xmalloc(len);
 	len = klogctl(3 + (opts & OPT_c), buf, len); /* read ring buffer */
 	if (len < 0)
-		bb_perror_msg_and_die("klogctl");
+		bb_simple_perror_msg_and_die("klogctl");
 	if (len == 0)
 		return EXIT_SUCCESS;
 
diff -Naur busybox-1.31.1/util-linux/eject.c busybox-be5a505d/util-linux/eject.c
--- busybox-1.31.1/util-linux/eject.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/eject.c	2019-10-24 07:26:55.000000000 -0700
@@ -70,7 +70,7 @@
 	sg_io_hdr_t io_hdr;
 
 	if ((ioctl(dev_fd, SG_GET_VERSION_NUM, &i) < 0) || (i < 30000))
-		bb_error_msg_and_die("not a sg device or old sg driver");
+		bb_simple_error_msg_and_die("not a sg device or old sg driver");
 
 	memset(&io_hdr, 0, sizeof(sg_io_hdr_t));
 	io_hdr.interface_id = 'S';
diff -Naur busybox-1.31.1/util-linux/fdformat.c busybox-be5a505d/util-linux/fdformat.c
--- busybox-1.31.1/util-linux/fdformat.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/fdformat.c	2019-10-24 07:26:55.000000000 -0700
@@ -117,7 +117,7 @@
 			read_bytes = safe_read(fd, data, n);
 			if (read_bytes != n) {
 				if (read_bytes < 0) {
-					bb_perror_msg(bb_msg_read_error);
+					bb_simple_perror_msg(bb_msg_read_error);
 				}
 				bb_error_msg_and_die("problem reading cylinder %d, "
 					"expected %d, read %d", cyl, n, read_bytes);
diff -Naur busybox-1.31.1/util-linux/fdisk_aix.c busybox-be5a505d/util-linux/fdisk_aix.c
--- busybox-1.31.1/util-linux/fdisk_aix.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/fdisk_aix.c	2019-10-24 07:26:55.000000000 -0700
@@ -6,10 +6,10 @@
  */
 
 typedef struct {
-	unsigned int   magic;        /* expect AIX_LABEL_MAGIC */
-	unsigned int   fillbytes1[124];
-	unsigned int   physical_volume_id;
-	unsigned int   fillbytes2[124];
+	uint32_t magic;        /* expect AIX_LABEL_MAGIC */
+	uint32_t fillbytes1[124];
+	uint32_t physical_volume_id;
+	uint32_t fillbytes2[124];
 } aix_partition;
 
 #define AIX_LABEL_MAGIC         0xc9c2d4c1
@@ -17,20 +17,18 @@
 #define AIX_INFO_MAGIC          0x00072959
 #define AIX_INFO_MAGIC_SWAPPED  0x59290700
 
-#define aixlabel ((aix_partition *)MBRbuffer)
-
-
 /*
-  Changes:
-  * 1999-03-20 Arnaldo Carvalho de Melo <acme@conectiva.com.br>
-  *     Internationalization
-  *
-  * 2003-03-20 Phillip Kesling <pkesling@sgi.com>
-  *      Some fixes
-*/
+ * Changes:
+ * 1999-03-20 Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *     Internationalization
+ *
+ * 2003-03-20 Phillip Kesling <pkesling@sgi.com>
+ *      Some fixes
+ */
 
-static smallint aix_other_endian; /* bool */
-static smallint aix_volumes = 1; /* max 15 */
+// Write-only vars, unfinished code?
+//static smallint aix_other_endian; /* bool */
+//static smallint aix_volumes = 1; /* max 15 */
 
 /*
  * only dealing with free blocks here
@@ -54,18 +52,20 @@
 static int
 check_aix_label(void)
 {
+	aix_partition *aixlabel = (void*)MBRbuffer;
+
 	if (aixlabel->magic != AIX_LABEL_MAGIC
 	 && aixlabel->magic != AIX_LABEL_MAGIC_SWAPPED
 	) {
-		current_label_type = 0;
-		aix_other_endian = 0;
+		current_label_type = LABEL_DOS;
+//		aix_other_endian = 0;
 		return 0;
 	}
-	aix_other_endian = (aixlabel->magic == AIX_LABEL_MAGIC_SWAPPED);
+//	aix_other_endian = (aixlabel->magic == AIX_LABEL_MAGIC_SWAPPED);
 	update_units();
 	current_label_type = LABEL_AIX;
 	g_partitions = 1016;
-	aix_volumes = 15;
+//	aix_volumes = 15;
 	aix_info();
 	/*aix_nolabel();*/              /* %% */
 	/*aix_label = 1;*/              /* %% */
diff -Naur busybox-1.31.1/util-linux/fdisk.c busybox-be5a505d/util-linux/fdisk.c
--- busybox-1.31.1/util-linux/fdisk.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/fdisk.c	2019-10-24 07:26:55.000000000 -0700
@@ -299,9 +299,6 @@
 static int get_boot(void);
 #endif
 
-#define PLURAL   0
-#define SINGULAR 1
-
 static sector_t get_start_sect(const struct partition *p);
 static sector_t get_nr_sects(const struct partition *p);
 
@@ -511,7 +508,7 @@
 			 * we support can't record more than 32 bit
 			 * sector counts or offsets
 			 */
-			bb_error_msg("device has more than 2^32 sectors, can't use all of them");
+			bb_simple_error_msg("device has more than 2^32 sectors, can't use all of them");
 			v64 = (uint32_t)-1L;
 		}
 		return v64;
@@ -597,12 +594,10 @@
 	return ptes[i].part_table;
 }
 
-static const char *
-str_units(int n)
-{      /* n==1: use singular */
-	if (n == 1)
-		return display_in_cyl_units ? "cylinder" : "sector";
-	return display_in_cyl_units ? "cylinders" : "sectors";
+static ALWAYS_INLINE const char *
+str_units(void)
+{
+	return display_in_cyl_units ? "cylinder" : "sector";
 }
 
 static int
@@ -1778,8 +1773,8 @@
 {
 	display_in_cyl_units = !display_in_cyl_units;
 	update_units();
-	printf("Changing display/entry units to %s\n",
-		str_units(PLURAL));
+	printf("Changing display/entry units to %ss\n",
+		str_units());
 }
 
 static void
@@ -2030,8 +2025,7 @@
 static void
 list_disk_geometry(void)
 {
-	ullong bytes = ((ullong)total_number_of_sectors << 9);
-	ullong xbytes = bytes / (1024*1024);
+	ullong xbytes = total_number_of_sectors / (1024*1024 / 512);
 	char x = 'M';
 
 	if (xbytes >= 10000) {
@@ -2041,11 +2035,12 @@
 	}
 	printf("Disk %s: %llu %cB, %llu bytes, %"SECT_FMT"u sectors\n"
 		"%u cylinders, %u heads, %u sectors/track\n"
-		"Units: %s of %u * %u = %u bytes\n\n",
+		"Units: %ss of %u * %u = %u bytes\n"
+		"\n",
 		disk_device, xbytes, x,
-		bytes, total_number_of_sectors,
+		((ullong)total_number_of_sectors * 512), total_number_of_sectors,
 		g_cylinders, g_heads, g_sectors,
-		str_units(PLURAL),
+		str_units(),
 		units_per_sector, sector_size, units_per_sector * sector_size
 	);
 }
@@ -2486,7 +2481,7 @@
 		for (i = 0; i < g_partitions; i++)
 			first[i] = (cround(first[i]) - 1) * units_per_sector;
 
-	snprintf(mesg, sizeof(mesg), "First %s", str_units(SINGULAR));
+	snprintf(mesg, sizeof(mesg), "First %s", str_units());
 	do {
 		temp = start;
 		for (i = 0; i < g_partitions; i++) {
@@ -2548,7 +2543,7 @@
 	} else {
 		snprintf(mesg, sizeof(mesg),
 			 "Last %s or +size{,K,M,G,T}",
-			 str_units(SINGULAR)
+			 str_units()
 		);
 		stop = read_int(cround(start), cround(limit), cround(limit), cround(start), mesg);
 		if (display_in_cyl_units) {
diff -Naur busybox-1.31.1/util-linux/fdisk_gpt.c busybox-be5a505d/util-linux/fdisk_gpt.c
--- busybox-1.31.1/util-linux/fdisk_gpt.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/fdisk_gpt.c	2019-10-24 07:26:55.000000000 -0700
@@ -161,7 +161,7 @@
 	if (!valid_part_table_flag(MBRbuffer)
 	 || first->sys_ind != LEGACY_GPT_TYPE
 	) {
-		current_label_type = 0;
+		current_label_type = LABEL_DOS;
 		return 0;
 	}
 
@@ -171,7 +171,7 @@
 	gpt_hdr = (void *)pe.sectorbuffer;
 
 	if (gpt_hdr->magic != SWAP_LE64(GPT_MAGIC)) {
-		current_label_type = 0;
+		current_label_type = LABEL_DOS;
 		return 0;
 	}
 
@@ -194,7 +194,7 @@
 	 || SWAP_LE32(gpt_hdr->hdr_size) > sector_size
 	) {
 		puts("\nwarning: unable to parse GPT disklabel\n");
-		current_label_type = 0;
+		current_label_type = LABEL_DOS;
 		return 0;
 	}
 
diff -Naur busybox-1.31.1/util-linux/fdisk_osf.c busybox-be5a505d/util-linux/fdisk_osf.c
--- busybox-1.31.1/util-linux/fdisk_osf.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/fdisk_osf.c	2019-10-24 07:26:55.000000000 -0700
@@ -470,7 +470,7 @@
 	end = xbsd_dlabel.d_secperunit - 1;
 #endif
 
-	snprintf(mesg, sizeof(mesg), "First %s", str_units(SINGULAR));
+	snprintf(mesg, sizeof(mesg), "First %s", str_units());
 	begin = read_int(bsd_cround(begin), bsd_cround(begin), bsd_cround(end),
 		0, mesg);
 
@@ -478,7 +478,7 @@
 		begin = (begin - 1) * xbsd_dlabel.d_secpercyl;
 
 	snprintf(mesg, sizeof(mesg), "Last %s or +size or +sizeM or +sizeK",
-		str_units(SINGULAR));
+		str_units());
 	end = read_int(bsd_cround(begin), bsd_cround(end), bsd_cround(end),
 		bsd_cround(begin), mesg);
 
diff -Naur busybox-1.31.1/util-linux/fdisk_sgi.c busybox-be5a505d/util-linux/fdisk_sgi.c
--- busybox-1.31.1/util-linux/fdisk_sgi.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/fdisk_sgi.c	2019-10-24 07:26:55.000000000 -0700
@@ -295,19 +295,19 @@
 			"%u cylinders, %u physical cylinders\n"
 			"%u extra sects/cyl, interleave %u:1\n"
 			"%s\n"
-			"Units = %s of %u * 512 bytes\n\n",
+			"Units = %ss of %u * 512 bytes\n\n",
 			disk_device, g_heads, g_sectors, g_cylinders,
 			SGI_SSWAP16(sgiparam.pcylcount),
 			SGI_SSWAP16(sgiparam.sparecyl),
 			SGI_SSWAP16(sgiparam.ilfact),
 			(char *)sgilabel,
-			str_units(PLURAL), units_per_sector);
+			str_units(), units_per_sector);
 	} else {
 		printf("\nDisk %s (SGI disk label): "
 			"%u heads, %u sectors, %u cylinders\n"
-			"Units = %s of %u * 512 bytes\n\n",
+			"Units = %ss of %u * 512 bytes\n\n",
 			disk_device, g_heads, g_sectors, g_cylinders,
-			str_units(PLURAL), units_per_sector );
+			str_units(), units_per_sector );
 	}
 
 	w = strlen(disk_device);
@@ -720,7 +720,7 @@
 		printf("You got a partition overlap on the disk. Fix it first!\n");
 		return;
 	}
-	snprintf(mesg, sizeof(mesg), "First %s", str_units(SINGULAR));
+	snprintf(mesg, sizeof(mesg), "First %s", str_units());
 	while (1) {
 		if (sys == SGI_VOLUME) {
 			last = sgi_get_lastblock();
@@ -746,7 +746,7 @@
 		printf("You will get a partition overlap on the disk. "
 				"Fix it first!\n");
 	}
-	snprintf(mesg, sizeof(mesg), " Last %s", str_units(SINGULAR));
+	snprintf(mesg, sizeof(mesg), " Last %s", str_units());
 	last = read_int(scround(first), scround(last)-1, scround(last)-1,
 			scround(first), mesg)+1;
 	if (display_in_cyl_units)
diff -Naur busybox-1.31.1/util-linux/fdisk_sun.c busybox-be5a505d/util-linux/fdisk_sun.c
--- busybox-1.31.1/util-linux/fdisk_sun.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/fdisk_sun.c	2019-10-24 07:26:55.000000000 -0700
@@ -491,7 +491,7 @@
 			return;
 		}
 	}
-	snprintf(mesg, sizeof(mesg), "First %s", str_units(SINGULAR));
+	snprintf(mesg, sizeof(mesg), "First %s", str_units());
 	while (1) {
 		if (whole_disk)
 			first = read_int(0, 0, 0, 0, mesg);
@@ -546,7 +546,7 @@
 	}
 	snprintf(mesg, sizeof(mesg),
 		"Last %s or +size or +sizeM or +sizeK",
-		str_units(SINGULAR));
+		str_units());
 	if (whole_disk)
 		last = read_int(scround(stop2), scround(stop2), scround(stop2),
 				0, mesg);
@@ -567,8 +567,8 @@
 "You haven't covered the whole disk with the 3rd partition,\n"
 "but your value %u %s covers some other partition.\n"
 "Your entry has been changed to %u %s\n",
-				scround(last), str_units(SINGULAR),
-				scround(stop), str_units(SINGULAR));
+				scround(last), str_units(),
+				scround(stop), str_units());
 			last = stop;
 		}
 	} else if (!whole_disk && last > stop)
@@ -636,20 +636,20 @@
 		"%u cylinders, %u alternate cylinders, %u physical cylinders\n"
 		"%u extra sects/cyl, interleave %u:1\n"
 		"%s\n"
-		"Units = %s of %u * 512 bytes\n\n",
+		"Units = %ss of %u * 512 bytes\n\n",
 			disk_device, g_heads, g_sectors, SUN_SSWAP16(sunlabel->rspeed),
 			g_cylinders, SUN_SSWAP16(sunlabel->nacyl),
 			SUN_SSWAP16(sunlabel->pcylcount),
 			SUN_SSWAP16(sunlabel->sparecyl),
 			SUN_SSWAP16(sunlabel->ilfact),
 			(char *)sunlabel,
-			str_units(PLURAL), units_per_sector);
+			str_units(), units_per_sector);
 	else
 		printf(
 	"\nDisk %s (Sun disk label): %u heads, %u sectors, %u cylinders\n"
-	"Units = %s of %u * 512 bytes\n\n",
+	"Units = %ss of %u * 512 bytes\n\n",
 			disk_device, g_heads, g_sectors, g_cylinders,
-			str_units(PLURAL), units_per_sector);
+			str_units(), units_per_sector);
 
 	printf("%*s Flag    Start       End    Blocks   Id  System\n",
 		w + 1, "Device");
diff -Naur busybox-1.31.1/util-linux/flock.c busybox-be5a505d/util-linux/flock.c
--- busybox-1.31.1/util-linux/flock.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/flock.c	2019-10-24 07:26:55.000000000 -0700
@@ -73,7 +73,7 @@
 	) {
 		argv++;
 		if (argv[1])
-			bb_error_msg_and_die("-c takes only one argument");
+			bb_simple_error_msg_and_die("-c takes only one argument");
 		opt |= OPT_c;
 	}
 
diff -Naur busybox-1.31.1/util-linux/fsck_minix.c busybox-be5a505d/util-linux/fsck_minix.c
--- busybox-1.31.1/util-linux/fsck_minix.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/fsck_minix.c	2019-10-24 07:26:55.000000000 -0700
@@ -321,7 +321,7 @@
 {
 	if (termios_set)
 		tcsetattr_stdin_TCSANOW(&sv_termios);
-	bb_error_msg_and_die("%s", str);
+	bb_simple_error_msg_and_die(str);
 }
 
 static void push_filename(const char *name)
diff -Naur busybox-1.31.1/util-linux/getopt.c busybox-be5a505d/util-linux/getopt.c
--- busybox-1.31.1/util-linux/getopt.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/getopt.c	2019-10-24 07:26:55.000000000 -0700
@@ -308,7 +308,7 @@
 				}
 				tokptr[tlen] = '\0';
 				if (tlen == 0)
-					bb_error_msg_and_die("empty long option specified");
+					bb_simple_error_msg_and_die("empty long option specified");
 			}
 			long_options = xrealloc_vector(long_options, 4, long_nr);
 			long_options[long_nr].has_arg = arg_opt;
@@ -380,7 +380,7 @@
 			puts(" --");
 			return 0;
 		}
-		bb_error_msg_and_die("missing optstring argument");
+		bb_simple_error_msg_and_die("missing optstring argument");
 	}
 
 	if (argv[1][0] != '-' || compatible) {
@@ -416,7 +416,7 @@
 	if (!optstr) {
 		optstr = argv[++n];
 		if (!optstr)
-			bb_error_msg_and_die("missing optstring argument");
+			bb_simple_error_msg_and_die("missing optstring argument");
 	}
 
 	argv[n] = name ? name : argv[0];
diff -Naur busybox-1.31.1/util-linux/hwclock.c busybox-be5a505d/util-linux/hwclock.c
--- busybox-1.31.1/util-linux/hwclock.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/hwclock.c	2019-10-24 07:26:55.000000000 -0700
@@ -132,7 +132,7 @@
 	tv.tv_sec = read_rtc(pp_rtcname, NULL, utc);
 	tv.tv_usec = 0;
 	if (settimeofday(&tv, &tz))
-		bb_perror_msg_and_die("settimeofday");
+		bb_simple_perror_msg_and_die("settimeofday");
 }
 
 static void from_sys_clock(const char **pp_rtcname, int utc)
@@ -284,7 +284,7 @@
 	if (!utc)
 		tv.tv_sec += tz.tz_minuteswest * 60;
 	if (settimeofday(&tv, &tz))
-		bb_perror_msg_and_die("settimeofday");
+		bb_simple_perror_msg_and_die("settimeofday");
 }
 
 //usage:#define hwclock_trivial_usage
diff -Naur busybox-1.31.1/util-linux/ipcs.c busybox-be5a505d/util-linux/ipcs.c
--- busybox-1.31.1/util-linux/ipcs.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/ipcs.c	2019-10-24 07:26:55.000000000 -0700
@@ -467,7 +467,7 @@
 	struct ipc_perm *ipcp = &shmds.shm_perm;
 
 	if (shmctl(shmid, IPC_STAT, &shmds) == -1) {
-		bb_perror_msg("shmctl");
+		bb_simple_perror_msg("shmctl");
 		return;
 	}
 
@@ -493,7 +493,7 @@
 	struct ipc_perm *ipcp = &buf.msg_perm;
 
 	if (msgctl(msqid, IPC_STAT, &buf) == -1) {
-		bb_perror_msg("msgctl");
+		bb_simple_perror_msg("msgctl");
 		return;
 	}
 
@@ -527,7 +527,7 @@
 
 	arg.buf = &semds;
 	if (semctl(semid, 0, IPC_STAT, arg)) {
-		bb_perror_msg("semctl");
+		bb_simple_perror_msg("semctl");
 		return;
 	}
 
@@ -555,7 +555,7 @@
 		zcnt = semctl(semid, i, GETZCNT, arg);
 		pid = semctl(semid, i, GETPID, arg);
 		if (val < 0 || ncnt < 0 || zcnt < 0 || pid < 0) {
-			bb_perror_msg_and_die("semctl");
+			bb_simple_perror_msg_and_die("semctl");
 		}
 		printf("%-10u %-10d %-10d %-10d %-10d\n", i, val, ncnt, zcnt, pid);
 	}
diff -Naur busybox-1.31.1/util-linux/last.c busybox-be5a505d/util-linux/last.c
--- busybox-1.31.1/util-linux/last.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/last.c	2019-10-24 07:26:55.000000000 -0700
@@ -100,7 +100,7 @@
 	pos = lseek(file, pos - sizeof(ut), SEEK_SET);
 	while ((n = full_read(file, &ut, sizeof(ut))) > 0) {
 		if (n != sizeof(ut)) {
-			bb_perror_msg_and_die("short read");
+			bb_simple_perror_msg_and_die("short read");
 		}
 		n = index_in_strings(_ut_lin, ut.ut_line);
 		if (n == _TILDE) { /* '~' */
diff -Naur busybox-1.31.1/util-linux/losetup.c busybox-be5a505d/util-linux/losetup.c
--- busybox-1.31.1/util-linux/losetup.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/losetup.c	2019-10-24 07:26:55.000000000 -0700
@@ -118,13 +118,13 @@
 
 		n = get_free_loop();
 		if (n == -1)
-			bb_error_msg_and_die("no free loop devices");
+			bb_simple_error_msg_and_die("no free loop devices");
 		if (n < 0) /* n == -2: no /dev/loop-control, use legacy method */
 			n = 0;
 		/* or: n >= 0: the number of next free loopdev, just verify it */
 		do {
 			if (n > MAX_LOOP_NUM)
-				bb_error_msg_and_die("no free loop devices");
+				bb_simple_error_msg_and_die("no free loop devices");
 			sprintf(dev, LOOP_FORMAT, n++);
 			s = query_loop(dev);
 			free(s);
diff -Naur busybox-1.31.1/util-linux/mdev.c busybox-be5a505d/util-linux/mdev.c
--- busybox-1.31.1/util-linux/mdev.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/mdev.c	2019-10-24 07:26:55.000000000 -0700
@@ -250,18 +250,24 @@
 
 #if DEBUG_LVL >= 1
 # define dbg1(...) do { if (G.verbose) bb_error_msg(__VA_ARGS__); } while(0)
+# define dbg1s(msg) do { if (G.verbose) bb_simple_error_msg(msg); } while(0)
 #else
 # define dbg1(...) ((void)0)
+# define dbg1s(msg) ((void)0)
 #endif
 #if DEBUG_LVL >= 2
 # define dbg2(...) do { if (G.verbose >= 2) bb_error_msg(__VA_ARGS__); } while(0)
+# define dbg2s(msg) do { if (G.verbose >= 2) bb_simple_error_msg(msg); } while(0)
 #else
 # define dbg2(...) ((void)0)
+# define dbg2s(msg) ((void)0)
 #endif
 #if DEBUG_LVL >= 3
 # define dbg3(...) do { if (G.verbose >= 3) bb_error_msg(__VA_ARGS__); } while(0)
+# define dbg3s(msg) do { if (G.verbose >= 3) bb_simple_error_msg(msg); } while(0)
 #else
 # define dbg3(...) ((void)0)
+# define dbg3s(msg) ((void)0)
 #endif
 
 
@@ -1021,7 +1027,7 @@
 			/* seed file: write out seq ASAP */
 			xwrite_str(seq_fd, utoa(expected_seq));
 			xlseek(seq_fd, 0, SEEK_SET);
-			dbg2("first seq written");
+			dbg2s("first seq written");
 			break;
 		}
 		seqbufnum = atoll(seqbuf);
@@ -1165,7 +1171,7 @@
 
 		len = safe_read(fd, netbuf, sizeof(netbuf) - 1);
 		if (len < 0) {
-			bb_perror_msg_and_die("read");
+			bb_simple_perror_msg_and_die("read");
 		}
 		end = netbuf + len;
 		*end = '\0';
diff -Naur busybox-1.31.1/util-linux/mesg.c busybox-be5a505d/util-linux/mesg.c
--- busybox-1.31.1/util-linux/mesg.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/mesg.c	2019-10-24 07:26:55.000000000 -0700
@@ -65,7 +65,7 @@
 	 */
 
 	if (!isatty(STDIN_FILENO))
-		bb_error_msg_and_die("not a tty");
+		bb_simple_error_msg_and_die("not a tty");
 
 	xfstat(STDIN_FILENO, &sb, "stdin");
 	if (c == 0) {
diff -Naur busybox-1.31.1/util-linux/mkfs_ext2.c busybox-be5a505d/util-linux/mkfs_ext2.c
--- busybox-1.31.1/util-linux/mkfs_ext2.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/mkfs_ext2.c	2019-10-24 07:26:55.000000000 -0700
@@ -266,7 +266,7 @@
 	// N.B. what if we format a file? find_mount_point will return false negative since
 	// it is loop block device which is mounted!
 	if (find_mount_point(argv[0], 0))
-		bb_error_msg_and_die("can't format mounted filesystem");
+		bb_simple_error_msg_and_die("can't format mounted filesystem");
 
 	// get size in kbytes
 	kilobytes = get_volume_size_in_bytes(fd, argv[1], 1024, /*extend:*/ !(option_mask32 & OPT_n)) / 1024;
@@ -326,11 +326,11 @@
 	kilobytes >>= (blocksize_log2 - EXT2_MIN_BLOCK_LOG_SIZE);
 	nblocks = kilobytes;
 	if (nblocks != kilobytes)
-		bb_error_msg_and_die("block count doesn't fit in 32 bits");
+		bb_simple_error_msg_and_die("block count doesn't fit in 32 bits");
 #define kilobytes kilobytes_unused_after_this
 	// Experimentally, standard mke2fs won't work on images smaller than 60k
 	if (nblocks < 60)
-		bb_error_msg_and_die("need >= 60 blocks");
+		bb_simple_error_msg_and_die("need >= 60 blocks");
 
 	// How many reserved blocks?
 	if (reserved_percent > 50)
diff -Naur busybox-1.31.1/util-linux/mkfs_minix.c busybox-be5a505d/util-linux/mkfs_minix.c
--- busybox-1.31.1/util-linux/mkfs_minix.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/mkfs_minix.c	2019-10-24 07:26:55.000000000 -0700
@@ -262,7 +262,7 @@
 	int blk;
 
 	if (G.used_good_blocks + 1 >= MAX_GOOD_BLOCKS)
-		bb_error_msg_and_die("too many bad blocks");
+		bb_simple_error_msg_and_die("too many bad blocks");
 	if (G.used_good_blocks)
 		blk = G.good_blocks_table[G.used_good_blocks - 1] + 1;
 	else
@@ -270,7 +270,7 @@
 	while (blk < SB_ZONES && zone_in_use(blk))
 		blk++;
 	if (blk >= SB_ZONES)
-		bb_error_msg_and_die("not enough good blocks");
+		bb_simple_error_msg_and_die("not enough good blocks");
 	G.good_blocks_table[G.used_good_blocks] = blk;
 	G.used_good_blocks++;
 	return blk;
@@ -342,7 +342,7 @@
 				goto end_bad;
 		}
 	}
-	bb_error_msg_and_die("too many bad blocks");
+	bb_simple_error_msg_and_die("too many bad blocks");
  end_bad:
 	if (ind)
 		write_block(ind, (char *) ind_block);
@@ -398,7 +398,7 @@
 		}
 	}
 	/* Could make triple indirect block here */
-	bb_error_msg_and_die("too many bad blocks");
+	bb_simple_error_msg_and_die("too many bad blocks");
  end_bad:
 	if (ind)
 		write_block(ind, (char *) ind_block);
@@ -514,7 +514,7 @@
 		if (got == try)
 			continue;
 		if (G.currently_testing < SB_FIRSTZONE)
-			bb_error_msg_and_die("bad blocks before data-area: cannot make fs");
+			bb_simple_error_msg_and_die("bad blocks before data-area: cannot make fs");
 		mark_zone(G.currently_testing);
 		G.badblocks++;
 		G.currently_testing++;
@@ -588,7 +588,7 @@
 		SB_ZMAPS = sb_zmaps;
 		/* new SB_ZMAPS, need to recalc NORM_FIRSTZONE */
 	} while (--i);
-	bb_error_msg_and_die("incompatible size/inode count, try different -i N");
+	bb_simple_error_msg_and_die("incompatible size/inode count, try different -i N");
  got_it:
 
 	SB_FIRSTZONE = norm_firstzone;
@@ -623,10 +623,10 @@
 	G.magic = MINIX1_SUPER_MAGIC2;
 
 	if (INODE_SIZE1 * MINIX1_INODES_PER_BLOCK != BLOCK_SIZE)
-		bb_error_msg_and_die("bad inode size");
+		bb_simple_error_msg_and_die("bad inode size");
 #if ENABLE_FEATURE_MINIX2
 	if (INODE_SIZE2 * MINIX2_INODES_PER_BLOCK != BLOCK_SIZE)
-		bb_error_msg_and_die("bad inode size");
+		bb_simple_error_msg_and_die("bad inode size");
 #endif
 
 	opt = getopt32(argv, "ci:l:n:+v", &str_i, &listfile, &G.namelen);
@@ -644,7 +644,7 @@
 #if ENABLE_FEATURE_MINIX2
 		version2 = 1;
 #else
-		bb_error_msg_and_die("not compiled with minix v2 support");
+		bb_simple_error_msg_and_die("not compiled with minix v2 support");
 #endif
 	}
 
@@ -654,14 +654,14 @@
 
 	/* Check if it is mounted */
 	if (find_mount_point(G.device_name, 0))
-		bb_error_msg_and_die("can't format mounted filesystem");
+		bb_simple_error_msg_and_die("can't format mounted filesystem");
 
 	xmove_fd(xopen(G.device_name, O_RDWR), dev_fd);
 
 	G.total_blocks = get_volume_size_in_bytes(dev_fd, argv[1], 1024, /*extend:*/ 1) / 1024;
 
 	if (G.total_blocks < 10)
-		bb_error_msg_and_die("must have at least 10 blocks");
+		bb_simple_error_msg_and_die("must have at least 10 blocks");
 
 	if (version2) {
 		G.magic = MINIX2_SUPER_MAGIC2;
diff -Naur busybox-1.31.1/util-linux/mkfs_reiser.c busybox-be5a505d/util-linux/mkfs_reiser.c
--- busybox-1.31.1/util-linux/mkfs_reiser.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/mkfs_reiser.c	2019-10-24 07:26:55.000000000 -0700
@@ -178,7 +178,7 @@
 	// N.B. what if we format a file? find_mount_point will return false negative since
 	// it is loop block device which is mounted!
 	if (find_mount_point(argv[0], 0))
-		bb_error_msg_and_die("can't format mounted filesystem");
+		bb_simple_error_msg_and_die("can't format mounted filesystem");
 
 	// open the device, get size in blocks
 	blocks = get_volume_size_in_bytes(fd, argv[1], blocksize, /*extend:*/ 1) / blocksize;
diff -Naur busybox-1.31.1/util-linux/mkfs_vfat.c busybox-be5a505d/util-linux/mkfs_vfat.c
--- busybox-1.31.1/util-linux/mkfs_vfat.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/mkfs_vfat.c	2019-10-24 07:26:55.000000000 -0700
@@ -278,7 +278,7 @@
 	if (!S_ISBLK(st.st_mode)) {
 		if (!S_ISREG(st.st_mode)) {
 			if (!argv[1])
-				bb_error_msg_and_die("image size must be specified");
+				bb_simple_error_msg_and_die("image size must be specified");
 		}
 		// not a block device, skip bad sectors check
 		opts &= ~OPT_c;
@@ -399,7 +399,7 @@
 	// "mkdosfs -v -F 32 image5k 5" is the minimum:
 	// 2 sectors for FATs and 2 data sectors
 	if ((off_t)(volume_size_sect - reserved_sect) < 4)
-		bb_error_msg_and_die("the image is too small for FAT32");
+		bb_simple_error_msg_and_die("the image is too small for FAT32");
 	sect_per_fat = 1;
 	while (1) {
 		while (1) {
@@ -439,7 +439,7 @@
 		}
  next:
 		if (sect_per_clust == 128)
-			bb_error_msg_and_die("can't make FAT32 with >128 sectors/cluster");
+			bb_simple_error_msg_and_die("can't make FAT32 with >128 sectors/cluster");
 		sect_per_clust *= 2;
 		sect_per_fat = (sect_per_fat / 2) | 1;
 	}
diff -Naur busybox-1.31.1/util-linux/mkswap.c busybox-be5a505d/util-linux/mkswap.c
--- busybox-1.31.1/util-linux/mkswap.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/mkswap.c	2019-10-24 07:26:55.000000000 -0700
@@ -75,7 +75,7 @@
 	}
 	return;
  error:
-	bb_perror_msg_and_die("SELinux relabeling failed");
+	bb_simple_perror_msg_and_die("SELinux relabeling failed");
 }
 #else
 # define mkswap_selinux_setcontext(fd, path) ((void)0)
diff -Naur busybox-1.31.1/util-linux/mount.c busybox-be5a505d/util-linux/mount.c
--- busybox-1.31.1/util-linux/mount.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/mount.c	2019-10-24 07:26:55.000000000 -0700
@@ -483,7 +483,7 @@
 
 	mountTable = setmntent(bb_path_mtab_file, "r");
 	if (!mountTable) {
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 		return;
 	}
 
@@ -511,7 +511,7 @@
 		}
 		endmntent(mountTable);
 	} else if (errno != EROFS)
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		for (i = 0; i < count; i++) {
@@ -739,7 +739,7 @@
 	// Abort entirely if permission denied.
 
 	if (rc && errno == EPERM)
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 
 	// If the mount was successful, and we're maintaining an old-style
 	// mtab file by hand, add the new entry to it now.
@@ -751,7 +751,7 @@
 		int i;
 
 		if (!mountTable) {
-			bb_perror_msg(bb_path_mtab_file);
+			bb_simple_perror_msg(bb_path_mtab_file);
 			goto ret;
 		}
 
@@ -1288,18 +1288,18 @@
 	s = strchr(hostname, ',');
 	if (s) {
 		*s = '\0';
-		bb_error_msg("warning: multiple hostnames not supported");
+		bb_simple_error_msg("warning: multiple hostnames not supported");
 	}
 
 	server_addr.sin_family = AF_INET;
 	if (!inet_aton(hostname, &server_addr.sin_addr)) {
 		hp = gethostbyname(hostname);
 		if (hp == NULL) {
-			bb_herror_msg("%s", hostname);
+			bb_simple_herror_msg(hostname);
 			goto fail;
 		}
 		if (hp->h_length != (int)sizeof(struct in_addr)) {
-			bb_error_msg_and_die("only IPv4 is supported");
+			bb_simple_error_msg_and_die("only IPv4 is supported");
 		}
 		memcpy(&server_addr.sin_addr, hp->h_addr_list[0], sizeof(struct in_addr));
 	}
@@ -1389,7 +1389,7 @@
 				else if (is_prefixed_with(opteq, "udp"))
 					tcp = 0;
 				else
-					bb_error_msg("warning: unrecognized proto= option");
+					bb_simple_error_msg("warning: unrecognized proto= option");
 				continue;
 			case 20: // "addr" - ignore
 				continue;
@@ -1522,7 +1522,7 @@
 				if (nfs_mount_version >= 3)
 					nolock = !val;
 				else
-					bb_error_msg("warning: option nolock is not supported");
+					bb_simple_error_msg("warning: option nolock is not supported");
 				break;
 			case 11: //rdirplus
 				nordirplus = !val;
@@ -1590,11 +1590,11 @@
 		} else {
 			hp = gethostbyname(mounthost);
 			if (hp == NULL) {
-				bb_herror_msg("%s", mounthost);
+				bb_simple_herror_msg(mounthost);
 				goto fail;
 			}
 			if (hp->h_length != (int)sizeof(struct in_addr)) {
-				bb_error_msg_and_die("only IPv4 is supported");
+				bb_simple_error_msg_and_die("only IPv4 is supported");
 			}
 			mount_server_addr.sin_family = AF_INET;
 			memcpy(&mount_server_addr.sin_addr, hp->h_addr_list[0], sizeof(struct in_addr));
@@ -1767,18 +1767,18 @@
 	/* Create nfs socket for kernel */
 	if (tcp) {
 		if (nfs_mount_version < 3) {
-			bb_error_msg("NFS over TCP is not supported");
+			bb_simple_error_msg("NFS over TCP is not supported");
 			goto fail;
 		}
 		fsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
 	} else
 		fsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (fsock < 0) {
-		bb_perror_msg("nfs socket");
+		bb_simple_perror_msg("nfs socket");
 		goto fail;
 	}
 	if (bindresvport(fsock, 0) < 0) {
-		bb_perror_msg("nfs bindresvport");
+		bb_simple_perror_msg("nfs bindresvport");
 		goto fail;
 	}
 	if (port == 0) {
@@ -2047,9 +2047,9 @@
 			);
 			if (loopfd < 0) {
 				if (errno == EPERM || errno == EACCES)
-					bb_error_msg(bb_msg_perm_denied_are_you_root);
+					bb_simple_error_msg(bb_msg_perm_denied_are_you_root);
 				else
-					bb_perror_msg("can't setup loop device");
+					bb_simple_perror_msg("can't setup loop device");
 				return errno;
 			}
 
@@ -2255,7 +2255,7 @@
 		// argument when we get it.
 		if (argv[1]) {
 			if (nonroot)
-				bb_error_msg_and_die(bb_msg_you_must_be_root);
+				bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 			mtpair->mnt_fsname = argv[0];
 			mtpair->mnt_dir = argv[1];
 			mtpair->mnt_type = fstype;
@@ -2272,7 +2272,7 @@
 
 	cmdopt_flags = parse_mount_options(cmdopts, NULL);
 	if (nonroot && (cmdopt_flags & ~MS_SILENT)) // Non-root users cannot specify flags
-		bb_error_msg_and_die(bb_msg_you_must_be_root);
+		bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 
 	// If we have a shared subtree flag, don't worry about fstab or mtab.
 	if (ENABLE_FEATURE_MOUNT_FLAGS
@@ -2337,7 +2337,7 @@
 			// No, mount -a won't mount anything,
 			// even user mounts, for mere humans
 			if (nonroot)
-				bb_error_msg_and_die(bb_msg_you_must_be_root);
+				bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 
 			// Does type match? (NULL matches always)
 			if (!fstype_matches(mtcur->mnt_type, fstype))
@@ -2417,7 +2417,7 @@
 			// fstab must have "users" or "user"
 			l = parse_mount_options(mtcur->mnt_opts, NULL);
 			if (!(l & MOUNT_USERS))
-				bb_error_msg_and_die(bb_msg_you_must_be_root);
+				bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 		}
 
 		//util-linux-2.12 does not do this check.
diff -Naur busybox-1.31.1/util-linux/nsenter.c busybox-be5a505d/util-linux/nsenter.c
--- busybox-1.31.1/util-linux/nsenter.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/nsenter.c	2019-10-24 07:26:55.000000000 -0700
@@ -257,7 +257,7 @@
 
 	if (opts & OPT_setgid) {
 		if (setgroups(0, NULL) < 0 && setgroups_failed)
-			bb_perror_msg_and_die("setgroups");
+			bb_simple_perror_msg_and_die("setgroups");
 		xsetgid(gid);
 	}
 	if (opts & OPT_setuid)
diff -Naur busybox-1.31.1/util-linux/rdate.c busybox-be5a505d/util-linux/rdate.c
--- busybox-1.31.1/util-linux/rdate.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/rdate.c	2019-10-24 07:26:55.000000000 -0700
@@ -33,7 +33,7 @@
 
 static void socket_timeout(int sig UNUSED_PARAM)
 {
-	bb_error_msg_and_die("timeout connecting to time server");
+	bb_simple_error_msg_and_die("timeout connecting to time server");
 }
 
 static time_t askremotedate(const char *host)
@@ -94,10 +94,10 @@
 
 	if (!(flags & 2)) { /* no -p (-s may be present) */
 		if (time(NULL) == remote_time)
-			bb_error_msg("current time matches remote time");
+			bb_simple_error_msg("current time matches remote time");
 		else
 			if (stime(&remote_time) < 0)
-				bb_perror_msg_and_die("can't set time of day");
+				bb_simple_perror_msg_and_die("can't set time of day");
 	}
 
 	if (flags != 1) /* not lone -s */
diff -Naur busybox-1.31.1/util-linux/readprofile.c busybox-be5a505d/util-linux/readprofile.c
--- busybox-1.31.1/util-linux/readprofile.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/readprofile.c	2019-10-24 07:26:55.000000000 -0700
@@ -142,7 +142,7 @@
 				small++;
 		}
 		if (big > small) {
-			bb_error_msg("assuming reversed byte order, "
+			bb_simple_error_msg("assuming reversed byte order, "
 				"use -n to force native byte order");
 			BUILD_BUG_ON(sizeof(*p) > 8);
 			for (p = buf; p < buf+len; p++) {
@@ -204,7 +204,7 @@
 		}
 
 		if (indx >= len)
-			bb_error_msg_and_die("profile address out of range. "
+			bb_simple_error_msg_and_die("profile address out of range. "
 					"Wrong map file?");
 
 		this = 0;
diff -Naur busybox-1.31.1/util-linux/rtcwake.c busybox-be5a505d/util-linux/rtcwake.c
--- busybox-1.31.1/util-linux/rtcwake.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/rtcwake.c	2019-10-24 07:26:55.000000000 -0700
@@ -230,7 +230,7 @@
 		do {
 			ssize_t ret = safe_read(fd, &data, sizeof(data));
 			if (ret < 0) {
-				bb_perror_msg("rtc read");
+				bb_simple_perror_msg("rtc read");
 				break;
 			}
 		} while (!(data & RTC_AF));
diff -Naur busybox-1.31.1/util-linux/setpriv.c busybox-be5a505d/util-linux/setpriv.c
--- busybox-1.31.1/util-linux/setpriv.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/setpriv.c	2019-10-24 07:26:55.000000000 -0700
@@ -164,7 +164,7 @@
 	}
 
 	if (capset(&caps.header, caps.data) != 0)
-		bb_perror_msg_and_die("capset");
+		bb_simple_perror_msg_and_die("capset");
 }
 
 static void set_ambient_caps(char *string)
@@ -178,10 +178,10 @@
 		idx = parse_cap(cap);
 		if (cap[0] == '+') {
 			if (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, idx, 0, 0) < 0)
-				bb_perror_msg("cap_ambient_raise");
+				bb_simple_perror_msg("cap_ambient_raise");
 		} else {
 			if (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_LOWER, idx, 0, 0) < 0)
-				bb_perror_msg("cap_ambient_lower");
+				bb_simple_perror_msg("cap_ambient_lower");
 		}
 		cap = strtok(NULL, ",");
 	}
@@ -236,7 +236,7 @@
 		unsigned idx = CAP_TO_INDEX(i);
 		if (idx >= caps.u32s) {
 			printf("\nindex: %u u32s: %u capability: %u\n", idx, caps.u32s, i);
-			bb_error_msg_and_die("unsupported capability");
+			bb_simple_error_msg_and_die("unsupported capability");
 		}
 		if (caps.data[idx].inheritable & CAP_TO_MASK(i)) {
 			printf_cap(fmt, i);
diff -Naur busybox-1.31.1/util-linux/switch_root.c busybox-be5a505d/util-linux/switch_root.c
--- busybox-1.31.1/util-linux/switch_root.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/switch_root.c	2019-10-24 07:26:55.000000000 -0700
@@ -117,7 +117,7 @@
 	getcaps(&caps);
 	caps.data[CAP_TO_INDEX(cap_idx)].inheritable &= ~CAP_TO_MASK(cap_idx);
 	if (capset(&caps.header, caps.data) != 0)
-		bb_perror_msg_and_die("capset");
+		bb_simple_perror_msg_and_die("capset");
 }
 
 static void drop_bounding_set(int cap_idx)
@@ -253,7 +253,7 @@
 	if ((unsigned)stfs.f_type != RAMFS_MAGIC
 	 && (unsigned)stfs.f_type != TMPFS_MAGIC
 	) {
-		bb_error_msg_and_die("root filesystem is not ramfs/tmpfs");
+		bb_simple_error_msg_and_die("root filesystem is not ramfs/tmpfs");
 	}
 
 	if (!dry_run) {
@@ -263,7 +263,7 @@
 		// Overmount / with newdir and chroot into it
 		if (mount(".", "/", NULL, MS_MOVE, NULL)) {
 			// For example, fails when newroot is not a mountpoint
-			bb_perror_msg_and_die("error moving root");
+			bb_simple_perror_msg_and_die("error moving root");
 		}
 	}
 	xchroot(".");
diff -Naur busybox-1.31.1/util-linux/uevent.c busybox-be5a505d/util-linux/uevent.c
--- busybox-1.31.1/util-linux/uevent.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/uevent.c	2019-10-24 07:26:55.000000000 -0700
@@ -75,12 +75,12 @@
 					MAP_PRIVATE | MAP_ANON,
 					/* ignored: */ -1, 0);
 		if (netbuf == MAP_FAILED)
-			bb_perror_msg_and_die("mmap");
+			bb_simple_perror_msg_and_die("mmap");
 
 		// Here we block, possibly for a very long time
 		len = safe_read(fd, netbuf, BUFFER_SIZE - 1);
 		if (len < 0)
-			bb_perror_msg_and_die("read");
+			bb_simple_perror_msg_and_die("read");
 		end = netbuf + len;
 		*end = '\0';
 
diff -Naur busybox-1.31.1/util-linux/unshare.c busybox-be5a505d/util-linux/unshare.c
--- busybox-1.31.1/util-linux/unshare.c	2019-06-10 03:50:53.000000000 -0700
+++ busybox-be5a505d/util-linux/unshare.c	2019-10-24 07:26:55.000000000 -0700
@@ -239,7 +239,7 @@
 	if (setgrp_str) {
 		if (strcmp(setgrp_str, "allow") == 0) {
 			if (opts & OPT_map_root) {
-				bb_error_msg_and_die(
+				bb_simple_error_msg_and_die(
 					"--setgroups=allow and --map-root-user "
 					"are mutually exclusive"
 				);
