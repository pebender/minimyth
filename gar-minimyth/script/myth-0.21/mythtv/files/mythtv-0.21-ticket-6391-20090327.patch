diff -Naur mythtv-0.21-20278-old/filters/fieldorder/fieldorder.pro mythtv-0.21-20278-new/filters/fieldorder/fieldorder.pro
--- mythtv-0.21-20278-old/filters/fieldorder/fieldorder.pro	1969-12-31 16:00:00.000000000 -0800
+++ mythtv-0.21-20278-new/filters/fieldorder/fieldorder.pro	2009-03-28 09:53:00.000000000 -0700
@@ -0,0 +1,8 @@
+include ( ../filter-common.pro )
+include ( ../filter-avcodec.pro )
+
+INCLUDEPATH += ../../libs/libmythtv ../../libs/libavcodec ../..
+
+# Input
+SOURCES += filter_fieldorder.c
+
diff -Naur mythtv-0.21-20278-old/filters/fieldorder/filter_fieldorder.c mythtv-0.21-20278-new/filters/fieldorder/filter_fieldorder.c
--- mythtv-0.21-20278-old/filters/fieldorder/filter_fieldorder.c	1969-12-31 16:00:00.000000000 -0800
+++ mythtv-0.21-20278-new/filters/fieldorder/filter_fieldorder.c	2009-03-28 09:53:00.000000000 -0700
@@ -0,0 +1,248 @@
+/*
+ * Field-order deinterlacer
+ *
+ * Written by Paul Gardiner (mythtv@glidos.net), based on overal
+ * structure of yadif deinterlacer.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "config.h"
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
+#include <inttypes.h>
+
+#include <string.h>
+#include <math.h>
+
+#include "filter.h"
+#include "frame.h"
+
+#define NREFS 2
+#define NCHANS 3
+
+typedef struct ThisFilter
+{
+    VideoFilter vf;
+
+    long long last_framenr;
+
+    uint8_t *ref[NREFS+1][NCHANS];
+    int stride[NCHANS];
+    int8_t got_frames[NREFS+1];
+
+    int width;
+    int height;
+
+    TF_STRUCT;
+} ThisFilter;
+
+
+static void AllocFilter(ThisFilter* filter, int width, int height)
+{
+    int i,j;
+    if ((width != filter->width) || height != filter->height)
+    {
+        for (i=0; i<NCHANS*NREFS; i++)
+        {
+            uint8_t **p= &filter->ref[i/NCHANS][i%NCHANS];
+            if (*p) free(*p);
+            *p= NULL;
+        }
+        for (i=0; i<NCHANS; i++)
+        {
+            int is_chroma= !!i;
+            int w= ((width   + 31) & (~31))>>is_chroma;
+            int h= ((height  + 31) & (~31))>>is_chroma;
+
+            filter->stride[i]= w;
+            for (j=0; j<NREFS; j++) 
+            {
+                filter->ref[j][i]= (uint8_t*)calloc(w*h*sizeof(uint8_t),1);
+            }
+        }
+        filter->width = width;
+        filter->height = height;
+        memset(filter->got_frames, 0, sizeof(filter->got_frames));
+    }
+}
+
+static inline void * memcpy_pic(void * dst, const void * src,
+                                int bytesPerLine, int height,
+                                int dstStride, int srcStride)
+{
+    int i;
+    void *retval=dst;
+
+    if (dstStride == srcStride)
+    {
+        if (srcStride < 0)
+        {
+            src = (uint8_t*)src + (height-1)*srcStride;
+            dst = (uint8_t*)dst + (height-1)*dstStride;
+            srcStride = -srcStride;
+        }
+        memcpy(dst, src, srcStride*height);
+    }
+    else
+    {
+        for (i=0; i<height; i++)
+        {
+            memcpy(dst, src, bytesPerLine);
+            src = (uint8_t*)src + srcStride;
+            dst = (uint8_t*)dst + dstStride;
+        }
+    }
+
+    return retval;
+}
+
+static void store_ref(struct ThisFilter *p, uint8_t *src, int src_offsets[3], int src_stride[3], int width, int height)
+{
+    int i;
+
+    memcpy (p->ref[NREFS], p->ref[0], sizeof(uint8_t *)*NCHANS);
+    memmove(p->ref[0], p->ref[1], sizeof(uint8_t *)*NREFS*NCHANS);
+
+    memcpy (&p->got_frames[NREFS], &p->got_frames[0], sizeof(uint8_t));
+    memmove(&p->got_frames[0], &p->got_frames[1], sizeof(uint8_t) * NREFS);
+
+    for (i=0; i<NCHANS; i++)
+    {
+        int is_chroma= !!i;
+        memcpy_pic(p->ref[NREFS-1][i], src + src_offsets[i], width>>is_chroma, height>>is_chroma, p->stride[i], src_stride[i]);
+    }
+    p->got_frames[NREFS-1] = 1;
+}
+
+
+
+static void filter_func(struct ThisFilter *p, uint8_t *dst, int dst_offsets[3], int dst_stride[3], int width, int height, int parity, int tff)
+{
+    int y, i;
+
+    uint8_t nr_p, nr_c;
+
+    //check if we already got this frames
+    nr_c = NREFS-1;//always there after store_ref
+    nr_p = p->got_frames[NREFS-2]?(NREFS-2):nr_c;
+
+    for (i=0; i<NCHANS; i++)
+    {
+        int is_chroma= !!i;
+        int w= width >>is_chroma;
+        int h= height>>is_chroma;
+        int refs= p->stride[i];
+
+        for (y=0; y<h; y++)
+        {
+            /* Alter only lines of the second field */
+            if (y & tff)
+            {
+                if(parity)
+                {
+                    /* Second call: put back the second field to its previous state */
+                    memcpy(dst + dst_offsets[i] + y*dst_stride[i], &p->ref[nr_c][i][y*refs], w);
+                }
+                else
+                {
+                    /* First call: replace second field by that of the previous frame */
+                    memcpy(dst + dst_offsets[i] + y*dst_stride[i], &p->ref[nr_p][i][y*refs], w);
+                }
+            }
+        }
+    }
+}
+
+
+static int FieldorderDeint (VideoFilter * f, VideoFrame * frame)
+{
+    ThisFilter *filter = (ThisFilter *) f;
+    TF_VARS;
+
+    int second_field = 0;
+    AllocFilter(filter, frame->width, frame->height);
+
+    if (filter->last_framenr != frame->frameNumber)
+    {
+        if (filter->last_framenr != (frame->frameNumber - 1))
+        {
+            memset(filter->got_frames, 0, sizeof(filter->got_frames));
+        }
+        store_ref(filter, frame->buf,  frame->offsets, frame->pitches, frame->width, frame->height);
+        second_field = 0;
+    }
+    else
+    {
+        second_field = 1;
+    }
+
+    /* filter all frames, even if frame->interlaced_frame is not set */
+    filter_func(
+        filter, frame->buf, frame->offsets, frame->pitches,
+        frame->width, frame->height, second_field, frame->top_field_first);
+
+    filter->last_framenr = frame->frameNumber;
+
+    return 0;
+}
+
+
+void CleanupFieldorderDeintFilter (VideoFilter * filter)
+{
+    int i;
+    ThisFilter* f = (ThisFilter*)filter;
+    for (i=0; i<NCHANS*NREFS; i++)
+    {
+        uint8_t **p= &f->ref[i/NCHANS][i%NCHANS];
+        if (*p) free(*p);
+        *p= NULL;
+    }
+}
+
+VideoFilter * FieldorderDeintFilter (VideoFrameType inpixfmt, VideoFrameType outpixfmt,
+    int *width, int *height, char *options)
+{
+    ThisFilter *filter;
+    (void) height;
+    (void) options;
+
+    fprintf(stderr, "Initialize Fieldorder Deinterlacer. In-Pixformat = %d Out-Pixformat=%d\n", inpixfmt, outpixfmt);
+    filter = (ThisFilter *) malloc (sizeof(ThisFilter));
+    if (filter == NULL)
+    {
+        fprintf (stderr, "FieldorderDeint: failed to allocate memory for filter.\n");
+        return NULL;
+    }
+
+    filter->width = 0;
+    filter->height = 0;
+    memset(filter->ref, 0, sizeof(filter->ref));
+
+    AllocFilter(filter, *width, *height);
+
+    filter->vf.filter = &FieldorderDeint;
+    filter->vf.cleanup = &CleanupFieldorderDeintFilter;
+    return (VideoFilter *) filter;
+}
+
+
+static FmtConv FmtList[] =
+{
+    { FMT_YV12, FMT_YV12 } ,
+    FMT_NULL
+};
+
+FilterInfo filter_table[] =
+{
+    {
+symbol:     "FieldorderDeintFilter",
+            name:       "fieldorderdoubleprocessdeint",
+            descript:   "avoids synchronisation problems when matching an interlaced video mode to an interlaced source",
+            formats:    FmtList,
+            libname:    NULL
+    },FILT_NULL
+};
+
+/* vim: set expandtab tabstop=4 shiftwidth=4: */
diff -Naur mythtv-0.21-20278-old/filters/filters.pro mythtv-0.21-20278-new/filters/filters.pro
--- mythtv-0.21-20278-old/filters/filters.pro	2009-03-28 09:52:59.000000000 -0700
+++ mythtv-0.21-20278-new/filters/filters.pro	2009-03-28 09:53:00.000000000 -0700
@@ -2,7 +2,7 @@
 
 # Directories
 SUBDIRS += invert linearblend denoise3d quickdnr kerneldeint crop force convert
-SUBDIRS += adjust onefield bobdeint ivtc greedyhdeint yadif
+SUBDIRS += adjust onefield bobdeint ivtc greedyhdeint yadif fieldorder
 
 # This filter is currently broken, because the FFmpeg code that
 # it depends on was moved into a seperate library (libpostproc).
diff -Naur mythtv-0.21-20278-old/libs/libmythtv/videodisplayprofile.cpp mythtv-0.21-20278-new/libs/libmythtv/videodisplayprofile.cpp
--- mythtv-0.21-20278-old/libs/libmythtv/videodisplayprofile.cpp	2009-03-28 09:52:59.000000000 -0700
+++ mythtv-0.21-20278-new/libs/libmythtv/videodisplayprofile.cpp	2009-03-28 09:53:00.000000000 -0700
@@ -680,6 +680,8 @@
         return QObject::tr("Bob (2x)");
     else if ("onefield" == short_name)
         return QObject::tr("One field");
+    else if ("fieldorderdoubleprocessdeint" == short_name)
+        return QObject::tr("Interlaced (2x)");
     else if ("opengllinearblend" == short_name)
         return QObject::tr("Linear blend (HW)");
     else if ("openglkerneldeint" == short_name)
@@ -1258,6 +1260,11 @@
         "This deinterlacer uses several fields to reduce motion blur. "
         "It has increased CPU requirements.");
 
+    QString kFieldorderMsg = QObject::tr(
+        "This deinterlacer avoids synchronisation problems when using an "
+        "interlaced display mode that exactly matches the source. "
+        "It has low CPU requirements.");
+
     if (deint == "none")
         msg = kNoneMsg;
     else if (deint == "onefield")
@@ -1294,6 +1301,8 @@
         msg = kYadifMsg;
     else if (deint == "yadifdoubleprocessdeint")
         msg = kYadifMsg + " " +  kDoubleRateMsg;
+    else if (deint == "fieldorderdoubleprocessdeint")
+        msg = kFieldorderMsg + " " +  kDoubleRateMsg;
     else if (deint == "opengldoublerateyadif")
         msg = kYadifMsg + " " +  kUsingOpenGLWorkaround;
     else
@@ -1469,6 +1478,7 @@
 "greedyhdoubleprocessdeint"
 "yadifdeint"
 "yadifdoubleprocessdeint"
+"fieldorderdoubleprocessdeint"
 "opengllinearblend"
 "openglkerneldeint"
 "openglonefield"
@@ -1513,6 +1523,7 @@
         safe_deint[*it] += "greedyhdoubleprocessdeint";
         safe_deint[*it] += "yadifdeint";
         safe_deint[*it] += "yadifdoubleprocessdeint";
+        safe_deint[*it] += "fieldorderdoubleprocessdeint";
         safe_deint[*it] += "none";
         safe_osd[*it]   += "softblend";
     }
