diff -Naur libdrm-2.4.23-old/nouveau/Makefile.am libdrm-2.4.23-new/nouveau/Makefile.am
--- libdrm-2.4.23-old/nouveau/Makefile.am	2010-04-11 09:46:32.000000000 -0700
+++ libdrm-2.4.23-new/nouveau/Makefile.am	2010-12-20 18:46:51.000000000 -0800
@@ -28,6 +28,8 @@
 				nouveau_grobj.h \
 				nouveau_notifier.h \
 				nouveau_pushbuf.h \
+				nv04_pushbuf.h \
+				nvc0_pushbuf.h \
 				nouveau_bo.h \
 				nouveau_resource.h \
 				nouveau_reloc.h
diff -Naur libdrm-2.4.23-old/nouveau/nouveau_channel.c libdrm-2.4.23-new/nouveau/nouveau_channel.c
--- libdrm-2.4.23-old/nouveau/nouveau_channel.c	2010-12-10 04:12:18.000000000 -0800
+++ libdrm-2.4.23-new/nouveau/nouveau_channel.c	2010-12-20 18:46:51.000000000 -0800
@@ -75,20 +75,23 @@
 		nvchan->base.subc[i].gr = &gr->base;
 	}
 
-	ret = nouveau_bo_wrap(dev, nvchan->drm.notifier_handle,
-			      &nvchan->notifier_bo);
-	if (!ret)
-		ret = nouveau_bo_map(nvchan->notifier_bo, NOUVEAU_BO_RDWR);
-	if (ret) {
-		nouveau_channel_free((void *)&nvchan);
-		return ret;
-	}
-
-	ret = nouveau_grobj_alloc(&nvchan->base, 0x00000000, 0x0030,
-				  &nvchan->base.nullobj);
-	if (ret) {
-		nouveau_channel_free((void *)&nvchan);
-		return ret;
+	if (dev->chipset < 0xc0) {
+		ret = nouveau_bo_wrap(dev, nvchan->drm.notifier_handle,
+				      &nvchan->notifier_bo);
+		if (!ret)
+			ret = nouveau_bo_map(nvchan->notifier_bo,
+					     NOUVEAU_BO_RDWR);
+		if (ret) {
+			nouveau_channel_free((void *)&nvchan);
+			return ret;
+		}
+
+		ret = nouveau_grobj_alloc(&nvchan->base, 0x00000000, 0x0030,
+					  &nvchan->base.nullobj);
+		if (ret) {
+			nouveau_channel_free((void *)&nvchan);
+			return ret;
+		}
 	}
 
 	ret = nouveau_pushbuf_init(&nvchan->base, pushbuf_size);
@@ -119,8 +122,10 @@
 	FIRE_RING(&nvchan->base);
 
 	nouveau_pushbuf_fini(&nvchan->base);
-	nouveau_bo_unmap(nvchan->notifier_bo);
-	nouveau_bo_ref(NULL, &nvchan->notifier_bo);
+	if (nvchan->notifier_bo) {
+		nouveau_bo_unmap(nvchan->notifier_bo);
+		nouveau_bo_ref(NULL, &nvchan->notifier_bo);
+	}
 
 	for (i = 0; i < nvchan->drm.nr_subchan; i++)
 		free(nvchan->base.subc[i].gr);
diff -Naur libdrm-2.4.23-old/nouveau/nouveau_grobj.c libdrm-2.4.23-new/nouveau/nouveau_grobj.c
--- libdrm-2.4.23-old/nouveau/nouveau_grobj.c	2010-12-10 04:12:18.000000000 -0800
+++ libdrm-2.4.23-new/nouveau/nouveau_grobj.c	2010-12-20 18:46:51.000000000 -0800
@@ -112,6 +112,7 @@
 void
 nouveau_grobj_autobind(struct nouveau_grobj *grobj)
 {
+	struct nouveau_channel *chan = grobj->channel;
 	struct nouveau_subchannel *subc = NULL;
 	int i;
 
@@ -134,7 +135,13 @@
 	subc->gr->bound = NOUVEAU_GROBJ_BOUND;
 	subc->gr->subc  = subc - &grobj->channel->subc[0];
 
-	BEGIN_RING(grobj->channel, grobj, 0x0000, 1);
-	OUT_RING  (grobj->channel, grobj->handle);
+	WAIT_RING(chan, 2);
+	if (chan->device->chipset < 0xc0) {
+		OUT_RING (chan, (1 << 18) | (grobj->subc << 13));
+		OUT_RING (chan, grobj->handle);
+	} else {
+		OUT_RING (chan, (2 << 28) | (1 << 16) | (grobj->subc << 13));
+		OUT_RING (chan, grobj->grclass);
+	}
 }
 
diff -Naur libdrm-2.4.23-old/nouveau/nouveau_pushbuf.h libdrm-2.4.23-new/nouveau/nouveau_pushbuf.h
--- libdrm-2.4.23-old/nouveau/nouveau_pushbuf.h	2010-02-19 04:35:19.000000000 -0800
+++ libdrm-2.4.23-new/nouveau/nouveau_pushbuf.h	2010-12-20 18:46:51.000000000 -0800
@@ -96,49 +96,11 @@
 }
 
 static __inline__ void
-BEGIN_RING(struct nouveau_channel *chan, struct nouveau_grobj *gr,
-	   unsigned mthd, unsigned size)
-{
-	if (gr->bound == NOUVEAU_GROBJ_UNBOUND)
-		nouveau_grobj_autobind(gr);
-	chan->subc[gr->subc].sequence = chan->subc_sequence++;
-
-	WAIT_RING(chan, size + 1);
-	OUT_RING(chan, (gr->subc << 13) | (size << 18) | mthd);
-}
-
-/* non-incrementing BEGIN_RING */
-static __inline__ void
-BEGIN_RING_NI(struct nouveau_channel *chan, struct nouveau_grobj *gr,
-	   unsigned mthd, unsigned size)
-{
-	BEGIN_RING(chan, gr, mthd | 0x40000000, size);
-}
-
-static __inline__ void
 FIRE_RING(struct nouveau_channel *chan)
 {
 	nouveau_pushbuf_flush(chan, 0);
 }
 
-static __inline__ void
-BIND_RING(struct nouveau_channel *chan, struct nouveau_grobj *gr, unsigned sc)
-{
-	struct nouveau_subchannel *subc = &gr->channel->subc[sc];
-	
-	if (subc->gr) {
-		if (subc->gr->bound == NOUVEAU_GROBJ_BOUND_EXPLICIT)
-			assert(0);
-		subc->gr->bound = NOUVEAU_GROBJ_UNBOUND;
-	}
-	subc->gr = gr;
-	subc->gr->subc = sc;
-	subc->gr->bound = NOUVEAU_GROBJ_BOUND_EXPLICIT;
-
-	BEGIN_RING(chan, gr, 0x0000, 1);
-	OUT_RING  (chan, gr->handle);
-}
-
 static __inline__ int
 OUT_RELOC(struct nouveau_channel *chan, struct nouveau_bo *bo,
 	  unsigned data, unsigned flags, unsigned vor, unsigned tor)
diff -Naur libdrm-2.4.23-old/nouveau/nouveau_reloc.c libdrm-2.4.23-new/nouveau/nouveau_reloc.c
--- libdrm-2.4.23-old/nouveau/nouveau_reloc.c	2010-03-03 08:42:13.000000000 -0800
+++ libdrm-2.4.23-new/nouveau/nouveau_reloc.c	2010-12-20 18:46:51.000000000 -0800
@@ -79,11 +79,7 @@
 	if (!(nvbo->flags & (NOUVEAU_BO_GART | NOUVEAU_BO_VRAM)))
 		nvbo->flags |= (flags & (NOUVEAU_BO_GART | NOUVEAU_BO_VRAM));
 
-	rpbbo = nouveau_bo_emit_buffer(chan, reloc_bo);
-	if (!rpbbo)
-		return -ENOMEM;
-	nouveau_bo(reloc_bo)->pending_refcnt++;
-
+	/* add buffer to validation list */
 	pbbo = nouveau_bo_emit_buffer(chan, bo);
 	if (!pbbo) {
 		fprintf(stderr, "buffer emit fail :(\n");
@@ -91,10 +87,13 @@
 	}
 	nouveau_bo(bo)->pending_refcnt++;
 
-	if (flags & NOUVEAU_BO_VRAM)
-		domains |= NOUVEAU_GEM_DOMAIN_VRAM;
-	if (flags & NOUVEAU_BO_GART)
-		domains |= NOUVEAU_GEM_DOMAIN_GART;
+	if (flags & (NOUVEAU_BO_VRAM | NOUVEAU_BO_GART)) {
+		if (flags & NOUVEAU_BO_VRAM)
+			domains |= NOUVEAU_GEM_DOMAIN_VRAM;
+		if (flags & NOUVEAU_BO_GART)
+			domains |= NOUVEAU_GEM_DOMAIN_GART;
+	} else
+		domains |= nvbo->domain;
 
 	if (!(pbbo->valid_domains & domains)) {
 		fprintf(stderr, "no valid domains remain!\n");
@@ -111,6 +110,23 @@
 		nvbo->write_marker = 1;
 	}
 
+	/* nvc0 gallium driver uses reloc_emit() with NULL target buffer
+	 * to inform bufmgr of a buffer's use - however, we need something
+	 * to track, so create a reloc for now, and hope it never triggers
+	 * (it shouldn't, constant virtual address..)..
+	 */
+	if (!reloc_bo) {
+		reloc_bo  = nvpb->buffer[nvpb->current];
+		reloc_offset = 0;
+		reloc_ptr = NULL;
+	}
+
+	/* add reloc target bo to validation list, and create the reloc */
+	rpbbo = nouveau_bo_emit_buffer(chan, reloc_bo);
+	if (!rpbbo)
+		return -ENOMEM;
+	nouveau_bo(reloc_bo)->pending_refcnt++;
+
 	r = nvpb->relocs + nvpb->nr_relocs++;
 	r->reloc_bo_index = rpbbo - nvpb->buffers;
 	r->reloc_bo_offset = reloc_offset;
diff -Naur libdrm-2.4.23-old/nouveau/nv04_pushbuf.h libdrm-2.4.23-new/nouveau/nv04_pushbuf.h
--- libdrm-2.4.23-old/nouveau/nv04_pushbuf.h	1969-12-31 16:00:00.000000000 -0800
+++ libdrm-2.4.23-new/nouveau/nv04_pushbuf.h	2010-12-20 18:46:51.000000000 -0800
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2007 Nouveau Project
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __NV04_PUSHBUF_H__
+#define __NV04_PUSHBUF_H__
+
+#include "nouveau_pushbuf.h"
+
+static __inline__ void
+BEGIN_RING(struct nouveau_channel *chan, struct nouveau_grobj *gr,
+	   unsigned mthd, unsigned size)
+{
+	if (gr->bound == NOUVEAU_GROBJ_UNBOUND)
+		nouveau_grobj_autobind(gr);
+	chan->subc[gr->subc].sequence = chan->subc_sequence++;
+
+	WAIT_RING(chan, size + 1);
+	OUT_RING(chan, (gr->subc << 13) | (size << 18) | mthd);
+}
+
+/* non-incrementing BEGIN_RING */
+static __inline__ void
+BEGIN_RING_NI(struct nouveau_channel *chan, struct nouveau_grobj *gr,
+	   unsigned mthd, unsigned size)
+{
+	BEGIN_RING(chan, gr, mthd | 0x40000000, size);
+}
+
+static __inline__ void
+BIND_RING(struct nouveau_channel *chan, struct nouveau_grobj *gr, unsigned sc)
+{
+	struct nouveau_subchannel *subc = &gr->channel->subc[sc];
+
+	if (subc->gr) {
+		if (subc->gr->bound == NOUVEAU_GROBJ_BOUND_EXPLICIT)
+			assert(0);
+		subc->gr->bound = NOUVEAU_GROBJ_UNBOUND;
+	}
+	subc->gr = gr;
+	subc->gr->subc = sc;
+	subc->gr->bound = NOUVEAU_GROBJ_BOUND_EXPLICIT;
+
+	BEGIN_RING(chan, gr, 0x0000, 1);
+	OUT_RING  (chan, gr->handle);
+}
+
+#endif
diff -Naur libdrm-2.4.23-old/nouveau/nvc0_pushbuf.h libdrm-2.4.23-new/nouveau/nvc0_pushbuf.h
--- libdrm-2.4.23-old/nouveau/nvc0_pushbuf.h	1969-12-31 16:00:00.000000000 -0800
+++ libdrm-2.4.23-new/nouveau/nvc0_pushbuf.h	2010-12-20 18:46:51.000000000 -0800
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2010 Nouveau Project
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __NVC0_PUSHBUF_H__
+#define __NVC0_PUSHBUF_H__
+
+#include "nouveau_pushbuf.h"
+
+#define SUBC_BIND(chan, gr) do {                                               \
+	if (gr->bound == NOUVEAU_GROBJ_UNBOUND)                                \
+		nouveau_grobj_autobind(gr);                                    \
+	chan->subc[gr->subc].sequence = chan->subc_sequence++;                 \
+} while (0)
+
+/* incremental methods */
+static __inline__ void
+BEGIN_RING(struct nouveau_channel *chan, struct nouveau_grobj *gr,
+	   unsigned mthd, unsigned size)
+{
+	SUBC_BIND(chan, gr);
+	WAIT_RING(chan, size + 1);
+	OUT_RING (chan, (0x2 << 28) | (size << 16) | (gr->subc << 13) | (mthd >> 2));
+}
+
+/* non-incremental */
+static __inline__ void
+BEGIN_RING_NI(struct nouveau_channel *chan, struct nouveau_grobj *gr,
+	      unsigned mthd, unsigned size)
+{
+	SUBC_BIND(chan, gr);
+	WAIT_RING(chan, size + 1);
+	OUT_RING (chan, (0x6 << 28) | (size << 16) | (gr->subc << 13) | (mthd >> 2));
+}
+
+/* increment-once */
+static __inline__ void
+BEGIN_RING_1I(struct nouveau_channel *chan, struct nouveau_grobj *gr,
+	      unsigned mthd, unsigned size)
+{
+	SUBC_BIND(chan, gr);
+	WAIT_RING(chan, size + 1);
+	OUT_RING (chan, (0xa << 28) | (size << 16) | (gr->subc << 13) | (mthd >> 2));
+}
+
+/* inline-data */
+static __inline__ void
+IMMED_RING(struct nouveau_channel *chan, struct nouveau_grobj *gr,
+	   unsigned mthd, unsigned data)
+{
+	SUBC_BIND(chan, gr);
+	WAIT_RING(chan, 1);
+	OUT_RING (chan, (0x8 << 28) | (data << 16) | (gr->subc << 13) | (mthd >> 2));
+}
+
+static __inline__ void
+BIND_RING(struct nouveau_channel *chan, struct nouveau_grobj *gr, unsigned sc)
+{
+	struct nouveau_subchannel *subc = &gr->channel->subc[sc];
+
+	if (subc->gr) {
+		if (subc->gr->bound == NOUVEAU_GROBJ_BOUND_EXPLICIT)
+			assert(0);
+		subc->gr->bound = NOUVEAU_GROBJ_UNBOUND;
+	}
+	subc->gr = gr;
+	subc->gr->subc = sc;
+	subc->gr->bound = NOUVEAU_GROBJ_BOUND_EXPLICIT;
+
+	BEGIN_RING(chan, gr, 0x0000, 1);
+	OUT_RING  (chan, gr->grclass);
+}
+
+#endif
