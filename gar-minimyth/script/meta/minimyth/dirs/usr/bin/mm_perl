#!/bin/sh
################################################################################
#
################################################################################

. /etc/rc.d/functions

if /usr/bin/test ! "${MM_SSH_REMOTE_ENABLED}" = "yes" ; then
    /usr/bin/logger -t minimyth -p "local0.error" \
         "mm_perl: ssh remote command execution has not been enabled."
    exit 1
fi

if /usr/bin/test ! -r ${HOME}/.ssh/id_rsa ; then
    /usr/bin/logger -t minimyth -p "local0.error" \
         "mm_perl: user '${USER}' does not have access to the ssh remote command execution identity."
    exit 1
fi

logfile="${HOME}/tmp/mm_perl.log"
tmp_remote="tmp/minimyth/${MM_HOSTNAME}/perl"

# Create local log file.
logdir=`/usr/bin/dirname ${logfile}`
/bin/mkdir -p ${logdir}
if /usr/bin/test ! -d ${logdir} ; then
    /usr/bin/logger -t minimyth -p "local0.error" \
         "mm_perl: failed to create local log directory '${logdir}'."
    exit 1
fi
/bin/rm -f ${logfile}
/bin/touch ${logfile}
if /usr/bin/test ! -d ${file} ; then
    /usr/bin/logger -t minimyth -p "local0.error" \
         "mm_perl: failed to create local log file '${logfile}'."
    exit 1
fi
/bin/echo ""                              >> ${logfile}
/bin/echo "log file for /usr/bin/mm_perl" >> ${logfile}
/bin/echo ""                              >> ${logfile}

# Process arguments.
argnumber=0
arglist=
perlflag='true'
script_type='unknown'
for arg in "$@" ; do
    # Discard perl flags since they came from the perl shebang.
    if /usr/bin/test "${perlflag}" = "true" ; then
        if ! /bin/echo ${arg} | /bin/grep -q -e "^-" 2> /dev/null ; then
            perlflag='false'
        fi
    fi
    if /usr/bin/test "${perlflag}" = "false" ; then
        # First argument is the perl script, which need to be copied to the remote
        # system so that it can be exectuted.
        if   /usr/bin/test ${argnumber} -eq 0 ; then
            file_local="${arg}"
            file_local=`/bin/echo ${file_local} | /bin/sed -e "s%//*%/%g`
            # Convert local file to absolute path.
            file_local_base=`/usr/bin/basename "${file_local}"`
            file_local_dir=`/usr/bin/dirname "${file_local}"`
            file_local_dir=`cd "${file_local_dir}" ; pwd`
            file_local="${file_local_dir}/${file_local_base}"
            if /usr/bin/test ! -e "${file_local}" ; then
                /bin/echo "mm_perl: perl script '${file_local}' does not exist." >> ${logfile}
                /usr/bin/logger -t minimyth -p "local0.error" \
                    "mm_perl: perl script '${file_local}' does not exist."
                exit 1
            fi

	    # Determine script type.
            if   /bin/echo ${file_local} | /bin/grep -q -e "^/usr/share/mythtv/mythstream/parsers/" 2> /dev/null ; then
                script_type='mythstream'
            elif /bin/echo ${file_local} | /bin/grep -q -e "^/usr/share/mythtv/mythvideo/scripts/" 2> /dev/null ; then
                script_type='mythvideo'
            else
                script_type='unknown'
            fi

	    # Sync local file and remote file.
            mm_ssh_remote_put ${logfile} ${file_local}
            if /usr/bin/test $? -ne 0 ; then
                /bin/echo "mm_perl: failed to copy perl script to remote system." >> ${logfile}
                /usr/bin/logger -t minimyth -p "local0.error" \
                    "mm_perl: failed to copy perl script to remote system."
                exit 1
            fi

	    # Replace argument with remote file name.
            arg="`mm_ssh_remote_file_map ${logfile} ${file_local}`"
        elif /usr/bin/test ${argnumber} -eq 1 ; then
            # Perl script is mythstream parser, so this argument is a file that must be copied to the remote server.
            if /usr/bin/test "${script_type}" = "mythstream" ; then
                file_local="${arg}"

                # Convert local file to absolute path.
                file_local_base=`/usr/bin/basename "${file_local}"`
                file_local_dir=`/usr/bin/dirname "${file_local}"`
                file_local_dir=`cd "${file_local_dir}" ; pwd`
                file_local="${file_local_dir}/${file_local_base}"

                if /usr/bin/test -e "${file_local}" ; then
	            # Sync local file and remote file.
                    mm_ssh_remote_put ${logfile} ${file_local}
                    if /usr/bin/test $? -ne 0 ; then
                        /bin/echo "mm_perl: failed to synchronize local file and remote file." >> ${logfile}
                        /usr/bin/logger -t minimyth -p "local0.error" \
                            "mm_perl: failed to synchronize local file and remote file."
                        exit 1
                    fi
                fi

	       # Replace argument with remote file name.
                arg="`mm_ssh_remote_file_map ${logfile} ${file_local}`"
            fi
        fi
        arg=`/bin/echo ${arg} | /bin/sed -e 's%^"%%g' -e 's%"$%%g'`
        if /usr/bin/test -z "${arglist}" ; then
            arglist="\"${arg}\""
        else
            arglist="${arglist} \"${arg}\""
        fi
        argnumber=$((${argnumber} + 1))
    fi
done

# Check argument count.
if /usr/bin/test ${argnumber} -lt 1 ; then
    /bin/echo "mm_perl: too few arguments.." >> ${logfile}
    /usr/bin/logger -t minimyth -p "local0.error" \
        "mm_perl: too few arguments.."
    exit 1
fi

# Run command with arguments on remote machine using ssh.
mm_ssh_remote_perl ${logfile} "${arglist}"
if /usr/bin/test $? -ne 0 ; then
    /bin/echo "mm_perl: remote command execution failed: perl ${arglist}." >> ${logfile}
    /usr/bin/logger -t minimyth -p "local0.error" \
        "mm_perl: remote command execution failed: perl ${arglist}."
   exit 1
fi

exit 0
