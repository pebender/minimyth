#!/bin/sh
################################################################################
# functions
################################################################################
[ -n "${MM_DEBUG}" ] && set -x

. /etc/conf

#===============================================================================
# general functions.
#===============================================================================
mm_command_run() {
    COMMAND=$1

    if [ "${MM_DEBUG}" = "yes" ] ; then
        LOG_DIR="/var/log"
        LOG_FILE="/var/log/minimyth.log"
    else
        LOG_DIR="/dev"
        LOG_FILE="/dev/null"
    fi

    RETURN=0
    if [ -w "${LOG_FILE}" ] || [ -w "${LOG_DIR}" ] ; then
        echo "--- execution start: ${COMMAND}"  >> "${LOG_FILE}" 2>&1
        ${COMMAND}                              >> "${LOG_FILE}" 2>&1
        RETURN=$?
        echo "--- execution end  : ${COMMAND}"  >> "${LOG_FILE}" 2>&1
    else
        echo "--- execution start: ${COMMAND}"  2>&1
        ${COMMAND}                              2>&1
        RETURN=$?
        echo "--- execution end  : ${COMMAND}"  2>&1
    fi

    return ${RETURN}
}

mm_conf_get() {
    REMOTE_FILE=$1
    LOCAL_FILE=$2

    LOCAL_DIR=`echo "${LOCAL_FILE}" | sed -e 's%[^/]*$%%' -e 's%/$%%'`
    [ -n "${LOCAL_DIR}" ] && mkdir -p "${LOCAL_DIR}"

    TMP_FILE="${LOCAL_FILE}~"

    rm -f "${TMP_FILE}"
    FILE_GOT=0
    if [ -d "/minimyth" ] ; then
        [ ${FILE_GOT} = 0 ] && [ -n "`hostname`" ] && [ -e "/minimyth/conf/`hostname`/${REMOTE_FILE}" ] &&
	    cp          "/minimyth/conf/`hostname`/${REMOTE_FILE}"            "${TMP_FILE}"                     && FILE_GOT=1
        [ ${FILE_GOT} = 0 ] &&                        [ -e "/minimyth/conf/default/${REMOTE_FILE}"    ] &&
	    cp          "/minimyth/conf/default/${REMOTE_FILE}"               "${TMP_FILE}"                     && FILE_GOT=1
    else
        [ ${FILE_GOT} = 0 ] && [ -n "`hostname`" ] &&
            tftp -g -r "${MM_TFTP_ROOTDIR}/conf/`hostname`/${REMOTE_FILE}" -l "${TMP_FILE}" "${MM_TFTP_SERVER}" && FILE_GOT=1
        [ ${FILE_GOT} = 0 ] && 
            tftp -g -r "${MM_TFTP_ROOTDIR}/conf/default/${REMOTE_FILE}"    -l "${TMP_FILE}" "${MM_TFTP_SERVER}" && FILE_GOT=1
    fi
    [ ${FILE_GOT} = 1 ] && 
        mv -f "${TMP_FILE}" "${LOCAL_FILE}"
    rm -f "${TMP_FILE}"
}

mm_message_output() {
    LEVEL=$1
    MESSAGE=$2

    if [ `mm_splash_running_test ; echo $?` -eq 0 ] ; then
        logger    -t minimyth -p "local0.${LEVEL}" "${MESSAGE}"
        mm_splash_message_output "${MESSAGE}"
    else
        logger -s -t minimyth -p "local0.${LEVEL}" "${MESSAGE}"
    fi
}

mm_uniq() {
    if [ "$#" = "0" ] ; then
        ARG=
        while read line ; do
            ARG="${ARG} ${line}"
        done
    else
        ARG=$1
    fi

    echo `echo "${ARG}" | sed -e 's% %\n%g' | sort | uniq | sed -e :a -e '$!N;s/\n/ /;ta' -e 'P;D'`
}

#-------------------------------------------------------------------------------
# mm_url_mount
#
# This function mounts a remote directory as a local directory.
#
# This function takes three arguments:
#     URL: required argument:
#         A URL that points to the remote directory. A URL must have the
#         following form:
#             <protocol>://<username>:<password>@<server>/<path>?<options>
#         where <options> are additional mount options (-o).
#         For example:
#             nfs://server.home/home/public/music
#             cifs://user:pass@server.home/home/public/music,domain=home
#             conf:themecache.tar.bz2
#         The valid protocol values are: nfs, cifs, tftp, file and conf. For
#         nfs and cifs the URL points to a remote directory. For tftp, the URL
#         points to a tarfile (*.tar.bz2) or a cramfs image (*.cmg) on a TFTP
#         server that will be downloaded and expanded into (for files) or
#         downloaded and mounted at (for images) the mount point. For file, the
#         URL point to a tarfile (*.tar.bz2), a cramfs image (*.cmg) or a 
#         directory on the local file system that will be copied and expanded
#         into (for files), copied and mounted at (for images) or mounted at
#         (for directories) the mount point. For conf, the URL points to a
#         tarfile (*.tar.bz2) or a cramfs image (*.cmg) in the MiniMyth conf
#         directory that is either on the TFTP server (when network booting) or
#         on the USB key (when USB booting) that will be downloaded/copied and
#         expanded into (for files) or downloaded/copied and mounted at (for
#         images) the mount point.
#     MOUNT_DIR: required argument:
#         The local directory (e.g. /mnt/music) where the URL will be mounted.
#-------------------------------------------------------------------------------
mm_url_mount() {
    URL="$1"
    MOUNT_DIR="$2"

    mkdir -p "${MOUNT_DIR}"

    URL_PROTOCOL=`echo "${URL}" | cut -d? -f1 | cut -d: -f1`
    URL_USERNAME=`echo "${URL}" | cut -d? -f1 | sed 's%^[^:]*:%%' | sed 's%^//%%' | sed 's%[^@]*$%%'  | sed 's%@$%%' | cut -d: -f1`
    URL_PASSWORD=`echo "${URL}" | cut -d? -f1 | sed 's%^[^:]*:%%' | sed 's%^//%%' | sed 's%[^@]*$%%'  | sed 's%@$%%' | cut -d: -f2`
    URL_SERVER=`  echo "${URL}" | cut -d? -f1 | sed 's%^[^:]*:%%' | sed 's%^//%%' | sed 's%^[^@]*@%%' | sed 's%/[^/]*%%g'`
    URL_PATH=`    echo "${URL}" | cut -d? -f1 | sed 's%^[^:]*:%%' | sed 's%^//[^/]*/%/%'`
    URL_OPTIONS=` echo "${URL}"               | sed 's%^[^?]*%%'  | sed 's%^?%%'`

    URL_FILE=`    echo "${URL_PATH}" | sed 's%^.*/%%'`
    URL_EXTMAX=`  echo "${URL_FILE}" | sed 's%^.*/%%' |sed 's%[^.]*%%g' | wc -c` 
    URL_EXT1=
    [ ${URL_EXTMAX} -ge 1 ] && URL_EXT1=`echo ${URL_FILE} | sed 's%^.*/%%' | cut -s -d. -f$((${URL_EXTMAX}-0))`
    URL_EXT2=
    [ ${URL_EXTMAX} -ge 2 ] && URL_EXT2=`echo ${URL_FILE} | sed 's%^.*/%%' | cut -s -d. -f$((${URL_EXTMAX}-1))`

    MOUNT_VFSTYPE=""
    EXTRA_OPTIONS=""
    MOUNT_DEVICE=""
    MOUNT_OPTIONS="${URL_OPTIONS}"
    if   [ "${URL_PROTOCOL}" = "nfs" ] ; then
        MOUNT_VFSTYPE="nfs"
        MOUNT_DEVICE="${URL_SERVER}:${URL_PATH}"
        MOUNT_OPTIONS="${MOUNT_OPTIONS},rsize=8192,wsize=8192"
    elif [ "${URL_PROTOCOL}" = "cifs" ] ; then
        MOUNT_VFSTYPE="cifs"
        EXTRA_OPTIONS="-n"
        MOUNT_DEVICE="//${URL_SERVER}${URL_PATH}"
        if [ ! "${URL_USERNAME}" = "" ] ; then
            MOUNT_OPTIONS="${MOUNT_OPTIONS},username=${URL_USERNAME}"
        fi
        if [ ! "${URL_PASSWORD}" = "" ] ; then
            MOUNT_OPTIONS="${MOUNT_OPTIONS},password=${URL_PASSWORD}"
        fi
    elif [ "${URL_PROTOCOL}" = "tftp" ] ; then
        if   [ "${URL_EXT1}" = "cmg" ] ; then
            DIR="/initrd/rw/loopfs/`echo ${MOUNT_DIR} | sed 's%//*%~%g'`"
            FILE="image.cmg"
            mkdir -p "${DIR}"
            mkdir -p "${DIR}/ro"
            mkdir -p "${DIR}/rw"
            cd "${DIR}"
            tftp -g -r "${URL_PATH}" -l "${FILE}" "${URL_SERVER}"
            mount -t cramfs -o loop "${DIR}/${FILE}" "${DIR}/ro"
            mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none "${MOUNT_DIR}"
        elif [ "${URL_EXT1}" = "bz2" ] && [ "${URL_EXT2}" = "tar" ] ; then
            TARFILE="tmp.tar.bz2~"
            cd "${MOUNT_DIR}"
            tftp -g -r "${URL_PATH}" -l "${TARFILE}" "${URL_SERVER}"
            tar -jxf "${TARFILE}"
            rm -f "${TARFILE}"
        fi
    elif [ "${URL_PROTOCOL}" = "conf" ] ; then
        if   [ "${URL_EXT1}" = "cmg" ] ; then
            DIR="/initrd/rw/loopfs/`echo ${MOUNT_DIR} | sed 's%//*%~%g'`"
            FILE="image.cmg"
            mkdir -p "${DIR}"
            mkdir -p "${DIR}/ro"
            mkdir -p "${DIR}/rw"
            cd "${DIR}"
            mm_conf_get "${URL_PATH}" "${FILE}"
            mount -t cramfs -o loop "${DIR}/${FILE}" "${DIR}/ro"
            mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none "${MOUNT_DIR}"
        elif [ "${URL_EXT1}" = "bz2" ] && [ "${URL_EXT2}" = "tar" ] ; then
            TARFILE="tmp.tar.bz2~"
            cd "${MOUNT_DIR}"
            mm_conf_get "${URL_PATH}" "${TARFILE}"
            tar -jxf "${TARFILE}"
            rm -f "${TARFILE}"
        fi
    elif [ "${URL_PROTOCOL}" = "file" ] ; then
        if   [ -f "${URL_PATH}" ] ; then
            if   [ "${URL_EXT1}" = "cmg" ] ; then
                DIR="/initrd/rw/loopfs/`echo ${MOUNT_DIR} | sed 's%//*%~%g'`"
                FILE="image.cmg"
                mkdir -p "${DIR}"
                mkdir -p "${DIR}/ro"
                mkdir -p "${DIR}/rw"
                cd "${DIR}"
                cp "${URL_PATH}" "${FILE}"
                mount -t cramfs -o loop "${DIR}/${FILE}" "${DIR}/ro"
                mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none "${MOUNT_DIR}"
            elif [ "${URL_EXT1}" = "bz2" ] && [ "${URL_EXT2}" = "tar" ] ; then
                TARFILE="tmp.tar.bz2~"
                cd "${MOUNT_DIR}"
                cp "${URL_PATH}" "${TARFILE}"
                tar -jxf "${TARFILE}"
                rm -f "${TARFILE}"
            fi
        elif [ -d "${URL_PATH}" ] ; then
            mount --rbind "${URL_PATH}" "${MOUNT_DIR}"
        fi
    fi

    if [ -n "${MOUNT_VFSTYPE}" ] ; then
        OPTIONS=""
        MOUNT_OPTIONS=`echo ${MOUNT_OPTIONS} | sed 's%^,%%'`
        [ -n "${EXTRA_OPTIONS}" ] && OPTIONS="${EXTRA_OPTIONS}"
        [ -n "${MOUNT_OPTIONS}" ] && OPTIONS="${OPTIONS} -o ${MOUNT_OPTIONS}"
        mount -n -t "${MOUNT_VFSTYPE}" ${OPTIONS} "${MOUNT_DEVICE}" "${MOUNT_DIR}"
    fi

    # Update fstab.
    case "${MOUNT_VFSTYPE}" in
        cifs)
            echo "${MOUNT_DEVICE} ${MOUNT_DIR} ${MOUNT_VFSTYPE} ${MOUNT_OPTIONS} 0 0" >> /etc/fstab
            ;;
        nfs)
            echo "${MOUNT_DEVICE} ${MOUNT_DIR} ${MOUNT_VFSTYPE} ${MOUNT_OPTIONS} 0 0" >> /etc/fstab
            ;;
    esac
}

mm_var_get() {
    VAR=$1

    echo `set | grep "^${VAR}=" | sed 's%^[^=]*=%%' | sed "s%^'%%" | sed "s%'$%%"`
}

#===============================================================================
# splash screen functions
#===============================================================================
mm_splash_progress_val=1
mm_splash_progress_max=1

mm_splash_running_test() {
    if [ -n "`pidof splash_util`" ] && [ -e /var/cache/splash/fifo ] ; then
        return 0
    else
        return 1
    fi
}

mm_splash_init() {
    # Initialize progress variables.
    mm_splash_progress_val=0
    mm_splash_progress_max=$1

    SPLASH_ENABLE=yes

    # Disable splash screen when more than kernel errors are logged to the console.
    # That is when the loglevel is greater than 4.
    if [ "${SPLASH_ENABLE}" = "yes" ] ; then
        LOGLEVEL=`cat /proc/sys/kernel/printk | cut -f 1`
        [ -z "${LOGLEVEL}" ] && SPLASH_ENABLE='no'
        [ -n "${LOGLEVEL}" ] && [ ${LOGLEVEL} -gt 4 ] && SPLASH_ENABLE='no'
    fi

    # Disable splash screen when there is no framebuffer device.
    if [ "${SPLASH_ENABLE}" = "yes" ] ; then
        [ ! -e '/dev/fb0' ] && SPLASH_ENABLE='no'
    fi

    # Disable splash screen when the video resolution is not compatible.
    # That is when the resolution is not 800x600 or color depth is less than 16.
    if [ "${SPLASH_ENABLE}" = "yes" ] ; then
        GEOMETRY=`fbset | grep geometry`
        XRES=` echo ${GEOMETRY} | cut -d ' ' -f 2`
        YRES=` echo ${GEOMETRY} | cut -d ' ' -f 3`
        VXRES=`echo ${GEOMETRY} | cut -d ' ' -f 4`
        VYRES=`echo ${GEOMETRY} | cut -d ' ' -f 5`
        DEPTH=`echo ${GEOMETRY} | cut -d ' ' -f 6`
        [ -z "${XRES}"  ] && SPLASH_ENABLE='no'
        [ -z "${YRES}"  ] && SPLASH_ENABLE='no'
        [ -z "${VXRES}" ] && SPLASH_ENABLE='no'
        [ -z "${VYRES}" ] && SPLASH_ENABLE='no'
        [ -z "${DEPTH}" ] && SPLASH_ENABLE='no'
        [ -n "${XRES}"  ] && [ ${XRES}  -ne 800 ] && SPLASH_ENABLE='no'
        [ -n "${YRES}"  ] && [ ${YRES}  -ne 600 ] && SPLASH_ENABLE='no'
        [ -n "${VXRES}" ] && [ ${VXRES} -ne 800 ] && SPLASH_ENABLE='no'
        [ -n "${VYRES}" ] && [ ${VYRES} -ne 600 ] && SPLASH_ENABLE='no'
        [ -n "${DEPTH}" ] && [ ${DEPTH} -lt 16  ] && SPLASH_ENABLE='no'
    fi

    if [ "${SPLASH_ENABLE}" = "yes" ] ; then
        chvt 1
        mkdir -p "/var/cache/splash"
        splash_util --daemon --theme="MythTV"
        mm_splash_command "set mode silent"
        mm_splash_command "progress 0"
        mm_splash_command "set message starting splash screen ..."
        mm_splash_command "repaint"
    fi

    return 0
}

mm_splash_halt() {
    [ -n "`pidof -s splash_util`" ] && killall splash_util

    [ -e "/var/cache/splash" ] && rm -rf "/var/cache/spalsh"

    return 0
}

mm_splash_command()
{
    [ `mm_splash_running_test ; echo $?` -eq 0 ] && echo "$1" >> "/var/cache/splash/fifo"

    return 0
}

mm_splash_message_output() {
    mm_splash_command "set message ${MESSAGE}"
    mm_splash_command "repaint"

    return 0
}

mm_splash_progress_update() {
    mm_splash_progress_val=$((mm_splash_progress_val + 1))
    [ ${mm_splash_progress_val} -gt ${mm_splash_progress_max} ] && mm_splash_progress_val=${mm_splash_progress_max}
    mm_splash_command "progress $(( 65535 * ${mm_splash_progress_val} / ${mm_splash_progress_max} ))"
    mm_splash_command "repaint"

    return 0
}

#===============================================================================
# mythdb functions.
#===============================================================================
mm_mythdb_command_run() {
    COMMAND=$1

    RETURN=0
    mysql \
        --host=${MM_MYTH_SERVER} \
        --user=${MM_MYTH_DBUSERNAME} \
        --password=${MM_MYTH_DBPASSWORD} \
        --database=${MM_MYTH_DBNAME} \
        --execute="${COMMAND} ;"
    RETURN=$?

    return ${RETURN}
}

mm_mythdb_jumppoint_delete() {
    DESTINATION=$1
    HOSTNAME=`hostname`

    if [ -n "${DESTINATION}" ] ; then
        mm_mythdb_command_run "DELETE FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\" AND destination=\"${DESTINATION}\""
    else
        mm_mythdb_command_run "DELETE FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_jumppoint_dump() {
    DESTINATION=$1
    HOSTNAME=`hostname`

    if [ -n "${DESTINATION}" ] ; then
        mm_mythdb_command_run "SELECT * FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\" AND destination=\"${DESTINATION}\""
    else
        mm_mythdb_command_run "SELECT * FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_jumppoint_update() {
    DESTINATION=$1
    KEYLIST=$2
    HOSTNAME=`hostname`

    mm_mythdb_command_run "UPDATE jumppoints SET keylist=\"${KEYLIST}\" \
        WHERE hostname=\"${HOSTNAME}\" AND destination=\"${DESTINATION}\""
}

mm_mythdb_keybinding_delete() {
    CONTEXT=$1
    ACTION=$2
    HOSTNAME=`hostname`

    if   [ -n "${CONTEXT}" ] && [ -n "${ACTION}" ] ; then
        mm_mythdb_command_run "DELETE FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
    elif [ -n "${CONTEXT}" ] ; then
        mm_mythdb_command_run "DELETE FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\""
    else
        mm_mythdb_command_run "DELETE FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_keybinding_dump() {
    CONTEXT=$1
    ACTION=$2
    HOSTNAME=`hostname`

    if   [ -n "${CONTEXT}" ] && [ -n "${ACTION}" ] ; then
        mm_mythdb_command_run "SELECT * FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
    elif [ -n "${CONTEXT}" ] ; then
        mm_mythdb_command_run "SELECT * FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\""
    else
        mm_mythdb_command_run "SELECT * FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_keybinding_update() {
    CONTEXT=$1
    ACTION=$2
    KEYLIST=$3
    HOSTNAME=`hostname`

    mm_mythdb_command_run "UPDATE keybindings SET keylist=\"${KEYLIST}\" \
        WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
}

mm_mythdb_musicplaylist_dump() {
    mm_mythdb_command_run "SELECT * FROM musicplaylist"
}

mm_mythdb_musicplaylist_scope() {
    MUSICPLAYLIST=$1
    SCOPE=$2
    HOSTNAME=`hostname`

    case "${SCOPE}" in
        local)
            mm_mythdb_command_run "UPDATE musicplaylist SET hostname=\"${HOSTNAME}\" WHERE name=\"${MUSICPLAYLIST}\""
            ;;
        global)
            mm_mythdb_command_run "UPDATE musicplaylist SET hostname=\"\"            WHERE name=\"${MUSICPLAYLIST}\""
            ;;
    esac
}

mm_mythdb_setting_delete() {
    VALUE=$1
    HOSTNAME=`hostname`

    if [ -n "${VALUE}" ] ; then
        mm_mythdb_command_run "DELETE FROM settings WHERE value=\"${VALUE}\" AND hostname=\"${HOSTNAME}\""
    else
        mm_mythdb_command_run "DELETE FROM settings WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_setting_dump() {
    VALUE=$1
    HOSTNAME=`hostname`

    if [ -n "${VALUE}" ] ; then
        mm_mythdb_command_run "SELECT * FROM settings WHERE value=\"${VALUE}\" AND hostname=\"${HOSTNAME}\""
    else
        mm_mythdb_command_run "SELECT * FROM settings WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_setting_update() {
    VALUE=$1
    DATA=$2
    HOSTNAME=`hostname`

    mm_mythdb_command_run "UPDATE settings SET data=\"${DATA}\" WHERE value=\"${VALUE}\" AND hostname=\"${HOSTNAME}\""
}


#===============================================================================
# Hardware processing functions.
#===============================================================================

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
mm_hardware_pci_process() {
    pci_process_function=$1

    lspci -mn | sed -e 's%"%%g' | 
    while read pci ; do
        index=1            ; bus=`      echo "${pci}" | cut -d ' ' -f ${index}`
        index=$((index+1)) ; class=`    echo "${pci}" | cut -d ' ' -f ${index}`
        index=$((index+1)) ; vendor=`   echo "${pci}" | cut -d ' ' -f ${index}`
        index=$((index+1)) ; device=`   echo "${pci}" | cut -d ' ' -f ${index}`
        index=$((index+1)) ; revision=` echo "${pci}" | cut -d ' ' -f ${index}`
        if [ `echo "${revision}"   | grep -c -e '^-r'` = "1" ] ; then
            revision=`  echo "${revision}"   | sed -e 's%^-r%%'`
        else
            index=$((index-1)) ; revision='00'
        fi
        index=$((index+1)) ; class_prog=`echo "${pci}" | cut -d ' ' -f ${index}`
        if [ `echo "${class_prog}" | grep -c -e '^-p'` = "1" ] ; then
            class_prog=`echo "${class_prog}" | sed -e 's%^-p%%'`
        else
            index=$((index-1)) ; class_prog='00'
        fi
        index=$((index+1)) ; subvendor=`echo "${pci}" | cut -d ' ' -f ${index}`
        index=$((index+1)) ; subdevice=`echo "${pci}" | cut -d ' ' -f ${index}`
        echo `${pci_process_function} ${class} ${vendor} ${device} ${revision} ${class_prog} ${subvendor} ${subdevice}`
    done |
    mm_uniq
}

mm_hardware_pci2kernel_map() {
    class=$1
    vendor=$2
    device=$3
    revision=$4
    class_prog=$5
    subvendor=$6
    subdevice=$7

    cat /etc/hardware.d/pci2kernel.map | sed -e 's%#.*$%%g' | sed -e 's% *%%g' | grep -e "^${class}," |
    {
        found=
        while read map ; do
            if [ -n "${map}" ] ; then
                map_class_prog=`   echo ${map} | cut -d ',' -f 2`
                map_vendor=`       echo ${map} | cut -d ',' -f 3`
                map_device=`       echo ${map} | cut -d ',' -f 4`
                map_kernel_module=`echo ${map} | cut -d ',' -f 5`
                if ( [ -z "${map_class_prog}" ] || [ "${map_class_prog}" = "${class_prog}" ] ) &&
                   ( [ -z "${map_vendor}"     ] || [ "${map_vendor}"     = "${vendor}"     ] ) &&
                   ( [ -z "${map_device}"     ] || [ "${map_device}"     = "${device}"     ] ) ; then
                    if [ -z "${found}" ] ; then
                        found=1
                        echo ${map_kernel_module}
                    fi
                fi
            fi
        done
    }
}

mm_hardware_pci2x_map() {
    class=$1
    vendor=$2
    device=$3
    revision=$4
    class_prog=$5
    subvendor=$6
    subdevice=$7

    cat /etc/hardware.d/pci2x.map | sed -e 's%#.*$%%g' | sed -e 's% *%%g' | grep -e "^${class}," |
    {
        found=
        while read map ; do
            if [ -n "${map}" ] ; then
                map_class_prog=`echo ${map} | cut -d ',' -f 2`
                map_vendor=`    echo ${map} | cut -d ',' -f 3`
                map_device=`    echo ${map} | cut -d ',' -f 4`
                map_x_driver=`  echo ${map} | cut -d ',' -f 5`
                if ( [ -z "${map_class_prog}" ] || [ "${map_class_prog}" = "${class_prog}" ] ) &&
                   ( [ -z "${map_vendor}"     ] || [ "${map_vendor}"     = "${vendor}"     ] ) &&
                   ( [ -z "${map_device}"     ] || [ "${map_device}"     = "${device}"     ] ) ; then
                    if [ -z "${found}" ] ; then
                        found=1
                        echo ${map_x_driver}
                    fi
                fi
            fi
        done
    }
}

mm_hardware_x2kernel_map() {
    x_driver=$1

    cat /etc/hardware.d/x2kernel.map | sed -e 's%#.*$%%g' | sed -e 's% *%%g' | grep -e "^${x_driver}," |
    {
        found=
        while read map ; do
            if [ -n "${map}" ] ; then
                map_kernel_module=`echo ${map} | cut -d ',' -f 2`
            fi
            if [ -z "${found}" ] ; then
                found=1
                echo ${map_kernel_module}
            fi
        done
    }
}

mm_hardware_cpu_get() {
    case `cat /proc/cpuinfo | grep '^model name' | cut -d ':' -f 2 | sed 's%^ *%%' | sed 's% *$$%%'` in
        AMD\ Athlon\(tm\)\ 64\ Processor\ *) echo 'athlon64' ;;
        VIA\ Nehemiah)                       echo 'c3-2'     ;;
        VIA\ Samuel\ 2)                      echo 'c3'       ;;
        *)                                   echo ''         ;;
    esac
}
