diff -Naur mesa-demos-8.4.0-old/index.html mesa-demos-8.4.0-new/index.html
--- mesa-demos-8.4.0-old/index.html	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/index.html	2020-04-11 09:49:44.110059934 -0700
@@ -0,0 +1,232 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html lang="en">
+<head>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <title>Mesa Demos Distribution</title>
+  <style type="text/css">
+    <!--
+    pre { background: #cccccc; }
+	-->
+  </style>
+</head>
+<body>
+
+<h1>Introduction</h1>
+<p>
+The Mesa Demos package contains a large number of OpenGL demonstration
+and test programs.
+</p>
+
+<p>
+These programs were previously distributed as the MesaDemos-x.y.z.tar.gz
+package released in conjunction with the MesaLib-x.y.z.tar.gz package.
+The demos are separated now since they don't change often and
+aren't tied to a particular version of Mesa.
+</p>
+
+<p>
+Note that the Mesa demos should be usable with any OpenGL implementation;
+not just Mesa.
+</p>
+
+
+<h1>FTP site</h1>
+
+<p>
+The latest version of the Mesa demos can be found on the
+<a href="ftp://ftp.freedesktop.org/pub/mesa/demos/">freedesktop.org FTP</a>
+site.
+</p>
+
+
+
+<h1>Git Repository</h1>
+
+<p>
+The Mesa demos git repository can be obtained with:
+</p>
+<pre>
+git clone git://anongit.freedesktop.org/git/mesa/demos
+</pre>
+
+<p>
+Or, if you're a developer:
+</p>
+<pre>
+git clone git+ssh://USERNAME@git.freedesktop.org/git/mesa/demos
+</pre>
+
+
+<h1>Building</h1>
+
+<p>
+The Mesa demos can be built with autoconf or <a href="http://www.cmake.org/">CMake</a>.
+</p>
+
+
+<h2>Prerequisites</h2>
+
+<p>
+You'll need <a href="http://glew.sourceforge.net/">glew</a> version 1.5.4
+or later and glut or <a href="http://freeglut.sourceforge.net/">freeglut</a> (runtime libraries and header files).
+</p>
+
+<p>
+If you're using an RPM-based Linux distro you can install these items with:
+</p>
+<pre>
+yum install glew glew-devel
+yum install freeglut freeglut-devel
+</pre>
+
+<p>
+And if you're using a Debian based Linux distro you can install these items with:
+</p>
+<pre>
+apt-get install libglew-dev freeglut3-dev
+</pre>
+
+
+
+<h2>Autoconf</h2>
+
+<p>
+Run <b>./configure --help</b> to see the options available for building
+the demos.
+</p>
+
+<p>
+Otherwise, just run <b>./configure ; make</b> to build the demos.
+</p>
+
+
+
+<h2>CMake</h2>
+
+<p>
+See the <a href="http://www.cmake.org/cmake/help/documentation.html">CMake documentation</a> for more information about CMake.
+</p>
+
+<h3>Unix</h3>
+
+<p>
+Run:
+</p>
+<pre>
+cmake .
+make
+</pre>
+
+<h3>MSVC</h3>
+
+<ul>
+  <li>Start the CMake GUI.</li>
+  <li>Specify where this source is and where to build the binaries.</li>
+  <li>Click <i>Configure</i>.</li>
+  <li>Specify where GLEW and GLUT headers and libraries are; specifically via the 
+  <b>GLEW_INCLUDE_DIR</b>, <b>GLEW_glew_LIBRARY</b>, <b>GLUT_INCLUDE_DIR</b>, and <b>GLUT_glut_LIBRARY</b> variables.</li>
+  <li>Click <i>Generate</i>.</li>
+  <li>Open the generated <b>mesademos.sln</b> Visual Studio solution file and build the target <b>ALL</b>.
+</ul>
+
+<h3>MinGW cross-compilation</h3>
+
+<p>
+Create a <b>Toolchain.cmake</b> file containing:
+</p>
+<pre>
+# the name of the target operating system
+set (CMAKE_SYSTEM_NAME Windows)
+
+# which compilers to use for C and C++
+set (CMAKE_C_COMPILER i586-mingw32msvc-gcc)
+set (CMAKE_CXX_COMPILER i586-mingw32msvc-g++)
+set (CMAKE_RC_COMPILER i586-mingw32msvc-windres)
+
+# here is the target environment located
+set (CMAKE_FIND_ROOT_PATH /usr/i586-mingw32msvc)
+
+# adjust the default behaviour of the FIND_XXX() commands:
+# search headers and libraries in the target environment, search
+# programs in the host environment
+set (CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
+set (CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
+set (CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
+</pre>
+
+<p>
+Create a <b>Cache.cmake</b> file containing:
+</p>
+<pre>
+set (GLEW_INCLUDE_DIR "/path/to/glew/include" CACHE PATH "" FORCE)
+set (GLEW_glew_LIBRARY "/path/to/glew/lib/libglew32.a" CACHE FILEPATH "" FORCE)
+
+set (GLUT_INCLUDE_DIR "/path/to/glut/include" CACHE PATH "" FORCE)
+set (GLUT_glut_LIBRARY "/path/to/glut/lib/libglut32.a" CACHE FILEPATH "" FORCE)
+</pre>
+
+<p>
+Then do:
+</p>
+<pre>
+cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX=/path/to/install -DCMAKE_BUILD_TYPE=MinSizeRel -DCMAKE_TOOLCHAIN_FILE=/path/to/Toolchain.cmake -C /path/to/Cache.cmake
+make
+make install
+</pre>
+
+<p>
+Read <a href="http://www.vtk.org/Wiki/CmakeMingw">this</a> for more information about CMake and MinGW cross compilation.
+</p>
+
+
+<h1>The Demos</h1>
+
+<p>
+Look in the <b>src/</b> directory for these sub-directories, among others:
+</p>
+<ul>
+  <li>demos - the original Mesa demos, such as gears, gloss, etc.</li>
+  <li>redbook - the OpenGL Programming Guide demos</li>
+  <li>samples- original SGI OpenGL demos</li>
+  <li>glsl - OpenGL Shading Language demos</li>
+  <li>gs - Geometry shader demos</li>
+  <li>xdemos - GLX-based demos</li>
+  <li>egl - EGL-based demos</li>
+  <li>wgl - WGL-based demos</li>
+  <li>fp - fragment program tests</li>
+  <li>vp - vertex program tests</li>
+  <li>data - data files used by the demos</li>
+  <li>perf - performance tests</li>
+  <li>tests - assorted test programs</li>
+  <li>objviewer - program to view .obj modes with a skybox</li>
+</ul>
+
+
+
+<h1>Getting Help</h1>
+
+<p>
+If you have trouble building or using the Mesa demos, you can post
+to the<a href="http://lists.freedesktop.org/mailman/listinfo/mesa-users">
+Mesa users</a> mailing list.
+</p>
+
+<p>
+If your question is especially technical, you can try the
+to the<a href="http://lists.freedesktop.org/mailman/listinfo/mesa-dev">
+Mesa dev</a> mailing list.
+</p>
+
+
+<h1>Reporting Bugs</h1>
+
+<p>
+Bugs in the demos can be reported to the
+<a href="https://bugs.freedesktop.org/enter_bug.cgi?product=Mesa">
+Mesa bug database</a>.
+Choose Component="Demos" in the drop-down list.
+</p>
+
+
+</body>
+</html>
diff -Naur mesa-demos-8.4.0-old/src/demos/Makefile.cygnus mesa-demos-8.4.0-new/src/demos/Makefile.cygnus
--- mesa-demos-8.4.0-old/src/demos/Makefile.cygnus	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/demos/Makefile.cygnus	2020-04-11 09:49:44.110059934 -0700
@@ -0,0 +1,86 @@
+
+# Mesa 3-D graphics library
+# Version:  3.3
+# Copyright (C) 1995-2000  Brian Paul
+
+
+# Makefile for demo programs for cygnus
+# Stephane Rehel (rehel@worldnet.fr) April 13 1997
+
+
+
+##### MACROS #####
+
+INCDIR = ../include
+LIBDIR = ../lib
+
+GL_LIBS = -L$(LIBDIR) -lglut -lMesaGLU -lMesaGL -lm $(WLIBS)
+
+LIB_DEP = $(LIBDIR)/$(GL_LIB) $(LIBDIR)/$(GLU_LIB) $(LIBDIR)/$(GLUT_LIB)
+
+PROGS = bounce \
+	clearspd \
+	cubemap \
+	drawpix \
+	fire \
+	gamma \
+	gears \
+	geartrain \
+	glinfo \
+	gloss \
+	gltestperf \
+	glutfx \
+	isosurf \
+	ipers \
+	lodbias \
+	morph3d \
+	multiarb \
+	osdemo \
+	paltex \
+	pixeltex \
+	pointblast \
+	ray \
+	readpix \
+	reflect \
+	renormal \
+	spectex \
+	stex3d \
+	teapot \
+	terrain \
+	tessdemo \
+	texcyl \
+	texdown \
+	texenv \
+	texobj \
+	trispd \
+	tunnel \
+	tunnel2 \
+	winpos
+
+
+##### RULES #####
+
+.SUFFIXES:
+.SUFFIXES: .c
+
+.c: $(LIB_DEP)
+	$(CC) -I$(INCDIR) -I../util $(CFLAGS) $< $(GL_LIBS) -o $@
+
+
+##### TARGETS #####
+
+default:
+	@echo "Specify a target configuration"
+
+clean:
+	-rm *.o *~
+
+realclean:
+	-rm $(PROGS:=.exe)
+	-rm *.o *~
+
+targets: $(PROGS)
+
+include ../Make-config
+
+
diff -Naur mesa-demos-8.4.0-old/src/demos/normal.c mesa-demos-8.4.0-new/src/demos/normal.c
--- mesa-demos-8.4.0-old/src/demos/normal.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/demos/normal.c	2020-04-11 09:49:44.110059934 -0700
@@ -0,0 +1,596 @@
+/**
+ * Test gl_NormalMatrix.
+ * Tom Fogal
+ * 5 Oct 2011
+ *
+ * Based on Test OpenGL 2.0 vertex/fragment shaders.
+ * Brian Paul
+ * 1 November 2006
+ *
+ * Based on ARB version by:
+ * Michal Krol
+ * 20 February 2006
+ *
+ * Based on the original demo by:
+ * Brian Paul
+ * 17 April 2003
+ */
+
+#include <assert.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <GL/glew.h>
+#include "glut_wrap.h"
+
+
+#define TEXTURE 0
+
+static GLint CoordAttrib = 0;
+
+static char *FragProgFile = NULL;
+static char *VertProgFile = NULL;
+
+static GLfloat diffuse[4] = { 0.5f, 0.5f, 1.0f, 1.0f };
+static GLfloat specular[4] = { 0.8f, 0.8f, 0.8f, 1.0f };
+static GLfloat lightPos[4] = { 0.0f, 10.0f, 20.0f, 0.0f };
+static GLfloat delta = 1.0f;
+
+static GLuint fragShader;
+static GLuint vertShader;
+static GLuint program;
+
+static GLuint SphereList, RectList, CurList;
+static GLint win = 0;
+static GLboolean anim = GL_TRUE;
+static GLboolean wire = GL_FALSE;
+static GLboolean pixelLight = GL_TRUE;
+
+static GLint t0 = 0;
+static GLint frames = 0;
+
+static GLfloat xRot = 90.0f, yRot = 0.0f;
+
+
+static void
+normalize(GLfloat *dst, const GLfloat *src)
+{
+   GLfloat len = sqrt(src[0] * src[0] + src[1] * src[1] + src[2] * src[2]);
+   dst[0] = src[0] / len;
+   dst[1] = src[1] / len;
+   dst[2] = src[2] / len;
+   dst[3] = src[3];
+}
+
+
+static void
+Redisplay(void)
+{
+   GLfloat vec[4];
+
+   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+   /* update light position */
+   normalize(vec, lightPos);
+   glLightfv(GL_LIGHT0, GL_POSITION, vec);
+   
+   if (pixelLight) {
+      glUseProgram(program);
+      glDisable(GL_LIGHTING);
+   }
+   else {
+      glUseProgram(0);
+      glEnable(GL_LIGHTING);
+   }
+
+   glPushMatrix();
+   glRotatef(xRot, 1.0f, 0.0f, 0.0f);
+   glRotatef(yRot, 0.0f, 1.0f, 0.0f);
+   /*
+   glutSolidSphere(2.0, 10, 5);
+   */
+   glCallList(CurList);
+   glPopMatrix();
+
+   glutSwapBuffers();
+   frames++;
+
+   if (anim) {
+      GLint t = glutGet(GLUT_ELAPSED_TIME);
+      if (t - t0 >= 5000) {
+         GLfloat seconds =(GLfloat)(t - t0) / 1000.0f;
+         GLfloat fps = frames / seconds;
+         printf("%d frames in %6.3f seconds = %6.3f FPS\n",
+                frames, seconds, fps);
+         fflush(stdout);
+         t0 = t;
+         frames = 0;
+      }
+   }
+}
+
+
+static void
+Idle(void)
+{
+   lightPos[0] += delta;
+   if (lightPos[0] > 25.0f || lightPos[0] < -25.0f)
+      delta = -delta;
+   glutPostRedisplay();
+}
+
+
+static void
+Reshape(int width, int height)
+{
+   glViewport(0, 0, width, height);
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+   glFrustum(-1.0, 1.0, -1.0, 1.0, 5.0, 25.0);
+   glMatrixMode(GL_MODELVIEW);
+   glLoadIdentity();
+   glTranslatef(0.0f, 0.0f, -15.0f);
+}
+
+
+static void
+CleanUp(void)
+{
+   glDeleteShader(fragShader);
+   glDeleteShader(vertShader);
+   glDeleteProgram(program);
+   glutDestroyWindow(win);
+}
+
+
+static void
+Key(unsigned char key, int x, int y)
+{
+  (void) x;
+  (void) y;
+
+   switch(key) {
+   case ' ':
+   case 'a':
+      anim = !anim;
+      if (anim)
+         glutIdleFunc(Idle);
+      else
+         glutIdleFunc(NULL);
+      break;
+   case 'x':
+      lightPos[0] -= 1.0f;
+      break;
+   case 'X':
+      lightPos[0] += 1.0f;
+      break;
+   case 'w':
+      wire = !wire;
+      if (wire)
+         glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+      else
+         glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+      break;
+   case 'o':
+      if (CurList == SphereList)
+         CurList = RectList;
+      else
+         CurList = SphereList;
+      break;
+   case 'p':
+      pixelLight = !pixelLight;
+      if (pixelLight)
+         printf("Per-pixel lighting\n");
+      else
+         printf("Conventional lighting\n");
+      break;
+   case 27:
+      CleanUp();
+      exit(0);
+      break;
+   }
+   glutPostRedisplay();
+}
+
+
+static void
+SpecialKey(int key, int x, int y)
+{
+   const GLfloat step = 3.0f;
+
+  (void) x;
+  (void) y;
+
+   switch(key) {
+   case GLUT_KEY_UP:
+      xRot -= step;
+      break;
+   case GLUT_KEY_DOWN:
+      xRot += step;
+      break;
+   case GLUT_KEY_LEFT:
+      yRot -= step;
+      break;
+   case GLUT_KEY_RIGHT:
+      yRot += step;
+      break;
+   }
+   glutPostRedisplay();
+}
+
+
+static void
+TestFunctions(void)
+{
+   printf("Error 0x%x at line %d\n", glGetError(), __LINE__);
+
+   assert(glIsProgram(program));
+   assert(glIsShader(fragShader));
+   assert(glIsShader(vertShader));
+
+   /* attached shaders */
+   {
+      GLuint shaders[20];
+      GLsizei count;
+      int i;
+      glGetAttachedShaders(program, 20, &count, shaders);
+      for (i = 0; i < count; i++) {
+         printf("Attached: %u\n", shaders[i]);
+         assert(shaders[i] == fragShader ||
+                shaders[i] == vertShader);
+      }
+   }
+
+   {
+      GLchar log[1000];
+      GLsizei len;
+      glGetShaderInfoLog(vertShader, 1000, &len, log);
+      printf("Vert Shader Info Log: %s\n", log);
+      glGetShaderInfoLog(fragShader, 1000, &len, log);
+      printf("Frag Shader Info Log: %s\n", log);
+      glGetProgramInfoLog(program, 1000, &len, log);
+      printf("Program Info Log: %s\n", log);
+   }
+
+   /* active uniforms */
+   {
+      GLint n, max, i;
+      glGetProgramiv(program, GL_ACTIVE_UNIFORMS, &n);
+      glGetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &max);
+      printf("Num uniforms: %d  Max name length: %d\n", n, max);
+      for (i = 0; i < n; i++) {
+         GLint size, len;
+         GLenum type;
+         char name[100];
+         glGetActiveUniform(program, i, 100, &len, &size, &type, name);
+         printf("  %d: %s nameLen=%d size=%d type=0x%x\n",
+                i, name, len, size, type);
+      }
+   }
+}
+
+
+#if TEXTURE
+static void
+MakeTexture(void)
+{
+#define SZ0 64
+#define SZ1 32
+   GLubyte image0[SZ0][SZ0][SZ0][4];
+   GLubyte image1[SZ1][SZ1][SZ1][4];
+   GLuint i, j, k;
+
+   /* level 0: two-tone gray checkboard */
+   for (i = 0; i < SZ0; i++) {
+      for (j = 0; j < SZ0; j++) {
+         for (k = 0; k < SZ0; k++) {
+            if ((i/8 + j/8 + k/8) & 1) {
+               image0[i][j][k][0] = 
+               image0[i][j][k][1] = 
+               image0[i][j][k][2] = 200;
+            }
+            else {
+               image0[i][j][k][0] = 
+               image0[i][j][k][1] = 
+               image0[i][j][k][2] = 100;
+            }
+            image0[i][j][k][3] = 255;
+         }
+      }
+   }
+
+   /* level 1: two-tone green checkboard */
+   for (i = 0; i < SZ1; i++) {
+      for (j = 0; j < SZ1; j++) {
+         for (k = 0; k < SZ1; k++) {
+            if ((i/8 + j/8 + k/8) & 1) {
+               image1[i][j][k][0] = 0;
+               image1[i][j][k][1] = 250;
+               image1[i][j][k][2] = 0;
+            }
+            else {
+               image1[i][j][k][0] = 0;
+               image1[i][j][k][1] = 200;
+               image1[i][j][k][2] = 0;
+            }
+            image1[i][j][k][3] = 255;
+         }
+      }
+   }
+
+   glActiveTexture(GL_TEXTURE2); /* unit 2 */
+   glBindTexture(GL_TEXTURE_2D, 42);
+   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, SZ0, SZ0, 0,
+                GL_RGBA, GL_UNSIGNED_BYTE, image0);
+   glTexImage2D(GL_TEXTURE_2D, 1, GL_RGBA, SZ1, SZ1, 0,
+                GL_RGBA, GL_UNSIGNED_BYTE, image1);
+   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 1);
+   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+   glActiveTexture(GL_TEXTURE4); /* unit 4 */
+   glBindTexture(GL_TEXTURE_3D, 43);
+   glTexImage3D(GL_TEXTURE_3D, 0, GL_RGBA, SZ0, SZ0, SZ0, 0,
+                GL_RGBA, GL_UNSIGNED_BYTE, image0);
+   glTexImage3D(GL_TEXTURE_3D, 1, GL_RGBA, SZ1, SZ1, SZ1, 0,
+                GL_RGBA, GL_UNSIGNED_BYTE, image1);
+   glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAX_LEVEL, 1);
+   glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+   glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+}
+#endif
+
+
+static void
+MakeSphere(void)
+{
+   GLUquadricObj *obj = gluNewQuadric();
+   SphereList = glGenLists(1);
+   gluQuadricTexture(obj, GL_TRUE);
+   glNewList(SphereList, GL_COMPILE);
+   gluSphere(obj, 2.0f, 10, 5);
+   glEndList();
+   gluDeleteQuadric(obj);
+}
+
+static void
+VertAttrib(GLint index, float x, float y)
+{
+#if 1
+   glVertexAttrib2f(index, x, y);
+#else
+   glTexCoord2f(x, y);
+#endif
+}
+
+static void
+MakeRect(void)
+{
+   RectList = glGenLists(1);
+   glNewList(RectList, GL_COMPILE);
+   glNormal3f(0, 0, 1);
+   glBegin(GL_POLYGON);
+   VertAttrib(CoordAttrib, 0, 0);   glVertex2f(-2, -2);
+   VertAttrib(CoordAttrib, 1, 0);   glVertex2f( 2, -2);
+   VertAttrib(CoordAttrib, 1, 1);   glVertex2f( 2,  2);
+   VertAttrib(CoordAttrib, 0, 1);   glVertex2f(-2,  2);
+   glEnd();    /* XXX omit this and crash! */
+   glEndList();
+}
+
+
+
+static void
+LoadAndCompileShader(GLuint shader, const char *text)
+{
+   GLint stat;
+
+   glShaderSource(shader, 1, (const GLchar **) &text, NULL);
+
+   glCompileShader(shader);
+
+   glGetShaderiv(shader, GL_COMPILE_STATUS, &stat);
+   if (!stat) {
+      GLchar log[1000];
+      GLsizei len;
+      glGetShaderInfoLog(shader, 1000, &len, log);
+      fprintf(stderr, "fslight: problem compiling shader:\n%s\n", log);
+      exit(1);
+   }
+}
+
+
+/**
+ * Read a shader from a file.
+ */
+static void
+ReadShader(GLuint shader, const char *filename)
+{
+   const int max = 100*1000;
+   int n;
+   char *buffer = (char*) malloc(max);
+   FILE *f = fopen(filename, "r");
+   if (!f) {
+      fprintf(stderr, "fslight: Unable to open shader file %s\n", filename);
+      exit(1);
+   }
+
+   n = fread(buffer, 1, max, f);
+   printf("fslight: read %d bytes from shader file %s\n", n, filename);
+   if (n > 0) {
+      buffer[n] = 0;
+      LoadAndCompileShader(shader, buffer);
+   }
+
+   fclose(f);
+   free(buffer);
+}
+
+
+static void
+CheckLink(GLuint prog)
+{
+   GLint stat;
+   glGetProgramiv(prog, GL_LINK_STATUS, &stat);
+   if (!stat) {
+      GLchar log[1000];
+      GLsizei len;
+      glGetProgramInfoLog(prog, 1000, &len, log);
+      fprintf(stderr, "Linker error:\n%s\n", log);
+   }
+}
+
+
+static void
+Init(void)
+{
+   static const char *fragShaderText =
+      "void main(void) {\n"
+      "  if(gl_NormalMatrix[1].z == 1.0) {\n"
+      "    gl_FragColor = vec4(1.0, 0.0, 0.0, 0.05);\n"
+      "  } else {\n"
+      "    gl_FragColor = vec4(0.0, 1.0, 0.0, 0.05);\n"
+      "  }\n"
+      "}\n";
+/*      "   gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n" */
+   static const char *vertShaderText =
+      "void main() {\n"
+      "  gl_Position = ftransform();\n"
+      "}\n";
+
+   if (!GLEW_VERSION_2_0) {
+      printf("This program requires OpenGL 2.x or higher\n");
+      exit(1);
+   }
+
+   fragShader = glCreateShader(GL_FRAGMENT_SHADER);
+   if (FragProgFile)
+      ReadShader(fragShader, FragProgFile);
+   else
+      LoadAndCompileShader(fragShader, fragShaderText);
+
+
+   vertShader = glCreateShader(GL_VERTEX_SHADER);
+   if (VertProgFile)
+      ReadShader(vertShader, VertProgFile);
+   else
+      LoadAndCompileShader(vertShader, vertShaderText);
+
+   program = glCreateProgram();
+   glAttachShader(program, fragShader);
+   glAttachShader(program, vertShader);
+   glLinkProgram(program);
+   CheckLink(program);
+   glUseProgram(program);
+
+   if (CoordAttrib) {
+      int i;
+      glBindAttribLocation(program, CoordAttrib, "coord");
+      i = glGetAttribLocation(program, "coord");
+      assert(i >= 0);
+      if (i != CoordAttrib) {
+         printf("Hmmm, NVIDIA bug?\n");
+         CoordAttrib = i;
+      }
+      else {
+         printf("Mesa bind attrib: coord = %d\n", i);
+      }
+   }
+
+   /*assert(glGetError() == 0);*/
+
+   glClearColor(0.3f, 0.3f, 0.3f, 0.0f);
+   glEnable(GL_DEPTH_TEST);
+   glEnable(GL_LIGHT0);
+   glEnable(GL_LIGHTING);
+   glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse);
+   glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, specular);
+   glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 20.0f);
+
+   MakeSphere();
+   MakeRect();
+
+   CurList = SphereList;
+
+#if TEXTURE
+   MakeTexture();
+#endif
+
+   printf("GL_RENDERER = %s\n",(const char *) glGetString(GL_RENDERER));
+   printf("Press p to toggle between per-pixel and per-vertex lighting\n");
+
+   /* test glGetShaderSource() */
+   if (0) {
+      GLsizei len = strlen(fragShaderText) + 1;
+      GLsizei lenOut;
+      GLchar *src =(GLchar *) malloc(len * sizeof(GLchar));
+      glGetShaderSource(fragShader, 0, NULL, src);
+      glGetShaderSource(fragShader, len, &lenOut, src);
+      assert(len == lenOut + 1);
+      assert(strcmp(src, fragShaderText) == 0);
+      free(src);
+   }
+
+   assert(glIsProgram(program));
+   assert(glIsShader(fragShader));
+   assert(glIsShader(vertShader));
+
+   glColor3f(1, 0, 0);
+
+   /* for testing state vars */
+   {
+      static GLfloat fc[4] = { 1, 1, 0, 0 };
+      static GLfloat amb[4] = { 1, 0, 1, 0 };
+      glFogfv(GL_FOG_COLOR, fc);
+      glLightfv(GL_LIGHT1, GL_AMBIENT, amb);
+   }
+
+#if 0
+   TestFunctions();
+#else
+   (void) TestFunctions;
+#endif
+}
+
+
+static void
+ParseOptions(int argc, char *argv[])
+{
+   int i;
+   for (i = 1; i < argc; i++) {
+      if (strcmp(argv[i], "-fs") == 0) {
+         FragProgFile = argv[++i];
+      }
+      else if (strcmp(argv[i], "-vs") == 0) {
+         VertProgFile = argv[++i];
+      }
+      else {
+         fprintf(stderr, "unknown option %s\n", argv[i]);
+         break;
+      }
+   }
+}
+
+
+int
+main(int argc, char *argv[])
+{
+   glutInitWindowSize(200, 200);
+   glutInit(&argc, argv);
+   glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
+   win = glutCreateWindow(argv[0]);
+   glewInit();
+   glutReshapeFunc(Reshape);
+   glutKeyboardFunc(Key);
+   glutSpecialFunc(SpecialKey);
+   glutDisplayFunc(Redisplay);
+   if (anim)
+      glutIdleFunc(Idle);
+   ParseOptions(argc, argv);
+   Init();
+   glutMainLoop();
+   return 0;
+}
+
+
diff -Naur mesa-demos-8.4.0-old/src/demos/particles.cxx mesa-demos-8.4.0-new/src/demos/particles.cxx
--- mesa-demos-8.4.0-old/src/demos/particles.cxx	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/demos/particles.cxx	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,219 @@
+/*
+ * This program is under the GNU GPL.
+ * Use at your own risk.
+ *
+ * written by David Bucciarelli (humanware@plus.it)
+ *            Humanware s.r.l.
+ */
+
+#include <stdlib.h>
+
+#include "particles.h"
+
+#define vinit(a,i,j,k) {\
+  (a)[0]=i;\
+  (a)[1]=j;\
+  (a)[2]=k;\
+}
+
+#define vadds(a,dt,b) {\
+  (a)[0]+=(dt)*(b)[0];\
+  (a)[1]+=(dt)*(b)[1];\
+  (a)[2]+=(dt)*(b)[2];\
+}
+
+#define vequ(a,b) {\
+  (a)[0]=(b)[0];\
+  (a)[1]=(b)[1];\
+  (a)[2]=(b)[2];\
+}
+
+#define vinter(a,dt,b,c) {\
+  (a)[0]=(dt)*(b)[0]+(1.0-dt)*(c)[0];\
+  (a)[1]=(dt)*(b)[1]+(1.0-dt)*(c)[1];\
+  (a)[2]=(dt)*(b)[2]+(1.0-dt)*(c)[2];\
+}
+
+#define clamp(a)        ((a) < 0.0 ? 0.0 : ((a) < 1.0 ? (a) : 1.0))
+
+#define vclamp(v) {\
+  (v)[0]=clamp((v)[0]);\
+  (v)[1]=clamp((v)[1]);\
+  (v)[2]=clamp((v)[2]);\
+}
+
+
+float rainParticle::min[3];
+float rainParticle::max[3];
+float rainParticle::partLength=0.2f;
+
+
+static float vrnd(void)
+{
+  return(((float)rand())/RAND_MAX);
+}
+
+
+particle::particle()
+{
+  age=0.0f;
+
+  vinit(acc,0.0f,0.0f,0.0f);
+  vinit(vel,0.0f,0.0f,0.0f);
+  vinit(pos,0.0f,0.0f,0.0f);
+}
+
+void particle::elapsedTime(float dt)
+{
+  age+=dt;
+
+  vadds(vel,dt,acc);
+
+  vadds(pos,dt,vel);
+}
+
+/////////////////////////////////////////
+// Particle System
+/////////////////////////////////////////
+
+particleSystem::particleSystem()
+{
+  t=0.0f;
+
+  part=NULL;
+
+  particleNum=0;
+}
+
+particleSystem::~particleSystem()
+{
+  if(part)
+    free(part);
+}
+
+void particleSystem::addParticle(particle *p)
+{
+  if(!part) {
+    part=(particle **)calloc(1,sizeof(particle *));
+    part[0]=p;
+    particleNum=1;
+  } else {
+    particleNum++;
+    part=(particle **)realloc(part,sizeof(particle *)*particleNum);
+    part[particleNum-1]=p;
+  }
+}
+
+void particleSystem::reset(void)
+{
+  if(part)
+    free(part);
+
+  t=0.0f;
+
+  part=NULL;
+
+  particleNum=0;
+}
+
+void particleSystem::draw(void)
+{
+  if(!part)
+    return;
+
+  part[0]->beginDraw();
+  for(unsigned int i=0;i<particleNum;i++)
+    part[i]->draw();
+  part[0]->endDraw();
+}
+
+void particleSystem::addTime(float dt)
+{
+  if(!part)
+    return;
+
+  for(unsigned int i=0;i<particleNum;i++) {
+    part[i]->elapsedTime(dt);
+    part[i]->checkAge();
+  }
+}
+
+/////////////////////////////////////////
+// Rain
+/////////////////////////////////////////
+
+void rainParticle::init(void)
+{
+  age=0.0f;
+
+  acc[0]=0.0f;
+  acc[1]=-0.98f;
+  acc[2]=0.0f;
+
+  vel[0]=0.0f;
+  vel[1]=0.0f;
+  vel[2]=0.0f;
+
+  oldpos[0]=pos[0]=min[0]+(max[0]-min[0])*vrnd();
+  oldpos[1]=pos[1]=max[1]+0.2f*max[1]*vrnd();
+  oldpos[2]=pos[2]=min[2]+(max[2]-min[2])*vrnd();
+
+  vadds(oldpos,-partLength,vel);
+}
+
+rainParticle::rainParticle()
+{ 
+  init();
+}
+
+void rainParticle::setRainingArea(float minx, float miny, float minz,
+				  float maxx, float maxy, float maxz)
+{
+  vinit(min,minx,miny,minz);
+  vinit(max,maxx,maxy,maxz);
+}
+
+void rainParticle::setLength(float l)
+{
+  partLength=l;
+}
+
+void rainParticle::draw(void)
+{
+  glColor4f(0.7f,0.95f,1.0f,0.0f);
+  glVertex3fv(oldpos);
+
+  glColor4f(0.3f,0.7f,1.0f,1.0f);
+  glVertex3fv(pos);
+}
+
+void rainParticle::checkAge(void)
+{
+  if(pos[1]<min[1])
+    init();
+}
+
+void rainParticle::elapsedTime(float dt)
+{
+  particle::elapsedTime(dt);
+
+  if(pos[0]<min[0])
+    pos[0]=max[0]-(min[0]-pos[0]);
+  if(pos[2]<min[2])
+    pos[2]=max[2]-(min[2]-pos[2]);
+
+  if(pos[0]>max[0])
+    pos[0]=min[0]+(pos[0]-max[0]);
+  if(pos[2]>max[2])
+    pos[2]=min[2]+(pos[2]-max[2]);
+
+  vequ(oldpos,pos);
+  vadds(oldpos,-partLength,vel);
+}
+
+void rainParticle::randomHeight(void)
+{
+  pos[1]=(max[1]-min[1])*vrnd()+min[1];
+
+  oldpos[1]=pos[1]-partLength*vel[1];
+}
diff -Naur mesa-demos-8.4.0-old/src/demos/particles.h mesa-demos-8.4.0-new/src/demos/particles.h
--- mesa-demos-8.4.0-old/src/demos/particles.h	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/demos/particles.h	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,81 @@
+/*
+ * This program is under the GNU GPL.
+ * Use at your own risk.
+ *
+ * written by David Bucciarelli (humanware@plus.it)
+ *            Humanware s.r.l.
+ */
+
+#ifndef PARTICLES_H
+#define PARTICLES_H
+
+#include "gl_wrap.h"
+
+class particle {
+ protected:
+  float age;         // in seconds
+  float acc[3];
+  float vel[3];
+  float pos[3];
+
+ public:
+  particle();
+  virtual ~particle() {};
+
+  virtual void beginDraw(void) {};
+  virtual void draw(void)=0;
+  virtual void endDraw(void) {};
+
+  virtual void elapsedTime(float);
+  virtual void checkAge(void) {};
+};
+
+class particleSystem {
+ protected:
+  particle **part;
+
+  float t;
+
+  unsigned long particleNum;
+ public:
+  particleSystem();
+  ~particleSystem();
+
+  void addParticle(particle *);
+
+  void reset(void);
+
+  void draw(void);
+
+  void addTime(float);
+};
+
+class rainParticle : public particle {
+ protected:
+  static float min[3];
+  static float max[3];
+  static float partLength;
+
+  float oldpos[3];
+
+  void init(void);
+ public:
+  rainParticle();
+
+  static void setRainingArea(float, float, float,
+			     float, float, float);
+  static void setLength(float);
+  static float getLength(void) { return partLength; };
+
+  void beginDraw(void) { glBegin(GL_LINES); };
+  void draw(void);
+  void endDraw(void) { glEnd(); };
+
+  void elapsedTime(float);
+
+  void checkAge(void);
+
+  void randomHeight(void);
+};
+
+#endif
diff -Naur mesa-demos-8.4.0-old/src/demos/rain.cxx mesa-demos-8.4.0-new/src/demos/rain.cxx
--- mesa-demos-8.4.0-old/src/demos/rain.cxx	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/demos/rain.cxx	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,394 @@
+/*
+ * This program is under the GNU GPL.
+ * Use at your own risk.
+ *
+ * written by David Bucciarelli (humanware@plus.it)
+ *            Humanware s.r.l.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <time.h>
+#include "glut_wrap.h"
+#ifndef M_PI
+#define M_PI 3.14159265
+#endif
+
+#include "particles.h"
+extern "C" {
+#include "readtex.h"
+}
+
+#ifdef _WIN32
+#include <windows.h>
+#include <mmsystem.h>
+#endif
+
+#ifdef XMESA
+#include "GL/xmesa.h"
+static int fullscreen=1;
+#endif
+
+static int WIDTH=640;
+static int HEIGHT=480;
+static int NUMPART=7500;
+
+#define FRAME 50
+
+static float fogcolor[4]={1.0,1.0,1.0,1.0};
+
+#define DIMP 40.0
+#define DIMTP 32.0
+
+static float q[4][3]={
+  {-DIMP,0.0,-DIMP},
+  {DIMP,0.0,-DIMP},
+  {DIMP,0.0,DIMP},
+  {-DIMP,0.0,DIMP}
+};
+
+static float qt[4][2]={
+  {-DIMTP,-DIMTP},
+  {DIMTP,-DIMTP},
+  {DIMTP,DIMTP},
+  {-DIMTP,DIMTP}
+};
+
+static int win=0;
+
+static int fog=1;
+static int help=1;
+
+static GLuint groundid;
+
+static float obs[3]={2.0,1.0,0.0};
+static float dir[3];
+static float v=0.0;
+static float alpha=-90.0;
+static float beta=90.0;
+
+static particleSystem *ps;
+
+static float gettime()
+{
+  static clock_t told=0;
+  clock_t tnew,ris;
+
+  tnew=clock();
+
+  ris=tnew-told;
+
+  told=tnew;
+
+  return(ris/(float)CLOCKS_PER_SEC);
+}
+
+static float gettimerain()
+{
+  static clock_t told=0;
+  clock_t tnew,ris;
+
+  tnew=clock();
+
+  ris=tnew-told;
+
+  told=tnew;
+
+  return(ris/(float)CLOCKS_PER_SEC);
+}
+
+static void calcposobs(void)
+{
+  dir[0]=sin(alpha*M_PI/180.0);
+  dir[2]=cos(alpha*M_PI/180.0)*sin(beta*M_PI/180.0);
+  dir[1]=cos(beta*M_PI/180.0);
+
+  obs[0]+=v*dir[0];
+  obs[1]+=v*dir[1];
+  obs[2]+=v*dir[2];
+
+  rainParticle::setRainingArea(obs[0]-7.0f,-0.2f,obs[2]-7.0f,obs[0]+7.0f,8.0f,obs[2]+7.0f);
+}
+
+static void printstring(void *font, const char *string)
+{
+  int len,i;
+
+  len=(int)strlen(string);
+  for(i=0;i<len;i++)
+    glutBitmapCharacter(font,string[i]);
+}
+
+static void reshape(int width, int height)
+{
+  WIDTH=width;
+  HEIGHT=height;
+  glViewport(0,0,(GLint)width,(GLint)height);
+  glMatrixMode(GL_PROJECTION);
+  glLoadIdentity();
+  gluPerspective(70.0,width/(float)height,0.1,30.0);
+
+  glMatrixMode(GL_MODELVIEW);
+}
+
+static void printhelp(void)
+{
+  glEnable(GL_BLEND);
+  glColor4f(0.0,0.0,0.0,0.5);
+  glRecti(40,40,600,440);
+  glDisable(GL_BLEND);
+
+  glColor3f(1.0,0.0,0.0);
+  glRasterPos2i(300,420);
+  printstring(GLUT_BITMAP_TIMES_ROMAN_24,"Help");
+
+  glRasterPos2i(60,390);
+  printstring(GLUT_BITMAP_TIMES_ROMAN_24,"h - Toggle Help");
+
+  glRasterPos2i(60,360);
+  printstring(GLUT_BITMAP_TIMES_ROMAN_24,"f - Toggle Fog");
+  glRasterPos2i(60,330);
+  printstring(GLUT_BITMAP_TIMES_ROMAN_24,"Arrow Keys - Rotate");
+  glRasterPos2i(60,300);
+  printstring(GLUT_BITMAP_TIMES_ROMAN_24,"a - Increase velocity");
+  glRasterPos2i(60,270);
+  printstring(GLUT_BITMAP_TIMES_ROMAN_24,"z - Decrease velocity");
+  glRasterPos2i(60,240);
+  printstring(GLUT_BITMAP_TIMES_ROMAN_24,"l - Increase rain length");
+  glRasterPos2i(60,210);
+  printstring(GLUT_BITMAP_TIMES_ROMAN_24,"k - Decrease rain length");
+}
+
+static void drawrain(void)
+{
+  static int count=0;
+  static char frbuf[80];
+  float fr;
+
+  glEnable(GL_DEPTH_TEST);
+
+  if(fog)
+    glEnable(GL_FOG);
+  else
+    glDisable(GL_FOG);
+
+  glDepthMask(GL_TRUE);
+  glClearColor(1.0,1.0,1.0,1.0);
+  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
+
+  glPushMatrix();
+  calcposobs();
+  gluLookAt(obs[0],obs[1],obs[2],
+	    obs[0]+dir[0],obs[1]+dir[1],obs[2]+dir[2],
+	    0.0,1.0,0.0);
+
+  glColor4f(1.0,1.0,1.0,1.0);
+
+  glEnable(GL_TEXTURE_2D);
+
+  glBindTexture(GL_TEXTURE_2D,groundid);
+  glBegin(GL_QUADS);
+  glTexCoord2fv(qt[0]);
+  glVertex3fv(q[0]);
+  glTexCoord2fv(qt[1]);
+  glVertex3fv(q[1]);
+  glTexCoord2fv(qt[2]);
+  glVertex3fv(q[2]);
+  glTexCoord2fv(qt[3]);
+  glVertex3fv(q[3]);
+  glEnd();
+
+  // Particle System
+
+  glDisable(GL_TEXTURE_2D);
+  glShadeModel(GL_SMOOTH);
+  glEnable(GL_BLEND);
+
+  ps->draw();
+  ps->addTime(gettimerain());
+  
+  glShadeModel(GL_FLAT);
+ 
+
+  if((count % FRAME)==0) {
+    fr=gettime();
+    sprintf(frbuf,"Frame rate: %f",FRAME/fr);
+  }
+
+  glDisable(GL_TEXTURE_2D);
+  glDisable(GL_DEPTH_TEST);
+  glDisable(GL_FOG);
+
+  glMatrixMode(GL_PROJECTION);
+  glLoadIdentity();
+  glOrtho(-0.5,639.5,-0.5,479.5,-1.0,1.0);
+  glMatrixMode(GL_MODELVIEW);
+  glLoadIdentity();
+
+  glColor3f(1.0,0.0,0.0);
+  glRasterPos2i(10,10);
+  printstring(GLUT_BITMAP_HELVETICA_18,frbuf);
+  glRasterPos2i(350,470);
+  printstring(GLUT_BITMAP_HELVETICA_10,"Rain V1.0 Written by David Bucciarelli (humanware@plus.it)");
+
+  if(help)
+    printhelp();
+
+  reshape(WIDTH,HEIGHT);
+  glPopMatrix();
+
+  glutSwapBuffers();
+
+  count++;
+}
+
+
+static void special(int key, int x, int y)
+{
+  switch (key) {
+  case GLUT_KEY_LEFT:
+    alpha+=2.0;
+    break;
+  case GLUT_KEY_RIGHT:
+    alpha-=2.0;
+    break;
+  case GLUT_KEY_DOWN:
+    beta-=2.0;
+    break;
+  case GLUT_KEY_UP:
+    beta+=2.0;
+    break;
+  }
+}
+
+static void key(unsigned char key, int x, int y)
+{
+  switch (key) {
+  case 27:
+    exit(0);
+    break;
+
+  case 'a':
+    v+=0.01;
+    break;
+  case 'z':
+    v-=0.01;
+    break;
+
+  case 'l':
+    rainParticle::setLength(rainParticle::getLength()+0.025f);
+    break;
+  case 'k':
+    rainParticle::setLength(rainParticle::getLength()-0.025f);
+    break;
+
+  case 'h':
+    help=(!help);
+    break;
+  case 'f':
+    fog=(!fog);
+    break;
+#ifdef XMESA
+  case ' ':
+    XMesaSetFXmode(fullscreen ? XMESA_FX_FULLSCREEN : XMESA_FX_WINDOW);
+    fullscreen=(!fullscreen);
+    break;
+#endif
+  }
+}
+
+static void inittextures(void)
+{
+  GLubyte *img;
+  GLint width,height;
+  GLenum format;
+  GLenum gluerr;
+
+  glGenTextures(1,&groundid);
+  glBindTexture(GL_TEXTURE_2D,groundid);
+
+  if(!(img=LoadRGBImage(DEMOS_DATA_DIR "s128.rgb",
+			&width,&height,&format))){
+  	fprintf(stderr,"Error reading a texture.\n");
+  	exit(-1);
+  }
+  glPixelStorei(GL_UNPACK_ALIGNMENT,4);
+  if((gluerr=(GLenum)gluBuild2DMipmaps(GL_TEXTURE_2D, 3, width, height,GL_RGB,
+			       GL_UNSIGNED_BYTE, (GLvoid *)(img)))) {
+    fprintf(stderr,"GLULib%s\n",gluErrorString(gluerr));
+    exit(-1);
+  }
+
+  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
+  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
+
+  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
+  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+
+  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);
+}
+
+static void initparticle(void)
+{
+  ps=new particleSystem;
+
+  rainParticle::setRainingArea(-7.0f,-0.2f,-7.0f,7.0f,8.0f,7.0f);
+
+  for(int i=0;i<NUMPART;i++) {
+    rainParticle *p=new rainParticle;
+    p->randomHeight();
+
+    ps->addParticle((particle *)p);
+  }
+}
+
+int main(int ac,char **av)
+{
+  fprintf(stderr,"Rain V1.0\nWritten by David Bucciarelli (humanware@plus.it)\n");
+
+  /* Default settings */
+
+  WIDTH=640;
+  HEIGHT=480;
+
+  glutInitWindowPosition(0,0);
+  glutInitWindowSize(WIDTH,HEIGHT);
+  glutInit(&ac,av);
+
+  glutInitDisplayMode(GLUT_RGB|GLUT_DEPTH|GLUT_DOUBLE);
+
+  if(!(win=glutCreateWindow("Rain"))) {
+    fprintf(stderr,"Error opening a window.\n");
+    exit(-1);
+  }
+  
+  reshape(WIDTH,HEIGHT);
+
+  inittextures();
+
+  glShadeModel(GL_FLAT);
+  glEnable(GL_DEPTH_TEST);
+
+  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
+
+  glEnable(GL_FOG);
+  glFogi(GL_FOG_MODE,GL_EXP);
+  glFogfv(GL_FOG_COLOR,fogcolor);
+  glFogf(GL_FOG_DENSITY,0.1);
+#ifdef FX
+  glHint(GL_FOG_HINT,GL_NICEST);
+#endif
+
+  initparticle();
+
+  glutKeyboardFunc(key);
+  glutSpecialFunc(special);
+  glutDisplayFunc(drawrain);
+  glutIdleFunc(drawrain);
+  glutReshapeFunc(reshape);
+  glutMainLoop();
+
+  return(0);
+}
diff -Naur mesa-demos-8.4.0-old/src/egl/opengles1/Makefile.am mesa-demos-8.4.0-new/src/egl/opengles1/Makefile.am
--- mesa-demos-8.4.0-old/src/egl/opengles1/Makefile.am	2018-02-23 00:50:21.000000000 -0800
+++ mesa-demos-8.4.0-new/src/egl/opengles1/Makefile.am	2020-04-11 09:53:24.950047896 -0700
@@ -42,7 +42,6 @@
 	bindtex \
 	clear \
 	drawtex_x11 \
-	eglfbdev \
 	es1_info \
 	gears_x11 \
 	msaa \
diff -Naur mesa-demos-8.4.0-old/src/egl/openvg/trivial/vguarc.c mesa-demos-8.4.0-new/src/egl/openvg/trivial/vguarc.c
--- mesa-demos-8.4.0-old/src/egl/openvg/trivial/vguarc.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/egl/openvg/trivial/vguarc.c	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,74 @@
+#include "eglcommon.h"
+
+#include <VG/openvg.h>
+#include <VG/vgu.h>
+
+const VGfloat white_color[4] = {1.0, 1.0, 1.0, 1.0};
+const VGfloat color[4] = {0.4, 0.1, 1.0, 1.0};
+
+VGPath path;
+VGPaint paint;
+
+
+static void
+init(void)
+{
+    VGfloat clearColor[] = {0.0f, 0.0f, 0.0f, 1.0f};/* black color */
+    VGfloat greenColor[] = {0.0f, 1.0f, 0.0f, 1.0f};/* green color */
+    VGint arcType = VGU_ARC_OPEN;
+    VGfloat x, y, w, h, startAngle, angleExtent;
+
+    x = 150;
+    y = 150;
+    w = 150;
+    h = 150;
+#if 0
+    startAngle  = -540.0f;
+    angleExtent = 270.0f;
+#else
+    startAngle  = 270.0f;
+    angleExtent = 90.0f;
+#endif
+
+    paint = vgCreatePaint();
+
+    vgSetPaint(paint, VG_STROKE_PATH);
+    vgSetParameterfv(paint, VG_PAINT_COLOR, 4, greenColor);
+    vgSetParameteri( paint, VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
+    vgSetf(VG_STROKE_LINE_WIDTH, 6.0f);
+    vgSeti(VG_RENDERING_QUALITY, VG_RENDERING_QUALITY_NONANTIALIASED);
+    vgSetfv(VG_CLEAR_COLOR, 4, clearColor);
+
+    path  = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F,
+                         1.0f, 0.0f, 0, 0, VG_PATH_CAPABILITY_ALL);
+
+    vguArc(path, x, y, w, h, startAngle, angleExtent, arcType);
+
+    vgSeti(VG_STROKE_CAP_STYLE, VG_CAP_BUTT);
+    vgSeti(VG_STROKE_JOIN_STYLE, VG_JOIN_BEVEL);
+    vgSetf(VG_STROKE_MITER_LIMIT, 4.0f);
+}
+
+/* new window size or exposure */
+static void
+reshape(int w, int h)
+{
+   vgLoadIdentity();
+}
+
+static void
+draw(void)
+{
+   vgClear(0, 0, window_width(), window_height());
+   vgDrawPath(path, VG_STROKE_PATH);
+
+   vgFlush();
+}
+
+
+int main(int argc, char **argv)
+{
+    // set_window_size(64, 63);
+   return run(argc, argv, init, reshape,
+              draw, 0);
+}
diff -Naur mesa-demos-8.4.0-old/src/fp/mov-imm.txt mesa-demos-8.4.0-new/src/fp/mov-imm.txt
--- mesa-demos-8.4.0-old/src/fp/mov-imm.txt	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/fp/mov-imm.txt	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,3 @@
+!!ARBfp1.0
+MOV result.color, {0.5, 0.8, 0.3, 1.0};
+END
diff -Naur mesa-demos-8.4.0-old/src/fp/mov-param.txt mesa-demos-8.4.0-new/src/fp/mov-param.txt
--- mesa-demos-8.4.0-old/src/fp/mov-param.txt	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/fp/mov-param.txt	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,4 @@
+!!ARBfp1.0
+PARAM Diffuse = state.material.diffuse; 
+MOV result.color, Diffuse;
+END
diff -Naur mesa-demos-8.4.0-old/src/fp/position-frc-integer.txt mesa-demos-8.4.0-new/src/fp/position-frc-integer.txt
--- mesa-demos-8.4.0-old/src/fp/position-frc-integer.txt	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/fp/position-frc-integer.txt	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,7 @@
+!!ARBfp1.0
+# expected: black triangle
+# brown means the wrong pixel center convention is being used
+OPTION ARB_fragment_coord_pixel_center_integer;
+MOV result.color, {0}.x;
+FRC result.color.xy, fragment.position;
+END
diff -Naur mesa-demos-8.4.0-old/src/fp/position-frc.txt mesa-demos-8.4.0-new/src/fp/position-frc.txt
--- mesa-demos-8.4.0-old/src/fp/position-frc.txt	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/fp/position-frc.txt	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,6 @@
+!!ARBfp1.0
+# expected: brown triangle
+# black means the wrong pixel center convention is being used
+MOV result.color, {0}.x;
+FRC result.color.xy, fragment.position;
+END
diff -Naur mesa-demos-8.4.0-old/src/fp/position-upper-left.txt mesa-demos-8.4.0-new/src/fp/position-upper-left.txt
--- mesa-demos-8.4.0-old/src/fp/position-upper-left.txt	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/fp/position-upper-left.txt	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,7 @@
+!!ARBfp1.0
+# expected: the yellow vertex is the bottom one
+# if it is the top one, the wrong origin convention is being used
+OPTION ARB_fragment_coord_origin_upper_left;
+MOV result.color, {0}.x;
+MUL result.color.xy, fragment.position, {.005}.x;
+END
diff -Naur mesa-demos-8.4.0-old/src/fp/run.sh mesa-demos-8.4.0-new/src/fp/run.sh
--- mesa-demos-8.4.0-old/src/fp/run.sh	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/fp/run.sh	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+for i in *.txt ; do
+echo $i
+./fp-tri $i
+done
+
diff -Naur mesa-demos-8.4.0-old/src/fpglsl/depth-read.glsl mesa-demos-8.4.0-new/src/fpglsl/depth-read.glsl
--- mesa-demos-8.4.0-old/src/fpglsl/depth-read.glsl	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/fpglsl/depth-read.glsl	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,4 @@
+void main()
+{
+   gl_FragColor = gl_FragCoord.zzzz;
+}
diff -Naur mesa-demos-8.4.0-old/src/fpglsl/infinite-loop.glsl mesa-demos-8.4.0-new/src/fpglsl/infinite-loop.glsl
--- mesa-demos-8.4.0-old/src/fpglsl/infinite-loop.glsl	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/fpglsl/infinite-loop.glsl	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,7 @@
+void main() {
+   vec4 sum = vec4(0);
+   for (int i = 1; i != 2; i += 2) {
+      sum += vec4(0.1, 0.1, 0.1, 0.1);
+   }
+   gl_FragColor = sum;
+}
diff -Naur mesa-demos-8.4.0-old/src/glsl/blinking-teapot.frag mesa-demos-8.4.0-new/src/glsl/blinking-teapot.frag
--- mesa-demos-8.4.0-old/src/glsl/blinking-teapot.frag	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/glsl/blinking-teapot.frag	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,31 @@
+#extension GL_ARB_uniform_buffer_object : enable
+
+layout(std140) uniform colors0
+{
+    float DiffuseCool;
+    float DiffuseWarm;
+    vec3  SurfaceColor;
+    vec3  WarmColor;
+    vec3  CoolColor;
+    vec4  some[8];
+};
+
+varying float NdotL;
+varying vec3  ReflectVec;
+varying vec3  ViewVec;
+
+void main (void)
+{
+
+    vec3 kcool    = min(CoolColor + DiffuseCool * SurfaceColor, 1.0);
+    vec3 kwarm    = min(WarmColor + DiffuseWarm * SurfaceColor, 1.0);
+    vec3 kfinal   = mix(kcool, kwarm, NdotL);
+
+    vec3 nreflect = normalize(ReflectVec);
+    vec3 nview    = normalize(ViewVec);
+
+    float spec    = max(dot(nreflect, nview), 0.0);
+    spec          = pow(spec, 32.0);
+
+    gl_FragColor = vec4 (min(kfinal + spec, 1.0), 1.0);
+}
diff -Naur mesa-demos-8.4.0-old/src/glsl/blinking-teapot.vert mesa-demos-8.4.0-new/src/glsl/blinking-teapot.vert
--- mesa-demos-8.4.0-old/src/glsl/blinking-teapot.vert	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/glsl/blinking-teapot.vert	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,16 @@
+vec3 LightPosition = vec3(0.0, 10.0, 4.0); 
+ 
+varying float NdotL;
+varying vec3  ReflectVec;
+varying vec3  ViewVec;
+ 
+void main(void)
+{
+    vec3 ecPos      = vec3 (gl_ModelViewMatrix * gl_Vertex);
+    vec3 tnorm      = normalize(gl_NormalMatrix * gl_Normal);
+    vec3 lightVec   = normalize(LightPosition - ecPos);
+    ReflectVec      = normalize(reflect(-lightVec, tnorm));
+    ViewVec         = normalize(-ecPos);
+    NdotL           = (dot(lightVec, tnorm) + 1.0) * 0.5;
+    gl_Position     = ftransform();
+}
diff -Naur mesa-demos-8.4.0-old/src/glsl/CH11-bumpmaptex.frag mesa-demos-8.4.0-new/src/glsl/CH11-bumpmaptex.frag
--- mesa-demos-8.4.0-old/src/glsl/CH11-bumpmaptex.frag	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/glsl/CH11-bumpmaptex.frag	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,47 @@
+//
+// Fragment shader for procedural bumps
+//
+// Authors: John Kessenich, Randi Rost
+//
+// Copyright (c) 2002-2006 3Dlabs Inc. Ltd. 
+//
+// See 3Dlabs-License.txt for license information
+//
+// Texture mapping/modulation added by Brian Paul
+//
+
+varying vec3 LightDir;
+varying vec3 EyeDir;
+
+uniform float BumpDensity;     // = 16.0
+uniform float BumpSize;        // = 0.15
+uniform float SpecularFactor;  // = 0.5
+
+uniform sampler2D Tex;
+
+void main()
+{
+    vec3 ambient = vec3(0.25);
+    vec3 litColor;
+    vec2 c = BumpDensity * gl_TexCoord[0].st;
+    vec2 p = fract(c) - vec2(0.5);
+
+    float d, f;
+    d = p.x * p.x + p.y * p.y;
+    f = inversesqrt(d + 1.0);
+
+    if (d >= BumpSize)
+        { p = vec2(0.0); f = 1.0; }
+
+    vec3 SurfaceColor = texture2D(Tex, gl_TexCoord[0].st).xyz;
+
+    vec3 normDelta = vec3(p.x, p.y, 1.0) * f;
+    litColor = SurfaceColor * (ambient + max(dot(normDelta, LightDir), 0.0));
+    vec3 reflectDir = reflect(LightDir, normDelta);
+    
+    float spec = max(dot(EyeDir, reflectDir), 0.0);
+    spec *= SpecularFactor;
+    litColor = min(litColor + spec, vec3(1.0));
+
+    gl_FragColor = vec4(litColor, 1.0);
+}
diff -Naur mesa-demos-8.4.0-old/src/glsl/convolution.frag mesa-demos-8.4.0-new/src/glsl/convolution.frag
--- mesa-demos-8.4.0-old/src/glsl/convolution.frag	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/glsl/convolution.frag	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,21 @@
+
+const int KernelSize = 9;
+
+//texture offsets
+uniform vec2 Offset[KernelSize];
+//convolution kernel
+uniform vec4 KernelValue[KernelSize];
+uniform sampler2D srcTex;
+uniform vec4 ScaleFactor;
+uniform vec4 BaseColor;
+
+void main(void)
+{
+    int i;
+    vec4 sum = vec4(0.0);
+    for (i = 0; i < KernelSize; ++i) {
+        vec4 tmp = texture2D(srcTex, gl_TexCoord[0].st + Offset[i]);
+        sum += tmp * KernelValue[i];
+    }
+    gl_FragColor = sum * ScaleFactor + BaseColor;
+}
diff -Naur mesa-demos-8.4.0-old/src/glsl/simplex-noise.glsl mesa-demos-8.4.0-new/src/glsl/simplex-noise.glsl
--- mesa-demos-8.4.0-old/src/glsl/simplex-noise.glsl	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/glsl/simplex-noise.glsl	2020-04-11 09:49:44.111059934 -0700
@@ -0,0 +1,279 @@
+//
+// Description : Array and textureless GLSL 2D/3D/4D simplex
+// noise functions.
+// Author : Ian McEwan, Ashima Arts.
+// Maintainer : ijm
+// Lastmod : 20110223
+// License : Copyright (C) 2011 Ashima Arts. All rights reserved.
+// Distributed under the Artistic License 2.0; See LICENCE file.
+//
+
+#define NORMALIZE_GRADIENTS
+#undef USE_CIRCLE
+#define COLLAPSE_SORTNET
+
+float permute(float x0,vec3 p) {
+  float x1 = mod(x0 * p.y, p.x);
+  return floor( mod( (x1 + p.z) *x0, p.x ));
+  }
+vec2 permute(vec2 x0,vec3 p) {
+  vec2 x1 = mod(x0 * p.y, p.x);
+  return floor( mod( (x1 + p.z) *x0, p.x ));
+  }
+vec3 permute(vec3 x0,vec3 p) {
+  vec3 x1 = mod(x0 * p.y, p.x);
+  return floor( mod( (x1 + p.z) *x0, p.x ));
+  }
+vec4 permute(vec4 x0,vec3 p) {
+  vec4 x1 = mod(x0 * p.y, p.x);
+  return floor( mod( (x1 + p.z) *x0, p.x ));
+  }
+
+uniform vec4 pParam;
+// Example
+// const vec4 pParam = vec4( 17.* 17., 34., 1., 7.);
+
+float taylorInvSqrt(float r)
+  {
+  return ( 0.83666002653408 + 0.7*0.85373472095314 - 0.85373472095314 * r );
+  }
+
+float simplexNoise2(vec2 v)
+  {
+  const vec2 C = vec2(0.211324865405187134, // (3.0-sqrt(3.0))/6.;
+                      0.366025403784438597); // 0.5*(sqrt(3.0)-1.);
+  const vec3 D = vec3( 0., 0.5, 2.0) * 3.14159265358979312;
+// First corner
+  vec2 i = floor(v + dot(v, C.yy) );
+  vec2 x0 = v - i + dot(i, C.xx);
+
+// Other corners
+  vec2 i1 = (x0.x > x0.y) ? vec2(1.,0.) : vec2(0.,1.) ;
+
+   // x0 = x0 - 0. + 0. * C
+  vec2 x1 = x0 - i1 + 1. * C.xx ;
+  vec2 x2 = x0 - 1. + 2. * C.xx ;
+
+// Permutations
+  i = mod(i, pParam.x);
+  vec3 p = permute( permute(
+             i.y + vec3(0., i1.y, 1. ), pParam.xyz)
+           + i.x + vec3(0., i1.x, 1. ), pParam.xyz);
+
+#ifndef USE_CIRCLE
+// ( N points uniformly over a line, mapped onto a diamond.)
+  vec3 x = fract(p / pParam.w) ;
+  vec3 h = 0.5 - abs(x) ;
+
+  vec3 sx = vec3(lessThan(x,D.xxx)) *2. -1.;
+  vec3 sh = vec3(lessThan(h,D.xxx));
+
+  vec3 a0 = x + sx*sh;
+  vec2 p0 = vec2(a0.x,h.x);
+  vec2 p1 = vec2(a0.y,h.y);
+  vec2 p2 = vec2(a0.z,h.z);
+
+#ifdef NORMALISE_GRADIENTS
+  p0 *= taylorInvSqrt(dot(p0,p0));
+  p1 *= taylorInvSqrt(dot(p1,p1));
+  p2 *= taylorInvSqrt(dot(p2,p2));
+#endif
+
+  vec3 g = 2.0 * vec3( dot(p0, x0), dot(p1, x1), dot(p2, x2) );
+#else
+// N points around a unit circle.
+  vec3 phi = D.z * mod(p,pParam.w) /pParam.w ;
+  vec4 a0 = sin(phi.xxyy+D.xyxy);
+  vec2 a1 = sin(phi.zz +D.xy);
+  vec3 g = vec3( dot(a0.xy, x0), dot(a0.zw, x1), dot(a1.xy, x2) );
+#endif
+// mix
+  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.);
+  m = m*m ;
+  return 1.66666* 70.*dot(m*m, g);
+  }
+
+float simplexNoise3(vec3 v)
+  {
+  const vec2 C = vec2(1./6. , 1./3. ) ;
+  const vec4 D = vec4(0., 0.5, 1.0, 2.0);
+
+// First corner
+  vec3 i = floor(v + dot(v, C.yyy) );
+  vec3 x0 = v - i + dot(i, C.xxx) ;
+  
+// Other corners
+#ifdef COLLAPSE_SORTNET
+  vec3 g = vec3( greaterThan( x0.xyz, x0.yzx) );
+  vec3 l = vec3( lessThanEqual( x0.xyz, x0.yzx) );
+
+  vec3 i1 = g.xyz * l.zxy;
+  vec3 i2 = max( g.xyz, l.zxy);
+#else
+// Keeping this clean - let the compiler optimize.
+  vec3 q1;
+  q1.x = max(x0.x, x0.y);
+  q1.y = min(x0.x, x0.y);
+  q1.z = x0.z;
+
+  vec3 q2;
+  q2.x = max(q1.x,q1.z);
+  q2.z = min(q1.x,q1.z);
+  q2.y = q1.y;
+
+  vec3 q3;
+  q3.y = max(q2.y, q2.z);
+  q3.z = min(q2.y, q2.z);
+  q3.x = q2.x;
+
+  vec3 i1 = vec3(equal(q3.xxx, x0));
+  vec3 i2 = i1 + vec3(equal(q3.yyy, x0));
+#endif
+
+   // x0 = x0 - 0. + 0. * C
+  vec3 x1 = x0 - i1 + 1. * C.xxx;
+  vec3 x2 = x0 - i2 + 2. * C.xxx;
+  vec3 x3 = x0 - 1. + 3. * C.xxx;
+
+// Permutations
+  i = mod(i, pParam.x );
+  vec4 p = permute( permute( permute(
+             i.z + vec4(0., i1.z, i2.z, 1. ), pParam.xyz)
+           + i.y + vec4(0., i1.y, i2.y, 1. ), pParam.xyz)
+           + i.x + vec4(0., i1.x, i2.x, 1. ), pParam.xyz);
+
+// Gradients
+// ( N*N points uniformly over a square, mapped onto a octohedron.)
+  float n_ = 1.0/pParam.w ;
+  vec3 ns = n_ * D.wyz - D.xzx ;
+
+  vec4 j = p - pParam.w*pParam.w*floor(p * ns.z *ns.z); // mod(p,N*N)
+
+  vec4 x_ = floor(j * ns.z) ;
+  vec4 y_ = floor(j - pParam.w * x_ ) ; // mod(j,N)
+
+  vec4 x = x_ *ns.x + ns.yyyy;
+  vec4 y = y_ *ns.x + ns.yyyy;
+  vec4 h = 1. - abs(x) - abs(y);
+
+  vec4 b0 = vec4( x.xy, y.xy );
+  vec4 b1 = vec4( x.zw, y.zw );
+
+  vec4 s0 = vec4(lessThan(b0,D.xxxx)) *2. -1.;
+  vec4 s1 = vec4(lessThan(b1,D.xxxx)) *2. -1.;
+  vec4 sh = vec4(lessThan(h, D.xxxx));
+
+  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
+  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
+
+  vec3 p0 = vec3(a0.xy,h.x);
+  vec3 p1 = vec3(a0.zw,h.y);
+  vec3 p2 = vec3(a1.xy,h.z);
+  vec3 p3 = vec3(a1.zw,h.w);
+
+#ifdef NORMALISE_GRADIENTS
+  p0 *= taylorInvSqrt(dot(p0,p0));
+  p1 *= taylorInvSqrt(dot(p1,p1));
+  p2 *= taylorInvSqrt(dot(p2,p2));
+  p3 *= taylorInvSqrt(dot(p3,p3));
+#endif
+
+// Mix
+  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);
+  m = m * m;
+//used to be 64.
+  return 48.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
+                                dot(p2,x2), dot(p3,x3) ) );
+  }
+
+vec4 grad4(float j, vec4 ip)
+  {
+  const vec4 ones = vec4(1.,1.,1.,-1.);
+  vec4 p,s;
+
+  p.xyz = floor( fract (vec3(j) * ip.xyz) *pParam.w) * ip.z -1.0;
+  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
+  s = vec4(lessThan(p,vec4(0.)));
+  p.xyz = p.xyz + (s.xyz*2.-1.) * s.www;
+
+  return p;
+  }
+
+float simplexNoise4(vec4 v)
+  {
+  const vec2 C = vec2( 0.138196601125010504, // (5 - sqrt(5))/20 G4
+                        0.309016994374947451); // (sqrt(5) - 1)/4 F4
+// First corner
+  vec4 i = floor(v + dot(v, C.yyyy) );
+  vec4 x0 = v - i + dot(i, C.xxxx);
+
+// Other corners
+
+// Force existance of strict total ordering in sort.
+  vec4 q0 = floor(x0 * 1024.0) + vec4( 0., 1./4., 2./4. , 3./4.);
+  vec4 q1;
+  q1.xy = max(q0.xy,q0.zw); // x:z y:w
+  q1.zw = min(q0.xy,q0.zw);
+
+  vec4 q2;
+  q2.xz = max(q1.xz,q1.yw); // x:y z:w
+  q2.yw = min(q1.xz,q1.yw);
+  
+  vec4 q3;
+  q3.y = max(q2.y,q2.z); // y:z
+  q3.z = min(q2.y,q2.z);
+  q3.xw = q2.xw;
+
+  vec4 i1 = vec4(lessThanEqual(q3.xxxx, q0));
+  vec4 i2 = vec4(lessThanEqual(q3.yyyy, q0));
+  vec4 i3 = vec4(lessThanEqual(q3.zzzz, q0));
+
+   // x0 = x0 - 0. + 0. * C
+  vec4 x1 = x0 - i1 + 1. * C.xxxx;
+  vec4 x2 = x0 - i2 + 2. * C.xxxx;
+  vec4 x3 = x0 - i3 + 3. * C.xxxx;
+  vec4 x4 = x0 - 1. + 4. * C.xxxx;
+
+// Permutations
+  i = mod(i, pParam.x );
+  float j0 = permute( permute( permute( permute (
+              i.w, pParam.xyz) + i.z, pParam.xyz)
+            + i.y, pParam.xyz) + i.x, pParam.xyz);
+  vec4 j1 = permute( permute( permute( permute (
+             i.w + vec4(i1.w, i2.w, i3.w, 1. ), pParam.xyz)
+           + i.z + vec4(i1.z, i2.z, i3.z, 1. ), pParam.xyz)
+           + i.y + vec4(i1.y, i2.y, i3.y, 1. ), pParam.xyz)
+           + i.x + vec4(i1.x, i2.x, i3.x, 1. ), pParam.xyz);
+// Gradients
+// ( N*N*N points uniformly over a cube, mapped onto a 4-octohedron.)
+  vec4 ip = pParam ;
+  ip.xy *= pParam.w ;
+  ip.x *= pParam.w ;
+  ip = vec4(1.,1.,1.,2.) / ip ;
+
+  vec4 p0 = grad4(j0, ip);
+  vec4 p1 = grad4(j1.x, ip);
+  vec4 p2 = grad4(j1.y, ip);
+  vec4 p3 = grad4(j1.z, ip);
+  vec4 p4 = grad4(j1.w, ip);
+
+#ifdef NORMALISE_GRADIENTS
+  p0 *= taylorInvSqrt(dot(p0,p0));
+  p1 *= taylorInvSqrt(dot(p1,p1));
+  p2 *= taylorInvSqrt(dot(p2,p2));
+  p3 *= taylorInvSqrt(dot(p3,p3));
+  p4 *= taylorInvSqrt(dot(p4,p4));
+#endif
+
+// Mix
+  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.);
+  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4) ), 0.);
+  m0 = m0 * m0;
+  m1 = m1 * m1;
+  return 32. * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
+               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
+
+  }
+
+
+
diff -Naur mesa-demos-8.4.0-old/src/glsl/skinning.vert mesa-demos-8.4.0-new/src/glsl/skinning.vert
--- mesa-demos-8.4.0-old/src/glsl/skinning.vert	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/glsl/skinning.vert	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,24 @@
+// Vertex weighting/blendin shader
+// Brian Paul
+// 4 Nov 2008
+
+uniform mat4 mat0, mat1;
+attribute float weight;
+
+void main() 
+{
+   // simple diffuse shading
+   // Note that we should really transform the normal vector along with
+   // the postion below... someday.
+   vec3 lightVec = vec3(0, 0, 1);
+   vec3 norm = gl_NormalMatrix * gl_Normal;
+   float dot = 0.2 + max(0.0, dot(norm, lightVec));
+   gl_FrontColor = vec4(dot);
+
+   // compute sum of weighted transformations
+   vec4 pos0 = mat0 * gl_Vertex;
+   vec4 pos1 = mat1 * gl_Vertex;
+   vec4 pos = mix(pos0, pos1, weight);
+
+   gl_Position = gl_ModelViewProjectionMatrix * pos;
+}
diff -Naur mesa-demos-8.4.0-old/src/objviewer/bobcat.mtl mesa-demos-8.4.0-new/src/objviewer/bobcat.mtl
--- mesa-demos-8.4.0-old/src/objviewer/bobcat.mtl	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/objviewer/bobcat.mtl	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,72 @@
+# Exported from Wings 3D 0.99.00b
+newmtl black
+Ns 48.6667
+d 1.00000
+illum 2
+Kd 1.00000e-3 1.00000e-3 1.00000e-3
+Ka 1.00000 1.00000 1.00000
+Ks 1.00000 1.00000 1.00000
+Ka 0.00000 0.00000 0.00000
+Ks 0.00000 0.00000 0.00000
+Ke 0.00000e+0 0.00000e+0 0.00000e+0
+
+newmtl blanco
+Ns 100.000
+d 1.00000
+illum 2
+Kd 1.00000 1.00000 1.00000
+Ka 0.620380 0.620380 0.620380
+Ks 0.806860 0.806860 0.806860
+Ke 1.00000e-3 1.00000e-3 1.00000e-3
+
+newmtl blue
+Ns 100.000
+d 1.00000
+illum 2
+Kd 0.105111 0.125293 0.366667
+Ka 1.00000 1.00000 1.00000
+Ks 1.00000 1.00000 1.00000
+Ka 0.00000 0.00000 0.00000
+Ks 0.00000 0.00000 0.00000
+Ke 0.00000e+0 0.00000e+0 0.00000e+0
+
+newmtl default
+Ns 100.000
+d 1.00000
+illum 2
+Kd 1.00000 1.00000 1.00000
+Ka 1.00000 1.00000 1.00000
+Ks 1.00000 1.00000 1.00000
+Ka 0.10000 0.10000 0.10000
+Ks 0.50000 0.50000 0.500000
+Ke 0.00000e+0 0.00000e+0 0.00000e+0
+
+newmtl gre
+Ns 100.000
+d 1.00000
+illum 2
+Kd 0.200800 0.200800 0.200800
+Ka 1.00000 1.00000 1.00000
+Ks 1.00000 1.00000 1.00000
+Ka 0.00000 0.00000 0.00000
+Ks 0.00000 0.00000 0.00000
+Ke 0.00000e+0 0.00000e+0 0.00000e+0
+
+newmtl red
+Ns 100.000
+d 1.00000
+illum 2
+Kd 0.460000 0.00000e+0 0.00000e+0
+Ka 0.00000 0.00000 0.00000
+Ks 0.00000 0.00000 0.00000
+Ke 0.00000e+0 0.00000e+0 0.00000e+0
+
+newmtl rojo
+Ns 100.000
+d 1.00000
+illum 2
+Kd 0.700000 0.00000e+0 0.00000e+0
+Ka 0.00000 0.00000 0.00000
+Ks 0.00000 0.00000 0.00000
+Ke 1.00000e-3 1.00000e-3 1.00000e-3
+
diff -Naur mesa-demos-8.4.0-old/src/objviewer/GreatLakesBiplaneHP.mtl mesa-demos-8.4.0-new/src/objviewer/GreatLakesBiplaneHP.mtl
--- mesa-demos-8.4.0-old/src/objviewer/GreatLakesBiplaneHP.mtl	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/objviewer/GreatLakesBiplaneHP.mtl	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,161 @@
+# Exported from Wings 3D 0.99.03
+
+# Top flaps
+newmtl BottomWing
+Ns 100.0
+d 1.0
+illum 2
+Kd 1.0 0.0 0.0
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+map_Kd TopBotMap.rgb
+
+newmtl CompBall_auv
+Ns 100.0
+d 1.0
+illum 2
+Kd 1.0 1.0 1.0
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+map_Kd CompBall_auv.rgb
+
+newmtl EngMat1
+Ns 100.0
+d 1.0
+illum 2
+Kd 0.334 0.334 0.334
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+
+newmtl EngMat2
+Ns 100.0
+d 1.0
+illum 2
+Kd 0.78688 0.78688 0.78688
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+
+newmtl Fuselage_auv
+Ns 100.0
+d 1.0
+illum 2
+Kd 1.0 1.0 1.0
+Ka 0.0 0.0 0.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+map_Kd SidesMap.rgb
+
+newmtl Glass
+Ns 100.0
+d 0.5
+illum 2
+#Kd 0.5533333333333333 1.0 1.0
+Kd 1.0 1.0 1.0
+#Ka 0.37333333333333335 0.68 1.0
+Ka 0.0 0.0 0.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+
+newmtl Grip
+Ns 100.0
+d 1.0
+illum 2
+Kd 0.47386 0.47386 0.47386
+Ka 0.6203799999999999 0.6203799999999999 0.6203799999999999
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+
+newmtl Interior
+Ns 100.0
+d 1.0
+illum 2
+Kd 0.70696 0.70696 0.70696
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+
+newmtl Prop
+Ns 100.0
+d 1.0
+illum 2
+Kd 1.0 1.0 0.6266666666666667
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+map_Kd PropMap.rgb
+
+# Rudder
+newmtl Sides
+Ns 100.0
+d 1.0
+illum 2
+Kd 1.0 0.0 0.0
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+map_Kd SidesMap.rgb
+
+newmtl TailHoriz
+Ns 100.0
+d 1.0
+illum 2
+Kd 1.0 0.0 0.0
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+map_Kd TopBotMap.rgb
+
+# Top wing, bot wing, fuselage
+newmtl TopWing
+Ns 100.0
+d 1.0
+illum 2
+Kd 1.0 1.0 1.0
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+map_Kd TopBotMap.rgb
+
+newmtl Wheels
+Ns 100.0
+d 1.0
+illum 2
+Kd 0.0 0.0 0.0
+Ka 0.0 0.0 0.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+map_Kd WheelsMap.rgb
+
+newmtl cylinder58_auv
+Ns 100.0
+d 1.0
+illum 2
+Kd 1.0 1.0 1.0
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+map_Kd cylinder58_auv.rgb
+
+newmtl default
+Ns 100.0
+d 1.0
+illum 2
+Kd 0.0 1.0 1.0
+Ka 0.0 1.0 1.0
+Ks 0.0 1.0 1.0
+Ke 0.0 0.0 0.0
+
+newmtl gage_auv
+Ns 100.0
+d 1.0
+illum 2
+Kd 1.0 1.0 1.0
+Ka 1.0 1.0 1.0
+Ks 1.0 1.0 1.0
+Ke 0.0 0.0 0.0
+map_Kd gage_auv.rgb
+
diff -Naur mesa-demos-8.4.0-old/src/osdemos/ostest1.c mesa-demos-8.4.0-new/src/osdemos/ostest1.c
--- mesa-demos-8.4.0-old/src/osdemos/ostest1.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/osdemos/ostest1.c	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,481 @@
+/*
+ * Test OSMesa interface at 8, 16 and 32 bits/channel.
+ *
+ * Usage: osdemo [options]
+ *
+ * Options:
+ *   -f   generate image files
+ *   -g   render gradient and print color values
+ */
+
+#include <assert.h>
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "GL/osmesa.h"
+
+
+#define WIDTH 600
+#define HEIGHT 600
+
+static GLboolean WriteFiles = GL_FALSE;
+static GLboolean Gradient = GL_FALSE;
+
+
+static void
+Sphere(float radius, int slices, int stacks)
+{
+   GLUquadric *q = gluNewQuadric();
+   gluQuadricNormals(q, GLU_SMOOTH);
+   gluSphere(q, radius, slices, stacks);
+   gluDeleteQuadric(q);
+}
+
+
+static void
+Cone(float base, float height, int slices, int stacks)
+{
+   GLUquadric *q = gluNewQuadric();
+   gluQuadricDrawStyle(q, GLU_FILL);
+   gluQuadricNormals(q, GLU_SMOOTH);
+   gluCylinder(q, base, 0.0, height, slices, stacks);
+   gluDeleteQuadric(q);
+}
+
+
+static void
+Torus(float innerRadius, float outerRadius, int sides, int rings)
+{
+   /* from GLUT... */
+   int i, j;
+   GLfloat theta, phi, theta1;
+   GLfloat cosTheta, sinTheta;
+   GLfloat cosTheta1, sinTheta1;
+   const GLfloat ringDelta = 2.0 * M_PI / rings;
+   const GLfloat sideDelta = 2.0 * M_PI / sides;
+
+   theta = 0.0;
+   cosTheta = 1.0;
+   sinTheta = 0.0;
+   for (i = rings - 1; i >= 0; i--) {
+      theta1 = theta + ringDelta;
+      cosTheta1 = cos(theta1);
+      sinTheta1 = sin(theta1);
+      glBegin(GL_QUAD_STRIP);
+      phi = 0.0;
+      for (j = sides; j >= 0; j--) {
+         GLfloat cosPhi, sinPhi, dist;
+
+         phi += sideDelta;
+         cosPhi = cos(phi);
+         sinPhi = sin(phi);
+         dist = outerRadius + innerRadius * cosPhi;
+
+         glNormal3f(cosTheta1 * cosPhi, -sinTheta1 * cosPhi, sinPhi);
+         glVertex3f(cosTheta1 * dist, -sinTheta1 * dist, innerRadius * sinPhi);
+         glNormal3f(cosTheta * cosPhi, -sinTheta * cosPhi, sinPhi);
+         glVertex3f(cosTheta * dist, -sinTheta * dist,  innerRadius * sinPhi);
+      }
+      glEnd();
+      theta = theta1;
+      cosTheta = cosTheta1;
+      sinTheta = sinTheta1;
+   }
+}
+
+
+static void Cube(float size)
+{
+   size = 0.5 * size;
+
+   glBegin(GL_QUADS);
+   /* +X face */
+   glNormal3f(1, 0, 0);
+   glVertex3f(size, -size,  size);
+   glVertex3f(size, -size, -size);
+   glVertex3f(size,  size, -size);
+   glVertex3f(size,  size,  size);
+
+   /* -X face */
+   glNormal3f(-1, 0, 0);
+   glVertex3f(-size,  size,  size);
+   glVertex3f(-size,  size, -size);
+   glVertex3f(-size, -size, -size);
+   glVertex3f(-size, -size,  size);
+
+   /* +Y face */
+   glNormal3f(0, 1, 0);
+   glVertex3f(-size, size,  size);
+   glVertex3f( size, size,  size);
+   glVertex3f( size, size, -size);
+   glVertex3f(-size, size, -size);
+
+   /* -Y face */
+   glNormal3f(0, -1, 0);
+   glVertex3f(-size, -size, -size);
+   glVertex3f( size, -size, -size);
+   glVertex3f( size, -size,  size);
+   glVertex3f(-size, -size,  size);
+
+   /* +Z face */
+   glNormal3f(0, 0, 1);
+   glVertex3f(-size, -size, size);
+   glVertex3f( size, -size, size);
+   glVertex3f( size,  size, size);
+   glVertex3f(-size,  size, size);
+
+   /* -Z face */
+   glNormal3f(0, 0, -1);
+   glVertex3f(-size,  size, -size);
+   glVertex3f( size,  size, -size);
+   glVertex3f( size, -size, -size);
+   glVertex3f(-size, -size, -size);
+
+   glEnd();
+}
+
+
+
+/**
+ * Draw red/green gradient across bottom of image.
+ * Read pixels to check deltas.
+ */
+static void
+render_gradient(void)
+{
+   GLfloat row[WIDTH][4];
+   int i;
+
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+   glOrtho(-1, 1, -1, 1, -1, 1);
+   glMatrixMode(GL_MODELVIEW);
+   glLoadIdentity();
+
+   glBegin(GL_POLYGON);
+   glColor3f(1, 0, 0);
+   glVertex2f(-1, -1.0);
+   glVertex2f(-1, -0.9);
+   glColor3f(0, 1, 0);
+   glVertex2f(1, -0.9);
+   glVertex2f(1, -1.0);
+   glEnd();
+   glFinish();
+
+   glReadPixels(0, 0, WIDTH, 1, GL_RGBA, GL_FLOAT, row);
+   for (i = 0; i < 4; i++) {
+      printf("row[i] = %f, %f, %f\n", row[i][0], row[i][1], row[i][2]);
+   }
+}
+
+
+static void
+render_image(void)
+{
+   static const GLfloat light_ambient[4] = { 0.0, 0.0, 0.0, 1.0 };
+   static const GLfloat light_diffuse[4] = { 1.0, 1.0, 1.0, 1.0 };
+   static const GLfloat light_specular[4] = { 1.0, 1.0, 1.0, 1.0 };
+   static const GLfloat light_position[4] = { 1.0, 1.0, 1.0, 0.0 };
+   static const GLfloat red_mat[4]   = { 1.0, 0.2, 0.2, 1.0 };
+   static const GLfloat green_mat[4] = { 0.2, 1.0, 0.2, 1.0 };
+   static const GLfloat blue_mat[4]  = { 0.2, 0.2, 1.0, 1.0 };
+#if 0
+   static const GLfloat yellow_mat[4]  = { 0.8, 0.8, 0.0, 1.0 };
+#endif
+   static const GLfloat purple_mat[4]  = { 0.8, 0.4, 0.8, 0.6 };
+
+   glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
+   glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
+   glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
+   glLightfv(GL_LIGHT0, GL_POSITION, light_position);
+    
+   glEnable(GL_DEPTH_TEST);
+   glEnable(GL_LIGHT0);
+
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+   glFrustum(-1.0, 1.0, -1.0, 1.0, 2.0, 50.0);
+   glMatrixMode(GL_MODELVIEW);
+   glTranslatef(0, 0.5, -7);
+
+   glClearColor(0.3, 0.3, 0.7, 0.0);
+   glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
+
+   glPushMatrix();
+   glRotatef(20.0, 1.0, 0.0, 0.0);
+
+   /* ground */
+   glEnable(GL_TEXTURE_2D);
+   glBegin(GL_POLYGON);
+   glNormal3f(0, 1, 0);
+   glTexCoord2f(0, 0);  glVertex3f(-5, -1, -5);
+   glTexCoord2f(1, 0);  glVertex3f( 5, -1, -5);
+   glTexCoord2f(1, 1);  glVertex3f( 5, -1,  5);
+   glTexCoord2f(0, 1);  glVertex3f(-5, -1,  5);
+   glEnd();
+   glDisable(GL_TEXTURE_2D);
+
+   glEnable(GL_LIGHTING);
+
+   glPushMatrix();
+   glTranslatef(-1.5, 0.5, 0.0); 
+   glRotatef(90.0, 1.0, 0.0, 0.0);
+   glMaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, red_mat );
+   Torus(0.275, 0.85, 20, 20);
+   glPopMatrix();
+
+   glPushMatrix();
+   glTranslatef(-1.5, -0.5, 0.0); 
+   glRotatef(270.0, 1.0, 0.0, 0.0);
+   glMaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, green_mat );
+   Cone(1.0, 2.0, 16, 1);
+   glPopMatrix();
+
+   glPushMatrix();
+   glTranslatef(0.95, 0.0, -0.8); 
+   glMaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, blue_mat );
+   glLineWidth(2.0);
+   glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+   Sphere(1.2, 20, 20);
+   glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+   glPopMatrix();
+
+#if 0
+   glPushMatrix();
+   glTranslatef(0.75, 0.0, 1.3); 
+   glMaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, yellow_mat );
+   glutWireTeapot(1.0);
+   glPopMatrix();
+#endif
+
+   glPushMatrix();
+   glTranslatef(-0.25, 0.0, 2.5);
+   glRotatef(40, 0, 1, 0);
+   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+   glEnable(GL_BLEND);
+   glEnable(GL_CULL_FACE);
+   glMaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, purple_mat );
+   Cube(1.0);
+   glDisable(GL_BLEND);
+   glDisable(GL_CULL_FACE);
+   glPopMatrix();
+
+   glDisable(GL_LIGHTING);
+
+   glPopMatrix();
+
+   glDisable(GL_DEPTH_TEST);
+}
+
+
+static void
+init_context(void)
+{
+   const GLint texWidth = 64, texHeight = 64;
+   GLubyte *texImage;
+   int i, j;
+
+   /* checker image */
+   texImage = malloc(texWidth * texHeight * 4);
+   for (i = 0; i < texHeight; i++) {
+      for (j = 0; j < texWidth; j++) {
+         int k = (i * texWidth + j) * 4;
+         if ((i % 5) == 0 || (j % 5) == 0) {
+            texImage[k+0] = 200;
+            texImage[k+1] = 200;
+            texImage[k+2] = 200;
+            texImage[k+3] = 255;
+         }
+         else {
+            if ((i % 5) == 1 || (j % 5) == 1) {
+               texImage[k+0] = 50;
+               texImage[k+1] = 50;
+               texImage[k+2] = 50;
+               texImage[k+3] = 255;
+            }
+            else {
+               texImage[k+0] = 100;
+               texImage[k+1] = 100;
+               texImage[k+2] = 100;
+               texImage[k+3] = 255;
+            }
+         }
+      }
+   }
+
+   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texWidth, texHeight, 0,
+                GL_RGBA, GL_UNSIGNED_BYTE, texImage);
+   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+   free(texImage);
+}
+
+
+static void
+write_ppm(const char *filename, const GLubyte *buffer, int width, int height)
+{
+   const int binary = 0;
+   FILE *f = fopen( filename, "w" );
+   if (f) {
+      int i, x, y;
+      const GLubyte *ptr = buffer;
+      if (binary) {
+         fprintf(f,"P6\n");
+         fprintf(f,"# ppm-file created by osdemo.c\n");
+         fprintf(f,"%i %i\n", width,height);
+         fprintf(f,"255\n");
+         fclose(f);
+         f = fopen( filename, "ab" );  /* reopen in binary append mode */
+         for (y=height-1; y>=0; y--) {
+            for (x=0; x<width; x++) {
+               i = (y*width + x) * 4;
+               fputc(ptr[i], f);   /* write red */
+               fputc(ptr[i+1], f); /* write green */
+               fputc(ptr[i+2], f); /* write blue */
+            }
+         }
+      }
+      else {
+         /*ASCII*/
+         int counter = 0;
+         fprintf(f,"P3\n");
+         fprintf(f,"# ascii ppm file created by osdemo.c\n");
+         fprintf(f,"%i %i\n", width, height);
+         fprintf(f,"255\n");
+         for (y=height-1; y>=0; y--) {
+            for (x=0; x<width; x++) {
+               i = (y*width + x) * 4;
+               fprintf(f, " %3d %3d %3d", ptr[i], ptr[i+1], ptr[i+2]);
+               counter++;
+               if (counter % 5 == 0)
+                  fprintf(f, "\n");
+            }
+         }
+      }
+      fclose(f);
+   }
+}
+
+
+static GLboolean
+test(GLenum type, GLint bits, const char *filename)
+{
+   const GLint z = 16, stencil = 0, accum = 0;
+   OSMesaContext ctx;
+   void *buffer;
+   GLint cBits;
+
+   assert(bits == 8 ||
+          bits == 16 ||
+          bits == 32);
+
+   assert(type == GL_UNSIGNED_BYTE ||
+          type == GL_UNSIGNED_SHORT ||
+          type == GL_FLOAT);
+
+   ctx = OSMesaCreateContextExt(OSMESA_RGBA, z, stencil, accum, NULL );
+   if (!ctx) {
+      printf("OSMesaCreateContextExt() failed!\n");
+      return 0;
+   }
+
+   /* Allocate the image buffer */
+   buffer = malloc(WIDTH * HEIGHT * 4 * bits / 8);
+   if (!buffer) {
+      printf("Alloc image buffer failed!\n");
+      return 0;
+   }
+
+   /* Bind the buffer to the context and make it current */
+   if (!OSMesaMakeCurrent( ctx, buffer, type, WIDTH, HEIGHT )) {
+      printf("OSMesaMakeCurrent (%d bits/channel) failed!\n", bits);
+      free(buffer);
+      OSMesaDestroyContext(ctx);
+      return 0;
+   }
+
+   /* sanity checks */
+   glGetIntegerv(GL_RED_BITS, &cBits);
+   if (cBits != bits) {
+      fprintf(stderr, "Unable to create %d-bit/channel renderbuffer.\n", bits);
+      fprintf(stderr, "May need to recompile Mesa with CHAN_BITS=16 or 32.\n");
+      return 0;
+   }
+   glGetIntegerv(GL_GREEN_BITS, &cBits);
+   assert(cBits == bits);
+   glGetIntegerv(GL_BLUE_BITS, &cBits);
+   assert(cBits == bits);
+   glGetIntegerv(GL_ALPHA_BITS, &cBits);
+   assert(cBits == bits);
+
+   if (WriteFiles)
+      printf("Rendering %d bit/channel image: %s\n", bits, filename);
+   else
+      printf("Rendering %d bit/channel image\n", bits);
+
+   OSMesaColorClamp(GL_TRUE);
+
+   init_context();
+   render_image();
+   if (Gradient)
+      render_gradient();
+
+   /* Make sure buffered commands are finished! */
+   glFinish();
+
+
+   if (WriteFiles && filename != NULL) {
+      if (type == GL_UNSIGNED_SHORT) {
+         GLushort *buffer16 = (GLushort *) buffer;
+         GLubyte *buffer8 = (GLubyte *) malloc(WIDTH * HEIGHT * 4);
+         int i;
+         for (i = 0; i < WIDTH * HEIGHT * 4; i++)
+            buffer8[i] = buffer16[i] >> 8;
+         write_ppm(filename, buffer8, WIDTH, HEIGHT);
+         free(buffer8);
+      }
+      else if (type == GL_FLOAT) {
+         GLfloat *buffer32 = (GLfloat *) buffer;
+         GLubyte *buffer8 = (GLubyte *) malloc(WIDTH * HEIGHT * 4);
+         int i;
+         /* colors may be outside [0,1] so we need to clamp */
+         for (i = 0; i < WIDTH * HEIGHT * 4; i++)
+            buffer8[i] = (GLubyte) (buffer32[i] * 255.0);
+         write_ppm(filename, buffer8, WIDTH, HEIGHT);
+         free(buffer8);
+      }
+      else {
+         write_ppm(filename, buffer, WIDTH, HEIGHT);
+      }
+   }
+
+   OSMesaDestroyContext(ctx);
+
+   free(buffer);
+
+   return 1;
+}
+
+
+int
+main( int argc, char *argv[] )
+{
+   int i;
+
+   printf("Use -f to write image files\n");
+
+   for (i = 1; i < argc; i++) {
+      if (strcmp(argv[i], "-f") == 0)
+         WriteFiles = GL_TRUE;
+      else if (strcmp(argv[i], "-g") == 0)
+         Gradient = GL_TRUE;
+   }
+
+   test(GL_UNSIGNED_BYTE, 8, "image8.ppm");
+   test(GL_UNSIGNED_SHORT, 16, "image16.ppm");
+   test(GL_FLOAT, 32, "image32.ppm");
+
+   return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/perf/glslstateschange1.frag mesa-demos-8.4.0-new/src/perf/glslstateschange1.frag
--- mesa-demos-8.4.0-old/src/perf/glslstateschange1.frag	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/perf/glslstateschange1.frag	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,19 @@
+// Multi-texture fragment shader
+// Brian Paul
+
+// Composite second texture over first.
+// We're assuming the 2nd texture has a meaningful alpha channel.
+
+uniform sampler2D tex1;
+uniform sampler2D tex2;
+uniform vec4 UniV1;
+uniform vec4 UniV2;
+
+void main()
+{
+   vec4 t3;
+   vec4 t1 = texture2D(tex1, gl_TexCoord[0].xy);
+   vec4 t2 = texture2D(tex2, gl_TexCoord[1].xy);
+   t3 = mix(t1, t2, t2.w);
+   gl_FragColor = t3 + UniV1 + UniV2;
+}
diff -Naur mesa-demos-8.4.0-old/src/perf/glslstateschange1.vert mesa-demos-8.4.0-new/src/perf/glslstateschange1.vert
--- mesa-demos-8.4.0-old/src/perf/glslstateschange1.vert	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/perf/glslstateschange1.vert	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,14 @@
+// Multi-texture vertex shader
+// Brian Paul
+
+
+attribute vec4 TexCoord0, TexCoord1;
+attribute vec4 VertCoord;
+
+void main()
+{
+   gl_TexCoord[0] = TexCoord0;
+   gl_TexCoord[1] = TexCoord1;
+   // note: may use gl_Vertex or VertCoord here for testing:
+   gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
+}
diff -Naur mesa-demos-8.4.0-old/src/perf/glslstateschange2.frag mesa-demos-8.4.0-new/src/perf/glslstateschange2.frag
--- mesa-demos-8.4.0-old/src/perf/glslstateschange2.frag	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/perf/glslstateschange2.frag	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,17 @@
+// Multi-texture fragment shader
+// Brian Paul
+
+// Composite second texture over first.
+// We're assuming the 2nd texture has a meaningful alpha channel.
+
+uniform sampler2D tex1;
+uniform sampler2D tex2;
+uniform vec4 UniV1;
+uniform vec4 UniV2;
+
+void main()
+{
+   vec4 t1 = texture2D(tex1, gl_TexCoord[0].xy);
+   vec4 t2 = texture2D(tex2, gl_TexCoord[1].xy);
+   gl_FragColor = t1 + t2 + UniV1 + UniV2;
+}
diff -Naur mesa-demos-8.4.0-old/src/perf/glslstateschange2.vert mesa-demos-8.4.0-new/src/perf/glslstateschange2.vert
--- mesa-demos-8.4.0-old/src/perf/glslstateschange2.vert	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/perf/glslstateschange2.vert	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,14 @@
+// Multi-texture vertex shader
+// Brian Paul
+
+
+attribute vec4 TexCoord0, TexCoord1;
+attribute vec4 VertCoord;
+
+void main()
+{
+   gl_TexCoord[0] = TexCoord0;
+   gl_TexCoord[1] = TexCoord1;
+   // note: may use gl_Vertex or VertCoord here for testing:
+   gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
+}
diff -Naur mesa-demos-8.4.0-old/src/samples/oglinfo.c mesa-demos-8.4.0-new/src/samples/oglinfo.c
--- mesa-demos-8.4.0-old/src/samples/oglinfo.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/samples/oglinfo.c	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,217 @@
+/* oglinfo.c */
+
+/* This demo modified by BrianP to accomodate Mesa and test
+ * the GLX 1.1 functions.
+ */
+
+
+
+#include <GL/gl.h>
+#include <GL/glx.h>
+#include <stdio.h>
+#include <string.h>
+
+int visual_request0[] = { None }; /* don't need much of a visual */
+int visual_request1[] = { GLX_RGBA, None }; /* in case CI failed */
+
+int main(int argc, char **argv)
+{
+  char *display_name = NULL;
+  char *string;
+  Display       *dpy;
+  int           screen_num;
+  int           major, minor;
+  XVisualInfo   *vis;
+  GLXContext    ctx;
+  Window        root,  win;
+  Colormap      cmap;
+  XSetWindowAttributes swa;
+  int dontcare;
+
+  /* parse arguments */
+  if(argc > 1) {
+    if(!strcmp(argv[1],"-display"))
+      display_name = argv[2];
+    else {
+      fprintf(stderr, "Usage: %s [-display <display>]\n",argv[0]);
+      return 0;
+    }
+  }
+
+  /* get display */
+  if (!(dpy = XOpenDisplay(display_name))) {
+    fprintf(stderr,"Error: XOpenDisplay() failed.\n");
+    return 1;
+  }
+
+  /* does the server know about OpenGL & GLX? */
+#ifndef MESA
+  if(!XQueryExtension(dpy, "GLX", &dontcare, &dontcare, &dontcare)) {
+    fprintf(stderr,"This system doesn't appear to support OpenGL\n");
+    return 1;
+  }
+#else
+  (void) dontcare;
+#endif
+
+  /* find the glx version */
+  if(glXQueryVersion(dpy, &major, &minor))
+    printf("GLX Version: %d.%d\n", major, minor);
+  else {
+    fprintf(stderr, "Error: glXQueryVersion() failed.\n");
+    return 1;
+  }
+
+  /* get screen number */
+  screen_num = DefaultScreen(dpy);
+
+/* This #ifdef isn't redundant. It keeps the build from breaking
+** if you are building on a machine that has an old (1.0) version
+** of glx.
+**
+** This program could still be *run* on a machine that has an old 
+** version of glx, even if it was *compiled* on a version that has
+** a new version.
+**
+** If compiled on a system with an old version of glx, then it will 
+** never recognize glx extensions, since that code would have been
+** #ifdef'ed out.
+*/
+#ifdef GLX_VERSION_1_1
+
+  /*
+  ** This test guarantees that glx, on the display you are inquiring,
+  ** suppports glXQueryExtensionsString().
+  */
+  if(minor > 0 || major > 1)
+    string = (char *) glXQueryExtensionsString(dpy, screen_num);
+  else
+    string = "";
+
+  if(string)
+    printf("GLX Extensions (client & server): %s\n",
+	   string);
+  else {
+    fprintf(stderr, "Error: glXQueryExtensionsString() failed.\n");
+    return 1;
+  }
+
+  if (minor>0 || major>1) {
+     printf("glXGetClientString(GLX_VENDOR): %s\n", glXGetClientString(dpy,GLX_VENDOR));
+     printf("glXGetClientString(GLX_VERSION): %s\n", glXGetClientString(dpy,GLX_VERSION));
+     printf("glXGetClientString(GLX_EXTENSIONS): %s\n", glXGetClientString(dpy,GLX_EXTENSIONS));
+     printf("glXQueryServerString(GLX_VENDOR): %s\n", glXQueryServerString(dpy,screen_num,GLX_VENDOR));
+     printf("glXQueryServerString(GLX_VERSION): %s\n", glXQueryServerString(dpy,screen_num,GLX_VERSION));
+     printf("glXQueryServerString(GLX_EXTENSIONS): %s\n", glXQueryServerString(dpy,screen_num,GLX_EXTENSIONS));
+  }
+
+
+#endif
+
+   /* get any valid OpenGL visual */
+   if (!(vis = glXChooseVisual(dpy, screen_num, visual_request0)))  {
+      if (!(vis = glXChooseVisual(dpy, screen_num, visual_request1)))  {
+         fprintf(stderr,"Error: glXChooseVisual() failed.\n");
+         return 1;
+      }
+   }
+
+   /* get context */
+   ctx = glXCreateContext(dpy,vis,0,GL_TRUE);
+
+   /* root window */
+   root = RootWindow(dpy,vis->screen);
+
+   /* get RGBA colormap */
+   cmap = XCreateColormap(dpy, root, vis->visual, AllocNone);
+
+   /* get window */
+   swa.colormap = cmap;
+   swa.border_pixel = 0;
+   swa.event_mask = StructureNotifyMask;
+   win = XCreateWindow(dpy, root, 0, 0, 1, 1, 0, vis->depth,
+		       InputOutput,vis->visual,
+		       CWBorderPixel|CWColormap|CWEventMask,
+		       &swa);
+
+   glXMakeCurrent(dpy,win,ctx);
+
+  string = (char *) glGetString(GL_VERSION);
+  if(string)
+#ifdef MESA
+    printf("Mesa Version: %s\n", string);
+#else
+    printf("OpenGL Version: %s\n", string);
+#endif
+  else {
+    fprintf(stderr, "Error: glGetString(GL_VERSION) failed.\n");
+    return 1;
+  }
+
+  string = (char *) glGetString(GL_EXTENSIONS);
+
+  if(string)
+#ifdef MESA
+    printf("Mesa Extensions: %s\n", string);
+#else
+    printf("OpenGL Extensions: %s\n", string);
+#endif
+  else {
+    fprintf(stderr, "Error: glGetString(GL_EXTENSIONS) failed.\n");
+    return 1;
+  }
+
+  string = (char *) glGetString(GL_RENDERER);
+
+  if(string)
+#ifdef MESA
+    printf("Mesa Renderer: %s\n", string);
+#else
+    printf("OpenGL renderer: %s\n", string);
+#endif
+  else {
+    fprintf(stderr, "Error: glGetString(GL_RENDERER) failed.\n");
+    return 1;
+  }
+
+/*
+** This #ifdef prevents a build failure if you compile on an a
+** machine with an old GLU library. 
+**
+** If you build on a pre GLU 1.1 machine, you will never be able
+** to get glu info, even if you run on a GLU 1.1 or latter machine,
+** since the code has been #ifdef'ed out.
+*/
+#ifdef GLU_VERSION_1_1
+
+  /*
+  ** If the glx version is 1.1 or latter, gluGetString() is guaranteed
+  ** to exist.
+  */
+  if(minor > 0 || major > 1)
+    string = (char *) gluGetString(GLU_VERSION);
+  else
+    string = "1.0";
+
+  if(string)
+    printf("GLU Version: %s\n", string);
+  else {
+    fprintf(stderr, "Error: gluGetString(GLU_VERSION) failed.\n");
+    return 1;
+  }
+  
+  if(minor > 0 || major > 1)
+    string = (char *) gluGetString(GLU_EXTENSIONS);
+  else
+    string = "";
+
+  if(string)
+    printf("GLU Extensions: %s\n", string);
+  else {
+    fprintf(stderr, "Error: gluGetString(GLU_EXTENSIONS) failed.\n");
+    return 1;
+  }
+
+#endif
+  return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/samples/rgbtoppm.c mesa-demos-8.4.0-new/src/samples/rgbtoppm.c
--- mesa-demos-8.4.0-old/src/samples/rgbtoppm.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/samples/rgbtoppm.c	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,303 @@
+
+/* texture.c - by David Blythe, SGI */
+
+/* texload is a simplistic routine for reading an SGI .rgb image file. */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h> 
+#include <string.h>
+
+#include "glut_wrap.h"
+
+typedef struct _ImageRec {
+    unsigned short imagic;
+    unsigned short type;
+    unsigned short dim;
+    unsigned short xsize, ysize, zsize;
+    unsigned int min, max;
+    unsigned int wasteBytes;
+    char name[80];
+    unsigned long colorMap;
+    FILE *file;
+    unsigned char *tmp;
+    unsigned long rleEnd;
+    unsigned int *rowStart;
+    int *rowSize;
+} ImageRec;
+
+static void
+rgbtorgb(unsigned char *r,unsigned char *g,unsigned char *b,unsigned char *l,int n) {
+    while(n--) {
+        l[0] = r[0];
+        l[1] = g[0];
+        l[2] = b[0];
+        l += 3; r++; g++; b++;
+    }
+}
+
+static void
+ConvertShort(unsigned short *array, unsigned int length) {
+    unsigned short b1, b2;
+    unsigned char *ptr;
+
+    ptr = (unsigned char *)array;
+    while (length--) {
+        b1 = *ptr++;
+        b2 = *ptr++;
+        *array++ = (b1 << 8) | (b2);
+    }
+}
+
+static void
+ConvertUint(unsigned *array, unsigned int length) {
+    unsigned int b1, b2, b3, b4;
+    unsigned char *ptr;
+
+    ptr = (unsigned char *)array;
+    while (length--) {
+        b1 = *ptr++;
+        b2 = *ptr++;
+        b3 = *ptr++;
+        b4 = *ptr++;
+        *array++ = (b1 << 24) | (b2 << 16) | (b3 << 8) | (b4);
+    }
+}
+
+static ImageRec *ImageOpen(char *fileName)
+{
+    union {
+        int testWord;
+        char testByte[4];
+    } endianTest;
+    ImageRec *image;
+    int swapFlag;
+    int x;
+    int result;
+
+    endianTest.testWord = 1;
+    if (endianTest.testByte[0] == 1) {
+        swapFlag = 1;
+    } else {
+        swapFlag = 0;
+    }
+
+    image = (ImageRec *)malloc(sizeof(ImageRec));
+    if (image == NULL) {
+        fprintf(stderr, "Out of memory!\n");
+        exit(1);
+    }
+    if ((image->file = fopen(fileName, "rb")) == NULL) {
+        free(image);
+        return NULL;
+    }
+
+    result = fread(image, 1, 12, image->file);
+    assert(result == 12);
+
+    if (swapFlag) {
+        ConvertShort(&image->imagic, 1);
+        ConvertShort(&image->type, 1);
+        ConvertShort(&image->dim, 1);
+        ConvertShort(&image->xsize, 1);
+        ConvertShort(&image->ysize, 1);
+        ConvertShort(&image->zsize, 1);
+    }
+
+    image->tmp = (unsigned char *)malloc(image->xsize*256);
+    if (image->tmp == NULL) {
+        fprintf(stderr, "\nOut of memory!\n");
+        exit(1);
+    }
+
+    if ((image->type & 0xFF00) == 0x0100) {
+        x = image->ysize * image->zsize * (int) sizeof(unsigned);
+        image->rowStart = (unsigned *)malloc(x);
+        image->rowSize = (int *)malloc(x);
+        if (image->rowStart == NULL || image->rowSize == NULL) {
+            fprintf(stderr, "\nOut of memory!\n");
+            exit(1);
+        }
+        image->rleEnd = 512 + (2 * x);
+        fseek(image->file, 512, SEEK_SET);
+        result = fread(image->rowStart, 1, x, image->file);
+        assert(result == x);
+        result = fread(image->rowSize, 1, x, image->file);
+        assert(result == x);
+        if (swapFlag) {
+            ConvertUint(image->rowStart, x/(int) sizeof(unsigned));
+            ConvertUint((unsigned *)image->rowSize, x/(int) sizeof(int));
+        }
+    }
+    return image;
+}
+
+static void
+ImageClose(ImageRec *image) {
+    fclose(image->file);
+    free(image->tmp);
+    free(image);
+}
+
+static void
+ImageGetRow(ImageRec *image, unsigned char *buf, int y, int z) {
+    unsigned char *iPtr, *oPtr, pixel;
+    int count;
+    int result;
+
+    if ((image->type & 0xFF00) == 0x0100) {
+        fseek(image->file, (long) image->rowStart[y+z*image->ysize], SEEK_SET);
+        result = fread(image->tmp, 1, (unsigned int)image->rowSize[y+z*image->ysize],
+                       image->file);
+        assert(result == (unsigned int)image->rowSize[y+z*image->ysize]);
+
+        iPtr = image->tmp;
+        oPtr = buf;
+        for (;;) {
+            pixel = *iPtr++;
+            count = (int)(pixel & 0x7F);
+            if (!count) {
+                return;
+            }
+            if (pixel & 0x80) {
+                while (count--) {
+                    *oPtr++ = *iPtr++;
+                }
+            } else {
+                pixel = *iPtr++;
+                while (count--) {
+                    *oPtr++ = pixel;
+                }
+            }
+        }
+    } else {
+        fseek(image->file, 512+(y*image->xsize)+(z*image->xsize*image->ysize),
+              SEEK_SET);
+        result = fread(buf, 1, image->xsize, image->file);
+        assert(result == image->xsize);
+    }
+}
+
+#if 0
+static GLubyte *
+read_alpha_texture(char *name, int *width, int *height)
+{
+    unsigned char *base, *lptr;
+    ImageRec *image;
+    int y;
+
+    image = ImageOpen(name);
+    if(!image) {
+        return NULL;
+    }
+
+    (*width)=image->xsize;
+    (*height)=image->ysize;
+    if (image->zsize != 1) {
+      ImageClose(image);
+      return NULL;
+    }
+
+    base = (unsigned char *)malloc(image->xsize*image->ysize*sizeof(unsigned char));
+    lptr = base;
+    for(y=0; y<image->ysize; y++) {
+        ImageGetRow(image,lptr,y,0);
+        lptr += image->xsize;
+    }
+    ImageClose(image);
+
+    return (unsigned char *) base;
+}
+#endif
+
+static GLubyte *
+read_rgb_texture(char *name, int *width, int *height)
+{
+    unsigned char *base, *ptr;
+    unsigned char *rbuf, *gbuf, *bbuf, *abuf;
+    ImageRec *image;
+    int y;
+
+    image = ImageOpen(name);
+    
+    if(!image)
+        return NULL;
+    (*width)=image->xsize;
+    (*height)=image->ysize;
+    if (image->zsize != 3 && image->zsize != 4) {
+      ImageClose(image);
+      return NULL;
+    }
+
+    base = (unsigned char*)malloc(image->xsize*image->ysize*sizeof(unsigned int)*3);
+    rbuf = (unsigned char *)malloc(image->xsize*sizeof(unsigned char));
+    gbuf = (unsigned char *)malloc(image->xsize*sizeof(unsigned char));
+    bbuf = (unsigned char *)malloc(image->xsize*sizeof(unsigned char));
+    abuf = (unsigned char *)malloc(image->xsize*sizeof(unsigned char));
+    if(!base || !rbuf || !gbuf || !bbuf || !abuf) {
+      if (base) free(base);
+      if (rbuf) free(rbuf);
+      if (gbuf) free(gbuf);
+      if (bbuf) free(bbuf);
+      if (abuf) free(abuf);
+      ImageClose(image); 
+      return NULL;
+    }
+    ptr = base;
+    for(y=0; y<image->ysize; y++) {
+        if(image->zsize == 4) {
+            ImageGetRow(image,rbuf,y,0);
+            ImageGetRow(image,gbuf,y,1);
+            ImageGetRow(image,bbuf,y,2);
+            ImageGetRow(image,abuf,y,3);  /* Discard. */
+            rgbtorgb(rbuf,gbuf,bbuf,ptr,image->xsize);
+            ptr += (image->xsize * 3);
+        } else {
+            ImageGetRow(image,rbuf,y,0);
+            ImageGetRow(image,gbuf,y,1);
+            ImageGetRow(image,bbuf,y,2);
+            rgbtorgb(rbuf,gbuf,bbuf,ptr,image->xsize);
+            ptr += (image->xsize * 3);
+        }
+    }
+    ImageClose(image);
+    free(rbuf);
+    free(gbuf);
+    free(bbuf);
+    free(abuf);
+
+    return (GLubyte *) base;
+}
+
+int main(int argc, char **argv)
+{
+	int width = 0;
+	int height = 0;
+	GLubyte *data;
+        char buff[32];
+        int n;
+        FILE *fo;
+
+	if (argc != 3)
+	{
+		fprintf(stderr, "usage: %s <infile.rgb> <outfile.p6>\n", argv[0]);
+		return 1;
+	}
+
+	data = read_rgb_texture(argv[1], &width, &height);
+
+	n = sprintf(buff, "P6\n%d %d\n255\n", width, height);
+
+        /* [dBorca] avoid LF to CRLF conversion */
+        if ((fo = fopen(argv[2], "wb")) == NULL) {
+           fprintf(stderr, "Cannot open output file!\n");
+           exit(1);
+        }
+
+	fwrite(buff, n, 1, fo);
+	fwrite(data, width * 3, height, fo);
+
+        fclose(fo);
+
+	return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/tests/api_speed.c mesa-demos-8.4.0-new/src/tests/api_speed.c
--- mesa-demos-8.4.0-old/src/tests/api_speed.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/tests/api_speed.c	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,145 @@
+/*
+ * (C) Copyright IBM Corporation 2002
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEM, IBM AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file api_speed.c
+ * Simple test to measure the overhead of making GL calls.
+ * 
+ * The main purpose of this test is to measure the difference in calling
+ * overhead of different dispatch methods.  Since it uses asm/timex.h to
+ * access the Pentium's cycle counters, it will probably only compile on
+ * Linux (though most architectures have a get_cycles function in timex.h).
+ * That is why it isn't in the default Makefile.
+ * 
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <GL/glew.h>
+#include "glut_wrap.h"
+
+#define inline __inline__
+#include <asm/timex.h>
+
+static float Width = 400;
+static float Height = 400;
+static unsigned count = 1000000;
+
+
+static void Idle( void )
+{
+   glutPostRedisplay();
+}
+
+#define DO_FUNC(f,p) \
+   do { \
+      t0 = get_cycles(); \
+      for ( i = 0 ; i < count ; i++ ) { \
+	 f p ; \
+      } \
+      t1 = get_cycles(); \
+      printf("%u calls to % 20s required %llu cycles.\n", count, # f, t1 - t0); \
+   } while( 0 )
+
+/**
+ * Main display function.  This is the place to add more API calls.
+ */
+static void Display( void )
+{
+   int i;
+   const float v[3] = { 1.0, 0.0, 0.0 };
+   cycles_t t0;
+   cycles_t t1;
+
+   glBegin(GL_TRIANGLE_STRIP);
+
+   DO_FUNC( glColor3fv, (v) );
+   DO_FUNC( glNormal3fv, (v) );
+   DO_FUNC( glTexCoord2fv, (v) );
+   DO_FUNC( glTexCoord3fv, (v) );
+   DO_FUNC( glMultiTexCoord2fv, (GL_TEXTURE0, v) );
+   DO_FUNC( glMultiTexCoord2f, (GL_TEXTURE0, 0.0, 0.0) );
+   DO_FUNC( glFogCoordfvEXT, (v) );
+   DO_FUNC( glFogCoordfEXT, (0.5) );
+
+   glEnd();
+
+   exit(0);
+}
+
+
+static void Reshape( int width, int height )
+{
+   Width = width;
+   Height = height;
+   glViewport( 0, 0, width, height );
+   glMatrixMode( GL_PROJECTION );
+   glLoadIdentity();
+   glOrtho(0.0, width, 0.0, height, -1.0, 1.0);
+   glMatrixMode( GL_MODELVIEW );
+   glLoadIdentity();
+}
+
+
+static void Key( unsigned char key, int x, int y )
+{
+   (void) x;
+   (void) y;
+   switch (key) {
+      case 27:
+         exit(0);
+         break;
+   }
+   glutPostRedisplay();
+}
+
+
+int main( int argc, char *argv[] )
+{
+   glutInit( &argc, argv );
+   glutInitWindowSize( (int) Width, (int) Height );
+   glutInitWindowPosition( 0, 0 );
+
+   glutInitDisplayMode( GLUT_RGB );
+
+   glutCreateWindow( argv[0] );
+   glewInit();
+
+   if ( argc > 1 ) {
+      count = strtoul( argv[1], NULL, 0 );
+      if ( count == 0 ) {
+	 fprintf( stderr, "Usage: %s [iterations]\n", argv[0] );
+	 exit(1);
+      }
+   }
+
+   glutReshapeFunc( Reshape );
+   glutKeyboardFunc( Key );
+   glutDisplayFunc( Display );
+   glutIdleFunc( Idle );
+
+   glutMainLoop();
+   return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/tests/api_speed.py mesa-demos-8.4.0-new/src/tests/api_speed.py
--- mesa-demos-8.4.0-old/src/tests/api_speed.py	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/tests/api_speed.py	2020-04-11 09:49:44.112059934 -0700
@@ -0,0 +1,143 @@
+#!/usr/bin/env python2
+
+# (C) Copyright IBM Corporation 2004
+# All Rights Reserved.
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files (the "Software"),
+# to deal in the Software without restriction, including without limitation
+# on the rights to use, copy, modify, merge, publish, distribute, sub
+# license, and/or sell copies of the Software, and to permit persons to whom
+# the Software is furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice (including the next
+# paragraph) shall be included in all copies or substantial portions of the
+# Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+# IBM AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+# IN THE SOFTWARE.
+#
+# Authors:
+#    Ian Romanick <idr@us.ibm.com>
+
+
+# This script is used to run api_speed against several different libGL
+# libraries and compare the results.  See the show_usage function for more
+# details on how to use it.
+
+
+import re, os, sys, getopt
+
+class results:
+	def process_file(self, f):
+		self.cycles = {}
+		self.iterations = -1
+
+		for line in f.readlines():
+			m = re.match("(\d+) calls to (.{20}) required (\d+) cycles.", line)
+
+			if self.iterations != -1 and int(m.group(1)) != self.iterations:
+				raise
+
+			# This could be done with lstrip, but the version of
+			# the Python library on my system doesn't have it.
+			# The installed version of Python is quite old. :(
+
+			temp = m.group(2)
+			function_name = None
+			for i in range(len(temp)):
+				if temp[i] != ' ':
+					function_name = temp[i:]
+					break
+
+			if function_name == None:
+				raise
+
+			self.cycles[ function_name ] = int(m.group(3))
+			self.iterations = int(m.group(1))
+
+
+	def show_results(self):
+		for name in self.cycles:
+			print "%s -> %f" % (name, float(self.cycles[name]) / self.iterations)
+
+
+	def compare_results(self, other):
+		for name in self.cycles:
+			if other.cycles.has_key(name):
+				a = float(self.cycles[name])  / float(self.iterations)
+				b = float(other.cycles[name]) / float(other.iterations)
+				if abs( a ) < 0.000001:
+				    print "a = %f, b = %f" % (a, b)
+				else:
+				    p = (100.0 * b / a) - 100.0
+				    print "%- 20s %7.2f - %7.2f = % -6.2f (%+.1f%%)" % (name, a, b, a - b, p)
+		return
+
+
+def make_execution_string(lib, iterations):
+	if lib == None:
+		return "./api_speed %u" % (iterations)
+	else:
+		return "LD_PRELOAD=%s ./api_speed %u" % (lib, iterations)
+
+
+def show_usage():
+	print """Usage: %s [-i iterations] {library ...}
+
+The full path to one or more libGL libraries (including the full name of the
+library) can be included on the command-line.  Each library will be tested,
+and the results compared.  The first library listed will be used as the
+"base line" for all comparisons.""" % (sys.argv[0])
+	sys.exit(1)
+
+
+if __name__ == '__main__':
+	try:
+		(args, trail) = getopt.getopt(sys.argv[1:], "i:")
+	except Exception,e:
+		show_usage()
+
+	iterations = 1000000
+	try:
+		for (arg,val) in args:
+			if arg == "-i":
+				iterations = int(val)
+	except Exception,e:
+		show_usage()
+
+
+	# If no libraries were specifically named, just run the test against
+	# the default system libGL.
+
+	if len(trail) == 0:
+		trail.append(None)
+
+
+	result_array = []
+	names = []
+
+	for lib in trail:
+		s = make_execution_string( lib, iterations )
+		r = results()
+		r.process_file( os.popen(s) )
+		names.append(lib)
+		result_array.append(r)
+
+
+	# If the test was only run against one library, just show the results
+	# of the test run.  Otherwise, compare each successive run against
+	# the first run.
+
+	if len( result_array ) == 1:
+		result_array[0].show_results()
+	else:
+		for i in range(1, len( result_array )):
+			print "%s vs. %s" % (names[0], names[i])
+			result_array[0].compare_results( result_array[i] )
+			print ""
diff -Naur mesa-demos-8.4.0-old/src/tests/debugger.c mesa-demos-8.4.0-new/src/tests/debugger.c
--- mesa-demos-8.4.0-old/src/tests/debugger.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/tests/debugger.c	2020-04-11 09:49:44.113059934 -0700
@@ -0,0 +1,735 @@
+/*
+ * Test the GL_MESA_program_debug extension
+ */
+
+
+#include <assert.h>
+#include <ctype.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <GL/glew.h>
+#include "glut_wrap.h"
+
+
+/*
+ * Print the string with line numbers
+ */
+static void list_program(const GLubyte *string, GLsizei len)
+{
+   const char *c = (const char *) string;
+   int i, line = 1, printNumber = 1;
+
+   for (i = 0; i < len; i++) {
+      if (printNumber) {
+         printf("%3d ", line);
+         printNumber = 0;
+      }
+      if (*c == '\n') {
+         line++;
+         printNumber = 1;
+      }
+      putchar(*c);
+      c++;
+   }
+   putchar('\n');
+}
+
+
+/*
+ * Return the line number and column number that corresponds to the
+ * given program position.  Also return a null-terminated copy of that
+ * line of the program string.
+ */
+static const GLubyte *
+find_line_column(const GLubyte *string, const GLubyte *pos,
+                 GLint *line, GLint *col)
+{
+   const GLubyte *lineStart = string;
+   const GLubyte *p = string;
+   GLubyte *s;
+   int len;
+
+   *line = 1;
+
+   while (p != pos) {
+      if (*p == (GLubyte) '\n') {
+         (*line)++;
+         lineStart = p + 1;
+      }
+      p++;
+   }
+
+   *col = (pos - lineStart) + 1;
+
+   /* return copy of this line */
+   while (*p != 0 && *p != '\n')
+      p++;
+   len = p - lineStart;
+   s = (GLubyte *) malloc(len + 1);
+   memcpy(s, lineStart, len);
+   s[len] = 0;
+
+   return s;
+}
+
+
+#define ARB_VERTEX_PROGRAM    1
+#define ARB_FRAGMENT_PROGRAM  2
+#define NV_VERTEX_PROGRAM     3
+#define NV_FRAGMENT_PROGRAM   4
+
+
+
+struct breakpoint {
+   enum {PIXEL, LINE} type;
+   int x, y;
+   int line;
+   GLboolean enabled;
+};
+
+#define MAX_BREAKPOINTS 100
+static struct breakpoint Breakpoints[MAX_BREAKPOINTS];
+static int NumBreakpoints = 0;
+
+
+
+/*
+ * Interactive debugger
+ */
+static void Debugger2(GLenum target, GLvoid *data)
+{
+   static GLuint skipCount = 0;
+   const GLubyte *ln;
+   GLint pos = 0, line, column;
+   GLint id;
+   int progType;
+   GLint len;
+   GLubyte *program;
+   GLboolean stop;
+   int i;
+
+   /* Sigh, GL_VERTEX_PROGRAM_ARB == GL_VERTEX_PROGRAM_NV so it's a bit
+    * hard to distinguish between them.
+    */
+   if (target == GL_FRAGMENT_PROGRAM_ARB)
+      progType = ARB_FRAGMENT_PROGRAM;
+   else if (target == GL_FRAGMENT_PROGRAM_NV)
+      progType = NV_FRAGMENT_PROGRAM;
+   else
+      progType = NV_VERTEX_PROGRAM;         
+
+   /* Until we hit zero, continue rendering */
+   if (skipCount > 0) {
+      skipCount--;
+      return;
+   }
+
+   /* Get id of the program and current position */
+   switch (progType) {
+   case ARB_FRAGMENT_PROGRAM:
+      glGetProgramivARB(GL_FRAGMENT_PROGRAM_ARB, GL_PROGRAM_BINDING_ARB, &id);
+      glGetIntegerv(GL_FRAGMENT_PROGRAM_POSITION_MESA, &pos);
+      break;
+   case NV_FRAGMENT_PROGRAM:
+      glGetIntegerv(GL_FRAGMENT_PROGRAM_BINDING_NV, &id);
+      glGetIntegerv(GL_FRAGMENT_PROGRAM_POSITION_MESA, &pos);
+      break;
+   case ARB_VERTEX_PROGRAM:
+      glGetProgramivARB(GL_VERTEX_PROGRAM_ARB, GL_PROGRAM_BINDING_ARB, &id);
+      glGetIntegerv(GL_VERTEX_PROGRAM_POSITION_MESA, &pos);
+      break;
+   case NV_VERTEX_PROGRAM:
+      glGetIntegerv(GL_VERTEX_PROGRAM_BINDING_NV, &id);
+      glGetIntegerv(GL_VERTEX_PROGRAM_POSITION_MESA, &pos);
+      break;
+   default:
+      abort();
+   }
+
+   /* get program string */
+   if (progType == ARB_VERTEX_PROGRAM ||
+       progType == ARB_FRAGMENT_PROGRAM)
+      glGetProgramivARB(target, GL_PROGRAM_LENGTH_ARB, &len);
+   else
+      glGetProgramivNV(id, GL_PROGRAM_LENGTH_NV, &len);
+   program = malloc(len + 1);
+   if (progType == ARB_VERTEX_PROGRAM ||
+       progType == ARB_FRAGMENT_PROGRAM)
+      glGetProgramStringARB(target, GL_PROGRAM_STRING_ARB, program);
+   else
+      glGetProgramStringNV(id, GL_PROGRAM_STRING_NV, program);
+
+
+   /* Get current line number, column, line string */
+   ln = find_line_column(program, program + pos, &line, &column);
+
+   /* test breakpoints */   
+   if (NumBreakpoints > 0)
+      stop = GL_FALSE;
+   else
+      stop = GL_TRUE;
+   for (i = 0; i < NumBreakpoints; i++) {
+      if (Breakpoints[i].enabled) {
+         switch (Breakpoints[i].type) {
+            case PIXEL:
+               if (progType == ARB_FRAGMENT_PROGRAM) {
+
+               }
+               else if (progType == NV_FRAGMENT_PROGRAM) {
+                  GLfloat pos[4];
+                  int px, py;
+                  glGetProgramRegisterfvMESA(GL_FRAGMENT_PROGRAM_NV,
+                                             6, (GLubyte *) "f[WPOS]", pos);
+                  px = (int) pos[0];
+                  py = (int) pos[1];
+                  printf("%d, %d\n", px, py);
+                  if (px == Breakpoints[i].x &&
+                      py == Breakpoints[i].y) {
+                     printf("Break at pixel (%d, %d)\n", px, py);
+                     stop = GL_TRUE;
+                  }
+               }
+               break;
+            case LINE:
+               if (line == Breakpoints[i].line) {
+                  /* hit a breakpoint! */
+                  printf("Break at line %d\n", line);
+                  stop = GL_TRUE;
+               }
+               break;
+         }
+      }
+   }
+   if (!stop) {
+      free(program);
+      return;
+   }
+
+   printf("%d: %s\n", line, ln);
+
+   /* get commands from stdin */
+   while (1) {
+      char command[1000], *cmd;
+
+      /* print prompt and get command */
+      printf("(%s %d) ", (target == GL_VERTEX_PROGRAM_ARB ? "vert" : "frag"),
+             line);
+      fgets(command, 999, stdin);
+
+      /* skip leading whitespace */
+      for (cmd = command; cmd[0] == ' '; cmd++)
+         ;
+
+      if (!cmd[0])
+         /* nothing (repeat the previous cmd?) */
+         continue;
+
+      switch (cmd[0]) {
+         case 's':
+            /* skip N instructions */
+            i = atoi(cmd + 2);
+            skipCount = i;
+            printf("Skipping %d instructions\n", i);
+            return;
+         case 'n':
+            /* next */
+            return;
+         case 'c':
+            return;
+         case 'd':
+            /* dump machine state */
+            if (progType == NV_FRAGMENT_PROGRAM) {
+               static const char *inRegs[] = {
+                  "f[WPOS]", "f[COL0]", "f[COL1]", "f[FOGC]",
+                  "f[TEX0]", "f[TEX1]", "f[TEX2]", "f[TEX3]",
+                  NULL
+               };
+               static const char *outRegs[] = {
+                  "o[COLR]", "o[COLH]", "o[DEPR]", NULL
+               };
+               GLfloat v[4];
+               int i;
+               printf("Fragment input attributes:\n");
+               for (i = 0; inRegs[i]; i++) {
+                  glGetProgramRegisterfvMESA(GL_FRAGMENT_PROGRAM_NV,
+                                             strlen(inRegs[i]),
+                                             (const GLubyte *) inRegs[i], v);
+                  printf("  %s: %g, %g, %g, %g\n", inRegs[i],
+                         v[0], v[1], v[2], v[3]);
+               }
+               printf("Fragment output attributes:\n");
+               for (i = 0; outRegs[i]; i++) {
+                  glGetProgramRegisterfvMESA(GL_FRAGMENT_PROGRAM_NV,
+                                             strlen(outRegs[i]),
+                                             (const GLubyte *) outRegs[i], v);
+                  printf("  %s: %g, %g, %g, %g\n", outRegs[i],
+                         v[0], v[1], v[2], v[3]);
+               }
+               printf("Temporaries:\n");
+               for (i = 0; i < 4; i++) {
+                  char temp[100];
+                  GLfloat v[4];
+                  sprintf(temp, "R%d", i);
+                  glGetProgramRegisterfvMESA(GL_FRAGMENT_PROGRAM_NV,
+                                             strlen(temp),
+                                             (const GLubyte *) temp, v);
+                  printf("  %s: %g, %g, %g, %g\n", temp, v[0],v[1],v[2],v[3]);
+               }
+            }
+            else if (progType == NV_VERTEX_PROGRAM) {
+               GLfloat v[4];
+               int i;
+               static const char *inRegs[] = {
+                  "v[OPOS]", "v[WGHT]", "v[NRML]", "v[COL0]",
+                  "v[COL1]", "v[FOGC]", "v[6]", "v[7]",
+                  "v[TEX0]", "v[TEX1]", "v[TEX2]", "v[TEX3]",
+                  "v[TEX4]", "v[TEX5]", "v[TEX6]", "v[TEX7]",
+                  NULL
+               };
+               static const char *outRegs[] = {
+                  "o[HPOS]", "o[COL0]", "o[COL1]", "o[BFC0]",
+                  "o[BFC1]", "o[FOGC]", "o[PSIZ]",
+                  "o[TEX0]", "o[TEX1]", "o[TEX2]", "o[TEX3]",
+                  "o[TEX4]", "o[TEX5]", "o[TEX6]", "o[TEX7]",
+                  NULL
+               };
+               printf("Vertex input attributes:\n");
+               for (i = 0; inRegs[i]; i++) {
+                  glGetProgramRegisterfvMESA(GL_VERTEX_PROGRAM_NV,
+                                             strlen(inRegs[i]),
+                                             (const GLubyte *) inRegs[i], v);
+                  printf("  %s: %g, %g, %g, %g\n", inRegs[i],
+                         v[0], v[1], v[2], v[3]);
+               }
+               printf("Vertex output attributes:\n");
+               for (i = 0; outRegs[i]; i++) {
+                  glGetProgramRegisterfvMESA(GL_VERTEX_PROGRAM_NV,
+                                             strlen(outRegs[i]),
+                                             (const GLubyte *) outRegs[i], v);
+                  printf("  %s: %g, %g, %g, %g\n", outRegs[i],
+                         v[0], v[1], v[2], v[3]);
+               }
+               printf("Temporaries:\n");
+               for (i = 0; i < 4; i++) {
+                  char temp[100];
+                  GLfloat v[4];
+                  sprintf(temp, "R%d", i);
+                  glGetProgramRegisterfvMESA(GL_VERTEX_PROGRAM_NV,
+                                             strlen(temp),
+                                             (const GLubyte *) temp, v);
+                  printf("  %s: %g, %g, %g, %g\n", temp, v[0],v[1],v[2],v[3]);
+               }
+            }
+            break;
+         case 'l':
+            /* list */
+            list_program(program, len);
+            break;
+         case 'p':
+            /* print */
+            {
+               GLfloat v[4];
+               char *c;
+               cmd++;
+               while (*cmd == ' ')
+                  cmd++;
+               c = cmd;
+               while (*c) {
+                  if (*c == '\n' || *c == '\r')
+                     *c = 0;
+                  else
+                     c++;
+               }
+               glGetProgramRegisterfvMESA(target, strlen(cmd),
+                                          (const GLubyte *) cmd, v);
+               if (glGetError() == GL_NO_ERROR)
+                  printf("%s = %g, %g, %g, %g\n", cmd, v[0], v[1], v[2], v[3]);
+               else
+                  printf("Invalid expression\n");
+            }
+            break;
+         case 'b':
+            if (cmd[1] == ' ' && isdigit(cmd[2])) {
+               char *comma = strchr(cmd, ',');
+               if (comma) {
+                  /* break at pixel */
+                  int x = atoi(cmd + 2);
+                  int y = atoi(comma + 1);
+                  if (NumBreakpoints < MAX_BREAKPOINTS) {
+                     Breakpoints[NumBreakpoints].type = PIXEL;
+                     Breakpoints[NumBreakpoints].x = x;
+                     Breakpoints[NumBreakpoints].y = y;
+                     Breakpoints[NumBreakpoints].enabled = GL_TRUE;
+                     NumBreakpoints++;
+                     printf("Breakpoint %d: break at pixel (%d, %d)\n",
+                            NumBreakpoints, x, y);
+                  }
+               }
+               else {
+                  /* break at line */
+                  int l = atoi(cmd + 2);
+                  if (l && NumBreakpoints < MAX_BREAKPOINTS) {
+                     Breakpoints[NumBreakpoints].type = LINE;
+                     Breakpoints[NumBreakpoints].line = l;
+                     Breakpoints[NumBreakpoints].enabled = GL_TRUE;
+                     NumBreakpoints++;
+                     printf("Breakpoint %d: break at line %d\n",
+                            NumBreakpoints, l);
+                  }
+               }
+            }
+            else {
+               /* list breakpoints */
+               printf("Breakpoints:\n");
+               for (i = 0; i < NumBreakpoints; i++) {
+                  switch (Breakpoints[i].type) {
+                  case LINE:
+                     printf("  %d: break at line %d\n",
+                            i + 1, Breakpoints[i].line);
+                     break;
+                  case PIXEL:
+                     printf("  %d: break at pixel (%d, %d)\n",
+                            i + 1, Breakpoints[i].x, Breakpoints[i].y);
+                     break;
+                  }
+               }
+            }
+            break;
+         case 'h':
+            /* help */
+            printf("Debugger commands:\n");
+            printf("  b      list breakpoints\n");
+            printf("  b N    break at line N\n");
+            printf("  b x,y  break at pixel x,y\n");
+            printf("  c      continue execution\n");
+            printf("  d      display register values\n");
+            printf("  h      help\n");
+            printf("  l      list program\n");
+            printf("  n      next instruction\n");
+            printf("  p V    print value V\n");
+            printf("  s N    skip N instructions\n");
+            break;
+         default:
+            printf("Unknown command: %c\n", cmd[0]);
+      }
+   }
+}
+
+
+/*
+ * Print current line, some registers, and continue.
+ */
+static void Debugger(GLenum target, GLvoid *data)
+{
+   GLint pos;
+   const GLubyte *ln;
+   GLint line, column;
+   GLfloat v[4];
+
+   assert(target == GL_FRAGMENT_PROGRAM_NV);
+
+   glGetIntegerv(GL_FRAGMENT_PROGRAM_POSITION_MESA, &pos);
+
+   ln = find_line_column((const GLubyte *) data, (const GLubyte *) data + pos,
+                         &line, &column);
+   printf("%d:%d: %s\n", line, column, (char *) ln);
+
+   glGetProgramRegisterfvMESA(GL_FRAGMENT_PROGRAM_NV,
+                              2, (const GLubyte *) "R0", v);
+   printf("  R0 = %g, %g, %g, %g\n", v[0], v[1], v[2], v[3]);
+   glGetProgramRegisterfvMESA(GL_FRAGMENT_PROGRAM_NV,
+                              7, (const GLubyte *) "f[WPOS]", v);
+   printf("  o[WPOS] = %g, %g, %g, %g\n", v[0], v[1], v[2], v[3]);
+   glGetProgramRegisterfvMESA(GL_FRAGMENT_PROGRAM_NV,
+                              7, (const GLubyte *) "o[COLR]", v);
+   printf("  o[COLR] = %g, %g, %g, %g\n", v[0], v[1], v[2], v[3]);
+
+   free((void *) ln);
+}
+
+
+
+
+/**********************************************************************/
+
+static GLfloat Diffuse[4] = { 0.5, 0.5, 1.0, 1.0 };
+static GLfloat Specular[4] = { 0.8, 0.8, 0.8, 1.0 };
+static GLfloat LightPos[4] = { 0.0, 10.0, 20.0, 1.0 };
+static GLfloat Delta = 1.0;
+
+static GLuint FragProg;
+static GLuint VertProg;
+static GLboolean Anim = GL_TRUE;
+static GLboolean Wire = GL_FALSE;
+static GLboolean PixelLight = GL_TRUE;
+
+static GLfloat Xrot = 0, Yrot = 0;
+
+
+#define NAMED_PARAMETER4FV(prog, name, v)        \
+  glProgramNamedParameter4fvNV(prog, strlen(name), (const GLubyte *) name, v)
+
+
+static void Display( void )
+{
+   glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
+
+   if (PixelLight) {
+      NAMED_PARAMETER4FV(FragProg, "LightPos", LightPos);
+      glEnable(GL_FRAGMENT_PROGRAM_NV);
+      glEnable(GL_VERTEX_PROGRAM_NV);
+      glDisable(GL_LIGHTING);
+   }
+   else {
+      glLightfv(GL_LIGHT0, GL_POSITION, LightPos);
+      glDisable(GL_FRAGMENT_PROGRAM_NV);
+      glDisable(GL_VERTEX_PROGRAM_NV);
+      glEnable(GL_LIGHTING);
+   }
+
+   glPushMatrix();
+   glRotatef(Xrot, 1, 0, 0);
+   glRotatef(Yrot, 0, 1, 0);
+
+#if 1
+   glutSolidSphere(2.0, 10, 5);
+#else
+   {
+      GLUquadricObj *q = gluNewQuadric();
+      gluQuadricNormals(q, GL_SMOOTH);
+      gluQuadricTexture(q, GL_TRUE);
+      glRotatef(90, 1, 0, 0);
+      glTranslatef(0, 0, -1);
+      gluCylinder(q, 1.0, 1.0, 2.0, 24, 1);
+      gluDeleteQuadric(q);
+   }
+#endif
+
+   glPopMatrix();
+
+   glutSwapBuffers();
+}
+
+
+static void Idle(void)
+{
+   LightPos[0] += Delta;
+   if (LightPos[0] > 25.0)
+      Delta = -1.0;
+   else if (LightPos[0] <- 25.0)
+      Delta = 1.0;
+   glutPostRedisplay();
+}
+
+
+static void Reshape( int width, int height )
+{
+   glViewport( 0, 0, width, height );
+   glMatrixMode( GL_PROJECTION );
+   glLoadIdentity();
+   glFrustum( -1.0, 1.0, -1.0, 1.0, 5.0, 25.0 );
+   /*glOrtho( -2.0, 2.0, -2.0, 2.0, 5.0, 25.0 );*/
+   glMatrixMode( GL_MODELVIEW );
+   glLoadIdentity();
+   glTranslatef( 0.0, 0.0, -15.0 );
+}
+
+
+static void Key( unsigned char key, int x, int y )
+{
+   (void) x;
+   (void) y;
+   switch (key) {
+     case ' ':
+        Anim = !Anim;
+        if (Anim)
+           glutIdleFunc(Idle);
+        else
+           glutIdleFunc(NULL);
+        break;
+      case 'x':
+         LightPos[0] -= 1.0;
+         break;
+      case 'X':
+         LightPos[0] += 1.0;
+         break;
+      case 'w':
+         Wire = !Wire;
+         if (Wire)
+            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+         else
+            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+         break;
+      case 'p':
+         PixelLight = !PixelLight;
+         if (PixelLight) {
+            printf("Per-pixel lighting\n");
+         }
+         else {
+            printf("Conventional lighting\n");
+         }
+         break;
+      case 27:
+         exit(0);
+         break;
+   }
+   glutPostRedisplay();
+}
+
+static void SpecialKey( int key, int x, int y )
+{
+   const GLfloat step = 3.0;
+   (void) x;
+   (void) y;
+   switch (key) {
+      case GLUT_KEY_UP:
+         Xrot -= step;
+         break;
+      case GLUT_KEY_DOWN:
+         Xrot += step;
+         break;
+      case GLUT_KEY_LEFT:
+         Yrot -= step;
+         break;
+      case GLUT_KEY_RIGHT:
+         Yrot += step;
+         break;
+   }
+   glutPostRedisplay();
+}
+
+
+static void Init( int argc, char *argv[] )
+{
+   static const char *fragProgramText =
+      "!!FP1.0\n"
+      "DECLARE Diffuse; \n"
+      "DECLARE Specular; \n"
+      "DECLARE LightPos; \n"
+
+      "# Compute normalized LightPos, put it in R0\n"
+      "DP3 R0.x, LightPos, LightPos;\n"
+      "RSQ R0.y, R0.x;\n"
+      "MUL R0, LightPos, R0.y;\n"
+
+      "# Compute normalized normal, put it in R1\n"
+      "DP3 R1, f[TEX0], f[TEX0]; \n"
+      "RSQ R1.y, R1.x;\n"
+      "MUL R1, f[TEX0], R1.y;\n"
+
+      "# Compute dot product of light direction and normal vector\n"
+      "DP3 R2, R0, R1;\n"
+
+      "MUL R3, Diffuse, R2;    # diffuse attenuation\n"
+
+      "POW R4, R2.x, {20.0}.x; # specular exponent\n"
+
+      "MUL R5, Specular, R4;   # specular attenuation\n"
+
+      "ADD o[COLR], R3, R5;    # add diffuse and specular colors\n"
+      "END \n"
+      ;
+
+   static const char *vertProgramText =
+      "!!VP1.0\n"
+      "# typical modelview/projection transform\n"
+      "DP4   o[HPOS].x, c[0], v[OPOS] ;\n"
+      "DP4   o[HPOS].y, c[1], v[OPOS] ;\n"
+      "DP4   o[HPOS].z, c[2], v[OPOS] ;\n"
+      "DP4   o[HPOS].w, c[3], v[OPOS] ;\n"
+      "# transform normal by inv transpose of modelview, put in tex0\n"
+      "DP4   o[TEX0].x, c[4], v[NRML] ;\n"
+      "DP4   o[TEX0].y, c[5], v[NRML] ;\n"
+      "DP4   o[TEX0].z, c[6], v[NRML] ;\n"
+      "DP4   o[TEX0].w, c[7], v[NRML] ;\n"
+      "END\n";
+   ;
+
+   if (!glutExtensionSupported("GL_NV_vertex_program")) {
+      printf("Sorry, this demo requires GL_NV_vertex_program\n");
+      exit(1);
+   }
+   if (!glutExtensionSupported("GL_NV_fragment_program")) {
+      printf("Sorry, this demo requires GL_NV_fragment_program\n");
+      exit(1);
+   }
+         
+   glGenProgramsNV(1, &FragProg);
+   assert(FragProg > 0);
+   glGenProgramsNV(1, &VertProg);
+   assert(VertProg > 0);
+
+   /*
+    * Fragment program
+    */
+   glLoadProgramNV(GL_FRAGMENT_PROGRAM_NV, FragProg,
+                   strlen(fragProgramText),
+                   (const GLubyte *) fragProgramText);
+   assert(glIsProgramNV(FragProg));
+   glBindProgramNV(GL_FRAGMENT_PROGRAM_NV, FragProg);
+
+   NAMED_PARAMETER4FV(FragProg, "Diffuse", Diffuse);
+   NAMED_PARAMETER4FV(FragProg, "Specular", Specular);
+
+   /*
+    * Vertex program
+    */
+   glLoadProgramNV(GL_VERTEX_PROGRAM_NV, VertProg,
+                   strlen(vertProgramText),
+                   (const GLubyte *) vertProgramText);
+   assert(glIsProgramNV(VertProg));
+   glBindProgramNV(GL_VERTEX_PROGRAM_NV, VertProg);
+   glTrackMatrixNV(GL_VERTEX_PROGRAM_NV, 0, GL_MODELVIEW_PROJECTION_NV, GL_IDENTITY_NV);
+   glTrackMatrixNV(GL_VERTEX_PROGRAM_NV, 4, GL_MODELVIEW, GL_INVERSE_TRANSPOSE_NV);
+
+   /*
+    * Misc init
+    */
+   glClearColor(0.3, 0.3, 0.3, 0.0);
+   glEnable(GL_DEPTH_TEST);
+   glEnable(GL_LIGHT0);
+   glEnable(GL_LIGHTING);
+   glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, Diffuse);
+   glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, Specular);
+   glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 20.0);
+
+   printf("GL_RENDERER = %s\n", (char *) glGetString(GL_RENDERER));
+   printf("Press p to toggle between per-pixel and per-vertex lighting\n");
+
+#ifdef GL_MESA_program_debug
+   if (argc > 1 && strcmp(argv[1], "fragment") == 0) {
+      printf(">> Debugging fragment program\n");
+      glProgramCallbackMESA(GL_FRAGMENT_PROGRAM_ARB, Debugger2,
+                            (GLvoid *) fragProgramText);
+      glEnable(GL_FRAGMENT_PROGRAM_CALLBACK_MESA);
+   }
+   else {
+      printf(">> Debugging vertex program\n");
+      glProgramCallbackMESA(GL_VERTEX_PROGRAM_ARB, Debugger2,
+                            (GLvoid *) fragProgramText);
+      glEnable(GL_VERTEX_PROGRAM_CALLBACK_MESA);
+   }
+#endif
+}
+
+
+int main( int argc, char *argv[] )
+{
+   glutInit( &argc, argv );
+   glutInitWindowPosition( 0, 0 );
+   glutInitWindowSize( 200, 200 );
+   glutInitDisplayMode( GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH );
+   glutCreateWindow(argv[0]);
+   glewInit();
+   glutReshapeFunc( Reshape );
+   glutKeyboardFunc( Key );
+   glutSpecialFunc( SpecialKey );
+   glutDisplayFunc( Display );
+   if (Anim)
+      glutIdleFunc(Idle);
+   Init(argc, argv);
+   glutMainLoop();
+   return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/tests/gremedy.c mesa-demos-8.4.0-new/src/tests/gremedy.c
--- mesa-demos-8.4.0-old/src/tests/gremedy.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/tests/gremedy.c	2020-04-11 09:49:44.113059934 -0700
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 1991, 1992, 1993 Silicon Graphics, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that (i) the above copyright notices and this permission notice appear in
+ * all copies of the software and related documentation, and (ii) the name of
+ * Silicon Graphics may not be used in any advertising or
+ * publicity relating to the software without the specific, prior written
+ * permission of Silicon Graphics.
+ *
+ * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF
+ * ANY KIND,
+ * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
+ * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * IN NO EVENT SHALL SILICON GRAPHICS BE LIABLE FOR
+ * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+ * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
+ * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <GL/glew.h>
+#include "glut_wrap.h"
+
+
+#define CI_OFFSET_1 16
+#define CI_OFFSET_2 32
+
+
+GLenum doubleBuffer = 1;
+int win;
+
+static void Init(void)
+{
+   fprintf(stderr, "GL_RENDERER   = %s\n", (char *) glGetString(GL_RENDERER));
+   fprintf(stderr, "GL_VERSION    = %s\n", (char *) glGetString(GL_VERSION));
+   fprintf(stderr, "GL_VENDOR     = %s\n", (char *) glGetString(GL_VENDOR));
+   fprintf(stderr, "GL_GREMEDY_string_marker = %i\n", GLEW_GREMEDY_string_marker);
+   fprintf(stderr, "GL_GREMEDY_frame_terminator = %i\n", GLEW_GREMEDY_frame_terminator);
+   fflush(stderr);
+
+   if (GLEW_GREMEDY_string_marker) {
+      glStringMarkerGREMEDY(0, __FUNCTION__);
+   }
+
+   glClearColor(0.3, 0.1, 0.3, 0.0);
+}
+
+static void Reshape(int width, int height)
+{
+   if (GLEW_GREMEDY_string_marker) {
+      glStringMarkerGREMEDY(0, __FUNCTION__);
+   }
+
+   glViewport(0, 0, (GLint)width, (GLint)height);
+
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+   glOrtho(-1.0, 1.0, -1.0, 1.0, -0.5, 1000.0);
+   glMatrixMode(GL_MODELVIEW);
+}
+
+static void Key(unsigned char key, int x, int y)
+{
+   switch (key) {
+      case 27:
+         glutDestroyWindow(win);
+         exit(0);
+      default:
+         glutPostRedisplay();
+         return;
+   }
+}
+
+static void Draw(void)
+{
+   if (GLEW_GREMEDY_string_marker) {
+      glStringMarkerGREMEDY(0, __FUNCTION__);
+   }
+
+   glClear(GL_COLOR_BUFFER_BIT); 
+
+   glBegin(GL_TRIANGLES);
+   glColor3f(.8,0,0); 
+   glVertex3f(-0.9, -0.9, -30.0);
+   glColor3f(0,.9,0); 
+   glVertex3f( 0.9, -0.9, -30.0);
+   glColor3f(0,0,.7); 
+   glVertex3f( 0.0,  0.9, -30.0);
+   glEnd();
+
+   glFlush();
+
+   if (GLEW_GREMEDY_frame_terminator) {
+      glFrameTerminatorGREMEDY();
+   }
+
+   if (doubleBuffer) {
+      glutSwapBuffers();
+   }
+}
+
+static GLenum Args(int argc, char **argv)
+{
+   GLint i;
+
+   for (i = 1; i < argc; i++) {
+      if (strcmp(argv[i], "-sb") == 0) {
+         doubleBuffer = GL_FALSE;
+      } else if (strcmp(argv[i], "-db") == 0) {
+         doubleBuffer = GL_TRUE;
+      } else {
+         fprintf(stderr, "%s (Bad option).\n", argv[i]);
+         return GL_FALSE;
+      }
+   }
+   return GL_TRUE;
+}
+
+int main(int argc, char **argv)
+{
+   GLenum type;
+
+   glutInit(&argc, argv);
+
+   if (Args(argc, argv) == GL_FALSE) {
+      exit(1);
+   }
+
+   glutInitWindowPosition(0, 0); glutInitWindowSize( 250, 250);
+
+   type = GLUT_RGB | GLUT_ALPHA;
+   type |= (doubleBuffer) ? GLUT_DOUBLE : GLUT_SINGLE;
+   glutInitDisplayMode(type);
+
+   win = glutCreateWindow(*argv);
+   if (!win) {
+      exit(1);
+   }
+
+   glewInit();
+
+   Init();
+
+   glutReshapeFunc(Reshape);
+   glutKeyboardFunc(Key);
+   glutDisplayFunc(Draw);
+   glutMainLoop();
+   return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/tools/dds.c mesa-demos-8.4.0-new/src/tools/dds.c
--- mesa-demos-8.4.0-old/src/tools/dds.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/tools/dds.c	2020-04-11 09:49:44.113059934 -0700
@@ -0,0 +1,385 @@
+/*
+ * dds.c -- dds texture loader
+ * last modification: aug. 14, 2007
+ *
+ * Copyright (c) 2005-2007 David HENRY
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+ * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * gcc -Wall -ansi -lGL -lGLU -lglut dds.c -o dds
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <GL/glew.h>
+#include "glut_wrap.h"
+
+
+/* OpenGL texture info */
+struct gl_texture_t
+{
+  GLsizei width;
+  GLsizei height;
+
+  GLenum format;
+  GLint internalFormat;
+  GLuint id;
+
+  GLubyte *texels;
+
+  GLint numMipmaps;
+};
+
+/* DirectDraw's structures */
+struct DDPixelFormat
+{
+  GLuint size;
+  GLuint flags;
+  GLuint fourCC;
+  GLuint bpp;
+  GLuint redMask;
+  GLuint greenMask;
+  GLuint blueMask;
+  GLuint alphaMask;
+};
+
+struct DDSCaps
+{
+  GLuint caps;
+  GLuint caps2;
+  GLuint caps3;
+  GLuint caps4;
+};
+
+struct DDColorKey
+{
+  GLuint lowVal;
+  GLuint highVal;
+};
+
+struct DDSurfaceDesc
+{
+  GLuint size;
+  GLuint flags;
+  GLuint height;
+  GLuint width;
+  GLuint pitch;
+  GLuint depth;
+  GLuint mipMapLevels;
+  GLuint alphaBitDepth;
+  GLuint reserved;
+  GLuint surface;
+
+  struct DDColorKey ckDestOverlay;
+  struct DDColorKey ckDestBlt;
+  struct DDColorKey ckSrcOverlay;
+  struct DDColorKey ckSrcBlt;
+
+  struct DDPixelFormat format;
+  struct DDSCaps caps;
+
+  GLuint textureStage;
+};
+
+#ifndef MAKEFOURCC
+#define MAKEFOURCC(ch0, ch1, ch2, ch3) \
+  (GLuint)( \
+    (((GLuint)(GLubyte)(ch3) << 24) & 0xFF000000) | \
+    (((GLuint)(GLubyte)(ch2) << 16) & 0x00FF0000) | \
+    (((GLuint)(GLubyte)(ch1) <<  8) & 0x0000FF00) | \
+     ((GLuint)(GLubyte)(ch0)        & 0x000000FF) )
+#endif
+
+#define FOURCC_DXT1 MAKEFOURCC('D', 'X', 'T', '1')
+#define FOURCC_DXT3 MAKEFOURCC('D', 'X', 'T', '3')
+#define FOURCC_DXT5 MAKEFOURCC('D', 'X', 'T', '5')
+
+/* texture Id */
+GLuint texId;
+
+
+#ifndef max
+static int
+max (int a, int b)
+{
+  return ((a > b) ? a : b);
+}
+#endif
+
+static struct gl_texture_t *
+ReadDDSFile (const char *filename)
+{
+  struct DDSurfaceDesc ddsd;
+  struct gl_texture_t *texinfo;
+  FILE *fp;
+  char magic[4];
+  long bufferSize, curr, end;
+
+  /* Open the file */
+  fp = fopen (filename, "rb");
+  if (!fp)
+    {
+      fprintf (stderr, "error: couldn't open \"%s\"!\n", filename);
+      return NULL;
+    }
+
+  /* Read magic number and check if valid .dds file */
+  fread (&magic, sizeof (char), 4, fp);
+
+  if (strncmp (magic, "DDS ", 4) != 0)
+    {
+      fprintf (stderr, "the file \"%s\" doesn't appear to be"
+	       "a valid .dds file!\n", filename);
+      fclose (fp);
+      return NULL;
+    }
+
+  /* Get the surface descriptor */
+  fread (&ddsd, sizeof (ddsd), 1, fp);
+
+  texinfo = (struct gl_texture_t *)
+    calloc (sizeof (struct gl_texture_t), 1);
+  texinfo->width = ddsd.width;
+  texinfo->height = ddsd.height;
+  texinfo->numMipmaps = ddsd.mipMapLevels;
+
+  switch (ddsd.format.fourCC)
+    {
+    case FOURCC_DXT1:
+      /* DXT1's compression ratio is 8:1 */
+      texinfo->format = GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
+      texinfo->internalFormat = 3;
+      break;
+
+    case FOURCC_DXT3:
+      /* DXT3's compression ratio is 4:1 */
+      texinfo->format = GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
+      texinfo->internalFormat = 4;
+      break;
+
+    case FOURCC_DXT5:
+      /* DXT5's compression ratio is 4:1 */
+      texinfo->format = GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
+      texinfo->internalFormat = 4;
+      break;
+
+    default:
+      /* Bad fourCC, unsupported or bad format */
+      fprintf (stderr, "the file \"%s\" doesn't appear to be"
+	       "compressed using DXT1, DXT3, or DXT5! [%i]\n",
+	       filename, ddsd.format.fourCC);
+      free (texinfo);
+      fclose (fp);
+      return NULL;
+    }
+
+  /* Calculate pixel data size */
+  curr = ftell (fp);
+  fseek (fp, 0, SEEK_END);
+  end = ftell (fp);
+  fseek (fp, curr, SEEK_SET);
+  bufferSize = end - curr;
+
+  /* Read pixel data with mipmaps */
+  texinfo->texels = (GLubyte *)malloc (bufferSize * sizeof (GLubyte));
+  fread (texinfo->texels, sizeof (GLubyte), bufferSize, fp);
+
+  /* Close the file */
+  fclose (fp);
+  return texinfo;
+}
+
+static GLuint
+loadDDSTexture (const char *filename)
+{
+  struct gl_texture_t *compressed_texture = NULL;
+  GLsizei mipWidth, mipHeight, mipSize;
+  int blockSize, offset;
+  GLuint tex_id = 0;
+  GLint mip;
+
+  /* Read texture from file */
+  compressed_texture = ReadDDSFile (filename);
+
+  if (compressed_texture && compressed_texture->texels)
+    {
+      /* Generate new texture */
+      glGenTextures (1, &compressed_texture->id);
+      glBindTexture (GL_TEXTURE_2D, compressed_texture->id);
+
+      /* Setup some parameters for texture filters and mipmapping */
+      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+      mipWidth = compressed_texture->width;
+      mipHeight = compressed_texture->height;
+      blockSize = (compressed_texture->format == GL_COMPRESSED_RGBA_S3TC_DXT1_EXT) ? 8 : 16;
+      offset = 0;
+
+      /* Upload mipmaps to video memory */
+      for (mip = 0; mip < compressed_texture->numMipmaps; ++mip)
+	{
+	  mipSize = ((mipWidth + 3) / 4) * ((mipHeight + 3) / 4) * blockSize;
+
+	  glCompressedTexImage2D (GL_TEXTURE_2D, mip, compressed_texture->format,
+				  mipWidth, mipHeight, 0, mipSize,
+				  compressed_texture->texels + offset);
+
+	  mipWidth = max (mipWidth >> 1, 1);
+	  mipHeight = max (mipHeight >> 1, 1);
+
+	  offset += mipSize;
+	}
+
+      tex_id = compressed_texture->id;
+
+      /* Opengl has its own copy of pixels */
+      free (compressed_texture->texels);
+      free (compressed_texture);
+    }
+
+  return tex_id;
+}
+
+static void
+cleanup (void)
+{
+  glDeleteTextures (1, &texId);
+}
+
+static void
+init (const char *filename)
+{
+  const char *glexts = (const char *)glGetString (GL_EXTENSIONS);
+
+  /* Initialize OpenGL */
+  glClearColor (0.5f, 0.5f, 0.5f, 1.0f);
+  glShadeModel (GL_SMOOTH);
+
+  glEnable (GL_DEPTH_TEST);
+
+  glEnable (GL_BLEND);
+  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+  /* Check for S3TC support */
+  if (!strstr (glexts, "GL_EXT_texture_compression_s3tc"))
+    {
+      fprintf (stderr, "error: GL_EXT_texture_compression_s3tc "
+	       "extension is required for DDS textures!\n");
+      exit(-1);
+    }
+
+
+  /* Load DDS texture from file */
+  texId = loadDDSTexture (filename);
+  if (!texId)
+    exit (EXIT_FAILURE);
+}
+
+static void
+reshape (int w, int h)
+{
+  if (h == 0)
+    h = 1;
+
+  glViewport (0, 0, (GLsizei)w, (GLsizei)h);
+
+  glMatrixMode (GL_PROJECTION);
+  glLoadIdentity ();
+  if (w <= h)
+    gluOrtho2D (-1.0, 1.0, -1.0*(GLfloat)h/(GLfloat)w, 1.0*(GLfloat)h/(GLfloat)w);
+  else
+    gluOrtho2D (-1.0*(GLfloat)w/(GLfloat)h, 1.0*(GLfloat)w/(GLfloat)h, -1.0, 1.0);
+
+  glMatrixMode (GL_MODELVIEW);
+  glLoadIdentity ();
+
+  glutPostRedisplay ();
+}
+
+static void
+display (void)
+{
+  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+  glLoadIdentity ();
+
+  glEnable (GL_TEXTURE_2D);
+  glBindTexture (GL_TEXTURE_2D, texId);
+
+  /* Draw textured quad */
+  glTranslatef (0.0, 0.0, 0.5);
+  glBegin (GL_QUADS);
+    glTexCoord2f (0.0f, 0.0f);
+    glVertex3f (-1.0f, -1.0f, 0.0f);
+
+    glTexCoord2f (1.0f, 0.0f);
+    glVertex3f (1.0f, -1.0f, 0.0f);
+
+    glTexCoord2f (1.0f, 1.0f);
+    glVertex3f (1.0f, 1.0f, 0.0f);
+
+    glTexCoord2f (0.0f, 1.0f);
+    glVertex3f (-1.0f, 1.0f, 0.0f);
+  glEnd  ();
+
+  glDisable (GL_TEXTURE_2D);
+
+  glutSwapBuffers ();
+}
+
+static void
+keyboard (unsigned char key, int x, int y)
+{
+  /* Escape */
+  if (key == 27)
+    exit (0);
+}
+
+int
+main (int argc, char *argv[])
+{
+  if (argc < 2)
+    {
+      fprintf (stderr, "usage: %s <filename.dds>\n", argv[0]);
+      return -1;
+    }
+
+  glutInit (&argc, argv);
+  glutInitDisplayMode (GLUT_RGBA | GLUT_DOUBLE);
+  glutInitWindowSize (512, 512);
+  glutCreateWindow ("DDS Texture Demo");
+
+  /* Initialize OpenGL extensions */
+  glewInit();
+
+  atexit (cleanup);
+  init (argv[1]);
+
+  glutReshapeFunc (reshape);
+  glutDisplayFunc (display);
+  glutKeyboardFunc (keyboard);
+
+  glutMainLoop ();
+
+  return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/util/dumpstate.c mesa-demos-8.4.0-new/src/util/dumpstate.c
--- mesa-demos-8.4.0-old/src/util/dumpstate.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/util/dumpstate.c	2020-04-11 09:49:44.113059934 -0700
@@ -0,0 +1,1959 @@
+
+/*
+ *
+ * From: Stephane Rehel <rehel@worldnet.fr>
+ * Date: Mon, 31 May 1999 18:40:54 -0400
+ * To: Paul Brian <brianp@ra.avid.com>
+ * Subject: OpenGL State Dump Function
+ * 
+ * Here is a function that dumps the current OpenGL state. I wrote it
+ * some time ago.
+ * 
+ * In the attachment:
+ *   + the code itself
+ *   + its output
+ * 
+ * I think Mesa is wrong on some getBooleanv(). For example, GL_VERTEX_ARRAY
+ * is queried by IsEnabled() (cf. p. 196 of the spec). But on page 193
+ * we can read that all the boolean attribs that can be queried by IsEnabled()
+ * can also be queried by IsEnabled().
+ * 
+ * I had duplicated all the enums (LOCAL_*) so that the code can run on any 
+ * OpenGL version, even if an enum is not recognized.
+ * 
+ * The code can be shipped in the public domain.
+ * 
+ * Stephane.
+ */
+
+
+/*
+ * Stephane Rehel
+ * Creation: February 5 1999
+ */
+
+#include <stdio.h>
+#include "gl_wrap.h"
+
+/***************************************************************************/
+
+enum {
+        /* Data types */
+        LOCAL_GL_BYTE                         = 0x1400,
+        LOCAL_GL_UNSIGNED_BYTE                = 0x1401,
+        LOCAL_GL_SHORT                        = 0x1402,
+        LOCAL_GL_UNSIGNED_SHORT               = 0x1403,
+        LOCAL_GL_INT                          = 0x1404,
+        LOCAL_GL_UNSIGNED_INT                 = 0x1405,
+        LOCAL_GL_FLOAT                        = 0x1406,
+        LOCAL_GL_DOUBLE                       = 0x140A,
+        LOCAL_GL_2_BYTES                      = 0x1407,
+        LOCAL_GL_3_BYTES                      = 0x1408,
+        LOCAL_GL_4_BYTES                      = 0x1409,
+
+        /* Primitives */
+        LOCAL_GL_LINES                        = 0x0001,
+        LOCAL_GL_POINTS                       = 0x0000,
+        LOCAL_GL_LINE_STRIP                   = 0x0003,
+        LOCAL_GL_LINE_LOOP                    = 0x0002,
+        LOCAL_GL_TRIANGLES                    = 0x0004,
+        LOCAL_GL_TRIANGLE_STRIP               = 0x0005,
+        LOCAL_GL_TRIANGLE_FAN                 = 0x0006,
+        LOCAL_GL_QUADS                        = 0x0007,
+        LOCAL_GL_QUAD_STRIP                   = 0x0008,
+        LOCAL_GL_POLYGON                      = 0x0009,
+        LOCAL_GL_EDGE_FLAG                    = 0x0B43,
+
+        /* Vertex Arrays */
+        LOCAL_GL_VERTEX_ARRAY                 = 0x8074,
+        LOCAL_GL_NORMAL_ARRAY                 = 0x8075,
+        LOCAL_GL_COLOR_ARRAY                  = 0x8076,
+        LOCAL_GL_INDEX_ARRAY                  = 0x8077,
+        LOCAL_GL_TEXTURE_COORD_ARRAY          = 0x8078,
+        LOCAL_GL_EDGE_FLAG_ARRAY              = 0x8079,
+        LOCAL_GL_VERTEX_ARRAY_SIZE            = 0x807A,
+        LOCAL_GL_VERTEX_ARRAY_TYPE            = 0x807B,
+        LOCAL_GL_VERTEX_ARRAY_STRIDE          = 0x807C,
+        LOCAL_GL_NORMAL_ARRAY_TYPE            = 0x807E,
+        LOCAL_GL_NORMAL_ARRAY_STRIDE          = 0x807F,
+        LOCAL_GL_COLOR_ARRAY_SIZE             = 0x8081,
+        LOCAL_GL_COLOR_ARRAY_TYPE             = 0x8082,
+        LOCAL_GL_COLOR_ARRAY_STRIDE           = 0x8083,
+        LOCAL_GL_INDEX_ARRAY_TYPE             = 0x8085,
+        LOCAL_GL_INDEX_ARRAY_STRIDE           = 0x8086,
+        LOCAL_GL_TEXTURE_COORD_ARRAY_SIZE     = 0x8088,
+        LOCAL_GL_TEXTURE_COORD_ARRAY_TYPE     = 0x8089,
+        LOCAL_GL_TEXTURE_COORD_ARRAY_STRIDE   = 0x808A,
+        LOCAL_GL_EDGE_FLAG_ARRAY_STRIDE       = 0x808C,
+        LOCAL_GL_VERTEX_ARRAY_POINTER         = 0x808E,
+        LOCAL_GL_NORMAL_ARRAY_POINTER         = 0x808F,
+        LOCAL_GL_COLOR_ARRAY_POINTER          = 0x8090,
+        LOCAL_GL_INDEX_ARRAY_POINTER          = 0x8091,
+        LOCAL_GL_TEXTURE_COORD_ARRAY_POINTER  = 0x8092,
+        LOCAL_GL_EDGE_FLAG_ARRAY_POINTER      = 0x8093,
+        LOCAL_GL_V2F                          = 0x2A20,
+        LOCAL_GL_V3F                          = 0x2A21,
+        LOCAL_GL_C4UB_V2F                     = 0x2A22,
+        LOCAL_GL_C4UB_V3F                     = 0x2A23,
+        LOCAL_GL_C3F_V3F                      = 0x2A24,
+        LOCAL_GL_N3F_V3F                      = 0x2A25,
+        LOCAL_GL_C4F_N3F_V3F                  = 0x2A26,
+        LOCAL_GL_T2F_V3F                      = 0x2A27,
+        LOCAL_GL_T4F_V4F                      = 0x2A28,
+        LOCAL_GL_T2F_C4UB_V3F                 = 0x2A29,
+        LOCAL_GL_T2F_C3F_V3F                  = 0x2A2A,
+        LOCAL_GL_T2F_N3F_V3F                  = 0x2A2B,
+        LOCAL_GL_T2F_C4F_N3F_V3F              = 0x2A2C,
+        LOCAL_GL_T4F_C4F_N3F_V4F              = 0x2A2D,
+
+        /* Matrix Mode */
+        LOCAL_GL_MATRIX_MODE                  = 0x0BA0,
+        LOCAL_GL_MODELVIEW                    = 0x1700,
+        LOCAL_GL_PROJECTION                   = 0x1701,
+        LOCAL_GL_TEXTURE                      = 0x1702,
+
+        /* Points */
+        LOCAL_GL_POINT_SMOOTH                 = 0x0B10,
+        LOCAL_GL_POINT_SIZE                   = 0x0B11,
+        LOCAL_GL_POINT_SIZE_GRANULARITY       = 0x0B13,
+        LOCAL_GL_POINT_SIZE_RANGE             = 0x0B12,
+
+        /* Lines */
+        LOCAL_GL_LINE_SMOOTH                  = 0x0B20,
+        LOCAL_GL_LINE_STIPPLE                 = 0x0B24,
+        LOCAL_GL_LINE_STIPPLE_PATTERN         = 0x0B25,
+        LOCAL_GL_LINE_STIPPLE_REPEAT          = 0x0B26,
+        LOCAL_GL_LINE_WIDTH                   = 0x0B21,
+        LOCAL_GL_LINE_WIDTH_GRANULARITY       = 0x0B23,
+        LOCAL_GL_LINE_WIDTH_RANGE             = 0x0B22,
+
+        /* Polygons */
+        LOCAL_GL_POINT                        = 0x1B00,
+        LOCAL_GL_LINE                         = 0x1B01,
+        LOCAL_GL_FILL                         = 0x1B02,
+        LOCAL_GL_CCW                          = 0x0901,
+        LOCAL_GL_CW                           = 0x0900,
+        LOCAL_GL_FRONT                        = 0x0404,
+        LOCAL_GL_BACK                         = 0x0405,
+        LOCAL_GL_CULL_FACE                    = 0x0B44,
+        LOCAL_GL_CULL_FACE_MODE               = 0x0B45,
+        LOCAL_GL_POLYGON_SMOOTH               = 0x0B41,
+        LOCAL_GL_POLYGON_STIPPLE              = 0x0B42,
+        LOCAL_GL_FRONT_FACE                   = 0x0B46,
+        LOCAL_GL_POLYGON_MODE                 = 0x0B40,
+        LOCAL_GL_POLYGON_OFFSET_FACTOR        = 0x8038,
+        LOCAL_GL_POLYGON_OFFSET_UNITS         = 0x2A00,
+        LOCAL_GL_POLYGON_OFFSET_POINT         = 0x2A01,
+        LOCAL_GL_POLYGON_OFFSET_LINE          = 0x2A02,
+        LOCAL_GL_POLYGON_OFFSET_FILL          = 0x8037,
+
+        /* Display Lists */
+        LOCAL_GL_COMPILE                      = 0x1300,
+        LOCAL_GL_COMPILE_AND_EXECUTE          = 0x1301,
+        LOCAL_GL_LIST_BASE                    = 0x0B32,
+        LOCAL_GL_LIST_INDEX                   = 0x0B33,
+        LOCAL_GL_LIST_MODE                    = 0x0B30,
+
+        /* Depth buffer */
+        LOCAL_GL_NEVER                        = 0x0200,
+        LOCAL_GL_LESS                         = 0x0201,
+        LOCAL_GL_GEQUAL                       = 0x0206,
+        LOCAL_GL_LEQUAL                       = 0x0203,
+        LOCAL_GL_GREATER                      = 0x0204,
+        LOCAL_GL_NOTEQUAL                     = 0x0205,
+        LOCAL_GL_EQUAL                        = 0x0202,
+        LOCAL_GL_ALWAYS                       = 0x0207,
+        LOCAL_GL_DEPTH_TEST                   = 0x0B71,
+        LOCAL_GL_DEPTH_BITS                   = 0x0D56,
+        LOCAL_GL_DEPTH_CLEAR_VALUE            = 0x0B73,
+        LOCAL_GL_DEPTH_FUNC                   = 0x0B74,
+        LOCAL_GL_DEPTH_RANGE                  = 0x0B70,
+        LOCAL_GL_DEPTH_WRITEMASK              = 0x0B72,
+        LOCAL_GL_DEPTH_COMPONENT              = 0x1902,
+
+        /* Lighting */
+        LOCAL_GL_LIGHTING                     = 0x0B50,
+        LOCAL_GL_LIGHT0                       = 0x4000,
+        LOCAL_GL_LIGHT1                       = 0x4001,
+        LOCAL_GL_LIGHT2                       = 0x4002,
+        LOCAL_GL_LIGHT3                       = 0x4003,
+        LOCAL_GL_LIGHT4                       = 0x4004,
+        LOCAL_GL_LIGHT5                       = 0x4005,
+        LOCAL_GL_LIGHT6                       = 0x4006,
+        LOCAL_GL_LIGHT7                       = 0x4007,
+        LOCAL_GL_SPOT_EXPONENT                = 0x1205,
+        LOCAL_GL_SPOT_CUTOFF                  = 0x1206,
+        LOCAL_GL_CONSTANT_ATTENUATION         = 0x1207,
+        LOCAL_GL_LINEAR_ATTENUATION           = 0x1208,
+        LOCAL_GL_QUADRATIC_ATTENUATION        = 0x1209,
+        LOCAL_GL_AMBIENT                      = 0x1200,
+        LOCAL_GL_DIFFUSE                      = 0x1201,
+        LOCAL_GL_SPECULAR                     = 0x1202,
+        LOCAL_GL_SHININESS                    = 0x1601,
+        LOCAL_GL_EMISSION                     = 0x1600,
+        LOCAL_GL_POSITION                     = 0x1203,
+        LOCAL_GL_SPOT_DIRECTION               = 0x1204,
+        LOCAL_GL_AMBIENT_AND_DIFFUSE          = 0x1602,
+        LOCAL_GL_COLOR_INDEXES                = 0x1603,
+        LOCAL_GL_LIGHT_MODEL_TWO_SIDE         = 0x0B52,
+        LOCAL_GL_LIGHT_MODEL_LOCAL_VIEWER     = 0x0B51,
+        LOCAL_GL_LIGHT_MODEL_AMBIENT          = 0x0B53,
+        LOCAL_GL_FRONT_AND_BACK               = 0x0408,
+        LOCAL_GL_SHADE_MODEL                  = 0x0B54,
+        LOCAL_GL_FLAT                         = 0x1D00,
+        LOCAL_GL_SMOOTH                       = 0x1D01,
+        LOCAL_GL_COLOR_MATERIAL               = 0x0B57,
+        LOCAL_GL_COLOR_MATERIAL_FACE          = 0x0B55,
+        LOCAL_GL_COLOR_MATERIAL_PARAMETER     = 0x0B56,
+        LOCAL_GL_NORMALIZE                    = 0x0BA1,
+
+        /* User clipping planes */
+        LOCAL_GL_CLIP_PLANE0                  = 0x3000,
+        LOCAL_GL_CLIP_PLANE1                  = 0x3001,
+        LOCAL_GL_CLIP_PLANE2                  = 0x3002,
+        LOCAL_GL_CLIP_PLANE3                  = 0x3003,
+        LOCAL_GL_CLIP_PLANE4                  = 0x3004,
+        LOCAL_GL_CLIP_PLANE5                  = 0x3005,
+
+        /* Accumulation buffer */
+        LOCAL_GL_ACCUM_RED_BITS               = 0x0D58,
+        LOCAL_GL_ACCUM_GREEN_BITS             = 0x0D59,
+        LOCAL_GL_ACCUM_BLUE_BITS              = 0x0D5A,
+        LOCAL_GL_ACCUM_ALPHA_BITS             = 0x0D5B,
+        LOCAL_GL_ACCUM_CLEAR_VALUE            = 0x0B80,
+        LOCAL_GL_ACCUM                        = 0x0100,
+        LOCAL_GL_ADD                          = 0x0104,
+        LOCAL_GL_LOAD                         = 0x0101,
+        LOCAL_GL_MULT                         = 0x0103,
+        LOCAL_GL_RETURN                       = 0x0102,
+
+        /* Alpha testing */
+        LOCAL_GL_ALPHA_TEST                   = 0x0BC0,
+        LOCAL_GL_ALPHA_TEST_REF               = 0x0BC2,
+        LOCAL_GL_ALPHA_TEST_FUNC              = 0x0BC1,
+
+        /* Blending */
+        LOCAL_GL_BLEND                        = 0x0BE2,
+        LOCAL_GL_BLEND_SRC                    = 0x0BE1,
+        LOCAL_GL_BLEND_DST                    = 0x0BE0,
+        LOCAL_GL_ZERO                         = 0,
+        LOCAL_GL_ONE                          = 1,
+        LOCAL_GL_SRC_COLOR                    = 0x0300,
+        LOCAL_GL_ONE_MINUS_SRC_COLOR          = 0x0301,
+        LOCAL_GL_DST_COLOR                    = 0x0306,
+        LOCAL_GL_ONE_MINUS_DST_COLOR          = 0x0307,
+        LOCAL_GL_SRC_ALPHA                    = 0x0302,
+        LOCAL_GL_ONE_MINUS_SRC_ALPHA          = 0x0303,
+        LOCAL_GL_DST_ALPHA                    = 0x0304,
+        LOCAL_GL_ONE_MINUS_DST_ALPHA          = 0x0305,
+        LOCAL_GL_SRC_ALPHA_SATURATE           = 0x0308,
+        LOCAL_GL_CONSTANT_COLOR               = 0x8001,
+        LOCAL_GL_ONE_MINUS_CONSTANT_COLOR     = 0x8002,
+        LOCAL_GL_CONSTANT_ALPHA               = 0x8003,
+        LOCAL_GL_ONE_MINUS_CONSTANT_ALPHA     = 0x8004,
+
+        /* Render Mode */
+        LOCAL_GL_FEEDBACK                     = 0x1C01,
+        LOCAL_GL_RENDER                       = 0x1C00,
+        LOCAL_GL_SELECT                       = 0x1C02,
+
+        /* Feedback */
+        LOCAL_GL_2D                           = 0x0600,
+        LOCAL_GL_3D                           = 0x0601,
+        LOCAL_GL_3D_COLOR                     = 0x0602,
+        LOCAL_GL_3D_COLOR_TEXTURE             = 0x0603,
+        LOCAL_GL_4D_COLOR_TEXTURE             = 0x0604,
+        LOCAL_GL_POINT_TOKEN                  = 0x0701,
+        LOCAL_GL_LINE_TOKEN                   = 0x0702,
+        LOCAL_GL_LINE_RESET_TOKEN             = 0x0707,
+        LOCAL_GL_POLYGON_TOKEN                = 0x0703,
+        LOCAL_GL_BITMAP_TOKEN                 = 0x0704,
+        LOCAL_GL_DRAW_PIXEL_TOKEN             = 0x0705,
+        LOCAL_GL_COPY_PIXEL_TOKEN             = 0x0706,
+        LOCAL_GL_PASS_THROUGH_TOKEN           = 0x0700,
+        LOCAL_GL_FEEDBACK_BUFFER_POINTER      = 0x0DF0,
+        LOCAL_GL_FEEDBACK_BUFFER_SIZE         = 0x0DF1,
+        LOCAL_GL_FEEDBACK_BUFFER_TYPE         = 0x0DF2,
+
+        /* Selection */
+        LOCAL_GL_SELECTION_BUFFER_POINTER     = 0x0DF3,
+        LOCAL_GL_SELECTION_BUFFER_SIZE        = 0x0DF4,
+
+        /* Fog */
+        LOCAL_GL_FOG                          = 0x0B60,
+        LOCAL_GL_FOG_MODE                     = 0x0B65,
+        LOCAL_GL_FOG_DENSITY                  = 0x0B62,
+        LOCAL_GL_FOG_COLOR                    = 0x0B66,
+        LOCAL_GL_FOG_INDEX                    = 0x0B61,
+        LOCAL_GL_FOG_START                    = 0x0B63,
+        LOCAL_GL_FOG_END                      = 0x0B64,
+        LOCAL_GL_LINEAR                       = 0x2601,
+        LOCAL_GL_EXP                          = 0x0800,
+        LOCAL_GL_EXP2                         = 0x0801,
+
+        /* Logic Ops */
+        LOCAL_GL_LOGIC_OP                     = 0x0BF1,
+        LOCAL_GL_INDEX_LOGIC_OP               = 0x0BF1,
+        LOCAL_GL_COLOR_LOGIC_OP               = 0x0BF2,
+        LOCAL_GL_LOGIC_OP_MODE                = 0x0BF0,
+        LOCAL_GL_CLEAR                        = 0x1500,
+        LOCAL_GL_SET                          = 0x150F,
+        LOCAL_GL_COPY                         = 0x1503,
+        LOCAL_GL_COPY_INVERTED                = 0x150C,
+        LOCAL_GL_NOOP                         = 0x1505,
+        LOCAL_GL_INVERT                       = 0x150A,
+        LOCAL_GL_AND                          = 0x1501,
+        LOCAL_GL_NAND                         = 0x150E,
+        LOCAL_GL_OR                           = 0x1507,
+        LOCAL_GL_NOR                          = 0x1508,
+        LOCAL_GL_XOR                          = 0x1506,
+        LOCAL_GL_EQUIV                        = 0x1509,
+        LOCAL_GL_AND_REVERSE                  = 0x1502,
+        LOCAL_GL_AND_INVERTED                 = 0x1504,
+        LOCAL_GL_OR_REVERSE                   = 0x150B,
+        LOCAL_GL_OR_INVERTED                  = 0x150D,
+
+        /* Stencil */
+        LOCAL_GL_STENCIL_TEST                 = 0x0B90,
+        LOCAL_GL_STENCIL_WRITEMASK            = 0x0B98,
+        LOCAL_GL_STENCIL_BITS                 = 0x0D57,
+        LOCAL_GL_STENCIL_FUNC                 = 0x0B92,
+        LOCAL_GL_STENCIL_VALUE_MASK           = 0x0B93,
+        LOCAL_GL_STENCIL_REF                  = 0x0B97,
+        LOCAL_GL_STENCIL_FAIL                 = 0x0B94,
+        LOCAL_GL_STENCIL_PASS_DEPTH_PASS      = 0x0B96,
+        LOCAL_GL_STENCIL_PASS_DEPTH_FAIL      = 0x0B95,
+        LOCAL_GL_STENCIL_CLEAR_VALUE          = 0x0B91,
+        LOCAL_GL_STENCIL_INDEX                = 0x1901,
+        LOCAL_GL_KEEP                         = 0x1E00,
+        LOCAL_GL_REPLACE                      = 0x1E01,
+        LOCAL_GL_INCR                         = 0x1E02,
+        LOCAL_GL_DECR                         = 0x1E03,
+
+        /* Buffers, Pixel Drawing/Reading */
+        LOCAL_GL_NONE                         = 0,
+        LOCAL_GL_LEFT                         = 0x0406,
+        LOCAL_GL_RIGHT                        = 0x0407,
+        /*LOCAL_GL_FRONT                      = 0x0404, */
+        /*LOCAL_GL_BACK                       = 0x0405, */
+        /*LOCAL_GL_FRONT_AND_BACK             = 0x0408, */
+        LOCAL_GL_FRONT_LEFT                   = 0x0400,
+        LOCAL_GL_FRONT_RIGHT                  = 0x0401,
+        LOCAL_GL_BACK_LEFT                    = 0x0402,
+        LOCAL_GL_BACK_RIGHT                   = 0x0403,
+        LOCAL_GL_AUX0                         = 0x0409,
+        LOCAL_GL_AUX1                         = 0x040A,
+        LOCAL_GL_AUX2                         = 0x040B,
+        LOCAL_GL_AUX3                         = 0x040C,
+        LOCAL_GL_COLOR_INDEX                  = 0x1900,
+        LOCAL_GL_RED                          = 0x1903,
+        LOCAL_GL_GREEN                        = 0x1904,
+        LOCAL_GL_BLUE                         = 0x1905,
+        LOCAL_GL_ALPHA                        = 0x1906,
+        LOCAL_GL_LUMINANCE                    = 0x1909,
+        LOCAL_GL_LUMINANCE_ALPHA              = 0x190A,
+        LOCAL_GL_ALPHA_BITS                   = 0x0D55,
+        LOCAL_GL_RED_BITS                     = 0x0D52,
+        LOCAL_GL_GREEN_BITS                   = 0x0D53,
+        LOCAL_GL_BLUE_BITS                    = 0x0D54,
+        LOCAL_GL_INDEX_BITS                   = 0x0D51,
+        LOCAL_GL_SUBPIXEL_BITS                = 0x0D50,
+        LOCAL_GL_AUX_BUFFERS                  = 0x0C00,
+        LOCAL_GL_READ_BUFFER                  = 0x0C02,
+        LOCAL_GL_DRAW_BUFFER                  = 0x0C01,
+        LOCAL_GL_DOUBLEBUFFER                 = 0x0C32,
+        LOCAL_GL_STEREO                       = 0x0C33,
+        LOCAL_GL_BITMAP                       = 0x1A00,
+        LOCAL_GL_COLOR                        = 0x1800,
+        LOCAL_GL_DEPTH                        = 0x1801,
+        LOCAL_GL_STENCIL                      = 0x1802,
+        LOCAL_GL_DITHER                       = 0x0BD0,
+        LOCAL_GL_RGB                          = 0x1907,
+        LOCAL_GL_RGBA                         = 0x1908,
+
+        /* Implementation limits */
+        LOCAL_GL_MAX_LIST_NESTING             = 0x0B31,
+        LOCAL_GL_MAX_ATTRIB_STACK_DEPTH       = 0x0D35,
+        LOCAL_GL_MAX_MODELVIEW_STACK_DEPTH    = 0x0D36,
+        LOCAL_GL_MAX_NAME_STACK_DEPTH         = 0x0D37,
+        LOCAL_GL_MAX_PROJECTION_STACK_DEPTH   = 0x0D38,
+        LOCAL_GL_MAX_TEXTURE_STACK_DEPTH      = 0x0D39,
+        LOCAL_GL_MAX_EVAL_ORDER               = 0x0D30,
+        LOCAL_GL_MAX_LIGHTS                   = 0x0D31,
+        LOCAL_GL_MAX_CLIP_PLANES              = 0x0D32,
+        LOCAL_GL_MAX_TEXTURE_SIZE             = 0x0D33,
+        LOCAL_GL_MAX_PIXEL_MAP_TABLE          = 0x0D34,
+        LOCAL_GL_MAX_VIEWPORT_DIMS            = 0x0D3A,
+        LOCAL_GL_MAX_CLIENT_ATTRIB_STACK_DEPTH= 0x0D3B,
+
+        /* Gets */
+        LOCAL_GL_ATTRIB_STACK_DEPTH           = 0x0BB0,
+        LOCAL_GL_CLIENT_ATTRIB_STACK_DEPTH    = 0x0BB1,
+        LOCAL_GL_COLOR_CLEAR_VALUE            = 0x0C22,
+        LOCAL_GL_COLOR_WRITEMASK              = 0x0C23,
+        LOCAL_GL_CURRENT_INDEX                = 0x0B01,
+        LOCAL_GL_CURRENT_COLOR                = 0x0B00,
+        LOCAL_GL_CURRENT_NORMAL               = 0x0B02,
+        LOCAL_GL_CURRENT_RASTER_COLOR         = 0x0B04,
+        LOCAL_GL_CURRENT_RASTER_DISTANCE      = 0x0B09,
+        LOCAL_GL_CURRENT_RASTER_INDEX         = 0x0B05,
+        LOCAL_GL_CURRENT_RASTER_POSITION      = 0x0B07,
+        LOCAL_GL_CURRENT_RASTER_TEXTURE_COORDS = 0x0B06,
+        LOCAL_GL_CURRENT_RASTER_POSITION_VALID = 0x0B08,
+        LOCAL_GL_CURRENT_TEXTURE_COORDS       = 0x0B03,
+        LOCAL_GL_INDEX_CLEAR_VALUE            = 0x0C20,
+        LOCAL_GL_INDEX_MODE                   = 0x0C30,
+        LOCAL_GL_INDEX_WRITEMASK              = 0x0C21,
+        LOCAL_GL_MODELVIEW_MATRIX             = 0x0BA6,
+        LOCAL_GL_MODELVIEW_STACK_DEPTH        = 0x0BA3,
+        LOCAL_GL_NAME_STACK_DEPTH             = 0x0D70,
+        LOCAL_GL_PROJECTION_MATRIX            = 0x0BA7,
+        LOCAL_GL_PROJECTION_STACK_DEPTH       = 0x0BA4,
+        LOCAL_GL_RENDER_MODE                  = 0x0C40,
+        LOCAL_GL_RGBA_MODE                    = 0x0C31,
+        LOCAL_GL_TEXTURE_MATRIX               = 0x0BA8,
+        LOCAL_GL_TEXTURE_STACK_DEPTH          = 0x0BA5,
+        LOCAL_GL_VIEWPORT                     = 0x0BA2,
+
+
+        /* Evaluators */
+        LOCAL_GL_AUTO_NORMAL                  = 0x0D80,
+        LOCAL_GL_MAP1_COLOR_4                 = 0x0D90,
+        LOCAL_GL_MAP1_GRID_DOMAIN             = 0x0DD0,
+        LOCAL_GL_MAP1_GRID_SEGMENTS           = 0x0DD1,
+        LOCAL_GL_MAP1_INDEX                   = 0x0D91,
+        LOCAL_GL_MAP1_NORMAL                  = 0x0D92,
+        LOCAL_GL_MAP1_TEXTURE_COORD_1         = 0x0D93,
+        LOCAL_GL_MAP1_TEXTURE_COORD_2         = 0x0D94,
+        LOCAL_GL_MAP1_TEXTURE_COORD_3         = 0x0D95,
+        LOCAL_GL_MAP1_TEXTURE_COORD_4         = 0x0D96,
+        LOCAL_GL_MAP1_VERTEX_3                = 0x0D97,
+        LOCAL_GL_MAP1_VERTEX_4                = 0x0D98,
+        LOCAL_GL_MAP2_COLOR_4                 = 0x0DB0,
+        LOCAL_GL_MAP2_GRID_DOMAIN             = 0x0DD2,
+        LOCAL_GL_MAP2_GRID_SEGMENTS           = 0x0DD3,
+        LOCAL_GL_MAP2_INDEX                   = 0x0DB1,
+        LOCAL_GL_MAP2_NORMAL                  = 0x0DB2,
+        LOCAL_GL_MAP2_TEXTURE_COORD_1         = 0x0DB3,
+        LOCAL_GL_MAP2_TEXTURE_COORD_2         = 0x0DB4,
+        LOCAL_GL_MAP2_TEXTURE_COORD_3         = 0x0DB5,
+        LOCAL_GL_MAP2_TEXTURE_COORD_4         = 0x0DB6,
+        LOCAL_GL_MAP2_VERTEX_3                = 0x0DB7,
+        LOCAL_GL_MAP2_VERTEX_4                = 0x0DB8,
+        LOCAL_GL_COEFF                        = 0x0A00,
+        LOCAL_GL_DOMAIN                       = 0x0A02,
+        LOCAL_GL_ORDER                        = 0x0A01,
+
+        /* Hints */
+        LOCAL_GL_FOG_HINT                     = 0x0C54,
+        LOCAL_GL_LINE_SMOOTH_HINT             = 0x0C52,
+        LOCAL_GL_PERSPECTIVE_CORRECTION_HINT  = 0x0C50,
+        LOCAL_GL_POINT_SMOOTH_HINT            = 0x0C51,
+        LOCAL_GL_POLYGON_SMOOTH_HINT          = 0x0C53,
+        LOCAL_GL_DONT_CARE                    = 0x1100,
+        LOCAL_GL_FASTEST                      = 0x1101,
+        LOCAL_GL_NICEST                       = 0x1102,
+
+        /* Scissor box */
+        LOCAL_GL_SCISSOR_TEST                 = 0x0C11,
+        LOCAL_GL_SCISSOR_BOX                  = 0x0C10,
+
+        /* Pixel Mode / Transfer */
+        LOCAL_GL_MAP_COLOR                    = 0x0D10,
+        LOCAL_GL_MAP_STENCIL                  = 0x0D11,
+        LOCAL_GL_INDEX_SHIFT                  = 0x0D12,
+        LOCAL_GL_INDEX_OFFSET                 = 0x0D13,
+        LOCAL_GL_RED_SCALE                    = 0x0D14,
+        LOCAL_GL_RED_BIAS                     = 0x0D15,
+        LOCAL_GL_GREEN_SCALE                  = 0x0D18,
+        LOCAL_GL_GREEN_BIAS                   = 0x0D19,
+        LOCAL_GL_BLUE_SCALE                   = 0x0D1A,
+        LOCAL_GL_BLUE_BIAS                    = 0x0D1B,
+        LOCAL_GL_ALPHA_SCALE                  = 0x0D1C,
+        LOCAL_GL_ALPHA_BIAS                   = 0x0D1D,
+        LOCAL_GL_DEPTH_SCALE                  = 0x0D1E,
+        LOCAL_GL_DEPTH_BIAS                   = 0x0D1F,
+        LOCAL_GL_PIXEL_MAP_S_TO_S_SIZE        = 0x0CB1,
+        LOCAL_GL_PIXEL_MAP_I_TO_I_SIZE        = 0x0CB0,
+        LOCAL_GL_PIXEL_MAP_I_TO_R_SIZE        = 0x0CB2,
+        LOCAL_GL_PIXEL_MAP_I_TO_G_SIZE        = 0x0CB3,
+        LOCAL_GL_PIXEL_MAP_I_TO_B_SIZE        = 0x0CB4,
+        LOCAL_GL_PIXEL_MAP_I_TO_A_SIZE        = 0x0CB5,
+        LOCAL_GL_PIXEL_MAP_R_TO_R_SIZE        = 0x0CB6,
+        LOCAL_GL_PIXEL_MAP_G_TO_G_SIZE        = 0x0CB7,
+        LOCAL_GL_PIXEL_MAP_B_TO_B_SIZE        = 0x0CB8,
+        LOCAL_GL_PIXEL_MAP_A_TO_A_SIZE        = 0x0CB9,
+        LOCAL_GL_PIXEL_MAP_S_TO_S             = 0x0C71,
+        LOCAL_GL_PIXEL_MAP_I_TO_I             = 0x0C70,
+        LOCAL_GL_PIXEL_MAP_I_TO_R             = 0x0C72,
+        LOCAL_GL_PIXEL_MAP_I_TO_G             = 0x0C73,
+        LOCAL_GL_PIXEL_MAP_I_TO_B             = 0x0C74,
+        LOCAL_GL_PIXEL_MAP_I_TO_A             = 0x0C75,
+        LOCAL_GL_PIXEL_MAP_R_TO_R             = 0x0C76,
+        LOCAL_GL_PIXEL_MAP_G_TO_G             = 0x0C77,
+        LOCAL_GL_PIXEL_MAP_B_TO_B             = 0x0C78,
+        LOCAL_GL_PIXEL_MAP_A_TO_A             = 0x0C79,
+        LOCAL_GL_PACK_ALIGNMENT               = 0x0D05,
+        LOCAL_GL_PACK_LSB_FIRST               = 0x0D01,
+        LOCAL_GL_PACK_ROW_LENGTH              = 0x0D02,
+        LOCAL_GL_PACK_SKIP_PIXELS             = 0x0D04,
+        LOCAL_GL_PACK_SKIP_ROWS               = 0x0D03,
+        LOCAL_GL_PACK_SWAP_BYTES              = 0x0D00,
+        LOCAL_GL_UNPACK_ALIGNMENT             = 0x0CF5,
+        LOCAL_GL_UNPACK_LSB_FIRST             = 0x0CF1,
+        LOCAL_GL_UNPACK_ROW_LENGTH            = 0x0CF2,
+        LOCAL_GL_UNPACK_SKIP_PIXELS           = 0x0CF4,
+        LOCAL_GL_UNPACK_SKIP_ROWS             = 0x0CF3,
+        LOCAL_GL_UNPACK_SWAP_BYTES            = 0x0CF0,
+        LOCAL_GL_ZOOM_X                       = 0x0D16,
+        LOCAL_GL_ZOOM_Y                       = 0x0D17,
+
+        /* Texture mapping */
+        LOCAL_GL_TEXTURE_ENV                  = 0x2300,
+        LOCAL_GL_TEXTURE_ENV_MODE             = 0x2200,
+        LOCAL_GL_TEXTURE_1D                   = 0x0DE0,
+        LOCAL_GL_TEXTURE_2D                   = 0x0DE1,
+        LOCAL_GL_TEXTURE_WRAP_S               = 0x2802,
+        LOCAL_GL_TEXTURE_WRAP_T               = 0x2803,
+        LOCAL_GL_TEXTURE_MAG_FILTER           = 0x2800,
+        LOCAL_GL_TEXTURE_MIN_FILTER           = 0x2801,
+        LOCAL_GL_TEXTURE_ENV_COLOR            = 0x2201,
+        LOCAL_GL_TEXTURE_GEN_S                = 0x0C60,
+        LOCAL_GL_TEXTURE_GEN_T                = 0x0C61,
+        LOCAL_GL_TEXTURE_GEN_MODE             = 0x2500,
+        LOCAL_GL_TEXTURE_BORDER_COLOR         = 0x1004,
+        LOCAL_GL_TEXTURE_WIDTH                = 0x1000,
+        LOCAL_GL_TEXTURE_HEIGHT               = 0x1001,
+        LOCAL_GL_TEXTURE_BORDER               = 0x1005,
+        LOCAL_GL_TEXTURE_COMPONENTS           = 0x1003,
+        LOCAL_GL_TEXTURE_RED_SIZE             = 0x805C,
+        LOCAL_GL_TEXTURE_GREEN_SIZE           = 0x805D,
+        LOCAL_GL_TEXTURE_BLUE_SIZE            = 0x805E,
+        LOCAL_GL_TEXTURE_ALPHA_SIZE           = 0x805F,
+        LOCAL_GL_TEXTURE_LUMINANCE_SIZE       = 0x8060,
+        LOCAL_GL_TEXTURE_INTENSITY_SIZE       = 0x8061,
+        LOCAL_GL_NEAREST_MIPMAP_NEAREST       = 0x2700,
+        LOCAL_GL_NEAREST_MIPMAP_LINEAR        = 0x2702,
+        LOCAL_GL_LINEAR_MIPMAP_NEAREST        = 0x2701,
+        LOCAL_GL_LINEAR_MIPMAP_LINEAR         = 0x2703,
+        LOCAL_GL_OBJECT_LINEAR                = 0x2401,
+        LOCAL_GL_OBJECT_PLANE                 = 0x2501,
+        LOCAL_GL_EYE_LINEAR                   = 0x2400,
+        LOCAL_GL_EYE_PLANE                    = 0x2502,
+        LOCAL_GL_SPHERE_MAP                   = 0x2402,
+        LOCAL_GL_DECAL                        = 0x2101,
+        LOCAL_GL_MODULATE                     = 0x2100,
+        LOCAL_GL_NEAREST                      = 0x2600,
+        LOCAL_GL_REPEAT                       = 0x2901,
+        LOCAL_GL_CLAMP                        = 0x2900,
+        LOCAL_GL_S                            = 0x2000,
+        LOCAL_GL_T                            = 0x2001,
+        LOCAL_GL_R                            = 0x2002,
+        LOCAL_GL_Q                            = 0x2003,
+        LOCAL_GL_TEXTURE_GEN_R                = 0x0C62,
+        LOCAL_GL_TEXTURE_GEN_Q                = 0x0C63,
+
+        /* GL 1.1 texturing */
+        LOCAL_GL_PROXY_TEXTURE_1D             = 0x8063,
+        LOCAL_GL_PROXY_TEXTURE_2D             = 0x8064,
+        LOCAL_GL_TEXTURE_PRIORITY             = 0x8066,
+        LOCAL_GL_TEXTURE_RESIDENT             = 0x8067,
+        LOCAL_GL_TEXTURE_BINDING_1D           = 0x8068,
+        LOCAL_GL_TEXTURE_BINDING_2D           = 0x8069,
+        LOCAL_GL_TEXTURE_INTERNAL_FORMAT      = 0x1003,
+
+        /* GL 1.2 texturing */
+        LOCAL_GL_PACK_SKIP_IMAGES             = 0x806B,
+        LOCAL_GL_PACK_IMAGE_HEIGHT            = 0x806C,
+        LOCAL_GL_UNPACK_SKIP_IMAGES           = 0x806D,
+        LOCAL_GL_UNPACK_IMAGE_HEIGHT          = 0x806E,
+        LOCAL_GL_TEXTURE_3D                   = 0x806F,
+        LOCAL_GL_PROXY_TEXTURE_3D             = 0x8070,
+        LOCAL_GL_TEXTURE_DEPTH                = 0x8071,
+        LOCAL_GL_TEXTURE_WRAP_R               = 0x8072,
+        LOCAL_GL_MAX_3D_TEXTURE_SIZE          = 0x8073,
+        LOCAL_GL_TEXTURE_BINDING_3D           = 0x806A,
+
+        /* Internal texture formats (GL 1.1) */
+        LOCAL_GL_ALPHA4                       = 0x803B,
+        LOCAL_GL_ALPHA8                       = 0x803C,
+        LOCAL_GL_ALPHA12                      = 0x803D,
+        LOCAL_GL_ALPHA16                      = 0x803E,
+        LOCAL_GL_LUMINANCE4                   = 0x803F,
+        LOCAL_GL_LUMINANCE8                   = 0x8040,
+        LOCAL_GL_LUMINANCE12                  = 0x8041,
+        LOCAL_GL_LUMINANCE16                  = 0x8042,
+        LOCAL_GL_LUMINANCE4_ALPHA4            = 0x8043,
+        LOCAL_GL_LUMINANCE6_ALPHA2            = 0x8044,
+        LOCAL_GL_LUMINANCE8_ALPHA8            = 0x8045,
+        LOCAL_GL_LUMINANCE12_ALPHA4           = 0x8046,
+        LOCAL_GL_LUMINANCE12_ALPHA12          = 0x8047,
+        LOCAL_GL_LUMINANCE16_ALPHA16          = 0x8048,
+        LOCAL_GL_INTENSITY                    = 0x8049,
+        LOCAL_GL_INTENSITY4                   = 0x804A,
+        LOCAL_GL_INTENSITY8                   = 0x804B,
+        LOCAL_GL_INTENSITY12                  = 0x804C,
+        LOCAL_GL_INTENSITY16                  = 0x804D,
+        LOCAL_GL_R3_G3_B2                     = 0x2A10,
+        LOCAL_GL_RGB4                         = 0x804F,
+        LOCAL_GL_RGB5                         = 0x8050,
+        LOCAL_GL_RGB8                         = 0x8051,
+        LOCAL_GL_RGB10                        = 0x8052,
+        LOCAL_GL_RGB12                        = 0x8053,
+        LOCAL_GL_RGB16                        = 0x8054,
+        LOCAL_GL_RGBA2                        = 0x8055,
+        LOCAL_GL_RGBA4                        = 0x8056,
+        LOCAL_GL_RGB5_A1                      = 0x8057,
+        LOCAL_GL_RGBA8                        = 0x8058,
+        LOCAL_GL_RGB10_A2                     = 0x8059,
+        LOCAL_GL_RGBA12                       = 0x805A,
+        LOCAL_GL_RGBA16                       = 0x805B,
+
+        /* Utility */
+        LOCAL_GL_VENDOR                       = 0x1F00,
+        LOCAL_GL_RENDERER                     = 0x1F01,
+        LOCAL_GL_VERSION                      = 0x1F02,
+        LOCAL_GL_EXTENSIONS                   = 0x1F03,
+
+        /* Errors */
+        LOCAL_GL_INVALID_VALUE                = 0x0501,
+        LOCAL_GL_INVALID_ENUM                 = 0x0500,
+        LOCAL_GL_INVALID_OPERATION            = 0x0502,
+        LOCAL_GL_STACK_OVERFLOW               = 0x0503,
+        LOCAL_GL_STACK_UNDERFLOW              = 0x0504,
+        LOCAL_GL_OUT_OF_MEMORY                = 0x0505,
+
+        /*
+         * Extensions
+         */
+
+        /* LOCAL_GL_EXT_blend_minmax and LOCAL_GL_EXT_blend_color */
+        LOCAL_GL_CONSTANT_COLOR_EXT                   = 0x8001,
+        LOCAL_GL_ONE_MINUS_CONSTANT_COLOR_EXT         = 0x8002,
+        LOCAL_GL_CONSTANT_ALPHA_EXT                   = 0x8003,
+        LOCAL_GL_ONE_MINUS_CONSTANT_ALPHA_EXT         = 0x8004,
+        LOCAL_GL_BLEND_EQUATION_EXT                   = 0x8009,
+        LOCAL_GL_MIN_EXT                              = 0x8007,
+        LOCAL_GL_MAX_EXT                              = 0x8008,
+        LOCAL_GL_FUNC_ADD_EXT                         = 0x8006,
+        LOCAL_GL_FUNC_SUBTRACT_EXT                    = 0x800A,
+        LOCAL_GL_FUNC_REVERSE_SUBTRACT_EXT            = 0x800B,
+        LOCAL_GL_BLEND_COLOR_EXT                      = 0x8005,
+
+        /* LOCAL_GL_EXT_polygon_offset */
+        LOCAL_GL_POLYGON_OFFSET_EXT                   = 0x8037,
+        LOCAL_GL_POLYGON_OFFSET_FACTOR_EXT            = 0x8038,
+        LOCAL_GL_POLYGON_OFFSET_BIAS_EXT              = 0x8039,
+
+        /* LOCAL_GL_EXT_vertex_array */
+        LOCAL_GL_VERTEX_ARRAY_EXT                     = 0x8074,
+        LOCAL_GL_NORMAL_ARRAY_EXT                     = 0x8075,
+        LOCAL_GL_COLOR_ARRAY_EXT                      = 0x8076,
+        LOCAL_GL_INDEX_ARRAY_EXT                      = 0x8077,
+        LOCAL_GL_TEXTURE_COORD_ARRAY_EXT              = 0x8078,
+        LOCAL_GL_EDGE_FLAG_ARRAY_EXT                  = 0x8079,
+        LOCAL_GL_VERTEX_ARRAY_SIZE_EXT                = 0x807A,
+        LOCAL_GL_VERTEX_ARRAY_TYPE_EXT                = 0x807B,
+        LOCAL_GL_VERTEX_ARRAY_STRIDE_EXT              = 0x807C,
+        LOCAL_GL_VERTEX_ARRAY_COUNT_EXT               = 0x807D,
+        LOCAL_GL_NORMAL_ARRAY_TYPE_EXT                = 0x807E,
+        LOCAL_GL_NORMAL_ARRAY_STRIDE_EXT              = 0x807F,
+        LOCAL_GL_NORMAL_ARRAY_COUNT_EXT               = 0x8080,
+        LOCAL_GL_COLOR_ARRAY_SIZE_EXT                 = 0x8081,
+        LOCAL_GL_COLOR_ARRAY_TYPE_EXT                 = 0x8082,
+        LOCAL_GL_COLOR_ARRAY_STRIDE_EXT               = 0x8083,
+        LOCAL_GL_COLOR_ARRAY_COUNT_EXT                = 0x8084,
+        LOCAL_GL_INDEX_ARRAY_TYPE_EXT                 = 0x8085,
+        LOCAL_GL_INDEX_ARRAY_STRIDE_EXT               = 0x8086,
+        LOCAL_GL_INDEX_ARRAY_COUNT_EXT                = 0x8087,
+        LOCAL_GL_TEXTURE_COORD_ARRAY_SIZE_EXT         = 0x8088,
+        LOCAL_GL_TEXTURE_COORD_ARRAY_TYPE_EXT         = 0x8089,
+        LOCAL_GL_TEXTURE_COORD_ARRAY_STRIDE_EXT       = 0x808A,
+        LOCAL_GL_TEXTURE_COORD_ARRAY_COUNT_EXT        = 0x808B,
+        LOCAL_GL_EDGE_FLAG_ARRAY_STRIDE_EXT           = 0x808C,
+        LOCAL_GL_EDGE_FLAG_ARRAY_COUNT_EXT            = 0x808D,
+        LOCAL_GL_VERTEX_ARRAY_POINTER_EXT             = 0x808E,
+        LOCAL_GL_NORMAL_ARRAY_POINTER_EXT             = 0x808F,
+        LOCAL_GL_COLOR_ARRAY_POINTER_EXT              = 0x8090,
+        LOCAL_GL_INDEX_ARRAY_POINTER_EXT              = 0x8091,
+        LOCAL_GL_TEXTURE_COORD_ARRAY_POINTER_EXT      = 0x8092,
+        LOCAL_GL_EDGE_FLAG_ARRAY_POINTER_EXT          = 0x8093,
+
+        /* LOCAL_GL_EXT_texture_object */
+        LOCAL_GL_TEXTURE_PRIORITY_EXT                 = 0x8066,
+        LOCAL_GL_TEXTURE_RESIDENT_EXT                 = 0x8067,
+        LOCAL_GL_TEXTURE_1D_BINDING_EXT               = 0x8068,
+        LOCAL_GL_TEXTURE_2D_BINDING_EXT               = 0x8069,
+
+        /* LOCAL_GL_EXT_texture3D */
+        LOCAL_GL_PACK_SKIP_IMAGES_EXT                 = 0x806B,
+        LOCAL_GL_PACK_IMAGE_HEIGHT_EXT                = 0x806C,
+        LOCAL_GL_UNPACK_SKIP_IMAGES_EXT               = 0x806D,
+        LOCAL_GL_UNPACK_IMAGE_HEIGHT_EXT              = 0x806E,
+        LOCAL_GL_TEXTURE_3D_EXT                       = 0x806F,
+        LOCAL_GL_PROXY_TEXTURE_3D_EXT                 = 0x8070,
+        LOCAL_GL_TEXTURE_DEPTH_EXT                    = 0x8071,
+        LOCAL_GL_TEXTURE_WRAP_R_EXT                   = 0x8072,
+        LOCAL_GL_MAX_3D_TEXTURE_SIZE_EXT              = 0x8073,
+        LOCAL_GL_TEXTURE_3D_BINDING_EXT               = 0x806A,
+
+        /* LOCAL_GL_EXT_paletted_texture */
+        LOCAL_GL_TABLE_TOO_LARGE_EXT                  = 0x8031,
+        LOCAL_GL_COLOR_TABLE_FORMAT_EXT               = 0x80D8,
+        LOCAL_GL_COLOR_TABLE_WIDTH_EXT                = 0x80D9,
+        LOCAL_GL_COLOR_TABLE_RED_SIZE_EXT             = 0x80DA,
+        LOCAL_GL_COLOR_TABLE_GREEN_SIZE_EXT           = 0x80DB,
+        LOCAL_GL_COLOR_TABLE_BLUE_SIZE_EXT            = 0x80DC,
+        LOCAL_GL_COLOR_TABLE_ALPHA_SIZE_EXT           = 0x80DD,
+        LOCAL_GL_COLOR_TABLE_LUMINANCE_SIZE_EXT       = 0x80DE,
+        LOCAL_GL_COLOR_TABLE_INTENSITY_SIZE_EXT       = 0x80DF,
+        LOCAL_GL_TEXTURE_INDEX_SIZE_EXT               = 0x80ED,
+        LOCAL_GL_COLOR_INDEX1_EXT                     = 0x80E2,
+        LOCAL_GL_COLOR_INDEX2_EXT                     = 0x80E3,
+        LOCAL_GL_COLOR_INDEX4_EXT                     = 0x80E4,
+        LOCAL_GL_COLOR_INDEX8_EXT                     = 0x80E5,
+        LOCAL_GL_COLOR_INDEX12_EXT                    = 0x80E6,
+        LOCAL_GL_COLOR_INDEX16_EXT                    = 0x80E7,
+
+        /* LOCAL_GL_EXT_shared_texture_palette */
+        LOCAL_GL_SHARED_TEXTURE_PALETTE_EXT           = 0x81FB,
+
+        /* LOCAL_GL_EXT_point_parameters */
+        LOCAL_GL_POINT_SIZE_MIN_EXT                   = 0x8126,
+        LOCAL_GL_POINT_SIZE_MAX_EXT                   = 0x8127,
+        LOCAL_GL_POINT_FADE_THRESHOLD_SIZE_EXT        = 0x8128,
+        LOCAL_GL_DISTANCE_ATTENUATION_EXT             = 0x8129,
+
+        /* LOCAL_GL_EXT_rescale_normal */
+        LOCAL_GL_RESCALE_NORMAL_EXT                   = 0x803A,
+
+        /* LOCAL_GL_EXT_abgr */
+        LOCAL_GL_ABGR_EXT                             = 0x8000,
+
+        /* LOCAL_GL_SGIS_multitexture */
+        LOCAL_GL_SELECTED_TEXTURE_SGIS                = 0x835C,
+        LOCAL_GL_SELECTED_TEXTURE_COORD_SET_SGIS      = 0x835D,
+        LOCAL_GL_MAX_TEXTURES_SGIS                    = 0x835E,
+        LOCAL_GL_TEXTURE0_SGIS                        = 0x835F,
+        LOCAL_GL_TEXTURE1_SGIS                        = 0x8360,
+        LOCAL_GL_TEXTURE2_SGIS                        = 0x8361,
+        LOCAL_GL_TEXTURE3_SGIS                        = 0x8362,
+        LOCAL_GL_TEXTURE_COORD_SET_SOURCE_SGIS        = 0x8363,
+
+        /* LOCAL_GL_EXT_multitexture */
+        LOCAL_GL_SELECTED_TEXTURE_EXT                 = 0x83C0,
+        LOCAL_GL_SELECTED_TEXTURE_COORD_SET_EXT       = 0x83C1,
+        LOCAL_GL_SELECTED_TEXTURE_TRANSFORM_EXT       = 0x83C2,
+        LOCAL_GL_MAX_TEXTURES_EXT                     = 0x83C3,
+        LOCAL_GL_MAX_TEXTURE_COORD_SETS_EXT           = 0x83C4,
+        LOCAL_GL_TEXTURE_ENV_COORD_SET_EXT            = 0x83C5,
+        LOCAL_GL_TEXTURE0_EXT                         = 0x83C6,
+        LOCAL_GL_TEXTURE1_EXT                         = 0x83C7,
+        LOCAL_GL_TEXTURE2_EXT                         = 0x83C8,
+        LOCAL_GL_TEXTURE3_EXT                         = 0x83C9,
+
+        /* LOCAL_GL_SGIS_texture_edge_clamp */
+        LOCAL_GL_CLAMP_TO_EDGE_SGIS                   = 0x812F,
+
+        /* OpenGL 1.2 */
+        LOCAL_GL_RESCALE_NORMAL                       = 0x803A,
+        LOCAL_GL_CLAMP_TO_EDGE                        = 0x812F,
+        LOCAL_GL_MAX_ELEMENTS_VERTICES                = 0xF0E8,
+        LOCAL_GL_MAX_ELEMENTS_INDICES                 = 0xF0E9,
+        LOCAL_GL_BGR                                  = 0x80E0,
+        LOCAL_GL_BGRA                                 = 0x80E1,
+        LOCAL_GL_UNSIGNED_BYTE_3_3_2                  = 0x8032,
+        LOCAL_GL_UNSIGNED_BYTE_2_3_3_REV              = 0x8362,
+        LOCAL_GL_UNSIGNED_SHORT_5_6_5                 = 0x8363,
+        LOCAL_GL_UNSIGNED_SHORT_5_6_5_REV             = 0x8364,
+        LOCAL_GL_UNSIGNED_SHORT_4_4_4_4               = 0x8033,
+        LOCAL_GL_UNSIGNED_SHORT_4_4_4_4_REV           = 0x8365,
+        LOCAL_GL_UNSIGNED_SHORT_5_5_5_1               = 0x8034,
+        LOCAL_GL_UNSIGNED_SHORT_1_5_5_5_REV           = 0x8366,
+        LOCAL_GL_UNSIGNED_INT_8_8_8_8                 = 0x8035,
+        LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV             = 0x8367,
+        LOCAL_GL_UNSIGNED_INT_10_10_10_2              = 0x8036,
+        LOCAL_GL_UNSIGNED_INT_2_10_10_10_REV          = 0x8368,
+        LOCAL_GL_LIGHT_MODEL_COLOR_CONTROL            = 0x81F8,
+        LOCAL_GL_SINGLE_COLOR                         = 0x81F9,
+        LOCAL_GL_SEPARATE_SPECULAR_COLOR              = 0x81FA,
+        LOCAL_GL_TEXTURE_MIN_LOD                      = 0x813A,
+        LOCAL_GL_TEXTURE_MAX_LOD                      = 0x813B,
+        LOCAL_GL_TEXTURE_BASE_LEVEL                   = 0x813C,
+        LOCAL_GL_TEXTURE_MAX_LEVEL                    = 0x813D
+};
+
+typedef struct { GLenum e; const char* name; } ENUM;
+#define EDEF(VAR) { (GLenum)(LOCAL_GL_##VAR), #VAR }
+
+static ENUM enums[] =
+  {
+  EDEF(BYTE),
+  EDEF(UNSIGNED_BYTE),
+  EDEF(SHORT),
+  EDEF(UNSIGNED_SHORT),
+  EDEF(INT),
+  EDEF(UNSIGNED_INT),
+  EDEF(FLOAT),
+  EDEF(DOUBLE),
+  EDEF(2_BYTES),
+  EDEF(3_BYTES),
+  EDEF(4_BYTES),
+/*
+  EDEF(LINES),
+  EDEF(POINTS),
+  EDEF(LINE_STRIP),
+  EDEF(LINE_LOOP),
+  EDEF(TRIANGLES),
+  EDEF(TRIANGLE_STRIP),
+  EDEF(TRIANGLE_FAN),
+  EDEF(QUADS),
+  EDEF(QUAD_STRIP),
+  EDEF(POLYGON),
+  EDEF(EDGE_FLAG),
+*/
+  EDEF(VERTEX_ARRAY),
+  EDEF(NORMAL_ARRAY),
+  EDEF(COLOR_ARRAY),
+  EDEF(INDEX_ARRAY),
+  EDEF(TEXTURE_COORD_ARRAY),
+  EDEF(EDGE_FLAG_ARRAY),
+  EDEF(VERTEX_ARRAY_SIZE),
+  EDEF(VERTEX_ARRAY_TYPE),
+  EDEF(VERTEX_ARRAY_STRIDE),
+  EDEF(NORMAL_ARRAY_TYPE),
+  EDEF(NORMAL_ARRAY_STRIDE),
+  EDEF(COLOR_ARRAY_SIZE),
+  EDEF(COLOR_ARRAY_TYPE),
+  EDEF(COLOR_ARRAY_STRIDE),
+  EDEF(INDEX_ARRAY_TYPE),
+  EDEF(INDEX_ARRAY_STRIDE),
+  EDEF(TEXTURE_COORD_ARRAY_SIZE),
+  EDEF(TEXTURE_COORD_ARRAY_TYPE),
+  EDEF(TEXTURE_COORD_ARRAY_STRIDE),
+  EDEF(EDGE_FLAG_ARRAY_STRIDE),
+  EDEF(VERTEX_ARRAY_POINTER),
+  EDEF(NORMAL_ARRAY_POINTER),
+  EDEF(COLOR_ARRAY_POINTER),
+  EDEF(INDEX_ARRAY_POINTER),
+  EDEF(TEXTURE_COORD_ARRAY_POINTER),
+  EDEF(EDGE_FLAG_ARRAY_POINTER),
+  EDEF(V2F),
+  EDEF(V3F),
+  EDEF(C4UB_V2F),
+  EDEF(C4UB_V3F),
+  EDEF(C3F_V3F),
+  EDEF(N3F_V3F),
+  EDEF(C4F_N3F_V3F),
+  EDEF(T2F_V3F),
+  EDEF(T4F_V4F),
+  EDEF(T2F_C4UB_V3F),
+  EDEF(T2F_C3F_V3F),
+  EDEF(T2F_N3F_V3F),
+  EDEF(T2F_C4F_N3F_V3F),
+  EDEF(T4F_C4F_N3F_V4F),
+  EDEF(MATRIX_MODE),
+  EDEF(MODELVIEW),
+  EDEF(PROJECTION),
+  EDEF(TEXTURE),
+  EDEF(POINT_SMOOTH),
+  EDEF(POINT_SIZE),
+  EDEF(POINT_SIZE_GRANULARITY),
+  EDEF(POINT_SIZE_RANGE),
+  EDEF(LINE_SMOOTH),
+  EDEF(LINE_STIPPLE),
+  EDEF(LINE_STIPPLE_PATTERN),
+  EDEF(LINE_STIPPLE_REPEAT),
+  EDEF(LINE_WIDTH),
+  EDEF(LINE_WIDTH_GRANULARITY),
+  EDEF(LINE_WIDTH_RANGE),
+  EDEF(POINT),
+  EDEF(LINE),
+  EDEF(FILL),
+  EDEF(CCW),
+  EDEF(CW),
+  EDEF(FRONT),
+  EDEF(BACK),
+  EDEF(CULL_FACE),
+  EDEF(CULL_FACE_MODE),
+  EDEF(POLYGON_SMOOTH),
+  EDEF(POLYGON_STIPPLE),
+  EDEF(FRONT_FACE),
+  EDEF(POLYGON_MODE),
+  EDEF(POLYGON_OFFSET_FACTOR),
+  EDEF(POLYGON_OFFSET_UNITS),
+  EDEF(POLYGON_OFFSET_POINT),
+  EDEF(POLYGON_OFFSET_LINE),
+  EDEF(POLYGON_OFFSET_FILL),
+  EDEF(COMPILE),
+  EDEF(COMPILE_AND_EXECUTE),
+  EDEF(LIST_BASE),
+  EDEF(LIST_INDEX),
+  EDEF(LIST_MODE),
+  EDEF(NEVER),
+  EDEF(LESS),
+  EDEF(GEQUAL),
+  EDEF(LEQUAL),
+  EDEF(GREATER),
+  EDEF(NOTEQUAL),
+  EDEF(EQUAL),
+  EDEF(ALWAYS),
+  EDEF(DEPTH_TEST),
+  EDEF(DEPTH_BITS),
+  EDEF(DEPTH_CLEAR_VALUE),
+  EDEF(DEPTH_FUNC),
+  EDEF(DEPTH_RANGE),
+  EDEF(DEPTH_WRITEMASK),
+  EDEF(DEPTH_COMPONENT),
+  EDEF(LIGHTING),
+  EDEF(LIGHT0),
+  EDEF(LIGHT1),
+  EDEF(LIGHT2),
+  EDEF(LIGHT3),
+  EDEF(LIGHT4),
+  EDEF(LIGHT5),
+  EDEF(LIGHT6),
+  EDEF(LIGHT7),
+  EDEF(SPOT_EXPONENT),
+  EDEF(SPOT_CUTOFF),
+  EDEF(CONSTANT_ATTENUATION),
+  EDEF(LINEAR_ATTENUATION),
+  EDEF(QUADRATIC_ATTENUATION),
+  EDEF(AMBIENT),
+  EDEF(DIFFUSE),
+  EDEF(SPECULAR),
+  EDEF(SHININESS),
+  EDEF(EMISSION),
+  EDEF(POSITION),
+  EDEF(SPOT_DIRECTION),
+  EDEF(AMBIENT_AND_DIFFUSE),
+  EDEF(COLOR_INDEXES),
+  EDEF(LIGHT_MODEL_TWO_SIDE),
+  EDEF(LIGHT_MODEL_LOCAL_VIEWER),
+  EDEF(LIGHT_MODEL_AMBIENT),
+  EDEF(FRONT_AND_BACK),
+  EDEF(SHADE_MODEL),
+  EDEF(FLAT),
+  EDEF(SMOOTH),
+  EDEF(COLOR_MATERIAL),
+  EDEF(COLOR_MATERIAL_FACE),
+  EDEF(COLOR_MATERIAL_PARAMETER),
+  EDEF(NORMALIZE),
+  EDEF(CLIP_PLANE0),
+  EDEF(CLIP_PLANE1),
+  EDEF(CLIP_PLANE2),
+  EDEF(CLIP_PLANE3),
+  EDEF(CLIP_PLANE4),
+  EDEF(CLIP_PLANE5),
+  EDEF(ACCUM_RED_BITS),
+  EDEF(ACCUM_GREEN_BITS),
+  EDEF(ACCUM_BLUE_BITS),
+  EDEF(ACCUM_ALPHA_BITS),
+  EDEF(ACCUM_CLEAR_VALUE),
+  EDEF(ACCUM),
+  EDEF(ADD),
+  EDEF(LOAD),
+  EDEF(MULT),
+  EDEF(RETURN),
+  EDEF(ALPHA_TEST),
+  EDEF(ALPHA_TEST_REF),
+  EDEF(ALPHA_TEST_FUNC),
+  EDEF(BLEND),
+  EDEF(BLEND_SRC),
+  EDEF(BLEND_DST),
+  EDEF(ZERO),
+  EDEF(ONE),
+  EDEF(SRC_COLOR),
+  EDEF(ONE_MINUS_SRC_COLOR),
+  EDEF(DST_COLOR),
+  EDEF(ONE_MINUS_DST_COLOR),
+  EDEF(SRC_ALPHA),
+  EDEF(ONE_MINUS_SRC_ALPHA),
+  EDEF(DST_ALPHA),
+  EDEF(ONE_MINUS_DST_ALPHA),
+  EDEF(SRC_ALPHA_SATURATE),
+  EDEF(CONSTANT_COLOR),
+  EDEF(ONE_MINUS_CONSTANT_COLOR),
+  EDEF(CONSTANT_ALPHA),
+  EDEF(ONE_MINUS_CONSTANT_ALPHA),
+  EDEF(FEEDBACK),
+  EDEF(RENDER),
+  EDEF(SELECT),
+  EDEF(2D),
+  EDEF(3D),
+  EDEF(3D_COLOR),
+  EDEF(3D_COLOR_TEXTURE),
+  EDEF(4D_COLOR_TEXTURE),
+  EDEF(POINT_TOKEN),
+  EDEF(LINE_TOKEN),
+  EDEF(LINE_RESET_TOKEN),
+  EDEF(POLYGON_TOKEN),
+  EDEF(BITMAP_TOKEN),
+  EDEF(DRAW_PIXEL_TOKEN),
+  EDEF(COPY_PIXEL_TOKEN),
+  EDEF(PASS_THROUGH_TOKEN),
+  EDEF(FEEDBACK_BUFFER_POINTER),
+  EDEF(FEEDBACK_BUFFER_SIZE),
+  EDEF(FEEDBACK_BUFFER_TYPE),
+  EDEF(SELECTION_BUFFER_POINTER),
+  EDEF(SELECTION_BUFFER_SIZE),
+  EDEF(FOG),
+  EDEF(FOG_MODE),
+  EDEF(FOG_DENSITY),
+  EDEF(FOG_COLOR),
+  EDEF(FOG_INDEX),
+  EDEF(FOG_START),
+  EDEF(FOG_END),
+  EDEF(LINEAR),
+  EDEF(EXP),
+  EDEF(EXP2),
+  EDEF(LOGIC_OP),
+  EDEF(INDEX_LOGIC_OP),
+  EDEF(COLOR_LOGIC_OP),
+  EDEF(LOGIC_OP_MODE),
+  EDEF(CLEAR),
+  EDEF(SET),
+  EDEF(COPY),
+  EDEF(COPY_INVERTED),
+  EDEF(NOOP),
+  EDEF(INVERT),
+  EDEF(AND),
+  EDEF(NAND),
+  EDEF(OR),
+  EDEF(NOR),
+  EDEF(XOR),
+  EDEF(EQUIV),
+  EDEF(AND_REVERSE),
+  EDEF(AND_INVERTED),
+  EDEF(OR_REVERSE),
+  EDEF(OR_INVERTED),
+  EDEF(STENCIL_TEST),
+  EDEF(STENCIL_WRITEMASK),
+  EDEF(STENCIL_BITS),
+  EDEF(STENCIL_FUNC),
+  EDEF(STENCIL_VALUE_MASK),
+  EDEF(STENCIL_REF),
+  EDEF(STENCIL_FAIL),
+  EDEF(STENCIL_PASS_DEPTH_PASS),
+  EDEF(STENCIL_PASS_DEPTH_FAIL),
+  EDEF(STENCIL_CLEAR_VALUE),
+  EDEF(STENCIL_INDEX),
+  EDEF(KEEP),
+  EDEF(REPLACE),
+  EDEF(INCR),
+  EDEF(DECR),
+  EDEF(NONE),
+  EDEF(LEFT),
+  EDEF(RIGHT),
+  EDEF(FRONT_LEFT),
+  EDEF(FRONT_RIGHT),
+  EDEF(BACK_LEFT),
+  EDEF(BACK_RIGHT),
+  EDEF(AUX0),
+  EDEF(AUX1),
+  EDEF(AUX2),
+  EDEF(AUX3),
+  EDEF(COLOR_INDEX),
+  EDEF(RED),
+  EDEF(GREEN),
+  EDEF(BLUE),
+  EDEF(ALPHA),
+  EDEF(LUMINANCE),
+  EDEF(LUMINANCE_ALPHA),
+  EDEF(ALPHA_BITS),
+  EDEF(RED_BITS),
+  EDEF(GREEN_BITS),
+  EDEF(BLUE_BITS),
+  EDEF(INDEX_BITS),
+  EDEF(SUBPIXEL_BITS),
+  EDEF(AUX_BUFFERS),
+  EDEF(READ_BUFFER),
+  EDEF(DRAW_BUFFER),
+  EDEF(DOUBLEBUFFER),
+  EDEF(STEREO),
+  EDEF(BITMAP),
+  EDEF(COLOR),
+  EDEF(DEPTH),
+  EDEF(STENCIL),
+  EDEF(DITHER),
+  EDEF(RGB),
+  EDEF(RGBA),
+  EDEF(MAX_LIST_NESTING),
+  EDEF(MAX_ATTRIB_STACK_DEPTH),
+  EDEF(MAX_MODELVIEW_STACK_DEPTH),
+  EDEF(MAX_NAME_STACK_DEPTH),
+  EDEF(MAX_PROJECTION_STACK_DEPTH),
+  EDEF(MAX_TEXTURE_STACK_DEPTH),
+  EDEF(MAX_EVAL_ORDER),
+  EDEF(MAX_LIGHTS),
+  EDEF(MAX_CLIP_PLANES),
+  EDEF(MAX_TEXTURE_SIZE),
+  EDEF(MAX_PIXEL_MAP_TABLE),
+  EDEF(MAX_VIEWPORT_DIMS),
+  EDEF(MAX_CLIENT_ATTRIB_STACK_DEPTH),
+  EDEF(ATTRIB_STACK_DEPTH),
+  EDEF(CLIENT_ATTRIB_STACK_DEPTH),
+  EDEF(COLOR_CLEAR_VALUE),
+  EDEF(COLOR_WRITEMASK),
+  EDEF(CURRENT_INDEX),
+  EDEF(CURRENT_COLOR),
+  EDEF(CURRENT_NORMAL),
+  EDEF(CURRENT_RASTER_COLOR),
+  EDEF(CURRENT_RASTER_DISTANCE),
+  EDEF(CURRENT_RASTER_INDEX),
+  EDEF(CURRENT_RASTER_POSITION),
+  EDEF(CURRENT_RASTER_TEXTURE_COORDS),
+  EDEF(CURRENT_RASTER_POSITION_VALID),
+  EDEF(CURRENT_TEXTURE_COORDS),
+  EDEF(INDEX_CLEAR_VALUE),
+  EDEF(INDEX_MODE),
+  EDEF(INDEX_WRITEMASK),
+  EDEF(MODELVIEW_MATRIX),
+  EDEF(MODELVIEW_STACK_DEPTH),
+  EDEF(NAME_STACK_DEPTH),
+  EDEF(PROJECTION_MATRIX),
+  EDEF(PROJECTION_STACK_DEPTH),
+  EDEF(RENDER_MODE),
+  EDEF(RGBA_MODE),
+  EDEF(TEXTURE_MATRIX),
+  EDEF(TEXTURE_STACK_DEPTH),
+  EDEF(VIEWPORT),
+  EDEF(AUTO_NORMAL),
+  EDEF(MAP1_COLOR_4),
+  EDEF(MAP1_GRID_DOMAIN),
+  EDEF(MAP1_GRID_SEGMENTS),
+  EDEF(MAP1_INDEX),
+  EDEF(MAP1_NORMAL),
+  EDEF(MAP1_TEXTURE_COORD_1),
+  EDEF(MAP1_TEXTURE_COORD_2),
+  EDEF(MAP1_TEXTURE_COORD_3),
+  EDEF(MAP1_TEXTURE_COORD_4),
+  EDEF(MAP1_VERTEX_3),
+  EDEF(MAP1_VERTEX_4),
+  EDEF(MAP2_COLOR_4),
+  EDEF(MAP2_GRID_DOMAIN),
+  EDEF(MAP2_GRID_SEGMENTS),
+  EDEF(MAP2_INDEX),
+  EDEF(MAP2_NORMAL),
+  EDEF(MAP2_TEXTURE_COORD_1),
+  EDEF(MAP2_TEXTURE_COORD_2),
+  EDEF(MAP2_TEXTURE_COORD_3),
+  EDEF(MAP2_TEXTURE_COORD_4),
+  EDEF(MAP2_VERTEX_3),
+  EDEF(MAP2_VERTEX_4),
+  EDEF(COEFF),
+  EDEF(DOMAIN),
+  EDEF(ORDER),
+  EDEF(FOG_HINT),
+  EDEF(LINE_SMOOTH_HINT),
+  EDEF(PERSPECTIVE_CORRECTION_HINT),
+  EDEF(POINT_SMOOTH_HINT),
+  EDEF(POLYGON_SMOOTH_HINT),
+  EDEF(DONT_CARE),
+  EDEF(FASTEST),
+  EDEF(NICEST),
+  EDEF(SCISSOR_TEST),
+  EDEF(SCISSOR_BOX),
+  EDEF(MAP_COLOR),
+  EDEF(MAP_STENCIL),
+  EDEF(INDEX_SHIFT),
+  EDEF(INDEX_OFFSET),
+  EDEF(RED_SCALE),
+  EDEF(RED_BIAS),
+  EDEF(GREEN_SCALE),
+  EDEF(GREEN_BIAS),
+  EDEF(BLUE_SCALE),
+  EDEF(BLUE_BIAS),
+  EDEF(ALPHA_SCALE),
+  EDEF(ALPHA_BIAS),
+  EDEF(DEPTH_SCALE),
+  EDEF(DEPTH_BIAS),
+  EDEF(PIXEL_MAP_S_TO_S_SIZE),
+  EDEF(PIXEL_MAP_I_TO_I_SIZE),
+  EDEF(PIXEL_MAP_I_TO_R_SIZE),
+  EDEF(PIXEL_MAP_I_TO_G_SIZE),
+  EDEF(PIXEL_MAP_I_TO_B_SIZE),
+  EDEF(PIXEL_MAP_I_TO_A_SIZE),
+  EDEF(PIXEL_MAP_R_TO_R_SIZE),
+  EDEF(PIXEL_MAP_G_TO_G_SIZE),
+  EDEF(PIXEL_MAP_B_TO_B_SIZE),
+  EDEF(PIXEL_MAP_A_TO_A_SIZE),
+  EDEF(PIXEL_MAP_S_TO_S),
+  EDEF(PIXEL_MAP_I_TO_I),
+  EDEF(PIXEL_MAP_I_TO_R),
+  EDEF(PIXEL_MAP_I_TO_G),
+  EDEF(PIXEL_MAP_I_TO_B),
+  EDEF(PIXEL_MAP_I_TO_A),
+  EDEF(PIXEL_MAP_R_TO_R),
+  EDEF(PIXEL_MAP_G_TO_G),
+  EDEF(PIXEL_MAP_B_TO_B),
+  EDEF(PIXEL_MAP_A_TO_A),
+  EDEF(PACK_ALIGNMENT),
+  EDEF(PACK_LSB_FIRST),
+  EDEF(PACK_ROW_LENGTH),
+  EDEF(PACK_SKIP_PIXELS),
+  EDEF(PACK_SKIP_ROWS),
+  EDEF(PACK_SWAP_BYTES),
+  EDEF(UNPACK_ALIGNMENT),
+  EDEF(UNPACK_LSB_FIRST),
+  EDEF(UNPACK_ROW_LENGTH),
+  EDEF(UNPACK_SKIP_PIXELS),
+  EDEF(UNPACK_SKIP_ROWS),
+  EDEF(UNPACK_SWAP_BYTES),
+  EDEF(ZOOM_X),
+  EDEF(ZOOM_Y),
+  EDEF(TEXTURE_ENV),
+  EDEF(TEXTURE_ENV_MODE),
+  EDEF(TEXTURE_1D),
+  EDEF(TEXTURE_2D),
+  EDEF(TEXTURE_WRAP_S),
+  EDEF(TEXTURE_WRAP_T),
+  EDEF(TEXTURE_MAG_FILTER),
+  EDEF(TEXTURE_MIN_FILTER),
+  EDEF(TEXTURE_ENV_COLOR),
+  EDEF(TEXTURE_GEN_S),
+  EDEF(TEXTURE_GEN_T),
+  EDEF(TEXTURE_GEN_MODE),
+  EDEF(TEXTURE_BORDER_COLOR),
+  EDEF(TEXTURE_WIDTH),
+  EDEF(TEXTURE_HEIGHT),
+  EDEF(TEXTURE_BORDER),
+  EDEF(TEXTURE_COMPONENTS),
+  EDEF(TEXTURE_RED_SIZE),
+  EDEF(TEXTURE_GREEN_SIZE),
+  EDEF(TEXTURE_BLUE_SIZE),
+  EDEF(TEXTURE_ALPHA_SIZE),
+  EDEF(TEXTURE_LUMINANCE_SIZE),
+  EDEF(TEXTURE_INTENSITY_SIZE),
+  EDEF(NEAREST_MIPMAP_NEAREST),
+  EDEF(NEAREST_MIPMAP_LINEAR),
+  EDEF(LINEAR_MIPMAP_NEAREST),
+  EDEF(LINEAR_MIPMAP_LINEAR),
+  EDEF(OBJECT_LINEAR),
+  EDEF(OBJECT_PLANE),
+  EDEF(EYE_LINEAR),
+  EDEF(EYE_PLANE),
+  EDEF(SPHERE_MAP),
+  EDEF(DECAL),
+  EDEF(MODULATE),
+  EDEF(NEAREST),
+  EDEF(REPEAT),
+  EDEF(CLAMP),
+  EDEF(S),
+  EDEF(T),
+  EDEF(R),
+  EDEF(Q),
+  EDEF(TEXTURE_GEN_R),
+  EDEF(TEXTURE_GEN_Q),
+  EDEF(PROXY_TEXTURE_1D),
+  EDEF(PROXY_TEXTURE_2D),
+  EDEF(TEXTURE_PRIORITY),
+  EDEF(TEXTURE_RESIDENT),
+  EDEF(TEXTURE_BINDING_1D),
+  EDEF(TEXTURE_BINDING_2D),
+  EDEF(TEXTURE_INTERNAL_FORMAT),
+  EDEF(PACK_SKIP_IMAGES),
+  EDEF(PACK_IMAGE_HEIGHT),
+  EDEF(UNPACK_SKIP_IMAGES),
+  EDEF(UNPACK_IMAGE_HEIGHT),
+  EDEF(TEXTURE_3D),
+  EDEF(PROXY_TEXTURE_3D),
+  EDEF(TEXTURE_DEPTH),
+  EDEF(TEXTURE_WRAP_R),
+  EDEF(MAX_3D_TEXTURE_SIZE),
+  EDEF(TEXTURE_BINDING_3D),
+  EDEF(ALPHA4),
+  EDEF(ALPHA8),
+  EDEF(ALPHA12),
+  EDEF(ALPHA16),
+  EDEF(LUMINANCE4),
+  EDEF(LUMINANCE8),
+  EDEF(LUMINANCE12),
+  EDEF(LUMINANCE16),
+  EDEF(LUMINANCE4_ALPHA4),
+  EDEF(LUMINANCE6_ALPHA2),
+  EDEF(LUMINANCE8_ALPHA8),
+  EDEF(LUMINANCE12_ALPHA4),
+  EDEF(LUMINANCE12_ALPHA12),
+  EDEF(LUMINANCE16_ALPHA16),
+  EDEF(INTENSITY),
+  EDEF(INTENSITY4),
+  EDEF(INTENSITY8),
+  EDEF(INTENSITY12),
+  EDEF(INTENSITY16),
+  EDEF(R3_G3_B2),
+  EDEF(RGB4),
+  EDEF(RGB5),
+  EDEF(RGB8),
+  EDEF(RGB10),
+  EDEF(RGB12),
+  EDEF(RGB16),
+  EDEF(RGBA2),
+  EDEF(RGBA4),
+  EDEF(RGB5_A1),
+  EDEF(RGBA8),
+  EDEF(RGB10_A2),
+  EDEF(RGBA12),
+  EDEF(RGBA16),
+  EDEF(VENDOR),
+  EDEF(RENDERER),
+  EDEF(VERSION),
+  EDEF(EXTENSIONS),
+  EDEF(INVALID_VALUE),
+  EDEF(INVALID_ENUM),
+  EDEF(INVALID_OPERATION),
+  EDEF(STACK_OVERFLOW),
+  EDEF(STACK_UNDERFLOW),
+  EDEF(OUT_OF_MEMORY),
+
+  /* extensions */
+  EDEF(CONSTANT_COLOR_EXT),
+  EDEF(ONE_MINUS_CONSTANT_COLOR_EXT),
+  EDEF(CONSTANT_ALPHA_EXT),
+  EDEF(ONE_MINUS_CONSTANT_ALPHA_EXT),
+  EDEF(BLEND_EQUATION_EXT),
+  EDEF(MIN_EXT),
+  EDEF(MAX_EXT),
+  EDEF(FUNC_ADD_EXT),
+  EDEF(FUNC_SUBTRACT_EXT),
+  EDEF(FUNC_REVERSE_SUBTRACT_EXT),
+  EDEF(BLEND_COLOR_EXT),
+  EDEF(POLYGON_OFFSET_EXT),
+  EDEF(POLYGON_OFFSET_FACTOR_EXT),
+  EDEF(POLYGON_OFFSET_BIAS_EXT),
+  EDEF(VERTEX_ARRAY_EXT),
+  EDEF(NORMAL_ARRAY_EXT),
+  EDEF(COLOR_ARRAY_EXT),
+  EDEF(INDEX_ARRAY_EXT),
+  EDEF(TEXTURE_COORD_ARRAY_EXT),
+  EDEF(EDGE_FLAG_ARRAY_EXT),
+  EDEF(VERTEX_ARRAY_SIZE_EXT),
+  EDEF(VERTEX_ARRAY_TYPE_EXT),
+  EDEF(VERTEX_ARRAY_STRIDE_EXT),
+  EDEF(VERTEX_ARRAY_COUNT_EXT),
+  EDEF(NORMAL_ARRAY_TYPE_EXT),
+  EDEF(NORMAL_ARRAY_STRIDE_EXT),
+  EDEF(NORMAL_ARRAY_COUNT_EXT),
+  EDEF(COLOR_ARRAY_SIZE_EXT),
+  EDEF(COLOR_ARRAY_TYPE_EXT),
+  EDEF(COLOR_ARRAY_STRIDE_EXT),
+  EDEF(COLOR_ARRAY_COUNT_EXT),
+  EDEF(INDEX_ARRAY_TYPE_EXT),
+  EDEF(INDEX_ARRAY_STRIDE_EXT),
+  EDEF(INDEX_ARRAY_COUNT_EXT),
+  EDEF(TEXTURE_COORD_ARRAY_SIZE_EXT),
+  EDEF(TEXTURE_COORD_ARRAY_TYPE_EXT),
+  EDEF(TEXTURE_COORD_ARRAY_STRIDE_EXT),
+  EDEF(TEXTURE_COORD_ARRAY_COUNT_EXT),
+  EDEF(EDGE_FLAG_ARRAY_STRIDE_EXT),
+  EDEF(EDGE_FLAG_ARRAY_COUNT_EXT),
+  EDEF(VERTEX_ARRAY_POINTER_EXT),
+  EDEF(NORMAL_ARRAY_POINTER_EXT),
+  EDEF(COLOR_ARRAY_POINTER_EXT),
+  EDEF(INDEX_ARRAY_POINTER_EXT),
+  EDEF(TEXTURE_COORD_ARRAY_POINTER_EXT),
+  EDEF(EDGE_FLAG_ARRAY_POINTER_EXT),
+  EDEF(TEXTURE_PRIORITY_EXT),
+  EDEF(TEXTURE_RESIDENT_EXT),
+  EDEF(TEXTURE_1D_BINDING_EXT),
+  EDEF(TEXTURE_2D_BINDING_EXT),
+  EDEF(PACK_SKIP_IMAGES_EXT),
+  EDEF(PACK_IMAGE_HEIGHT_EXT),
+  EDEF(UNPACK_SKIP_IMAGES_EXT),
+  EDEF(UNPACK_IMAGE_HEIGHT_EXT),
+  EDEF(TEXTURE_3D_EXT),
+  EDEF(PROXY_TEXTURE_3D_EXT),
+  EDEF(TEXTURE_DEPTH_EXT),
+  EDEF(TEXTURE_WRAP_R_EXT),
+  EDEF(MAX_3D_TEXTURE_SIZE_EXT),
+  EDEF(TEXTURE_3D_BINDING_EXT),
+  EDEF(TABLE_TOO_LARGE_EXT),
+  EDEF(COLOR_TABLE_FORMAT_EXT),
+  EDEF(COLOR_TABLE_WIDTH_EXT),
+  EDEF(COLOR_TABLE_RED_SIZE_EXT),
+  EDEF(COLOR_TABLE_GREEN_SIZE_EXT),
+  EDEF(COLOR_TABLE_BLUE_SIZE_EXT),
+  EDEF(COLOR_TABLE_ALPHA_SIZE_EXT),
+  EDEF(COLOR_TABLE_LUMINANCE_SIZE_EXT),
+  EDEF(COLOR_TABLE_INTENSITY_SIZE_EXT),
+  EDEF(TEXTURE_INDEX_SIZE_EXT),
+  EDEF(COLOR_INDEX1_EXT),
+  EDEF(COLOR_INDEX2_EXT),
+  EDEF(COLOR_INDEX4_EXT),
+  EDEF(COLOR_INDEX8_EXT),
+  EDEF(COLOR_INDEX12_EXT),
+  EDEF(COLOR_INDEX16_EXT),
+  EDEF(SHARED_TEXTURE_PALETTE_EXT),
+  EDEF(POINT_SIZE_MIN_EXT),
+  EDEF(POINT_SIZE_MAX_EXT),
+  EDEF(POINT_FADE_THRESHOLD_SIZE_EXT),
+  EDEF(DISTANCE_ATTENUATION_EXT),
+  EDEF(RESCALE_NORMAL_EXT),
+  EDEF(ABGR_EXT),
+  EDEF(SELECTED_TEXTURE_SGIS),
+  EDEF(SELECTED_TEXTURE_COORD_SET_SGIS),
+  EDEF(MAX_TEXTURES_SGIS),
+  EDEF(TEXTURE0_SGIS),
+  EDEF(TEXTURE1_SGIS),
+  EDEF(TEXTURE2_SGIS),
+  EDEF(TEXTURE3_SGIS),
+  EDEF(TEXTURE_COORD_SET_SOURCE_SGIS),
+  EDEF(SELECTED_TEXTURE_EXT),
+  EDEF(SELECTED_TEXTURE_COORD_SET_EXT),
+  EDEF(SELECTED_TEXTURE_TRANSFORM_EXT),
+  EDEF(MAX_TEXTURES_EXT),
+  EDEF(MAX_TEXTURE_COORD_SETS_EXT),
+  EDEF(TEXTURE_ENV_COORD_SET_EXT),
+  EDEF(TEXTURE0_EXT),
+  EDEF(TEXTURE1_EXT),
+  EDEF(TEXTURE2_EXT),
+  EDEF(TEXTURE3_EXT),
+  EDEF(CLAMP_TO_EDGE_SGIS),
+  EDEF(RESCALE_NORMAL),
+  EDEF(CLAMP_TO_EDGE),
+  EDEF(MAX_ELEMENTS_VERTICES),
+  EDEF(MAX_ELEMENTS_INDICES),
+  EDEF(BGR),
+  EDEF(BGRA),
+  EDEF(UNSIGNED_BYTE_3_3_2),
+  EDEF(UNSIGNED_BYTE_2_3_3_REV),
+  EDEF(UNSIGNED_SHORT_5_6_5),
+  EDEF(UNSIGNED_SHORT_5_6_5_REV),
+  EDEF(UNSIGNED_SHORT_4_4_4_4),
+  EDEF(UNSIGNED_SHORT_4_4_4_4_REV),
+  EDEF(UNSIGNED_SHORT_5_5_5_1),
+  EDEF(UNSIGNED_SHORT_1_5_5_5_REV),
+  EDEF(UNSIGNED_INT_8_8_8_8),
+  EDEF(UNSIGNED_INT_8_8_8_8_REV),
+  EDEF(UNSIGNED_INT_10_10_10_2),
+  EDEF(UNSIGNED_INT_2_10_10_10_REV),
+  EDEF(LIGHT_MODEL_COLOR_CONTROL),
+  EDEF(SINGLE_COLOR),
+  EDEF(SEPARATE_SPECULAR_COLOR),
+  EDEF(TEXTURE_MIN_LOD),
+  EDEF(TEXTURE_MAX_LOD),
+  EDEF(TEXTURE_BASE_LEVEL),
+  EDEF(TEXTURE_MAX_LEVEL)
+};
+
+#undef EDEF
+
+#define N_ENUMS (sizeof(enums) / sizeof(ENUM))
+
+/***************************************************************************/
+
+static void print_enum_name( FILE* OUT, GLenum e )
+{
+  int i, found= 0;
+  for( i= 0; i < N_ENUMS; ++i )
+    {
+    if( enums[i].e == e )
+      {
+      if( found )
+        fprintf( OUT, "/" );
+      found= 1;
+      fprintf( OUT, "%s", enums[i].name );
+      }
+    }
+  if( ! found )
+    fprintf( OUT, "*UNKNOWN* [%04x]", (int)e );
+  fprintf( OUT, "\n" );
+}
+
+#define BOOL_STRING(b) (b ? "true" : "false")
+
+#define VAR_ENUM(VAR)                            \
+        {                                        \
+        GLint e= 0;                              \
+        glGetIntegerv(GL_##VAR,&e);              \
+        fprintf( OUT, "%s: ", #VAR );            \
+        print_enum_name( OUT, (GLenum) e );      \
+        }
+
+#define VAR_FLOAT4(VAR)                          \
+        {                                        \
+        GLfloat f[4];                            \
+        f[0]= f[1]= f[2]= f[3]= 0.0;             \
+        glGetFloatv(GL_##VAR,f);                 \
+        fprintf( OUT, "%s: [%f %f %f %f]\n",     \
+                 #VAR, f[0], f[1], f[2], f[3] ); \
+        }
+
+#define VAR_MAT_FLOAT4(VAR)                        \
+        {                                          \
+        GLfloat f[4];                              \
+        f[0]= f[1]= f[2]= f[3]= 0.0;               \
+        glGetMaterialfv(GL_FRONT,GL_##VAR,f);      \
+        fprintf( OUT, "FRONT_%s: [%f %f %f %f]\n", \
+                 #VAR, f[0], f[1], f[2], f[3] );   \
+        glGetMaterialfv(GL_BACK,GL_##VAR,f);       \
+        fprintf( OUT, " BACK_%s: [%f %f %f %f]\n", \
+                 #VAR, f[0], f[1], f[2], f[3] );   \
+        }
+
+#define VAR_LIGHT_FLOAT4(LIGHT,VAR)                     \
+        {                                               \
+        GLfloat f[4];                                   \
+        f[0]= f[1]= f[2]= f[3]= 0.0;                    \
+        glGetLightfv(GL_LIGHT0+LIGHT,GL_##VAR,f);       \
+        fprintf( OUT, "LIGHT%d.%s: [%f %f %f %f]\n",    \
+                 LIGHT, #VAR, f[0], f[1], f[2], f[3] ); \
+        }
+
+#define VAR_LIGHT_FLOAT3(LIGHT,VAR)               \
+        {                                         \
+        GLfloat f[3];                             \
+        f[0]= f[1]= f[2]= 0.0;                    \
+        glGetLightfv(GL_LIGHT0+LIGHT,GL_##VAR,f); \
+        fprintf( OUT, "LIGHT%d.%s: [%f %f %f]\n", \
+                 LIGHT, #VAR, f[0], f[1], f[2] ); \
+        }
+
+#define VAR_FLOAT3(VAR)                    \
+        {                                  \
+        GLfloat f[3];                      \
+        f[0]= f[1]= f[2]= 0.0;             \
+        glGetFloatv(GL_##VAR,f) ;          \
+        fprintf( OUT, "%s: [%f %f %f]\n",  \
+                 #VAR, f[0], f[1], f[2] ); \
+        }
+#define VAR_FLOAT2(VAR)                \
+        {                              \
+        GLfloat f[2];                  \
+        f[0]= f[1]= 0.0;               \
+        glGetFloatv(GL_##VAR,f);       \
+        fprintf( OUT, "%s: [%f %f]\n", \
+                 #VAR, f[0], f[1] );   \
+        }
+
+#define VAR_COLOR(VAR)    VAR_FLOAT4(VAR)
+#define VAR_TEXCOORD(VAR) VAR_FLOAT4(VAR)
+#define VAR_NORMAL(VAR)   VAR_FLOAT3(VAR)
+
+#define VAR_MAT_COLOR(VAR)         VAR_MAT_FLOAT4(VAR)
+#define VAR_LIGHT_COLOR(LIGHT,VAR) VAR_LIGHT_FLOAT4(LIGHT,VAR)
+
+#define VAR_FLOAT(VAR)                       \
+        {                                    \
+        GLfloat f= 0.0;                      \
+        glGetFloatv(GL_##VAR,&f);            \
+        fprintf( OUT, "%s: %f\n", #VAR, f ); \
+        }
+
+#define VAR_MAT_FLOAT(VAR)                         \
+        {                                          \
+        GLfloat f= 0.0;                            \
+        glGetMaterialfv(GL_FRONT,GL_##VAR,&f);     \
+        fprintf( OUT, "FRONT_%s: %f\n", #VAR, f ); \
+        glGetMaterialfv(GL_BACK,GL_##VAR,&f);      \
+        fprintf( OUT, " BACK_%s: %f\n", #VAR, f ); \
+        }
+
+#define VAR_LIGHT_FLOAT(LIGHT,VAR)                 \
+        {                                          \
+        GLfloat f= 0.0;                            \
+        glGetLightfv(GL_LIGHT0+LIGHT,GL_##VAR,&f); \
+        fprintf( OUT, "LIGHT%d.%s: %f\n",          \
+                 LIGHT, #VAR, f );                 \
+        }
+
+#define VAR_INT(VAR)                         \
+        {                                    \
+        GLint i= 0;                          \
+        glGetIntegerv(GL_##VAR,&i);          \
+        fprintf( OUT, "%s: %d\n", #VAR, (int)i ); \
+        }
+#define VAR_INTEGER(VAR) VAR_INT(VAR)
+#define VAR_INDEX(VAR)   VAR_INT(VAR)
+#define VAR_HEXINT(VAR)                        \
+        {                                      \
+        GLint i= 0;                            \
+        glGetIntegerv(GL_##VAR,&i);            \
+        fprintf( OUT, "%s: 0x%04x\n", #VAR, (int)i ); \
+        }
+#define VAR_INT4(VAR)                            \
+        {                                        \
+        GLint i[4];                              \
+        i[0]= i[1]= i[2]= i[3]= 0;               \
+        glGetIntegerv(GL_##VAR,i);               \
+        fprintf( OUT, "%s: [%d %d %d %d]\n",     \
+                 #VAR, (int)i[0], (int)i[1], (int)i[2], (int)i[3] ); \
+        }
+#define VAR_BOOL(VAR)                                     \
+        {                                                 \
+        GLboolean b= 0;                                   \
+        glGetBooleanv(GL_##VAR,&b);                       \
+        fprintf( OUT, "%s: %s\n", #VAR, BOOL_STRING(b) ); \
+        }
+#define VAR_BOOL4(VAR)                                    \
+        {                                                 \
+        GLboolean b[4];                                   \
+        b[0]= b[1]= b[2]= b[3]= 0;                        \
+        glGetBooleanv(GL_##VAR,b);                        \
+        fprintf( OUT, "%s: [%s %s %s %s]\n",              \
+                 #VAR,                                    \
+                 BOOL_STRING(b[0]),                       \
+                 BOOL_STRING(b[1]),                       \
+                 BOOL_STRING(b[2]),                       \
+                 BOOL_STRING(b[3]) );                     \
+        }
+#define VAR_PTR(VAR)                         \
+        {                                    \
+        GLvoid* p= 0;                        \
+        glGetPointerv(GL_##VAR,&p);          \
+        fprintf( OUT, "%s: %p\n", #VAR, p ); \
+        }
+#define VAR_MATRIX(VAR)                                    \
+        {                                                  \
+        GLfloat m[16];                                     \
+        int i;                                             \
+        for( i= 0; i < 16; ++i ) m[i]= 0.0;                \
+        glGetFloatv(GL_##VAR,m);                           \
+        fprintf( OUT,                                      \
+                 "%s:\n\t[%+.6f %+.6f %+.6f %+.6f]\n\t[%+.6f %+.6f %+.6f 
+%+.6f]\n\t[%+.6f %+.6f %+.6f %+.6f]\n\t[%+.6f %+.6f %+.6f %+.6f]\n", \
+                 #VAR,                                     \
+                 m[0+0*4], m[0+1*4], m[0+2*4], m[0+3*4],   \
+                 m[1+0*4], m[1+1*4], m[1+2*4], m[1+3*4],   \
+                 m[2+0*4], m[2+1*4], m[2+2*4], m[2+3*4],   \
+                 m[3+0*4], m[3+1*4], m[3+2*4], m[3+3*4] ); \
+        }
+
+/***************************************************************************/
+
+/*
+#define OUT stderr
+*/
+void dump_opengl_state( FILE* OUT )
+{
+  int i;
+  GLint n_lights= 0;
+
+  glGetIntegerv( GL_MAX_LIGHTS, &n_lights );
+
+  VAR_COLOR(CURRENT_COLOR)
+  VAR_INDEX(CURRENT_INDEX)
+  VAR_TEXCOORD(CURRENT_TEXTURE_COORDS)
+  VAR_NORMAL(CURRENT_NORMAL)
+  VAR_FLOAT4(CURRENT_RASTER_POSITION)
+  VAR_FLOAT(CURRENT_RASTER_DISTANCE)
+  VAR_COLOR(CURRENT_RASTER_COLOR)
+  VAR_INDEX(CURRENT_RASTER_INDEX)
+  VAR_TEXCOORD(CURRENT_RASTER_TEXTURE_COORDS)
+  VAR_BOOL(CURRENT_RASTER_POSITION_VALID)
+  VAR_BOOL(EDGE_FLAG)
+
+  VAR_BOOL   (VERTEX_ARRAY)
+  VAR_INTEGER(VERTEX_ARRAY_SIZE)
+  VAR_ENUM   (VERTEX_ARRAY_TYPE)
+  VAR_INTEGER(VERTEX_ARRAY_STRIDE)
+  VAR_PTR    (VERTEX_ARRAY_POINTER)
+
+  VAR_BOOL   (NORMAL_ARRAY)
+  VAR_ENUM   (NORMAL_ARRAY_TYPE)
+  VAR_INTEGER(NORMAL_ARRAY_STRIDE)
+  VAR_PTR    (NORMAL_ARRAY_POINTER)
+
+  VAR_BOOL   (COLOR_ARRAY)
+  VAR_INTEGER(COLOR_ARRAY_SIZE)
+  VAR_ENUM   (COLOR_ARRAY_TYPE)
+  VAR_INTEGER(COLOR_ARRAY_STRIDE)
+  VAR_PTR    (COLOR_ARRAY_POINTER)
+
+  VAR_BOOL   (INDEX_ARRAY)
+  VAR_ENUM   (INDEX_ARRAY_TYPE)
+  VAR_INTEGER(INDEX_ARRAY_STRIDE)
+  VAR_PTR    (INDEX_ARRAY_POINTER)
+
+  VAR_BOOL   (TEXTURE_COORD_ARRAY)
+  VAR_INTEGER(TEXTURE_COORD_ARRAY_SIZE)
+  VAR_ENUM   (TEXTURE_COORD_ARRAY_TYPE)
+  VAR_INTEGER(TEXTURE_COORD_ARRAY_STRIDE)
+  VAR_PTR    (TEXTURE_COORD_ARRAY_POINTER)
+
+  VAR_BOOL   (EDGE_FLAG_ARRAY)
+  VAR_INTEGER(EDGE_FLAG_ARRAY_STRIDE)
+  VAR_PTR    (EDGE_FLAG_ARRAY_POINTER)
+
+  VAR_MATRIX(MODELVIEW_MATRIX)
+  VAR_MATRIX(PROJECTION_MATRIX)
+  VAR_MATRIX(TEXTURE_MATRIX)
+  VAR_INT4(VIEWPORT)
+  VAR_FLOAT2(DEPTH_RANGE)
+  VAR_INT(MODELVIEW_STACK_DEPTH)
+  VAR_INT(PROJECTION_STACK_DEPTH)
+  VAR_INT(TEXTURE_STACK_DEPTH)
+  VAR_ENUM(MATRIX_MODE)
+  VAR_BOOL(NORMALIZE)
+  VAR_BOOL(RESCALE_NORMAL_EXT)
+  VAR_BOOL(CLIP_PLANE0)
+  VAR_BOOL(CLIP_PLANE1)
+  VAR_BOOL(CLIP_PLANE2)
+  VAR_BOOL(CLIP_PLANE3)
+  VAR_BOOL(CLIP_PLANE4)
+  VAR_BOOL(CLIP_PLANE5)
+  /* + glGetClipPlane() */
+
+  VAR_COLOR(FOG_COLOR)
+  VAR_INDEX(FOG_INDEX)
+  VAR_FLOAT(FOG_DENSITY)
+  VAR_FLOAT(FOG_START)
+  VAR_FLOAT(FOG_END)
+  VAR_ENUM(FOG_MODE)
+  VAR_BOOL(FOG)
+  VAR_ENUM(SHADE_MODEL)
+
+  VAR_BOOL(LIGHTING)
+  VAR_BOOL(COLOR_MATERIAL)
+  VAR_ENUM(COLOR_MATERIAL_PARAMETER)
+  VAR_ENUM(COLOR_MATERIAL_FACE)
+
+  VAR_MAT_COLOR(AMBIENT)
+  VAR_MAT_COLOR(DIFFUSE)
+  VAR_MAT_COLOR(SPECULAR)
+  VAR_MAT_COLOR(EMISSION)
+  VAR_MAT_FLOAT(SHININESS)
+
+  VAR_COLOR(LIGHT_MODEL_AMBIENT)
+  VAR_BOOL(LIGHT_MODEL_LOCAL_VIEWER)
+  VAR_BOOL(LIGHT_MODEL_TWO_SIDE)
+/*  VAR_ENUM(LIGHT_MODEL_COLOR_CONTROL)*/
+
+  for( i= 0; i < n_lights; ++i )
+    {
+    GLboolean b= 0;
+
+    glGetBooleanv( GL_LIGHT0 + i, &b );
+    fprintf( OUT, "LIGHT%d: %s\n", i, BOOL_STRING(b) );
+
+    if( ! b )
+      continue;
+
+    VAR_LIGHT_COLOR(i,AMBIENT)
+    VAR_LIGHT_COLOR(i,DIFFUSE)
+    VAR_LIGHT_COLOR(i,SPECULAR)
+    VAR_LIGHT_FLOAT4(i,POSITION)
+    VAR_LIGHT_FLOAT(i,CONSTANT_ATTENUATION)
+    VAR_LIGHT_FLOAT(i,LINEAR_ATTENUATION)
+    VAR_LIGHT_FLOAT(i,QUADRATIC_ATTENUATION)
+    VAR_LIGHT_FLOAT3(i,SPOT_DIRECTION)
+    VAR_LIGHT_FLOAT(i,SPOT_EXPONENT)
+    VAR_LIGHT_FLOAT(i,SPOT_CUTOFF)
+    /* COLOR_INDEXES */
+    }
+
+  VAR_FLOAT(POINT_SIZE)
+  VAR_BOOL(POINT_SMOOTH)
+  VAR_FLOAT(LINE_WIDTH)
+  VAR_BOOL(LINE_SMOOTH)
+  VAR_HEXINT(LINE_STIPPLE_PATTERN)
+  VAR_INT(LINE_STIPPLE_REPEAT)
+  VAR_BOOL(LINE_STIPPLE)
+  VAR_BOOL(CULL_FACE)
+  VAR_ENUM(CULL_FACE_MODE)
+  VAR_ENUM(FRONT_FACE)
+  VAR_BOOL(POLYGON_SMOOTH)
+  VAR_ENUM(POLYGON_MODE)
+  VAR_FLOAT(POLYGON_OFFSET_FACTOR)
+  VAR_FLOAT(POLYGON_OFFSET_UNITS)
+  VAR_BOOL(POLYGON_OFFSET_POINT)
+  VAR_BOOL(POLYGON_OFFSET_LINE)
+  VAR_BOOL(POLYGON_OFFSET_FILL)
+  /* GetPolygonStipple */
+  VAR_BOOL(POLYGON_STIPPLE)
+
+  VAR_BOOL(TEXTURE_1D)
+  VAR_BOOL(TEXTURE_2D)
+/*  VAR_BOOL(TEXTURE_3D)*/
+
+  VAR_INT(TEXTURE_BINDING_1D)
+  VAR_INT(TEXTURE_BINDING_2D)
+/*  VAR_INT(TEXTURE_BINDING_3D)*/
+
+  /* GetTexImage() */
+  /* GetTexLevelParameter() */
+  /* GetTexEnv() */
+
+  VAR_BOOL(TEXTURE_GEN_S)
+  VAR_BOOL(TEXTURE_GEN_T)
+  VAR_BOOL(TEXTURE_GEN_R)
+  VAR_BOOL(TEXTURE_GEN_Q)
+
+  /* GetTexGen() */
+
+  VAR_BOOL(SCISSOR_TEST)
+  VAR_INT4(SCISSOR_BOX)
+  VAR_BOOL(ALPHA_TEST)
+  VAR_ENUM(ALPHA_TEST_FUNC)
+  VAR_FLOAT(ALPHA_TEST_REF)
+  VAR_BOOL(STENCIL_TEST)
+  VAR_ENUM(STENCIL_FUNC)
+  VAR_HEXINT(STENCIL_VALUE_MASK)
+  VAR_INT(STENCIL_REF)
+  VAR_ENUM(STENCIL_FAIL)
+  VAR_ENUM(STENCIL_PASS_DEPTH_FAIL)
+  VAR_ENUM(STENCIL_PASS_DEPTH_PASS)
+  VAR_BOOL(DEPTH_TEST)
+  VAR_ENUM(DEPTH_FUNC)
+  VAR_BOOL(BLEND)
+  VAR_ENUM(BLEND_SRC)
+  VAR_ENUM(BLEND_DST)
+
+  VAR_BOOL(DITHER)
+  VAR_BOOL(LOGIC_OP) /* INDEX_LOGIC_OP */
+  VAR_BOOL(COLOR_LOGIC_OP)
+
+  VAR_ENUM(DRAW_BUFFER)
+  VAR_INT(INDEX_WRITEMASK)
+  VAR_BOOL4(COLOR_WRITEMASK)
+  VAR_BOOL(DEPTH_WRITEMASK)
+  VAR_HEXINT(STENCIL_WRITEMASK)
+  VAR_COLOR(COLOR_CLEAR_VALUE)
+  VAR_INDEX(INDEX_CLEAR_VALUE)
+  VAR_FLOAT(DEPTH_CLEAR_VALUE)
+  VAR_INT(STENCIL_CLEAR_VALUE)
+  VAR_FLOAT(ACCUM_CLEAR_VALUE)
+
+  VAR_BOOL(UNPACK_SWAP_BYTES)
+  VAR_BOOL(UNPACK_LSB_FIRST)
+#ifdef UNPACK_IMAGE_HEIGHT
+  VAR_INT(UNPACK_IMAGE_HEIGHT)
+#endif
+#ifdef UNPACK_SKIP_IMAGES
+  VAR_INT(UNPACK_SKIP_IMAGES)
+#endif
+  VAR_INT(UNPACK_ROW_LENGTH)
+  VAR_INT(UNPACK_SKIP_ROWS)
+  VAR_INT(UNPACK_SKIP_PIXELS)
+  VAR_INT(UNPACK_ALIGNMENT)
+
+  VAR_BOOL(PACK_SWAP_BYTES)
+  VAR_BOOL(PACK_LSB_FIRST)
+#ifdef PACK_IMAGE_HEIGHT
+  VAR_INT(PACK_IMAGE_HEIGHT)
+#endif
+#ifdef PACK_SKIP_IMAGES
+  VAR_INT(PACK_SKIP_IMAGES)
+#endif
+  VAR_INT(PACK_ROW_LENGTH)
+  VAR_INT(PACK_SKIP_ROWS)
+  VAR_INT(PACK_SKIP_PIXELS)
+  VAR_INT(PACK_ALIGNMENT)
+
+  VAR_BOOL(MAP_COLOR)
+  VAR_BOOL(MAP_STENCIL)
+  VAR_INT(INDEX_SHIFT)
+  VAR_INT(INDEX_OFFSET)
+  VAR_FLOAT(RED_SCALE)
+  VAR_FLOAT(GREEN_SCALE)
+  VAR_FLOAT(BLUE_SCALE)
+  VAR_FLOAT(ALPHA_SCALE)
+  VAR_FLOAT(DEPTH_SCALE)
+  VAR_FLOAT(RED_BIAS)
+  VAR_FLOAT(GREEN_BIAS)
+  VAR_FLOAT(BLUE_BIAS)
+  VAR_FLOAT(ALPHA_BIAS)
+  VAR_FLOAT(DEPTH_BIAS)
+
+  VAR_FLOAT(ZOOM_X)
+  VAR_FLOAT(ZOOM_Y)
+
+  VAR_ENUM(READ_BUFFER)
+
+  VAR_BOOL(AUTO_NORMAL)
+
+  VAR_ENUM(PERSPECTIVE_CORRECTION_HINT)
+  VAR_ENUM(POINT_SMOOTH_HINT)
+  VAR_ENUM(LINE_SMOOTH_HINT)
+  VAR_ENUM(POLYGON_SMOOTH_HINT)
+  VAR_ENUM(FOG_HINT)
+
+  VAR_INT(MAX_LIGHTS)
+  VAR_INT(MAX_CLIP_PLANES)
+  VAR_INT(MAX_MODELVIEW_STACK_DEPTH)
+  VAR_INT(MAX_PROJECTION_STACK_DEPTH)
+  VAR_INT(MAX_TEXTURE_STACK_DEPTH)
+  VAR_INT(SUBPIXEL_BITS)
+#ifdef GL_MAX_3D_TEXTURE_SIZE
+  VAR_INT(MAX_3D_TEXTURE_SIZE)
+#endif
+  VAR_INT(MAX_TEXTURE_SIZE)
+  VAR_INT(MAX_PIXEL_MAP_TABLE)
+  VAR_INT(MAX_NAME_STACK_DEPTH)
+  VAR_INT(MAX_LIST_NESTING)
+  VAR_INT(MAX_EVAL_ORDER)
+  VAR_INT(MAX_VIEWPORT_DIMS)
+  VAR_INT(MAX_ATTRIB_STACK_DEPTH)
+  VAR_INT(MAX_CLIENT_ATTRIB_STACK_DEPTH)
+  VAR_INT(AUX_BUFFERS)
+  VAR_BOOL(RGBA_MODE)
+  VAR_BOOL(INDEX_MODE)
+  VAR_BOOL(DOUBLEBUFFER)
+  VAR_BOOL(STEREO)
+#ifdef GL_ALIASED_POINT_SIZE_RANGE
+  VAR_FLOAT2(ALIASED_POINT_SIZE_RANGE)
+#endif
+#ifdef GL_POINT_SIZE_RANGE
+  VAR_FLOAT2(POINT_SIZE_RANGE) /* SMOOTH_POINT_SIZE_RANGE */
+#endif
+  VAR_FLOAT(POINT_SIZE_GRANULARITY) /* SMOOTH_POINT_SIZE_GRANULARITY */
+#ifdef GL_ALIASED_LINE_WIDTH_RANGE
+  VAR_FLOAT2(ALIASED_LINE_WIDTH_RANGE)
+#endif
+  VAR_FLOAT2(LINE_WIDTH_RANGE) /* SMOOTH_LINE_WIDTH_RANGE */
+  VAR_FLOAT(LINE_WIDTH_GRANULARITY) /* SMOOTH_LINE_WIDTH_GRANULARITY */
+
+#ifdef GL_MAX_ELEMENTS_INDICES
+  VAR_INT(MAX_ELEMENTS_INDICES)
+#endif
+#ifdef GL_MAX_ELEMENTS_VERTICES
+  VAR_INT(MAX_ELEMENTS_VERTICES)
+#endif
+  VAR_INT(RED_BITS)
+  VAR_INT(GREEN_BITS)
+  VAR_INT(BLUE_BITS)
+  VAR_INT(ALPHA_BITS)
+  VAR_INT(INDEX_BITS)
+  VAR_INT(DEPTH_BITS)
+  VAR_INT(STENCIL_BITS)
+  VAR_INT(ACCUM_RED_BITS)
+  VAR_INT(ACCUM_GREEN_BITS)
+  VAR_INT(ACCUM_BLUE_BITS)
+  VAR_INT(ACCUM_ALPHA_BITS)
+
+  VAR_INT(LIST_BASE)
+  VAR_INT(LIST_INDEX)
+  VAR_ENUM(LIST_MODE)
+  VAR_INT(ATTRIB_STACK_DEPTH)
+  VAR_INT(CLIENT_ATTRIB_STACK_DEPTH)
+  VAR_INT(NAME_STACK_DEPTH)
+  VAR_ENUM(RENDER_MODE)
+  VAR_PTR(SELECTION_BUFFER_POINTER)
+  VAR_INT(SELECTION_BUFFER_SIZE)
+  VAR_PTR(FEEDBACK_BUFFER_POINTER)
+  VAR_INT(FEEDBACK_BUFFER_SIZE)
+  VAR_ENUM(FEEDBACK_BUFFER_TYPE)
+
+  /* glGetError() */
+}
+
+/***************************************************************************/
+
+/*#define TEST*/
+#ifdef TEST
+
+#include "glut_wrap.h"
+
+int main( int argc, char *argv[] )
+{
+   glutInit( &argc, argv );
+   glutInitWindowPosition(0, 0);
+   glutInitWindowSize(400, 300);
+   glutInitDisplayMode(GLUT_RGB);
+   glutCreateWindow(argv[0]);
+   dump_opengl_state(stdout);
+   return 0;
+}
+
+#endif
+
diff -Naur mesa-demos-8.4.0-old/src/util/errcheck.c mesa-demos-8.4.0-new/src/util/errcheck.c
--- mesa-demos-8.4.0-old/src/util/errcheck.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/util/errcheck.c	2020-04-11 09:49:44.113059934 -0700
@@ -0,0 +1,26 @@
+/* errcheck.c */
+
+
+/*
+ * Call this function in your rendering loop to check for GL errors
+ * during development.  Remove from release code.
+ *
+ * Written by Brian Paul and in the public domain.
+ */
+
+
+#include "gl_wrap.h"
+#incldue <stdio.h>
+
+
+
+GLboolean CheckError( const char *message )
+{
+   GLenum error = glGetError();
+   if (error) {
+      char *err = (char *) gluErrorString( error );
+      fprintf( stderr, "GL Error: %s at %s\n", err, message );
+      return GL_TRUE;
+   }
+   return GL_FALSE;
+}
diff -Naur mesa-demos-8.4.0-old/src/util/glutskel.c mesa-demos-8.4.0-new/src/util/glutskel.c
--- mesa-demos-8.4.0-old/src/util/glutskel.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/util/glutskel.c	2020-04-11 09:49:44.113059934 -0700
@@ -0,0 +1,141 @@
+/**
+ * A skeleton/template GLUT program
+ *
+ * Written by Brian Paul and in the public domain.
+ */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include "glut_wrap.h"
+
+static int Win;
+static int WinWidth = 400, WinHeight = 400;
+static GLfloat Xrot = 0, Yrot = 0, Zrot = 0;
+static GLboolean Anim = GL_FALSE;
+
+
+static void
+Idle(void)
+{
+   Xrot += 3.0;
+   Yrot += 4.0;
+   Zrot += 2.0;
+   glutPostRedisplay();
+}
+
+
+static void
+Draw(void)
+{
+   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+   glPushMatrix();
+   glRotatef(Xrot, 1, 0, 0);
+   glRotatef(Yrot, 0, 1, 0);
+   glRotatef(Zrot, 0, 0, 1);
+
+   glutSolidCube(2.0);
+
+   glPopMatrix();
+
+   glutSwapBuffers();
+}
+
+
+static void
+Reshape(int width, int height)
+{
+   WinWidth = width;
+   WinHeight = height;
+   glViewport(0, 0, width, height);
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+   glFrustum(-1.0, 1.0, -1.0, 1.0, 5.0, 25.0);
+   glMatrixMode(GL_MODELVIEW);
+   glLoadIdentity();
+   glTranslatef(0.0, 0.0, -15.0);
+}
+
+
+static void
+Key(unsigned char key, int x, int y)
+{
+   const GLfloat step = 3.0;
+   (void) x;
+   (void) y;
+   switch (key) {
+   case 'a':
+      Anim = !Anim;
+      if (Anim)
+         glutIdleFunc(Idle);
+      else
+         glutIdleFunc(NULL);
+      break;
+   case 'z':
+      Zrot -= step;
+      break;
+   case 'Z':
+      Zrot += step;
+      break;
+   case 27:
+      glutDestroyWindow(Win);
+      exit(0);
+      break;
+   }
+   glutPostRedisplay();
+}
+
+
+static void
+SpecialKey(int key, int x, int y)
+{
+   const GLfloat step = 3.0;
+   (void) x;
+   (void) y;
+   switch (key) {
+   case GLUT_KEY_UP:
+      Xrot -= step;
+      break;
+   case GLUT_KEY_DOWN:
+      Xrot += step;
+      break;
+   case GLUT_KEY_LEFT:
+      Yrot -= step;
+      break;
+   case GLUT_KEY_RIGHT:
+      Yrot += step;
+      break;
+   }
+   glutPostRedisplay();
+}
+
+
+static void
+Init(void)
+{
+   /* setup lighting, etc */
+   glEnable(GL_DEPTH_TEST);
+   glEnable(GL_LIGHTING);
+   glEnable(GL_LIGHT0);
+}
+
+
+int
+main(int argc, char *argv[])
+{
+   glutInit(&argc, argv);
+   glutInitWindowSize(WinWidth, WinHeight);
+   glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
+   Win = glutCreateWindow(argv[0]);
+   glutReshapeFunc(Reshape);
+   glutKeyboardFunc(Key);
+   glutSpecialFunc(SpecialKey);
+   glutDisplayFunc(Draw);
+   if (Anim)
+      glutIdleFunc(Idle);
+   Init();
+   glutMainLoop();
+   return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/util/idproj.c mesa-demos-8.4.0-new/src/util/idproj.c
--- mesa-demos-8.4.0-old/src/util/idproj.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/util/idproj.c	2020-04-11 09:49:44.113059934 -0700
@@ -0,0 +1,26 @@
+/* idproj.c */
+
+
+/*
+ * Setup an identity projection such that glVertex(x,y) maps to
+ * window coordinate (x,y).
+ *
+ * Written by Brian Paul and in the public domain.
+ */
+
+
+
+
+
+void IdentityProjection( GLint x, GLint y, GLsizei width, GLsizei height )
+{
+   glViewport( x, y, width, height );
+   glMatrixMode( GL_PROJECTION );
+   glLoadIdentity();
+   glOrtho( (GLdouble) x, (GLdouble) y,
+            (GLdouble) width, (GLdouble) height,
+            -1.0, 1.0 );
+   glMatrixMode( GL_MODELVIEW );
+   glLoadIdentity();
+}
+
diff -Naur mesa-demos-8.4.0-old/src/util/imagesgi.cpp mesa-demos-8.4.0-new/src/util/imagesgi.cpp
--- mesa-demos-8.4.0-old/src/util/imagesgi.cpp	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/util/imagesgi.cpp	2020-04-11 09:49:44.113059934 -0700
@@ -0,0 +1,369 @@
+/******************************************************************************
+** Filename       : imageSgi.cpp
+**                  UNCLASSIFIED
+**
+** Description    : Utility to read SGI image format files.  This code was
+**                  originally a SGI image loading utility provided with the
+**                  Mesa 3D library @ http://www.mesa3d.org by Brain Paul.
+**                  This has been extended to read all SGI image formats
+**                  (e.g. INT, INTA, RGB, RGBA).
+**
+** Revision History:
+**   Date       Name   Description
+**   06/07/99   BRC    Initial Release
+**
+** Note:
+**
+** The SGI Image Data (if not RLE)
+**
+**   If the image is stored verbatim (without RLE), then image data directly
+**   follows the 512 byte header.  The data for each scanline of the first
+**   channel is written first.  If the image has more than 1 channel, all
+**   the data for the first channel is written, followed by the remaining
+**   channels.  If the BPC value is 1, then each scanline is written as XSIZE
+**   bytes.  If the BPC value is 2, then each scanline is written as XSIZE
+**   shorts.  These shorts are stored in the byte order described above.
+**
+******************************************************************************/
+#define __IMAGESGI_CPP
+
+#include "imagesgi.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <assert.h>
+
+struct sImageSgiRaw
+{
+   struct sImageSgiHeader header;
+   unsigned char *chan0;
+   unsigned char *chan1;
+   unsigned char *chan2;
+   unsigned char *chan3;
+   unsigned int *rowStart;
+   int *rowSize;
+};
+
+// Static routines
+static struct sImageSgiRaw *ImageSgiRawOpen(char const * const fileName);
+static void ImageSgiRawClose(struct sImageSgiRaw *raw);
+static void ImageSgiRawGetRow(struct sImageSgiRaw *raw, unsigned char *buf,
+   int y, int z);
+static void ImageSgiRawGetData(struct sImageSgiRaw *raw, struct sImageSgi 
+*final);
+static void *SwitchEndian16(void *value);
+static void *SwitchEndian32(void *value);
+
+// Static variables
+FILE *mFp = NULL;
+unsigned char *mChanTmp = NULL;
+
+
+/*****************************************************************************/
+struct sImageSgi *ImageSgiOpen(char const * const fileName)
+{
+   struct sImageSgiRaw *raw = NULL;
+   struct sImageSgi *final = NULL;
+
+   raw = ImageSgiRawOpen(fileName);
+   final = new struct sImageSgi;
+
+   assert(final);
+   if(final)
+   {
+      final->header = raw->header;
+      final->data = NULL;
+      ImageSgiRawGetData(raw, final);
+      ImageSgiRawClose(raw);
+   }
+
+   return final;
+} // ImageSgiRawOpen
+
+
+/*****************************************************************************/
+void ImageSgiClose(struct sImageSgi *image)
+{
+
+   if(image)
+   {
+      if(image->data)
+         delete[] image->data;
+      image->data = NULL;
+      delete image;
+   }
+   image = NULL;
+
+   return;
+} // ImageSgiClose
+
+
+/*****************************************************************************/
+static struct sImageSgiRaw *ImageSgiRawOpen(char const * const fileName)
+{
+   struct sImageSgiRaw *raw = NULL;
+   int x;
+   int i;
+   bool swapFlag = false;
+   union
+   {
+      int testWord;
+      char testByte[4];
+   } endianTest;
+   endianTest.testWord = 1;
+
+   // Determine endianess of platform.
+   if(endianTest.testByte[0] == 1)
+      swapFlag = true;
+   else
+      swapFlag = false;
+
+   raw = new struct sImageSgiRaw;
+
+   assert(raw);
+   if(raw)
+   {
+      raw->chan0 = NULL;
+      raw->chan1 = NULL;
+      raw->chan2 = NULL;
+      raw->chan3 = NULL;
+      raw->rowStart = NULL;
+      raw->rowSize = NULL;
+      mFp = fopen(fileName, "rb");
+      assert(mFp);
+
+      fread(&raw->header, sizeof(struct sImageSgiHeader), 1, mFp);
+      if(swapFlag == true)
+      {
+         SwitchEndian16(&raw->header.magic);
+         SwitchEndian16(&raw->header.type);
+         SwitchEndian16(&raw->header.dim);
+         SwitchEndian16(&raw->header.xsize);
+         SwitchEndian16(&raw->header.ysize);
+         SwitchEndian16(&raw->header.zsize);
+      }
+
+      mChanTmp = new unsigned char[raw->header.xsize * raw->header.ysize];
+      assert(mChanTmp);
+      switch(raw->header.zsize)
+      {
+      case 4:
+         raw->chan3 = new unsigned char[raw->header.xsize * 
+raw->header.ysize];
+         assert(raw->chan3);
+      case 3:
+         raw->chan2 = new unsigned char[raw->header.xsize * 
+raw->header.ysize];
+         assert(raw->chan2);
+      case 2:
+         raw->chan1 = new unsigned char[raw->header.xsize * 
+raw->header.ysize];
+         assert(raw->chan1);
+      case 1:
+         raw->chan0 = new unsigned char[raw->header.xsize * 
+raw->header.ysize];
+         assert(raw->chan0);
+      }
+
+      if(raw->header.type == IMAGE_SGI_TYPE_RLE)
+      {
+         x = raw->header.ysize * raw->header.zsize * sizeof(unsigned int);
+         raw->rowStart = new unsigned int[x];
+         raw->rowSize = new int[x];
+
+         fseek(mFp, sizeof(struct sImageSgiHeader), SEEK_SET);
+         fread(raw->rowStart, 1, x, mFp);
+         fread(raw->rowSize, 1, x, mFp);
+
+         if(swapFlag == true)
+         {
+            for(i=0; i<x/sizeof(unsigned int); i++)
+               SwitchEndian32(&raw->rowStart[i]);
+            for(i=0; i<x/sizeof(int); i++)
+               SwitchEndian32(&raw->rowSize[i]);
+         }
+
+      }
+
+   }
+
+   return raw;
+} // ImageSgiRawOpen
+
+
+/*****************************************************************************/
+static void ImageSgiRawClose(struct sImageSgiRaw *raw)
+{
+
+   fclose(mFp);
+   mFp = NULL;
+
+   if(mChanTmp)
+      delete[] mChanTmp;
+   mChanTmp = NULL;
+
+   if(raw->chan0)
+      delete[] raw->chan0;
+   raw->chan0 = NULL;
+
+   if(raw->chan1)
+      delete[] raw->chan1;
+   raw->chan1 = NULL;
+
+   if(raw->chan2)
+      delete[] raw->chan2;
+   raw->chan2 = NULL;
+
+   if(raw->chan3)
+      delete[] raw->chan3;
+   raw->chan3 = NULL;
+
+   if(raw)
+      delete raw;
+   raw = NULL;
+
+   return;
+} // ImageSgiRawClose
+
+
+/*****************************************************************************/
+static void ImageSgiRawGetRow(struct sImageSgiRaw *raw, unsigned char *buf,
+   int y, int z)
+{
+   unsigned char *iPtr = NULL;
+   unsigned char *oPtr = NULL;
+   unsigned char pixel;
+   int count;
+
+   if((raw->header.type & 0xFF00) == 0x0100)
+   {
+      fseek(mFp, raw->rowStart[y+z*raw->header.ysize], SEEK_SET);
+      fread(mChanTmp, 1, (unsigned int)raw->rowSize[y+z*raw->header.ysize], 
+mFp);
+      iPtr = mChanTmp;
+      oPtr = buf;
+      while(1)
+      {
+         pixel = *iPtr++;
+         count = (int)(pixel & 0x7F);
+         if(!count)
+         {
+            return;
+         }
+         if (pixel & 0x80)
+         {
+            while (count--)
+            {
+               *oPtr++ = *iPtr++;
+            }
+         }
+         else
+         {
+            pixel = *iPtr++;
+            while (count--)
+            {
+               *oPtr++ = pixel;
+            }
+         }
+      }
+   }
+   else
+   {
+      fseek(mFp,
+         sizeof(struct sImageSgiHeader)+(y*raw->header.xsize) +
+            (z*raw->header.xsize*raw->header.ysize),
+         SEEK_SET);
+      fread(buf, 1, raw->header.xsize, mFp);
+   }
+
+   return;
+} // ImageSgiRawGetRow
+
+
+/*****************************************************************************/
+static void ImageSgiRawGetData(struct sImageSgiRaw *raw, struct sImageSgi 
+*final)
+{
+   unsigned char *ptr = NULL;
+   int i, j;
+
+   final->data =
+      new unsigned 
+char[raw->header.xsize*raw->header.ysize*raw->header.zsize];
+   assert(final->data);
+
+   ptr = final->data;
+   for(i=0; i<raw->header.ysize; i++)
+   {
+      switch(raw->header.zsize)
+      {
+      case 1:
+         ImageSgiRawGetRow(raw, raw->chan0, i, 0);
+         for(j=0; j<raw->header.xsize; j++)
+            *(ptr++) = raw->chan0[j];
+         break;
+      case 2:
+         ImageSgiRawGetRow(raw, raw->chan0, i, 0);
+         ImageSgiRawGetRow(raw, raw->chan1, i, 1);
+         for(j=0; j<raw->header.xsize; j++)
+         {
+            *(ptr++) = raw->chan0[j];
+            *(ptr++) = raw->chan1[j];
+         }
+         break;
+      case 3:
+         ImageSgiRawGetRow(raw, raw->chan0, i, 0);
+         ImageSgiRawGetRow(raw, raw->chan1, i, 1);
+         ImageSgiRawGetRow(raw, raw->chan2, i, 2);
+         for(j=0; j<raw->header.xsize; j++)
+         {
+            *(ptr++) = raw->chan0[j];
+            *(ptr++) = raw->chan1[j];
+            *(ptr++) = raw->chan2[j];
+         }
+         break;
+      case 4:
+         ImageSgiRawGetRow(raw, raw->chan0, i, 0);
+         ImageSgiRawGetRow(raw, raw->chan1, i, 1);
+         ImageSgiRawGetRow(raw, raw->chan2, i, 2);
+         ImageSgiRawGetRow(raw, raw->chan3, i, 3);
+         for(j=0; j<raw->header.xsize; j++)
+         {
+            *(ptr++) = raw->chan0[j];
+            *(ptr++) = raw->chan1[j];
+            *(ptr++) = raw->chan2[j];
+            *(ptr++) = raw->chan3[j];
+         }
+         break;
+      }
+   }
+
+   return;
+} // ImageSgiRawGetData
+
+
+/*****************************************************************************/
+static void *SwitchEndian16(void *value)
+{
+   short value16 = *(short *) value;
+   value16 = ((value16 & 0xff00) >> 8L) +
+             ((value16 & 0x00ff) << 8L);
+   *(short *)value = value16;
+   return value;
+} // SwitchEndian16
+
+
+/*****************************************************************************/
+static void *SwitchEndian32(void *value)
+{
+   int value32 = *(int *) value;
+   value32 = ((value32 & 0xff000000) >> 24L) +
+             ((value32 & 0x00ff0000) >> 8)   +
+             ((value32 & 0x0000ff00) << 8)   +
+             ((value32 & 0x000000ff) << 24L);
+   *(int *)value = value32;
+   return value;
+} // SwitchEndian32
+
diff -Naur mesa-demos-8.4.0-old/src/util/imagesgi.h mesa-demos-8.4.0-new/src/util/imagesgi.h
--- mesa-demos-8.4.0-old/src/util/imagesgi.h	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/util/imagesgi.h	2020-04-11 09:49:44.113059934 -0700
@@ -0,0 +1,55 @@
+/******************************************************************************
+** Filename       : imageSgi.h
+**                  UNCLASSIFIED
+**
+** Description    : Utility to read SGI image format files.  This code was
+**                  originally a SGI image loading utility provided with the
+**                  Mesa 3D library @ http://www.mesa3d.org by Brain Paul.
+**                  This has been extended to read all SGI image formats
+**                  (e.g. INT, INTA, RGB, RGBA).
+**
+** Revision History:
+**   Date       Name   Description
+**   06/08/99   BRC    Initial Release
+**
+******************************************************************************/
+
+#ifndef __IMAGESGI_H
+#define __IMAGESGI_H
+
+#define IMAGE_SGI_TYPE_VERBATIM 0
+#define IMAGE_SGI_TYPE_RLE      1
+
+struct sImageSgiHeader          // 512 bytes
+{
+  short magic;                  // IRIS image file magic number (474)
+  char type;                    // Storage format (e.g. RLE or VERBATIM)
+  char numBytesPerPixelChannel; // Number of bytes per pixel channel
+  unsigned short dim;           // Number of dimensions (1 to 3)
+  unsigned short xsize;         // Width (in pixels)
+  unsigned short ysize;         // Height (in pixels)
+  unsigned short zsize;         // Number of channels (1 to 4)
+  int minimumPixelValue;        // Minimum pixel value (0 to 255)
+  int maximumPixelValue;        // Maximum pixel value (0 to 255)
+  char padding1[4];             // (ignored)
+  char imageName[80];           // Image name
+  int colormap;                 // colormap ID (0=normal, 0=dithered,
+                                // 2=screen, 3=colormap)
+  char padding2[404];           // (ignored)
+};
+
+struct sImageSgi
+{
+   struct sImageSgiHeader header;
+   unsigned char *data;
+};
+
+#ifndef __IMAGESGI_CPP
+
+// RGB image load utility
+extern struct sImageSgi *ImageSgiOpen(char const * const fileName);
+extern void ImageSgiClose(struct sImageSgi *image);
+
+#endif
+
+#endif /* __IMAGESGI_H */
diff -Naur mesa-demos-8.4.0-old/src/util/matrix.c mesa-demos-8.4.0-new/src/util/matrix.c
--- mesa-demos-8.4.0-old/src/util/matrix.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/util/matrix.c	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,181 @@
+/*
+ * matrix.c
+ *
+ * Some useful matrix functions.
+ *
+ * Brian Paul
+ * 10 Feb 2004
+ */
+
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+
+/**
+ * Pretty-print the given matrix.
+ */
+void
+PrintMatrix(const float p[16])
+{
+   printf("[ %6.3f %6.3f %6.3f %6.3f ]\n", p[0], p[4], p[8], p[12]);
+   printf("[ %6.3f %6.3f %6.3f %6.3f ]\n", p[1], p[5], p[9], p[13]);
+   printf("[ %6.3f %6.3f %6.3f %6.3f ]\n", p[2], p[6], p[10], p[14]);
+   printf("[ %6.3f %6.3f %6.3f %6.3f ]\n", p[3], p[7], p[11], p[15]);
+}
+
+
+/**
+ * Build a glFrustum matrix.
+ */
+void
+Frustum(float left, float right, float bottom, float top, float nearZ, float farZ, float *m)
+{
+   float x = (2.0F*nearZ) / (right-left);
+   float y = (2.0F*nearZ) / (top-bottom);
+   float a = (right+left) / (right-left);
+   float b = (top+bottom) / (top-bottom);
+   float c = -(farZ+nearZ) / ( farZ-nearZ);
+   float d = -(2.0F*farZ*nearZ) / (farZ-nearZ);
+
+#define M(row,col)  m[col*4+row]
+   M(0,0) = x;     M(0,1) = 0.0F;  M(0,2) = a;      M(0,3) = 0.0F;
+   M(1,0) = 0.0F;  M(1,1) = y;     M(1,2) = b;      M(1,3) = 0.0F;
+   M(2,0) = 0.0F;  M(2,1) = 0.0F;  M(2,2) = c;      M(2,3) = d;
+   M(3,0) = 0.0F;  M(3,1) = 0.0F;  M(3,2) = -1.0F;  M(3,3) = 0.0F;
+#undef M
+}
+
+
+/**
+ * Build a glOrtho marix.
+ */
+void
+Ortho(float left, float right, float bottom, float top, float nearZ, float farZ, float *m)
+{
+#define M(row,col)  m[col*4+row]
+   M(0,0) = 2.0F / (right-left);
+   M(0,1) = 0.0F;
+   M(0,2) = 0.0F;
+   M(0,3) = -(right+left) / (right-left);
+
+   M(1,0) = 0.0F;
+   M(1,1) = 2.0F / (top-bottom);
+   M(1,2) = 0.0F;
+   M(1,3) = -(top+bottom) / (top-bottom);
+
+   M(2,0) = 0.0F;
+   M(2,1) = 0.0F;
+   M(2,2) = -2.0F / (farZ-nearZ);
+   M(2,3) = -(farZ+nearZ) / (farZ-nearZ);
+
+   M(3,0) = 0.0F;
+   M(3,1) = 0.0F;
+   M(3,2) = 0.0F;
+   M(3,3) = 1.0F;
+#undef M
+}
+
+
+/**
+ * Decompose a projection matrix to determine original glFrustum or
+ * glOrtho parameters.
+ */
+void
+DecomposeProjection( const float *m,
+                     int *isPerspective,
+                     float *leftOut, float *rightOut,
+                     float *botOut, float *topOut,
+                     float *nearOut, float *farOut)
+{
+   if (m[15] == 0.0) {
+      /* perspective */
+      float p[16];
+      const float x = m[0];  /* 2N / (R-L) */
+      const float y = m[5];  /* 2N / (T-B) */
+      const float a = m[8];  /* (R+L) / (R-L) */
+      const float b = m[9];  /* (T+B) / (T-B) */
+      const float c = m[10]; /* -(F+N) / (F-N) */
+      const float d = m[14]; /* -2FN / (F-N) */
+
+      /* These equations found with simple algebra, knowing the arithmetic
+       * use to set up a typical perspective projection matrix in OpenGL.
+       */
+      const float nearZ = -d / (1.0 - c);
+      const float farZ = (c - 1.0) * nearZ / (c + 1.0);
+      const float left = nearZ * (a - 1.0) / x;
+      const float right = 2.0 * nearZ / x + left;
+      const float bottom = nearZ * (b - 1.0) / y;
+      const float top = 2.0 * nearZ / y + bottom;
+
+      *isPerspective = 1;
+      *leftOut = left;
+      *rightOut = right;
+      *botOut = bottom;
+      *topOut = top;
+      *nearOut = nearZ;
+      *farOut = farZ;
+   }
+   else {
+      /* orthographic */
+      const float x = m[0];  /*  2 / (R-L) */
+      const float y = m[5];  /*  2 / (T-B) */
+      const float z = m[10]; /* -2 / (F-N) */
+      const float a = m[12]; /* -(R+L) / (R-L) */
+      const float b = m[13]; /* -(T+B) / (T-B) */
+      const float c = m[14]; /* -(F+N) / (F-N) */
+      /* again, simple algebra */
+      const float right  = -(a - 1.0) / x;
+      const float left   = right - 2.0 / x;
+      const float top    = -(b - 1.0) / y;
+      const float bottom = top - 2.0 / y;
+      const float farZ   = (c - 1.0) / z;
+      const float nearZ  = farZ + 2.0 / z;
+
+      *isPerspective = 0;
+      *leftOut = left;
+      *rightOut = right;
+      *botOut = bottom;
+      *topOut = top;
+      *nearOut = nearZ;
+      *farOut = farZ;
+   }
+}
+
+
+#if 0
+/* test harness */
+int
+main(int argc, char *argv[])
+{
+   float m[16], p[16];
+   float l, r, b, t, n, f;
+   int persp;
+   int i;
+
+#if 0
+   l = -.9;
+   r = 1.2;
+   b = -0.5;
+   t = 1.4;
+   n = 30;
+   f = 84;
+   printf("  Frustum(%f, %f, %f, %f, %f, %f\n",l+1, r+1.2, b+.5, t+.3, n, f);
+   Frustum(l+1, r+1.2, b+.5, t+.3, n, f, p);
+   DecomposeProjection(p, &persp, &l, &r, &b, &t, &n, &f);
+   printf("glFrustum(%f, %f, %f, %f, %f, %f)\n",
+          l, r, b, t, n, f);
+   PrintMatrix(p);
+#else
+   printf("Ortho(-1, 1, -1, 1, 10, 84)\n");
+   Ortho(-1, 1, -1, 1, 10, 84, m);
+   PrintMatrix(m);
+   DecomposeProjection(m, &persp, &l, &r, &b, &t, &n, &f);
+   printf("Ortho(%f, %f, %f, %f, %f, %f) %d\n", l, r, b, t, n, f, persp);
+#endif
+
+   return 0;
+}
+#endif
diff -Naur mesa-demos-8.4.0-old/src/util/mwmborder.c mesa-demos-8.4.0-new/src/util/mwmborder.c
--- mesa-demos-8.4.0-old/src/util/mwmborder.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/util/mwmborder.c	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,91 @@
+/* mwmborder.c */
+
+
+/*
+ * This function shows how to remove the border, title bar, resize button,
+ * etc from a Motif window frame from inside an Xlib-based application.
+ *
+ * Brian Paul  19 Sep 1995   brianp@ssec.wisc.edu
+ *
+ * This code is in the public domain.
+ */
+
+
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+
+#define HAVE_MOTIF
+#ifdef HAVE_MOTIF
+
+#include <X11/Xm/MwmUtil.h>
+
+#else
+
+/* bit definitions for MwmHints.flags */
+#define MWM_HINTS_FUNCTIONS     (1L << 0)
+#define MWM_HINTS_DECORATIONS   (1L << 1)
+#define MWM_HINTS_INPUT_MODE    (1L << 2)
+#define MWM_HINTS_STATUS        (1L << 3)
+
+/* bit definitions for MwmHints.decorations */
+#define MWM_DECOR_ALL           (1L << 0)
+#define MWM_DECOR_BORDER        (1L << 1)
+#define MWM_DECOR_RESIZEH       (1L << 2)
+#define MWM_DECOR_TITLE         (1L << 3)
+#define MWM_DECOR_MENU          (1L << 4)
+#define MWM_DECOR_MINIMIZE      (1L << 5)
+#define MWM_DECOR_MAXIMIZE      (1L << 6)
+
+typedef struct
+{
+    unsigned long       flags;
+    unsigned long       functions;
+    unsigned long       decorations;
+    long                inputMode;
+    unsigned long       status;
+} PropMotifWmHints;
+
+#define PROP_MOTIF_WM_HINTS_ELEMENTS    5
+
+#endif
+
+
+
+/*
+ * Specify which Motif window manager border decorations to put on a
+ * top-level window.  For example, you can specify that a window is not
+ * resizabe, or omit the titlebar, or completely remove all decorations.
+ * Input:  dpy - the X display
+ *         w - the X window
+ *         flags - bitwise-OR of the MWM_DECOR_xxx symbols in X11/Xm/MwmUtil.h
+ *                 indicating what decoration elements to enable.  Zero would
+ *                 be no decoration.
+ */
+void set_mwm_border( Display *dpy, Window w, unsigned long flags )
+{
+   PropMotifWmHints motif_hints;
+   Atom prop, proptype;
+
+   /* setup the property */
+   motif_hints.flags = MWM_HINTS_DECORATIONS;
+   motif_hints.decorations = flags;
+
+   /* get the atom for the property */
+   prop = XInternAtom( dpy, "_MOTIF_WM_HINTS", True );
+   if (!prop) {
+      /* something went wrong! */
+      return;
+   }
+
+   /* not sure this is correct, seems to work, XA_WM_HINTS didn't work */
+   proptype = prop;
+
+   XChangeProperty( dpy, w,                         /* display, window */
+                    prop, proptype,                 /* property, type */
+                    32,                             /* format: 32-bit datums */
+                    PropModeReplace,                /* mode */
+                    (unsigned char *) &motif_hints, /* data */
+                    PROP_MOTIF_WM_HINTS_ELEMENTS    /* nelements */
+                  );
+}
+
diff -Naur mesa-demos-8.4.0-old/src/util/winpos.c mesa-demos-8.4.0-new/src/util/winpos.c
--- mesa-demos-8.4.0-old/src/util/winpos.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/util/winpos.c	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,42 @@
+/* winpos.c */
+
+
+/*
+ * Set the current raster position to a specific window
+ * coordinate.  Also see the GL_MESA_window_pos extension.
+ *
+ * Written by Brian Paul and in the public domain.
+ */
+
+
+void WindowPos( GLfloat x, GLfloat y, GLfloat z )
+{
+   GLfloat fx, fy;
+
+   /* Push current matrix mode and viewport attributes */
+   glPushAttrib( GL_TRANSFORM_BIT | GL_VIEWPORT_BIT );
+
+   /* Setup projection parameters */
+   glMatrixMode( GL_PROJECTION );
+   glPushMatrix();
+   glLoadIdentity();
+   glMatrixMode( GL_MODELVIEW );
+   glPushMatrix();
+   glLoadIdentity();
+
+   glDepthRange( z, z );
+   glViewport( (int) x - 1, (int) y - 1, 2, 2 );
+
+   /* set the raster (window) position */
+   fx = x - (int) x;
+   fy = y - (int) y;
+   glRasterPos3f( fx, fy, 0.0 );
+
+   /* restore matrices, viewport and matrix mode */
+   glPopMatrix();
+   glMatrixMode( GL_PROJECTION );
+   glPopMatrix();
+
+   glPopAttrib();
+}
+
diff -Naur mesa-demos-8.4.0-old/src/vp/add-param-imm.txt mesa-demos-8.4.0-new/src/vp/add-param-imm.txt
--- mesa-demos-8.4.0-old/src/vp/add-param-imm.txt	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/vp/add-param-imm.txt	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,7 @@
+!!ARBvp1.0
+TEMP R0;
+PARAM Emission = state.material.emission; 
+ADD R0, vertex.color, {-0.5}.x;
+ADD result.color, R0, Emission.w;
+MOV  result.position, vertex.position;
+END
diff -Naur mesa-demos-8.4.0-old/src/vpglsl/infinite-loop.glsl mesa-demos-8.4.0-new/src/vpglsl/infinite-loop.glsl
--- mesa-demos-8.4.0-old/src/vpglsl/infinite-loop.glsl	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/vpglsl/infinite-loop.glsl	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,8 @@
+void main() {
+   gl_Position = gl_Vertex;
+   vec4 sum = vec4(0);
+   for (int i = 1; i != 2; i += 2) {
+      sum += vec4(0.1, 0.1, 0.1, 0.1);
+   }
+   gl_FrontColor = sum;
+}
diff -Naur mesa-demos-8.4.0-old/src/wgl/wglcontext.c mesa-demos-8.4.0-new/src/wgl/wglcontext.c
--- mesa-demos-8.4.0-old/src/wgl/wglcontext.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/wgl/wglcontext.c	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,338 @@
+/*
+ * Copyright (C) 2011 Morgan Armand <morgan.devel@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <windows.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <GL/glew.h>
+#include <GL/wglew.h>
+#include <GL/glext.h>
+
+#ifndef GL_CONTEXT_FLAG_DEBUG_BIT
+#define GL_CONTEXT_FLAG_DEBUG_BIT         0x00000002
+#endif
+#ifndef GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT
+#define GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT 0x00000004
+#endif
+
+#ifndef GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR
+#define GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR  0x00000008
+#endif
+
+
+static LRESULT CALLBACK
+WndProc(HWND hWnd,
+        UINT uMsg,
+        WPARAM wParam,
+        LPARAM lParam )
+{
+   switch (uMsg) {
+   case WM_DESTROY:
+      PostQuitMessage(0);
+      break;
+   default:
+      return DefWindowProc(hWnd, uMsg, wParam, lParam);
+   }
+
+   return 0;
+}
+
+static const char *
+context_error_to_string(DWORD error)
+{
+   switch (error) {
+   case ERROR_INVALID_VERSION_ARB:  return "ERROR_INVALID_VERSION_ARB";
+   case ERROR_INVALID_PROFILE_ARB:  return "ERROR_INVALID_PROFILE_ARB";
+   case ERROR_INVALID_OPERATION:    return "ERROR_INVALID_OPERATION";
+   case ERROR_DC_NOT_FOUND:         return "ERROR_DC_NOT_FOUND";
+   case ERROR_INVALID_PIXEL_FORMAT: return "ERROR_INVALID_PIXEL_FORMAT";
+   case ERROR_NO_SYSTEM_RESOURCES:  return "ERROR_NO_SYSTEM_RESOURCES";
+   case ERROR_INVALID_PARAMETER:    return "ERROR_INVALID_PARAMETER";
+   default:                         return "Unknown Error";
+   }
+}
+
+static char *
+profile_mask_to_string(GLint profileMask)
+{
+   switch (profileMask) {
+   case GL_CONTEXT_CORE_PROFILE_BIT:
+      return "GL_CONTEXT_CORE_PROFILE_BIT";
+   case GL_CONTEXT_COMPATIBILITY_PROFILE_BIT:
+      return "GL_CONTEXT_COMPATIBILITY_PROFILE_BIT";
+   default:
+      return "0";
+   }
+}
+
+static char *
+context_flags_to_string(GLint flags)
+{
+   static char buf[1000] = {0};
+   if (flags & GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT)
+      strcat(buf, "GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT | ");
+   if (flags & GL_CONTEXT_FLAG_DEBUG_BIT)
+      strcat(buf, "GL_CONTEXT_FLAG_DEBUG_BIT | ");
+   if (flags & GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT)
+      strcat(buf, "GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT | ");
+   if (flags & GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR)
+      strcat(buf, "GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR | ");
+
+   int n = strlen(buf);
+   if (n >= 3) {
+      /* rm the trailing " | " */
+      buf[n-3] = 0;
+   }
+   else {
+      strcat(buf, "(none)");
+   }
+
+   return buf;
+}
+
+static void
+print_context_infos(void)
+{
+   GLint majorVersion;
+   GLint minorVersion;
+   GLint profileMask, flags;
+   const char *version, *vendor, *renderer;
+
+   fprintf(stdout, "Context Informations\n");
+
+   version = (const char *)glGetString(GL_VERSION);
+   fprintf(stdout, "GL_VERSION: %s\n", version);
+
+   vendor = (const char *)glGetString(GL_VENDOR);
+   fprintf(stdout, "GL_VENDOR: %s\n", vendor);
+
+   renderer = (const char *)glGetString(GL_RENDERER);
+   fprintf(stdout, "GL_RENDERER: %s\n", renderer);
+
+   // Request informations with the new 3.x features.
+   if (sscanf(version, "%d.%d", &majorVersion, &minorVersion) != 2)
+      return;
+
+   if (majorVersion >= 3) {
+      glGetIntegerv(GL_MAJOR_VERSION, &majorVersion);
+      glGetIntegerv(GL_MINOR_VERSION, &minorVersion);
+      fprintf(stdout, "GL_MAJOR_VERSION: %d\n", majorVersion);
+      fprintf(stdout, "GL_MINOR_VERSION: %d\n", minorVersion);
+   }
+   if (majorVersion * 10 + minorVersion >= 32) {
+      glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &profileMask);
+      glGetIntegerv(GL_CONTEXT_FLAGS, &flags);
+      fprintf(stdout, "GL_CONTEXT_PROFILE_MASK: %s\n",
+              profile_mask_to_string(profileMask));
+      fprintf(stdout, "GL_CONTEXT_FLAGS: %s\n",
+              context_flags_to_string(flags));
+   }
+
+   /* Test if deprecated features work or generate an error */
+   while (glGetError() != GL_NO_ERROR)
+      ;
+
+   (void) glGenLists(1);
+   if (glGetError()) {
+      fprintf(stdout, "glGenLists generated an error.\n");
+   }
+   else {
+      fprintf(stdout, "glGenLists generated no error.\n");
+   }
+}
+
+static void
+create_context(int majorVersion, int minorVersion, int profileMask, int contextFlags)
+{
+   WNDCLASS wc;
+   HWND win;
+   HDC hdc;
+   PIXELFORMATDESCRIPTOR pfd;
+   int pixelFormat;
+   HGLRC tmp, ctx;
+   PFNWGLCREATECONTEXTATTRIBSARBPROC wglCreateContextAttribsARB;
+
+   memset(&wc, 0, sizeof(wc));
+   wc.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
+   wc.lpfnWndProc = WndProc;
+   wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
+   wc.hCursor = LoadCursor(NULL, IDC_ARROW);
+   wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
+   wc.lpszClassName = "wglcontext";
+
+   if (!RegisterClass(&wc)) {
+      fprintf(stderr, "RegisterClass() failed\n");
+      return;
+   }
+
+   win = CreateWindowEx(0,
+                     wc.lpszClassName,
+                     "wglinfo",
+                     WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
+                     CW_USEDEFAULT,
+                     CW_USEDEFAULT,
+                     CW_USEDEFAULT,
+                     CW_USEDEFAULT,
+                     NULL,
+                     NULL,
+                     wc.hInstance,
+                     NULL);
+   if (!win) {
+      fprintf(stderr, "CreateWindowEx() failed\n");
+      return;
+   }
+
+   hdc = GetDC(win);
+   if (!hdc) {
+      fprintf(stderr, "GetDC() failed\n");
+      return;
+   }
+
+   memset(&pfd, 0, sizeof(pfd));
+   pfd.nSize = sizeof(pfd);
+   pfd.nVersion = 1;
+   pfd.dwFlags = PFD_DOUBLEBUFFER | PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
+   pfd.iPixelType = PFD_TYPE_RGBA;
+   pfd.cColorBits = 24;
+   pfd.cDepthBits = 24;
+   pfd.iLayerType = PFD_MAIN_PLANE;
+
+   pixelFormat = ChoosePixelFormat(hdc, &pfd);
+   if (!pixelFormat) {
+      fprintf(stderr, "ChoosePixelFormat() failed\n");
+      return;
+   }
+
+   if (!SetPixelFormat(hdc, pixelFormat, &pfd)) {
+      fprintf(stderr, "SetPixelFormat() failed\n");
+      return;
+   }
+
+   tmp = wglCreateContext(hdc);
+   if (!tmp) {
+      fprintf(stderr, "wglCreateContext() failed\n");
+      return;
+   }
+
+   if (!wglMakeCurrent(hdc, tmp)) {
+      fprintf(stderr, "wglMakeCurrent() failed\n");
+      return;
+   }
+
+   wglCreateContextAttribsARB =
+      (PFNWGLCREATECONTEXTATTRIBSARBPROC)wglGetProcAddress("wglCreateContextAttribsARB");
+
+   if (!wglCreateContextAttribsARB) {
+      fprintf(stderr, "wglCreateContextAttribsARB isn't supported\n");
+      return;
+   }
+
+   int attribsList[20];
+   int i = 0;
+   attribsList[i++] = WGL_CONTEXT_MAJOR_VERSION_ARB;
+   attribsList[i++] = majorVersion;
+   attribsList[i++] = WGL_CONTEXT_MINOR_VERSION_ARB;
+   attribsList[i++] = minorVersion;
+   if (contextFlags) {
+      attribsList[i++] = WGL_CONTEXT_FLAGS_ARB;
+      attribsList[i++] = contextFlags;
+   }
+   if (profileMask) {
+      attribsList[i++] = WGL_CONTEXT_PROFILE_MASK_ARB;
+      attribsList[i++] = profileMask;
+   }
+   attribsList[i++] = 0;
+
+   ctx = wglCreateContextAttribsARB(hdc, 0, attribsList);
+   if (!ctx) {
+      DWORD error = GetLastError();
+      fprintf(stderr, "wglCreateContextAttribsARB failed(): %s (0x%lx)\n",
+              context_error_to_string(error), error);
+      return;
+   }
+
+   wglMakeCurrent(NULL, NULL);
+   wglDeleteContext(tmp);
+
+   if (!wglMakeCurrent(hdc, ctx)) {
+      fprintf(stderr, "wglMakeCurrent() failed\n");
+      return;
+   }
+
+   print_context_infos();
+}
+
+static void
+usage(void)
+{
+   fprintf(stdout, "Usage: wglcontext [-h] [-major <major>] [-minor <minor>] [-core] [-compat] [-debug] [-forward]\n");
+   fprintf(stdout, "   -major   : specify the major version you want\n");
+   fprintf(stdout, "   -minor   : specify the minor version you want\n");
+   fprintf(stdout, "   -core    : request a context implementing the core profile\n");
+   fprintf(stdout, "   -compat  : request a context implementing the compatibility profile\n");
+   fprintf(stdout, "   -debug   : request a debug context\n");
+   fprintf(stdout, "   -forward : request a forward-compatible context\n");
+}
+
+int
+main(int argc, char *argv[])
+{
+   int i;
+   int majorVersion = 1, minorVersion = 0;
+   int contextFlags = 0x0;
+   int profileMask = 0x0;
+
+   for (i = 1; i < argc; i++) {
+      if (strcmp(argv[i], "-h") == 0) {
+         usage();
+         exit(0);
+      }
+      else if (strcmp(argv[i], "-major") == 0 && i + 1 < argc) {
+         majorVersion = (int)strtol(argv[i + 1], (char **)NULL, 10);
+         i++;
+      }
+      else if (strcmp(argv[i], "-minor") == 0 && i + 1 < argc) {
+         minorVersion = (int)strtol(argv[i + 1], (char **)NULL, 10);
+         i++;
+      }
+      else if (strcmp(argv[i], "-core") == 0) {
+         profileMask = WGL_CONTEXT_CORE_PROFILE_BIT_ARB;
+      }
+      else if (strcmp(argv[i], "-compat") == 0) {
+         profileMask = WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB;
+      }
+      else if (strcmp(argv[i], "-debug") == 0) {
+         contextFlags |= WGL_CONTEXT_DEBUG_BIT_ARB;
+      }
+      else if (strcmp(argv[i], "-forward") == 0) {
+         contextFlags |= WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB;
+      }
+      else {
+         usage();
+         exit(1);
+      }
+   }
+
+   create_context(majorVersion, minorVersion,
+                  profileMask, contextFlags);
+
+   return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/wgl/wglfontbitmaps.c mesa-demos-8.4.0-new/src/wgl/wglfontbitmaps.c
--- mesa-demos-8.4.0-old/src/wgl/wglfontbitmaps.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/wgl/wglfontbitmaps.c	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016, VMware, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <windows.h>
+#include <stdlib.h>
+#include <GL/gl.h>
+
+int
+main(int argc, char *argv[])
+{
+   WNDCLASS wc;
+   HWND hwnd;
+   HDC hdc;
+   PIXELFORMATDESCRIPTOR pfd;
+   int iPixelFormat;
+   HGLRC hglrc;
+
+   ZeroMemory(&wc, sizeof wc);
+   wc.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
+   wc.lpfnWndProc = DefWindowProc;
+   wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
+   wc.hCursor = LoadCursor(NULL, IDC_ARROW);
+   wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
+   wc.lpszClassName = "wglfont";
+
+   if (!RegisterClass(&wc)) {
+      abort();
+   }
+
+   hwnd = CreateWindowEx(0,
+                         wc.lpszClassName,
+                         "wglfont",
+                         WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_TILEDWINDOW,
+                         CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
+                         NULL, NULL,
+                         wc.hInstance,
+                         NULL);
+   if (!hwnd) {
+      abort();
+   }
+
+   hdc = GetDC(hwnd);
+   if (!hdc) {
+      abort();
+   }
+
+   ZeroMemory(&pfd, sizeof pfd);
+   pfd.nSize = sizeof pfd;
+   pfd.nVersion = 1;
+   pfd.dwFlags = PFD_DOUBLEBUFFER | PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
+   pfd.iPixelType = PFD_TYPE_RGBA;
+   pfd.cColorBits = 24;
+   pfd.cDepthBits = 0;
+   pfd.iLayerType = PFD_MAIN_PLANE;
+
+   iPixelFormat = ChoosePixelFormat(hdc, &pfd);
+   if (!iPixelFormat) {
+      abort();
+   }
+
+   if (!SetPixelFormat(hdc, iPixelFormat, &pfd)) {
+      abort();
+   }
+
+   hglrc = wglCreateContext(hdc);
+   if (!hglrc) {
+      abort();
+   }
+
+   wglMakeCurrent(hdc, hglrc);
+
+   glClearColor(0.0, 0.0, 0.0, 1.0);
+   glClear(GL_COLOR_BUFFER_BIT);
+
+   SelectObject(hdc, GetStockObject(SYSTEM_FONT));
+
+   wglUseFontBitmaps(hdc, 0, 256, 1000);
+
+   glListBase(1000);
+
+   glCallLists(12, GL_UNSIGNED_BYTE, "Hello World!");
+
+   SwapBuffers(hdc);
+
+   Sleep(1000);
+
+   wglMakeCurrent(NULL, NULL);
+
+   wglDeleteContext(hglrc);
+
+   ReleaseDC(hwnd, hdc);
+
+   DestroyWindow(hwnd);
+
+   return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/wgl/wglfontoutlines.c mesa-demos-8.4.0-new/src/wgl/wglfontoutlines.c
--- mesa-demos-8.4.0-old/src/wgl/wglfontoutlines.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/wgl/wglfontoutlines.c	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2016, VMware, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <windows.h>
+#include <stdlib.h>
+#include <GL/gl.h>
+
+int
+main(int argc, char *argv[])
+{
+   WNDCLASS wc;
+   HWND hwnd;
+   HDC hdc;
+   PIXELFORMATDESCRIPTOR pfd;
+   int iPixelFormat;
+   HGLRC hglrc;
+
+   ZeroMemory(&wc, sizeof wc);
+   wc.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
+   wc.lpfnWndProc = DefWindowProc;
+   wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
+   wc.hCursor = LoadCursor(NULL, IDC_ARROW);
+   wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
+   wc.lpszClassName = "wglfont";
+
+   if (!RegisterClass(&wc)) {
+      abort();
+   }
+
+   hwnd = CreateWindowEx(0,
+                         wc.lpszClassName,
+                         "wglfont",
+                         WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_TILEDWINDOW,
+                         CW_USEDEFAULT, CW_USEDEFAULT, 512, 512,
+                         NULL, NULL,
+                         wc.hInstance,
+                         NULL);
+   if (!hwnd) {
+      abort();
+   }
+
+   hdc = GetDC(hwnd);
+   if (!hdc) {
+      abort();
+   }
+
+   ZeroMemory(&pfd, sizeof pfd);
+   pfd.nSize = sizeof pfd;
+   pfd.nVersion = 1;
+   pfd.dwFlags = PFD_DOUBLEBUFFER | PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
+   pfd.iPixelType = PFD_TYPE_RGBA;
+   pfd.cColorBits = 24;
+   pfd.cDepthBits = 0;
+   pfd.iLayerType = PFD_MAIN_PLANE;
+
+   iPixelFormat = ChoosePixelFormat(hdc, &pfd);
+   if (!iPixelFormat) {
+      abort();
+   }
+
+   if (!SetPixelFormat(hdc, iPixelFormat, &pfd)) {
+      abort();
+   }
+
+   hglrc = wglCreateContext(hdc);
+   if (!hglrc) {
+      abort();
+   }
+
+   wglMakeCurrent(hdc, hglrc);
+
+   glClearColor(0.0, 0.0, 0.0, 1.0);
+   glClear(GL_COLOR_BUFFER_BIT);
+
+   HFONT hFont;
+   hFont = CreateFont(72,			// Height Of Font
+                      0,			// Width Of Font
+                      0,			// Angle Of Escapement
+                      0,			// Orientation Angle
+                      FW_NORMAL,		// Font Weight
+                      FALSE,			// Italic
+                      FALSE,			// Underline
+                      FALSE,			// Strikeout
+                      ANSI_CHARSET,		// Character Set Identifier
+                      OUT_TT_PRECIS,		// Output Precision
+                      CLIP_DEFAULT_PRECIS,	// Clipping Precision
+                      ANTIALIASED_QUALITY,	// Output Quality
+                      FF_DONTCARE|DEFAULT_PITCH,	// Family And Pitch
+                      "Arial");			// Font Name
+   if (!hFont) {
+      abort();
+   }
+
+   SelectObject(hdc, hFont);
+
+   GLYPHMETRICSFLOAT agmf[256];
+   wglUseFontOutlinesA(hdc, 0, 256, 1000, 0.0f, 1.0f, WGL_FONT_POLYGONS, agmf);
+
+   glShadeModel(GL_SMOOTH);
+
+   glCullFace(GL_BACK);
+   glEnable(GL_CULL_FACE);
+
+   glEnable(GL_LIGHT0);
+   glEnable(GL_LIGHTING);
+   glEnable(GL_COLOR_MATERIAL);
+   glColor3f(1.0f, 0.5, 0.0);
+
+   glTranslatef(-0.8f, -0.0f, -1.0f);
+   glScalef(0.25f, 0.25f, 0.25f);
+
+   glListBase(1000);
+
+   glCallLists(12, GL_UNSIGNED_BYTE, "Hello World!");
+
+   SwapBuffers(hdc);
+
+   Sleep(1000);
+
+   wglMakeCurrent(NULL, NULL);
+
+   wglDeleteContext(hglrc);
+
+   ReleaseDC(hwnd, hdc);
+
+   DestroyWindow(hwnd);
+
+   return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/wgl/wglgears.c mesa-demos-8.4.0-new/src/wgl/wglgears.c
--- mesa-demos-8.4.0-old/src/wgl/wglgears.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/wgl/wglgears.c	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,576 @@
+/*
+ * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * This is a port of the infamous "gears" demo to straight GLX (i.e. no GLUT)
+ * Port by Brian Paul  23 March 2001
+ *
+ * Command line options:
+ *    -info      print GL implementation information
+ *
+ * Modified from X11/GLX to Win32/WGL by Ben Skeggs
+ * 25th October 2004
+ */
+
+#include <assert.h>
+#include <windows.h>
+#include <GL/gl.h>
+#include <GL/wglext.h>
+#include <math.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <math.h>
+
+/* XXX this probably isn't very portable */
+#include <time.h>
+#include <unistd.h>
+
+#ifndef M_PI
+#define M_PI 3.14159265
+#endif /* !M_PI */
+
+#ifndef WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB
+#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB 0x20A9
+#endif
+
+#ifndef GL_FRAMEBUFFER_SRGB
+#define GL_FRAMEBUFFER_SRGB 0x8db9
+#endif
+
+
+/* Global vars */
+static HDC hDC;
+static HGLRC hRC;
+static HWND hWnd;
+static HINSTANCE hInst;
+static RECT winrect;
+
+static const char *ProgramName;      /* program name (from argv[0]) */
+
+static GLfloat view_rotx = 20.0, view_roty = 30.0, view_rotz = 0.0;
+static GLint gear1, gear2, gear3;
+static GLfloat angle = 0.0;
+static GLboolean use_srgb = GL_FALSE;
+
+
+static
+void usage(void)
+{
+   fprintf (stderr, "usage:  %s [options]\n", ProgramName);
+   fprintf (stderr, "-info\tPrint additional GL information.\n");
+   fprintf (stderr, "-h\tPrint this help page.\n");
+   fprintf (stderr, "\n");
+   exit(EXIT_FAILURE);
+}
+
+
+/* return current time (in seconds) */
+static int
+current_time(void)
+{
+   return (int)time(NULL);
+}
+
+
+/*
+ *
+ *  Draw a gear wheel.  You'll probably want to call this function when
+ *  building a display list since we do a lot of trig here.
+ *
+ *  Input:  inner_radius - radius of hole at center
+ *          outer_radius - radius at center of teeth
+ *          width - width of gear
+ *          teeth - number of teeth
+ *          tooth_depth - depth of tooth
+ */
+static void
+gear(GLfloat inner_radius, GLfloat outer_radius, GLfloat width,
+     GLint teeth, GLfloat tooth_depth)
+{
+   GLint i;
+   GLfloat r0, r1, r2;
+   GLfloat angle, da;
+   GLfloat u, v, len;
+
+   r0 = inner_radius;
+   r1 = outer_radius - tooth_depth / 2.0;
+   r2 = outer_radius + tooth_depth / 2.0;
+
+   da = 2.0 * M_PI / teeth / 4.0;
+
+   glShadeModel(GL_FLAT);
+
+   glNormal3f(0.0, 0.0, 1.0);
+
+   /* draw front face */
+   glBegin(GL_QUAD_STRIP);
+   for (i = 0; i <= teeth; i++) {
+      angle = i * 2.0 * M_PI / teeth;
+      glVertex3f(r0 * cos(angle), r0 * sin(angle), width * 0.5);
+      glVertex3f(r1 * cos(angle), r1 * sin(angle), width * 0.5);
+      if (i < teeth) {
+	 glVertex3f(r0 * cos(angle), r0 * sin(angle), width * 0.5);
+	 glVertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
+		    width * 0.5);
+      }
+   }
+   glEnd();
+
+   /* draw front sides of teeth */
+   glBegin(GL_QUADS);
+   da = 2.0 * M_PI / teeth / 4.0;
+   for (i = 0; i < teeth; i++) {
+      angle = i * 2.0 * M_PI / teeth;
+
+      glVertex3f(r1 * cos(angle), r1 * sin(angle), width * 0.5);
+      glVertex3f(r2 * cos(angle + da), r2 * sin(angle + da), width * 0.5);
+      glVertex3f(r2 * cos(angle + 2 * da), r2 * sin(angle + 2 * da),
+		 width * 0.5);
+      glVertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
+		 width * 0.5);
+   }
+   glEnd();
+
+   glNormal3f(0.0, 0.0, -1.0);
+
+   /* draw back face */
+   glBegin(GL_QUAD_STRIP);
+   for (i = 0; i <= teeth; i++) {
+      angle = i * 2.0 * M_PI / teeth;
+      glVertex3f(r1 * cos(angle), r1 * sin(angle), -width * 0.5);
+      glVertex3f(r0 * cos(angle), r0 * sin(angle), -width * 0.5);
+      if (i < teeth) {
+	 glVertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
+		    -width * 0.5);
+	 glVertex3f(r0 * cos(angle), r0 * sin(angle), -width * 0.5);
+      }
+   }
+   glEnd();
+
+   /* draw back sides of teeth */
+   glBegin(GL_QUADS);
+   da = 2.0 * M_PI / teeth / 4.0;
+   for (i = 0; i < teeth; i++) {
+      angle = i * 2.0 * M_PI / teeth;
+
+      glVertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
+		 -width * 0.5);
+      glVertex3f(r2 * cos(angle + 2 * da), r2 * sin(angle + 2 * da),
+		 -width * 0.5);
+      glVertex3f(r2 * cos(angle + da), r2 * sin(angle + da), -width * 0.5);
+      glVertex3f(r1 * cos(angle), r1 * sin(angle), -width * 0.5);
+   }
+   glEnd();
+
+   /* draw outward faces of teeth */
+   glBegin(GL_QUAD_STRIP);
+   for (i = 0; i < teeth; i++) {
+      angle = i * 2.0 * M_PI / teeth;
+
+      glVertex3f(r1 * cos(angle), r1 * sin(angle), width * 0.5);
+      glVertex3f(r1 * cos(angle), r1 * sin(angle), -width * 0.5);
+      u = r2 * cos(angle + da) - r1 * cos(angle);
+      v = r2 * sin(angle + da) - r1 * sin(angle);
+      len = sqrt(u * u + v * v);
+      u /= len;
+      v /= len;
+      glNormal3f(v, -u, 0.0);
+      glVertex3f(r2 * cos(angle + da), r2 * sin(angle + da), width * 0.5);
+      glVertex3f(r2 * cos(angle + da), r2 * sin(angle + da), -width * 0.5);
+      glNormal3f(cos(angle), sin(angle), 0.0);
+      glVertex3f(r2 * cos(angle + 2 * da), r2 * sin(angle + 2 * da),
+		 width * 0.5);
+      glVertex3f(r2 * cos(angle + 2 * da), r2 * sin(angle + 2 * da),
+		 -width * 0.5);
+      u = r1 * cos(angle + 3 * da) - r2 * cos(angle + 2 * da);
+      v = r1 * sin(angle + 3 * da) - r2 * sin(angle + 2 * da);
+      glNormal3f(v, -u, 0.0);
+      glVertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
+		 width * 0.5);
+      glVertex3f(r1 * cos(angle + 3 * da), r1 * sin(angle + 3 * da),
+		 -width * 0.5);
+      glNormal3f(cos(angle), sin(angle), 0.0);
+   }
+
+   glVertex3f(r1 * cos(0), r1 * sin(0), width * 0.5);
+   glVertex3f(r1 * cos(0), r1 * sin(0), -width * 0.5);
+
+   glEnd();
+
+   glShadeModel(GL_SMOOTH);
+
+   /* draw inside radius cylinder */
+   glBegin(GL_QUAD_STRIP);
+   for (i = 0; i <= teeth; i++) {
+      angle = i * 2.0 * M_PI / teeth;
+      glNormal3f(-cos(angle), -sin(angle), 0.0);
+      glVertex3f(r0 * cos(angle), r0 * sin(angle), -width * 0.5);
+      glVertex3f(r0 * cos(angle), r0 * sin(angle), width * 0.5);
+   }
+   glEnd();
+}
+
+
+static void
+draw(void)
+{
+   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+   glPushMatrix();
+   glRotatef(view_rotx, 1.0, 0.0, 0.0);
+   glRotatef(view_roty, 0.0, 1.0, 0.0);
+   glRotatef(view_rotz, 0.0, 0.0, 1.0);
+
+   glPushMatrix();
+   glTranslatef(-3.0, -2.0, 0.0);
+   glRotatef(angle, 0.0, 0.0, 1.0);
+   glCallList(gear1);
+   glPopMatrix();
+
+   glPushMatrix();
+   glTranslatef(3.1, -2.0, 0.0);
+   glRotatef(-2.0 * angle - 9.0, 0.0, 0.0, 1.0);
+   glCallList(gear2);
+   glPopMatrix();
+
+   glPushMatrix();
+   glTranslatef(-3.1, 4.2, 0.0);
+   glRotatef(-2.0 * angle - 25.0, 0.0, 0.0, 1.0);
+   glCallList(gear3);
+   glPopMatrix();
+
+   glPopMatrix();
+}
+
+
+/* new window size or exposure */
+static void
+reshape(int width, int height)
+{
+   GLfloat h = (GLfloat) height / (GLfloat) width;
+
+   glViewport(0, 0, (GLint) width, (GLint) height);
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+   glFrustum(-1.0, 1.0, -h, h, 5.0, 60.0);
+   glMatrixMode(GL_MODELVIEW);
+   glLoadIdentity();
+   glTranslatef(0.0, 0.0, -40.0);
+}
+
+
+static void
+init(void)
+{
+   static GLfloat pos[4] = { 5.0, 5.0, 10.0, 0.0 };
+   static GLfloat red[4] = { 0.8, 0.1, 0.0, 1.0 };
+   static GLfloat green[4] = { 0.0, 0.8, 0.2, 1.0 };
+   static GLfloat blue[4] = { 0.2, 0.2, 1.0, 1.0 };
+
+   glLightfv(GL_LIGHT0, GL_POSITION, pos);
+   glEnable(GL_CULL_FACE);
+   glEnable(GL_LIGHTING);
+   glEnable(GL_LIGHT0);
+   glEnable(GL_DEPTH_TEST);
+   if (use_srgb) {
+      glEnable(GL_FRAMEBUFFER_SRGB);
+   }
+
+   /* make the gears */
+   gear1 = glGenLists(1);
+   glNewList(gear1, GL_COMPILE);
+   glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, red);
+   gear(1.0, 4.0, 1.0, 20, 0.7);
+   glEndList();
+
+   gear2 = glGenLists(1);
+   glNewList(gear2, GL_COMPILE);
+   glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, green);
+   gear(0.5, 2.0, 2.0, 10, 0.7);
+   glEndList();
+
+   gear3 = glGenLists(1);
+   glNewList(gear3, GL_COMPILE);
+   glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, blue);
+   gear(1.3, 2.0, 0.5, 10, 0.7);
+   glEndList();
+
+   glEnable(GL_NORMALIZE);
+}
+
+
+static LRESULT CALLBACK
+WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+   switch (uMsg) {
+   case WM_CLOSE:
+      PostQuitMessage(0);
+      return 0;
+   case WM_SIZE:
+      reshape(LOWORD(lParam), HIWORD(lParam));
+      return 0;
+   case WM_KEYDOWN:
+      if (wParam == VK_LEFT)
+         view_roty += 5.0;
+      else if (wParam == VK_RIGHT)
+         view_roty -= 5.0;
+      else if (wParam == VK_UP)
+         view_rotx += 5.0;
+      else if (wParam == VK_DOWN)
+         view_rotx -= 5.0;
+      else if (wParam == VK_ESCAPE)
+         PostQuitMessage(0);
+      return 0;
+   }
+
+   return DefWindowProc(hWnd, uMsg, wParam, lParam);
+}
+
+
+/*
+ * Create an RGB, double-buffered window.
+ * Return the window and context handles.
+ */
+static void
+make_window(const char *name, int x, int y, int width, int height)
+{
+   int pixelFormat;
+   WNDCLASS wc;
+   DWORD dwExStyle, dwStyle;
+   static const PIXELFORMATDESCRIPTOR pfd = {
+      sizeof(PIXELFORMATDESCRIPTOR),
+      1,
+      PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
+      PFD_TYPE_RGBA,
+      24,
+      0, 0, 0, 0, 0, 0,
+      0,
+      0,
+      0,
+      0, 0, 0, 0,
+      16,
+      0,
+      0,
+      PFD_MAIN_PLANE,
+      0,
+      0, 0, 0
+   };
+
+   winrect.left = (long)0;
+   winrect.right = (long)width;
+   winrect.top = (long) 0;
+   winrect.bottom = (long)height;
+
+   hInst = GetModuleHandle(NULL);
+   wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
+   wc.lpfnWndProc = (WNDPROC)WndProc;
+   wc.cbClsExtra = 0;
+   wc.cbWndExtra = 0;
+   wc.hInstance = hInst;
+   wc.hIcon = LoadIcon(NULL, IDI_WINLOGO);
+   wc.hCursor = LoadCursor(NULL, IDC_ARROW);
+   wc.hbrBackground = NULL;
+   wc.lpszMenuName = NULL;
+   wc.lpszClassName = name;
+   if (!RegisterClass(&wc)) {
+      printf("failed to register class\n");
+      exit(0);
+   }
+
+   dwExStyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;
+   dwStyle = WS_OVERLAPPEDWINDOW;
+   AdjustWindowRectEx(&winrect, dwStyle, FALSE, dwExStyle);
+
+   if (!(hWnd = CreateWindowEx(dwExStyle, name, name,
+                               WS_CLIPSIBLINGS | WS_CLIPCHILDREN | dwStyle,
+                               0, 0,
+                               winrect.right - winrect.left,
+                               winrect.bottom - winrect.top,
+                               NULL, NULL, hInst, NULL))) {
+      printf("failed to create window\n");
+      exit(0);
+   }
+
+   if (!(hDC = GetDC(hWnd)) ||
+       !(pixelFormat = ChoosePixelFormat(hDC, &pfd)) ||
+       !(SetPixelFormat(hDC, pixelFormat, &pfd)) ||
+       !(hRC = wglCreateContext(hDC)) ||
+       !(wglMakeCurrent(hDC, hRC))) {
+      printf("failed to initialise opengl\n");
+      exit(0);
+   }
+
+   if (use_srgb) {
+      /* We can't query/use extension functions until after we've
+       * created and bound a rendering context (done above).
+       *
+       * We can only set the pixel format of the window once, so we need to
+       * create a new device context in order to use the pixel format returned
+       * from wglChoosePixelFormatARB, and then create a new window.
+       */
+      PFNWGLCHOOSEPIXELFORMATARBPROC wglChoosePixelFormatARB_func =
+         (PFNWGLCHOOSEPIXELFORMATARBPROC)
+         wglGetProcAddress("wglChoosePixelFormatARB");
+      assert(wglChoosePixelFormatARB_func);
+
+      static const int int_attribs[] = {
+         WGL_SUPPORT_OPENGL_ARB, TRUE,
+         WGL_DRAW_TO_WINDOW_ARB, TRUE,
+         WGL_COLOR_BITS_ARB, 24,  // at least 24-bits of RGB
+         WGL_DEPTH_BITS_ARB, 24,
+         WGL_DOUBLE_BUFFER_ARB, TRUE,
+         WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB, TRUE,
+         0
+      };
+      static const float float_attribs[] = { 0 };
+      UINT numFormats;
+
+      pixelFormat = 0;
+      if (!wglChoosePixelFormatARB_func(hDC, int_attribs, float_attribs, 1,
+                                        &pixelFormat, &numFormats)) {
+         printf("wglChoosePixelFormatARB failed\n");
+         exit(0);
+      }
+      assert(numFormats > 0);
+      printf("Chose sRGB pixel format %d (0x%x)\n", pixelFormat, pixelFormat);
+      fflush(stdout);
+
+      PIXELFORMATDESCRIPTOR newPfd;
+      DescribePixelFormat(hDC, pixelFormat, sizeof(pfd), &newPfd);
+
+      /* now, create new context with new pixel format */
+      wglMakeCurrent(hDC, NULL);
+      wglDeleteContext(hRC);
+      DeleteDC(hDC);
+
+      if (!(hWnd = CreateWindowEx(dwExStyle, name, name,
+                                  WS_CLIPSIBLINGS | WS_CLIPCHILDREN | dwStyle,
+                                  0, 0,
+                                  winrect.right - winrect.left,
+                                  winrect.bottom - winrect.top,
+                                  NULL, NULL, hInst, NULL))) {
+         printf("failed to create window\n");
+         exit(0);
+      }
+
+      if (!(hDC = GetDC(hWnd))) {
+         printf("GetDC() failed.\n");
+         exit(0);
+      }
+      if (!SetPixelFormat(hDC, pixelFormat, &pfd)) {
+         printf("SetPixelFormat failed %d\n", (int) GetLastError());
+         exit(0);
+      }
+      if (!(hRC = wglCreateContext(hDC))) {
+         printf("wglCreateContext() failed\n");
+         exit(0);
+      }
+      if (!wglMakeCurrent(hDC, hRC)) {
+         printf("wglMakeCurrent() failed\n");
+         exit(0);
+      }
+   }
+
+   ShowWindow(hWnd, SW_SHOW);
+   SetForegroundWindow(hWnd);
+   SetFocus(hWnd);
+}
+
+
+static void
+event_loop(void)
+{
+   MSG msg;
+   int t, t0 = current_time();
+   int frames = 0;
+
+   while(1) {
+      if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
+         if (msg.message == WM_QUIT) break;;
+         TranslateMessage(&msg);
+         DispatchMessage(&msg);
+      }
+
+      angle += 2.0;
+      draw();
+      SwapBuffers(hDC);
+
+      /* calc framerate */
+      t = current_time();
+      frames++;
+      if (t - t0 >= 5.0) {
+         GLfloat s = t - t0;
+         GLfloat fps = frames / s;
+         printf("%d frames in %3.1f seconds = %6.3f FPS\n", frames, s, fps);
+         t0 = t;
+         frames = 0;
+      }
+   }
+}
+
+
+int
+main(int argc, char *argv[])
+{
+   int i;
+   GLboolean printInfo = GL_FALSE;
+
+   ProgramName = argv[0];
+
+   for (i = 1; i < argc; i++) {
+      if (strcmp(argv[i], "-info") == 0) {
+         printInfo = GL_TRUE;
+      }
+      else if (strcmp(argv[i], "-h") == 0) {
+         usage();
+      }
+      else if (strcmp(argv[i], "-srgb") == 0) {
+         use_srgb = GL_TRUE;
+      }
+      else {
+        fprintf(stderr, "%s: Unsupported option '%s'.\n", ProgramName, argv[i]);
+        usage();
+      }
+   }
+
+   make_window("glxgears", 0, 0, 300, 300);
+   reshape(300, 300);
+
+   if (printInfo) {
+      printf("GL_RENDERER   = %s\n", (char *) glGetString(GL_RENDERER));
+      printf("GL_VERSION    = %s\n", (char *) glGetString(GL_VERSION));
+      printf("GL_VENDOR     = %s\n", (char *) glGetString(GL_VENDOR));
+      printf("GL_EXTENSIONS = %s\n", (char *) glGetString(GL_EXTENSIONS));
+   }
+
+   init();
+
+   event_loop();
+
+   /* cleanup */
+   wglMakeCurrent (NULL, NULL);
+   wglDeleteContext (hRC);
+   ReleaseDC (hWnd, hDC);
+
+   return EXIT_SUCCESS;
+}
diff -Naur mesa-demos-8.4.0-old/src/wgl/wglutil.c mesa-demos-8.4.0-new/src/wgl/wglutil.c
--- mesa-demos-8.4.0-old/src/wgl/wglutil.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/wgl/wglutil.c	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,235 @@
+/*
+ * Author: kenc
+ *
+ * Created: March 1, 2013
+ * Copyright	(c) 2013, Attachmate Corporation All Rights Reserved
+ */
+#include <windows.h>
+#include <assert.h>
+#include <GL/gl.h>
+#include "wglutil.h"
+
+#define STYLE			WS_OVERLAPPEDWINDOW
+#define EXSTYLE			WS_EX_OVERLAPPEDWINDOW
+#define GL_CLASS		"GL"
+
+static PFNWGLMAKECONTEXTCURRENTARBPROC WGLMakeContextCurrent = NULL;
+static PFNWGLCHOOSEPIXELFORMATARBPROC WGLChoosePixelFormat = NULL;
+
+LRESULT
+storeDC(HWND hWnd)
+{
+	HDC hDC;
+
+	if ((hDC = GetDC(hWnd)) != NULL) {
+		SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)hDC);
+
+		assert(GetWindowLongPtr(hWnd, GWLP_USERDATA) == (LONG_PTR)hDC);
+		return 0;
+	}
+	return -1;
+}
+
+HDC
+fetchDC(HWND hWnd)
+{
+	assert(hWnd != NULL);
+	if (hWnd != NULL) {
+		HDC hDC = (HDC)(INT_PTR)GetWindowLongPtr(hWnd, GWLP_USERDATA);
+
+		assert(hDC != NULL);
+		return hDC;
+	}
+	return NULL;
+}
+
+HWND
+getWindow(HINSTANCE hInst, int x, int y, int w, int h, int format)
+{
+	HWND hParent;
+
+	if ((hParent = GetDesktopWindow()) != NULL) {
+		HWND hWnd = CreateWindowEx(EXSTYLE, GL_CLASS, "wincopy", STYLE, x, y, w, h, hParent, NULL, hInst, NULL);
+		HDC hDC;
+		BOOL ret;
+
+		assert(hWnd != NULL);
+		if ((hDC = (HDC)(INT_PTR)GetWindowLongPtr(hWnd, GWLP_USERDATA)) != NULL) {
+			PIXELFORMATDESCRIPTOR pfd;
+
+			if ((ret = SetPixelFormat(hDC, format, &pfd)) != FALSE)
+				return hWnd;
+			ret = DestroyWindow(hWnd);
+			assert(ret != FALSE);
+		}
+	}
+	assert(hParent != NULL);
+	return NULL;
+}
+
+static int
+getFormat(HDC hDC, PIXELFORMATDESCRIPTOR *pfd)
+{
+	int format;
+
+	int size = sizeof(PIXELFORMATDESCRIPTOR);
+	memset(pfd, 0, size);
+	pfd->nSize = size;
+	pfd->nVersion = 1;
+	pfd->dwFlags = PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL;
+	pfd->iLayerType = PFD_MAIN_PLANE;
+	pfd->iPixelType = PFD_TYPE_RGBA;
+	format = ChoosePixelFormat(hDC, pfd);
+	assert(format > 0);
+	return format;
+}
+
+static HGLRC
+createCurrentContext(HDC hDC)
+{
+	HGLRC hGLRC = NULL;
+
+	if ((hGLRC = wglCreateContext(hDC)) != NULL) {
+		BOOL current;
+
+		if ((current = wglMakeCurrent(hDC, hGLRC)) == FALSE) {
+			BOOL ret = wglDeleteContext(hGLRC);
+
+			assert(ret != FALSE);
+			hGLRC = NULL;
+		}
+	}
+	else
+		assert(hGLRC != NULL);
+	return hGLRC;
+}
+
+static BOOL
+checkWGLExtensions(HINSTANCE hInst)
+{
+	HWND hWnd;
+	BOOL rval, ret = FALSE;
+
+	if ((hWnd = CreateWindowEx(EXSTYLE, GL_CLASS, "tmp", STYLE, 0, 0, 1, 1,
+		GetDesktopWindow(), NULL, hInst, NULL)) != NULL) {
+		HDC hDC;
+
+		if ((hDC = fetchDC(hWnd)) != NULL) {
+			PIXELFORMATDESCRIPTOR pfd;
+			int format;
+
+			if ((format = getFormat(hDC, &pfd)) > 0) {
+				BOOL setFormat;
+
+				if ((setFormat = SetPixelFormat(hDC, format, &pfd)) != FALSE) {
+					HGLRC hGLRC = createCurrentContext(hDC);
+
+					if (hGLRC != NULL) {
+						PFNWGLGETEXTENSIONSSTRINGPROC WGLGetExtensionsStringFunc;
+
+						WGLGetExtensionsStringFunc = (PFNWGLGETEXTENSIONSSTRINGPROC)wglGetProcAddress("wglGetExtensionsStringARB");
+						assert(WGLGetExtensionsStringFunc != NULL);
+						if (WGLGetExtensionsStringFunc != NULL) {
+							const char *wglExtensionString = (*WGLGetExtensionsStringFunc)(hDC);
+
+							if (wglExtensionString != NULL) {
+								WGLMakeContextCurrent = (PFNWGLMAKECONTEXTCURRENTARBPROC)wglGetProcAddress("wglMakeContextCurrentARB");
+								assert(WGLMakeContextCurrent != NULL);
+								WGLChoosePixelFormat = (PFNWGLCHOOSEPIXELFORMATARBPROC)wglGetProcAddress("wglChoosePixelFormatARB");
+								assert(WGLChoosePixelFormat != NULL);
+								if (WGLMakeContextCurrent != NULL && WGLChoosePixelFormat != NULL)
+									ret = TRUE;
+							}
+						}
+						rval = wglDeleteContext(hGLRC);
+						assert(rval != FALSE);
+					}
+				}
+			}
+		}
+		rval = DestroyWindow(hWnd);
+		assert(rval != FALSE);
+	}
+	return ret;
+}
+
+
+BOOL
+wglExtInit(HINSTANCE hInst, WNDPROC proc)
+{
+	WNDCLASS glClass;
+	ATOM atom;
+
+	memset(&glClass, 0, sizeof(WNDCLASS));
+	glClass.style = CS_PARENTDC;
+	glClass.lpfnWndProc = proc;
+	glClass.hInstance = hInst;
+	glClass.lpszClassName = GL_CLASS;
+	glClass.cbWndExtra = sizeof(HANDLE);
+	if ((atom = RegisterClass(&glClass)) == 0) {
+		assert(atom != 0);
+		return FALSE;
+	}
+	return checkWGLExtensions(hInst);
+}
+
+void
+wglExtDispose(HINSTANCE hInst)
+{
+	BOOL ret;
+
+	ret = UnregisterClass(GL_CLASS, hInst);
+	assert(ret != FALSE);
+}
+
+BOOL
+wglExtMakeContextCurrent(HWND did, HWND rid, HGLRC gid)
+{
+	HDC hDrawDC;
+	BOOL ret = FALSE;
+
+	if ((hDrawDC = (HDC)(INT_PTR)GetWindowLongPtr(did, GWLP_USERDATA)) != NULL) {
+		if (did != rid) {
+			HDC hReadDC;
+
+			if ((hReadDC = (HDC)(INT_PTR)GetWindowLongPtr(rid, GWLP_USERDATA)) != NULL) {
+				ret = (*WGLMakeContextCurrent)(hDrawDC, hReadDC, gid);
+				assert(ret != FALSE);
+			}
+		}
+		else
+			ret = wglMakeCurrent(hDrawDC, gid);
+	}
+	assert(ret != FALSE);
+	return ret;
+}
+
+BOOL
+wglExtSwapBuffers(HWND hWnd)
+{
+	HDC hDC;
+
+	if ((hDC = (HDC)(INT_PTR)GetWindowLongPtr(hWnd, GWLP_USERDATA)) != NULL);
+		return wglSwapLayerBuffers(hDC, WGL_SWAP_MAIN_PLANE);
+	return FALSE;
+}
+
+int
+wglExtChoosePixelFormat(const int *attrs)
+{
+	HDC hDC;
+	HWND hWnd = GetDesktopWindow();
+
+	if ((hDC = (HDC)GetDC(hWnd)) != NULL) {
+		int format = 0;
+		UINT nFormats;
+		BOOL ret;
+
+		WGLChoosePixelFormat(hDC, attrs, NULL, 1, &format, &nFormats);
+		assert(nFormats > 0 && format != 0);
+		ret = ReleaseDC(hWnd, hDC);
+		assert(ret != FALSE);
+		return format;
+	}
+	return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/wgl/wglutil.h mesa-demos-8.4.0-new/src/wgl/wglutil.h
--- mesa-demos-8.4.0-old/src/wgl/wglutil.h	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/wgl/wglutil.h	2020-04-11 09:49:44.114059934 -0700
@@ -0,0 +1,123 @@
+/*
+ * Author: kenc
+ *
+ * Created: March 1, 2013
+ * Copyright	(c) 2013, Attachmate Corporation All Rights Reserved
+ */
+#ifndef wglExt_h
+#define wglExt_h
+
+/*
+ * Derrived from... at http://developer.download.nvidia.com/opengl/includes/wglext.h
+ */
+
+#define WGL_WGLEXT_PROTOTYPES	1
+
+/* WGL_extensions_string extension */
+typedef const char * (WINAPI *PFNWGLGETEXTENSIONSSTRINGPROC)(HDC);
+
+/* WGL_pixel_format extension */
+typedef BOOL (WINAPI *PFNWGLCHOOSEPIXELFORMATARBPROC)(HDC, const int *, const FLOAT *,  UINT, int *, UINT *);
+
+/*
+ * Accepted in the <piAttributes> parameter array of
+ * wglGetPixelFormatAttribivARB, and wglGetPixelFormatAttribfvARB, and
+ * as a type in the <piAttribIList> and <pfAttribFList> parameter
+ * arrays of wglChoosePixelFormatARB:
+ */
+
+#ifndef WGL_ARB_make_current_read
+#define ERROR_INVALID_PIXEL_TYPE_ARB	0x2043
+#define ERROR_INCOMPATIBLE_DEVICE_CONTEXTS_ARB 0x2054
+#endif
+
+#define WGL_NUMBER_PIXEL_FORMATS	0x2000
+#define WGL_DRAW_TO_WINDOW			0x2001
+#define WGL_DRAW_TO_BITMAP			0x2002
+#define WGL_ACCELERATION			0x2003
+#define WGL_NEED_PALETTE			0x2004
+#define WGL_NEED_SYSTEM_PALETTE		0x2005
+#define WGL_SWAP_LAYER_BUFFERS		0x2006
+#define WGL_SWAP_METHOD				0x2007
+#define WGL_NUMBER_OVERLAYS			0x2008
+#define WGL_NUMBER_UNDERLAYS		0x2009
+#define WGL_TRANSPARENT				0x200A
+#define WGL_TRANSPARENT_RED_VALUE	0x2037
+#define WGL_TRANSPARENT_GREEN_VALUE	0x2038
+#define WGL_TRANSPARENT_BLUE_VALUE	0x2039
+#define WGL_TRANSPARENT_ALPHA_VALUE	0x203A
+#define WGL_TRANSPARENT_INDEX_VALUE	0x203B
+#define WGL_SHARE_DEPTH				0x200C
+#define WGL_SHARE_STENCIL			0x200D
+#define WGL_SHARE_ACCUM				0x200E
+#define WGL_SUPPORT_GDI				0x200F
+#define WGL_SUPPORT_OPENGL			0x2010
+#define WGL_DOUBLE_BUFFER			0x2011
+#define WGL_STEREO					0x2012
+#define WGL_PIXEL_TYPE				0x2013
+#define WGL_COLOR_BITS				0x2014
+#define WGL_RED_BITS				0x2015
+#define WGL_RED_SHIFT				0x2016
+#define WGL_GREEN_BITS				0x2017
+#define WGL_GREEN_SHIFT				0x2018
+#define WGL_BLUE_BITS				0x2019
+#define WGL_BLUE_SHIFT				0x201A
+#define WGL_ALPHA_BITS				0x201B
+#define WGL_ALPHA_SHIFT				0x201C
+#define WGL_ACCUM_BITS				0x201D
+#define WGL_ACCUM_RED_BITS			0x201E
+#define WGL_ACCUM_GREEN_BITS		0x201F
+#define WGL_ACCUM_BLUE_BITS			0x2020
+#define WGL_ACCUM_ALPHA_BITS		0x2021
+#define WGL_DEPTH_BITS				0x2022
+#define WGL_STENCIL_BITS			0x2023
+#define WGL_AUX_BUFFERS				0x2024
+#define WGL_SAMPLE_BUFFERS			0x2041
+#define WGL_SAMPLES					0x2042
+#define PFD_DRAW_TO_PBUFFER			0x4000
+
+/*
+ * Accepted as a value in the <piAttribIList> and <pfAttribFList>
+ * parameter arrays of wglChoosePixelFormatARB, and returned in the
+ * <piValues> parameter array of wglGetPixelFormatAttribivARB, and the
+ * <pfValues> parameter array of wglGetPixelFormatAttribfvARB:
+ */
+#define WGL_NO_ACCELERATION			0x2025
+#define WGL_GENERIC_ACCELERATION	0x2026
+#define WGL_FULL_ACCELERATION		0x2027
+
+#define WGL_SWAP_EXCHANGE			0x2028
+#define WGL_SWAP_COPY				0x2029
+#define WGL_SWAP_UNDEFINED			0x202A
+
+#define WGL_TYPE_RGBA				0x202B
+#define WGL_TYPE_COLORINDEX			0x202C
+#define PFD_TYPE_FLOAT_RGBA			2
+
+#ifndef WGL_EXT_make_current_read
+#define ERROR_INVALID_PIXEL_TYPE_EXT	0x2043
+#endif
+
+#ifndef WGL_ARB_make_current_read
+#define WGL_ARB_make_current_read 1
+#ifdef WGL_WGLEXT_PROTOTYPES
+extern BOOL WINAPI wglMakeContextCurrentARB(HDC, HDC, HGLRC);
+extern HDC WINAPI wglGetCurrentReadDCARB(void);
+#endif /* WGL_WGLEXT_PROTOTYPES */
+typedef BOOL (WINAPI *PFNWGLMAKECONTEXTCURRENTARBPROC)(HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
+typedef HDC (WINAPI *PFNWGLGETCURRENTREADDCARBPROC)(void);
+#endif
+
+/*
+ * Inits some function pointers and return number of formats.
+ * Returns 0 on failure.
+ */
+extern HWND getWindow(HINSTANCE hInst, int x, int y, int w, int h, int format);
+extern BOOL wglExtMakeContextCurrent(HWND did, HWND rid, HGLRC gid);
+extern BOOL wglExtSwapBuffers(HWND);
+extern int wglExtChoosePixelFormat(const int *);
+extern BOOL wglExtInit(HINSTANCE, WNDPROC);
+extern void wglExtDispose(HINSTANCE);
+LRESULT storeDC(HWND hWnd);
+HDC fetchDC(HWND hWnd);
+#endif
diff -Naur mesa-demos-8.4.0-old/src/wgl/wincopy.c mesa-demos-8.4.0-new/src/wgl/wincopy.c
--- mesa-demos-8.4.0-old/src/wgl/wincopy.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/wgl/wincopy.c	2020-04-11 09:49:44.115059934 -0700
@@ -0,0 +1,248 @@
+/*
+ * Mesa 3-D graphics library
+ * Version: 6.5.2
+ *
+ * Copyright (C) 1999-2006 Brian Paul   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+/*
+ * This program opens two windows, renders into one and uses
+ * glCopyPixels to copy the image from the first window into the
+ * second by means of the extension function wglMakeContextCurrentARB().
+ */
+/*
+ * Author: kenc
+ *
+ * Created: March 1, 2013
+ * Copyright	(c) 2013, Attachmate Corporation All Rights Reserved
+ */
+#include <windows.h>
+#include <GL/gl.h>
+#include <assert.h>
+#include "wglutil.h"
+
+static HGLRC Context = NULL;
+static HWND Win[2] = {NULL, NULL};
+static int Width[2] = {0, 0}, Height[2] = {0, 0};
+static float Angle = 0.0f;
+
+
+static BOOL
+Redraw(BOOL DrawFront)
+{
+	assert(Context != NULL);
+	if (!wglExtMakeContextCurrent(Win[0], Win[0], Context))
+		return FALSE;
+
+	Angle += 1.0f;
+	if (DrawFront) {
+		glDrawBuffer(GL_FRONT);
+		glReadBuffer(GL_FRONT);
+	}
+	else {
+		glDrawBuffer(GL_BACK);
+		glReadBuffer(GL_BACK);
+	}
+
+	glViewport(0, 0, Width[0], Height[0]);
+	glMatrixMode(GL_PROJECTION);
+	glLoadIdentity();
+	glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
+	glMatrixMode(GL_MODELVIEW);
+	glShadeModel(GL_FLAT);
+	glClearColor(0.5, 0.5, 0.5, 0.0);
+	glClear(GL_COLOR_BUFFER_BIT);
+
+	/* draw blue quad */
+	glColor3f(0.3f, 0.3f, 1.0f);
+	glPushMatrix();
+	glRotatef(Angle, 0, 0, 1);
+	glBegin(GL_POLYGON);
+	glVertex2f(-0.5, -0.25);
+	glVertex2f(0.5, -0.25);
+	glVertex2f(0.5, 0.25);
+	glVertex2f(-0.5, 0.25);
+	glEnd();
+	glPopMatrix();
+
+	if (DrawFront)
+		glFinish();
+	else
+		wglExtSwapBuffers(Win[0]);
+
+	/* copy image from window 0 to window 1 */
+	if (!wglExtMakeContextCurrent(Win[1], Win[0], Context))
+		return FALSE;
+
+	/* copy the image between windows */
+	glClearColor(0.0, 0.0, 0.0, 0.0);
+	glClear(GL_COLOR_BUFFER_BIT);
+	glCopyPixels(0, 0, Width[0], Height[0], GL_COLOR);
+	if (DrawFront)
+		glFinish();
+	else
+		wglExtSwapBuffers(Win[1]);
+	return TRUE;
+}
+
+
+static void
+Resize(HWND win, int width, int height)
+{
+	int i;
+	HDC hDC;
+
+	if (win == Win[0])
+		i = 0;
+	else
+		i = 1;
+
+	if ((hDC = (HDC)(INT_PTR)GetWindowLongPtr(win, GWLP_USERDATA)) != NULL) {
+		BOOL ret;
+
+		if ((ret = wglMakeCurrent(hDC, Context)) != FALSE) {
+			Width[i] = width;
+			Height[i] = height;
+		}
+		assert(ret != FALSE);
+	}
+}
+
+static LRESULT CALLBACK
+EventLoop(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
+{
+	HDC hDC;
+	RECT rect;
+	LRESULT ret;
+	LPWINDOWPOS pWinPos;
+	static BOOL drawFront = FALSE;
+
+	switch (msg) {
+	case WM_CREATE:
+		ret = (LRESULT)storeDC(hWnd);
+		assert(ret == 0);
+		break;
+
+	case WM_PAINT:
+		GetUpdateRect(hWnd, &rect, FALSE);
+		Redraw(drawFront);
+		ret = 0;
+		break;
+
+	case WM_WINDOWPOSCHANGED:
+		pWinPos = (LPWINDOWPOS)lParam;
+		//if (!(pWinPos->flags&SWP_NOSIZE))
+			Resize(hWnd, pWinPos->cx, pWinPos->cy);
+		ret = 0;
+		break;
+
+	case WM_CHAR:
+		if (wParam == 'f') {	// 'f' key
+			drawFront = !drawFront;
+			Redraw(drawFront);
+		}
+		else if (wParam == VK_ESCAPE)
+			PostQuitMessage(0);
+		ret = 0;
+		break;
+
+	case WM_DESTROY:
+		if ((hDC = fetchDC(hWnd)) != NULL) {
+			ret = ReleaseDC(hWnd, hDC);
+			assert(ret != FALSE);
+		}
+		ret = 1;
+		break;
+
+	default:
+		ret = DefWindowProc(hWnd, msg, wParam, lParam);
+		break;
+	}
+	return ret;
+}
+
+
+static BOOL
+Init(HINSTANCE hInst, int show)
+{
+	BOOL rval = FALSE;
+
+	if (wglExtInit(hInst, EventLoop) != FALSE) {
+		const int attribList[] = {
+				WGL_DRAW_TO_WINDOW, GL_TRUE,
+				WGL_SUPPORT_OPENGL, GL_TRUE,
+				WGL_DOUBLE_BUFFER, GL_TRUE,
+				WGL_PIXEL_TYPE, WGL_TYPE_RGBA,
+				WGL_COLOR_BITS, 32,
+				WGL_DEPTH_BITS, 24,
+				0};
+		int format;
+
+		if ((format = wglExtChoosePixelFormat(attribList)) != 0) {
+			if ((Win[0] = getWindow(hInst, 0, 0, 300, 300, format)) != NULL) {
+				if ((Win[1] = getWindow(hInst, 350, 0, 300, 300, format)) != NULL) {
+					ShowWindow(Win[0], show);
+					ShowWindow(Win[1], show);
+					rval = TRUE;
+				}
+			}
+		}
+	}
+	return rval;
+}
+
+
+int CALLBACK
+WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow)
+{
+	int ret = -1;
+
+	if (Init(hInst, nCmdShow) != FALSE) {
+		MSG msg;
+		HDC hDC;
+
+		if ((hDC = fetchDC(Win[0])) != NULL) {
+			if ((Context = wglCreateContext(hDC)) != NULL) {
+				BOOL rval;
+
+				while ((ret = GetMessage(&msg, NULL, 0, 0)) != 0) {
+					TranslateMessage(&msg);
+					DispatchMessage(&msg);
+				}
+				if (Win[0] != NULL) {
+					rval = DestroyWindow(Win[0]);
+					assert(rval != FALSE);
+				}
+				if (Win[1] != NULL) {
+					rval = DestroyWindow(Win[1]);
+					assert(rval != FALSE);
+				}
+				rval = wglDeleteContext(Context);
+				assert(rval != FALSE);
+			}
+		}
+		wglExtDispose(hInst);
+		ret = (int)msg.wParam;
+    }
+	if (Context != NULL)
+		wglDeleteContext(Context);
+	return ret;
+}
diff -Naur mesa-demos-8.4.0-old/src/xdemos/msctest.c mesa-demos-8.4.0-new/src/xdemos/msctest.c
--- mesa-demos-8.4.0-old/src/xdemos/msctest.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/xdemos/msctest.c	2020-04-11 09:49:44.115059934 -0700
@@ -0,0 +1,194 @@
+/*
+ * Copyright © 2009 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Jesse Barnes <jesse.barnes@intel.com>
+ *
+ */
+
+/** @file msctest.c
+ * Simple test for MSC functionality.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <GL/gl.h>
+#include <GL/glx.h>
+#include <GL/glxext.h>
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+void (*get_sync_values)(Display *dpy, Window winGL, int64_t *ust, int64_t *msc, int64_t *sbc);
+void (*wait_sync)(Display *dpy, Window winGL, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
+
+static int GLXExtensionSupported(Display *dpy, const char *extension)
+{
+	const char *extensionsString, *pos;
+
+	extensionsString = glXQueryExtensionsString(dpy, DefaultScreen(dpy));
+
+	pos = strstr(extensionsString, extension);
+
+	if (pos != NULL && (pos == extensionsString || pos[-1] == ' ') &&
+	    (pos[strlen(extension)] == ' ' || pos[strlen(extension)] == '\0'))
+		return 1;
+
+	return 0;
+}
+
+extern char *optarg;
+extern int optind, opterr, optopt;
+static char optstr[] = "v";
+
+static void usage(char *name)
+{
+	printf("usage: %s\n", name);
+	exit(-1);
+}
+
+int main(int argc, char *argv[])
+{
+	Display *disp;
+	XVisualInfo *pvi;
+	XSetWindowAttributes swa;
+	int attrib[14];
+	Window winGL;
+	GLXContext context;
+	int dummy;
+	Atom wmDelete;
+	int verbose = 0, width = 200, height = 200;
+	int c, i = 1;
+	int64_t ust, msc, sbc;
+
+	opterr = 0;
+	while ((c = getopt(argc, argv, optstr)) != -1) {
+		switch (c) {
+		case 'v':
+			verbose = 1;
+			break;
+		default:
+			usage(argv[0]);
+			break;
+		}
+	}
+
+	disp = XOpenDisplay(NULL);
+	if (!disp) {
+		fprintf(stderr, "failed to open display\n");
+		return -1;
+	}
+
+	if (!glXQueryExtension(disp, &dummy, &dummy)) {
+		fprintf(stderr, "glXQueryExtension failed\n");
+		return -1;
+	}
+
+	if (!GLXExtensionSupported(disp, "GLX_OML_sync_control")) {
+		fprintf(stderr, "GLX_OML_sync_control not supported, exiting\n");
+		return -1;
+	}
+
+	attrib[0] = GLX_RGBA;
+	attrib[1] = 1;
+	attrib[2] = GLX_RED_SIZE;
+	attrib[3] = 1;
+	attrib[4] = GLX_GREEN_SIZE;
+	attrib[5] = 1;
+	attrib[6] = GLX_BLUE_SIZE;
+	attrib[7] = 1;
+	attrib[8] = GLX_DOUBLEBUFFER;
+	attrib[9] = 1;
+	attrib[10] = None;
+
+	pvi = glXChooseVisual(disp, DefaultScreen(disp), attrib);
+	if (!pvi) {
+		fprintf(stderr, "failed to choose visual, exiting\n");
+		return -1;
+	}
+
+	context = glXCreateContext(disp, pvi, None, GL_TRUE);
+	if (!context) {
+		fprintf(stderr, "failed to create glx context\n");
+		return -1;
+	}
+
+	pvi->screen = DefaultScreen(disp);
+
+	swa.colormap = XCreateColormap(disp, RootWindow(disp, pvi->screen),
+				       pvi->visual, AllocNone);
+	swa.border_pixel = 0;
+	swa.event_mask = ExposureMask | KeyPressMask | ButtonPressMask |
+		StructureNotifyMask;
+	winGL = XCreateWindow(disp, RootWindow(disp, pvi->screen),
+			      0, 0,
+			      width, height,
+			      0, pvi->depth, InputOutput, pvi->visual,
+			      CWBorderPixel | CWColormap | CWEventMask, &swa);
+	if (!winGL) {
+		fprintf(stderr, "window creation failed\n");
+		return -1;
+	}
+        wmDelete = XInternAtom(disp, "WM_DELETE_WINDOW", True);
+        XSetWMProtocols(disp, winGL, &wmDelete, 1);
+
+	XSetStandardProperties(disp, winGL, "msc test", "msc text",
+			       None, NULL, 0, NULL);
+
+	XMapRaised(disp, winGL);
+
+	glXMakeCurrent(disp, winGL, context);
+
+	get_sync_values = (void *)glXGetProcAddress((unsigned char *)"glXGetSyncValuesOML");
+	wait_sync = (void *)glXGetProcAddress((unsigned char *)"glXWaitForMscOML");
+
+	if (!get_sync_values || !wait_sync) {
+		fprintf(stderr, "failed to get sync values function\n");
+		return -1;
+	}
+
+	while (i++) {
+		get_sync_values(disp, winGL, &ust, &msc, &sbc);
+		fprintf(stderr, "ust: %llu, msc: %llu, sbc: %llu\n", ust, msc,
+			sbc);
+
+		/* Alternate colors to make tearing obvious */
+		if (i & 1)
+			glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
+		else
+			glClearColor(1.0f, 0.0f, 0.0f, 0.0f);
+		glClear(GL_COLOR_BUFFER_BIT);
+		glXSwapBuffers(disp, winGL);
+		wait_sync(disp, winGL, 0, 60, 0, &ust, &msc, &sbc);
+		fprintf(stderr,
+			"wait returned ust: %llu, msc: %llu, sbc: %llu\n",
+			ust, msc, sbc);
+		sleep(1);
+	}
+
+	XDestroyWindow(disp, winGL);
+	glXDestroyContext(disp, context);
+	XCloseDisplay(disp);
+
+	return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/xdemos/omlsync.c mesa-demos-8.4.0-new/src/xdemos/omlsync.c
--- mesa-demos-8.4.0-old/src/xdemos/omlsync.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/xdemos/omlsync.c	2020-04-11 09:49:44.115059934 -0700
@@ -0,0 +1,266 @@
+/*
+ * Copyright © 2007-2010 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Jesse Barnes <jesse.barnes@intel.com>
+ *
+ */
+
+/** @file omlsync.c
+ * The program is simple:  it paints a window alternating colors (red &
+ * white) either as fast as possible or synchronized to vblank events
+ *
+ * If run normally, the program should display a window that exhibits
+ * significant tearing between red and white colors (e.g. you might get
+ * a "waterfall" effect of red and white horizontal bars).
+ *
+ * If run with the '-s b' option, the program should synchronize the
+ * window color changes with the vertical blank period, resulting in a
+ * window that looks orangish with a high frequency flicker (which may
+ * be invisible).  If the window is moved to another screen, this
+ * property should be preserved.  If the window spans two screens, it
+ * shouldn't tear on whichever screen most of the window is on; the
+ * portion on the other screen may show some tearing (like the
+ * waterfall effect above).
+ *
+ * Other options include '-w <width>' and '-h <height>' to set the
+ * window size.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <GL/gl.h>
+#include <GL/glx.h>
+#include <GL/glxext.h>
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+Bool (*glXGetSyncValuesOML)(Display *dpy, GLXDrawable drawable,
+			    int64_t *ust, int64_t *msc, int64_t *sbc);
+Bool (*glXGetMscRateOML)(Display *dpy, GLXDrawable drawable, int32_t *numerator,
+			 int32_t *denominator);
+int64_t (*glXSwapBuffersMscOML)(Display *dpy, GLXDrawable drawable,
+				int64_t target_msc, int64_t divisor,
+				int64_t remainder);
+Bool (*glXWaitForMscOML)(Display *dpy, GLXDrawable drawable, int64_t target_msc,
+			 int64_t divisor, int64_t remainder, int64_t *ust,
+			 int64_t *msc, int64_t *sbc);
+Bool (*glXWaitForSbcOML)(Display *dpy, GLXDrawable drawable, int64_t target_sbc,
+			 int64_t *ust, int64_t *msc, int64_t *sbc);
+int (*glXSwapInterval)(int interval);
+
+static int GLXExtensionSupported(Display *dpy, const char *extension)
+{
+	const char *extensionsString, *pos;
+
+	extensionsString = glXQueryExtensionsString(dpy, DefaultScreen(dpy));
+
+	pos = strstr(extensionsString, extension);
+
+	if (pos != NULL && (pos == extensionsString || pos[-1] == ' ') &&
+	    (pos[strlen(extension)] == ' ' || pos[strlen(extension)] == '\0'))
+		return 1;
+
+	return 0;
+}
+
+extern char *optarg;
+extern int optind, opterr, optopt;
+static char optstr[] = "w:h:vd:r:n:i:";
+
+static void usage(char *name)
+{
+	printf("usage: %s [-w <width>] [-h <height>] ...\n", name);
+	printf("\t-d<divisor> - divisor for OML swap\n");
+	printf("\t-r<remainder> - remainder for OML swap\n");
+	printf("\t-n<interval> - wait interval for OML WaitMSC\n");
+	printf("\t-i<swap interval> - swap at most once every n frames\n");
+	printf("\t-v: verbose (print count)\n");
+	exit(-1);
+}
+
+int main(int argc, char *argv[])
+{
+	Display *disp;
+	XVisualInfo *pvi;
+	XSetWindowAttributes swa;
+	Window winGL;
+	GLXContext context;
+	int dummy;
+	Atom wmDelete;
+	int64_t ust, msc, sbc;
+	int width = 500, height = 500, verbose = 0, divisor = 0, remainder = 0,
+		wait_interval = 0, swap_interval = 1;
+	int c, i = 1;
+	int ret;
+	int db_attribs[] = { GLX_RGBA,
+                     GLX_RED_SIZE, 1,
+                     GLX_GREEN_SIZE, 1,
+                     GLX_BLUE_SIZE, 1,
+                     GLX_DOUBLEBUFFER,
+                     GLX_DEPTH_SIZE, 1,
+                     None };
+	XSizeHints sizehints;
+
+	opterr = 0;
+	while ((c = getopt(argc, argv, optstr)) != -1) {
+		switch (c) {
+		case 'w':
+			width = atoi(optarg);
+			break;
+		case 'h':
+			height = atoi(optarg);
+			break;
+		case 'v':
+			verbose = 1;
+			break;
+		case 'd':
+			divisor = atoi(optarg);
+			break;
+		case 'r':
+			remainder = atoi(optarg);
+			break;
+		case 'n':
+			wait_interval = atoi(optarg);
+			break;
+		case 'i':
+			swap_interval = atoi(optarg);
+			break;
+		default:
+			usage(argv[0]);
+			break;
+		}
+	}
+
+	disp = XOpenDisplay(NULL);
+	if (!disp) {
+		fprintf(stderr, "failed to open display\n");
+		return -1;
+	}
+
+	if (!glXQueryExtension(disp, &dummy, &dummy)) {
+		fprintf(stderr, "glXQueryExtension failed\n");
+		return -1;
+	}
+
+	if (!GLXExtensionSupported(disp, "GLX_OML_sync_control")) {
+		fprintf(stderr, "GLX_OML_sync_control not supported\n");
+		return -1;
+	}
+
+	if (!GLXExtensionSupported(disp, "GLX_MESA_swap_control")) {
+		fprintf(stderr, "GLX_MESA_swap_control not supported\n");
+		return -1;
+	}
+
+	pvi = glXChooseVisual(disp, DefaultScreen(disp), db_attribs);
+
+	if (!pvi) {
+		fprintf(stderr, "failed to choose visual, exiting\n");
+		return -1;
+	}
+
+	pvi->screen = DefaultScreen(disp);
+
+	swa.colormap = XCreateColormap(disp, RootWindow(disp, pvi->screen),
+				       pvi->visual, AllocNone);
+	swa.border_pixel = 0;
+	swa.event_mask = ExposureMask | KeyPressMask | ButtonPressMask |
+		StructureNotifyMask;
+	winGL = XCreateWindow(disp, RootWindow(disp, pvi->screen),
+			      0, 0,
+			      width, height,
+			      0, pvi->depth, InputOutput, pvi->visual,
+			      CWBorderPixel | CWColormap | CWEventMask, &swa);
+	if (!winGL) {
+		fprintf(stderr, "window creation failed\n");
+		return -1;
+	}
+        wmDelete = XInternAtom(disp, "WM_DELETE_WINDOW", True);
+        XSetWMProtocols(disp, winGL, &wmDelete, 1);
+
+	sizehints.x = 0;
+	sizehints.y = 0;
+	sizehints.width  = width;
+	sizehints.height = height;
+	sizehints.flags = USSize | USPosition;
+
+	XSetNormalHints(disp, winGL, &sizehints);
+	XSetStandardProperties(disp, winGL, "glsync test", "glsync text",
+			       None, NULL, 0, &sizehints);
+
+	context = glXCreateContext(disp, pvi, NULL, GL_TRUE);
+	if (!context) {
+		fprintf(stderr, "failed to create glx context\n");
+		return -1;
+	}
+
+	XMapWindow(disp, winGL);
+	ret = glXMakeCurrent(disp, winGL, context);
+	if (!ret) {
+		fprintf(stderr, "failed to make context current: %d\n", ret);
+	}
+
+	glXGetSyncValuesOML = (void *)glXGetProcAddress((unsigned char *)"glXGetSyncValuesOML");
+	glXGetMscRateOML = (void *)glXGetProcAddress((unsigned char *)"glXGetMscRateOML");
+	glXSwapBuffersMscOML = (void *)glXGetProcAddress((unsigned char *)"glXSwapBuffersMscOML");
+	glXWaitForMscOML = (void *)glXGetProcAddress((unsigned char *)"glXWaitForMscOML");
+	glXWaitForSbcOML = (void *)glXGetProcAddress((unsigned char *)"glXWaitForSbcOML");
+	glXSwapInterval = (void *)glXGetProcAddress((unsigned char *)"glXSwapIntervalMESA");
+
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+	glXSwapInterval(swap_interval);
+	fprintf(stderr, "set swap interval to %d\n", swap_interval);
+
+	glXGetSyncValuesOML(disp, winGL, &ust, &msc, &sbc);
+	while (i++) {
+		/* Alternate colors to make tearing obvious */
+		if (i & 1) {
+			glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
+			glColor3f(1.0f, 1.0f, 1.0f);
+		} else {
+			glClearColor(1.0f, 0.0f, 0.0f, 0.0f);
+			glColor3f(1.0f, 0.0f, 0.0f);
+		}
+
+		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+		glRectf(0, 0, width, height);
+
+		if (!wait_interval)
+			glXSwapBuffersMscOML(disp, winGL, 0, divisor,
+					     remainder);
+		else {
+			glXWaitForMscOML(disp, winGL, msc + wait_interval,
+					 divisor, remainder, &ust, &msc, &sbc);
+			glXSwapBuffersMscOML(disp, winGL, 0, 0, 0);
+		}
+	}
+
+	XDestroyWindow(disp, winGL);
+	glXDestroyContext(disp, context);
+	XCloseDisplay(disp);
+
+	return 0;
+}
diff -Naur mesa-demos-8.4.0-old/src/xdemos/opencloseopen.c mesa-demos-8.4.0-new/src/xdemos/opencloseopen.c
--- mesa-demos-8.4.0-old/src/xdemos/opencloseopen.c	1969-12-31 16:00:00.000000000 -0800
+++ mesa-demos-8.4.0-new/src/xdemos/opencloseopen.c	2020-04-11 09:49:44.115059934 -0700
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
+ * (C) Copyright IBM Corporation 2003
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <X11/Xlib.h>
+#include <GL/gl.h>
+#include <GL/glx.h>
+
+/** \file opencloseopen.c
+ * Simple test for Mesa bug #508473.  Create a window and rendering context.
+ * Draw a single frame.  Close the window, destroy the context, and close
+ * the display.  Re-open the display, create a new window and context.  This
+ * should work, but, at least as of Mesa 5.1, it segfaults.  See the bug
+ * report for more details.
+ * 
+ * Most of the code here was lifed from various other Mesa xdemos.
+ */
+
+static void
+draw(void)
+{
+   glViewport(0, 0, 300, 300);
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+   glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
+   glMatrixMode(GL_MODELVIEW);
+
+   glShadeModel(GL_FLAT);
+   glClearColor(0.5, 0.5, 0.5, 1.0);
+   glClear(GL_COLOR_BUFFER_BIT);
+
+   /* draw blue quad */
+   glLoadIdentity();
+   glColor3f(0.3, 0.3, 1.0);
+   glPushMatrix();
+   glRotatef(0, 0, 0, 1);
+   glBegin(GL_POLYGON);
+   glVertex2f(-0.5, -0.25);
+   glVertex2f( 0.5, -0.25);
+   glVertex2f( 0.5, 0.25);
+   glVertex2f(-0.5, 0.25);
+   glEnd();
+   glPopMatrix();}
+
+
+/*
+ * Create an RGB, double-buffered window.
+ * Return the window and context handles.
+ */
+static void
+make_window( const char * dpyName, const char *name,
+             int x, int y, int width, int height,
+	     Display **dpyRet, Window *winRet, GLXContext *ctxRet)
+{
+   int attrib[] = { GLX_RGBA,
+		    GLX_RED_SIZE, 1,
+		    GLX_GREEN_SIZE, 1,
+		    GLX_BLUE_SIZE, 1,
+		    GLX_DOUBLEBUFFER,
+		    None };
+   int scrnum;
+   XSetWindowAttributes attr;
+   unsigned long mask;
+   Window root;
+   Window win;
+   GLXContext ctx;
+   XVisualInfo *visinfo;
+   Display *dpy;
+
+   dpy = XOpenDisplay(dpyName);
+   if (!dpy) {
+      printf("Error: couldn't open display %s\n", XDisplayName(dpyName));
+      exit(1);
+   }
+
+   *dpyRet = dpy;
+   scrnum = DefaultScreen( dpy );
+   root = RootWindow( dpy, scrnum );
+
+   visinfo = glXChooseVisual( dpy, scrnum, attrib );
+   if (!visinfo) {
+      printf("Error: couldn't get an RGB, Double-buffered visual\n");
+      exit(1);
+   }
+
+   /* window attributes */
+   attr.background_pixel = 0;
+   attr.border_pixel = 0;
+   attr.colormap = XCreateColormap( dpy, root, visinfo->visual, AllocNone);
+   attr.event_mask = StructureNotifyMask | ExposureMask | KeyPressMask;
+   mask = CWBackPixel | CWBorderPixel | CWColormap | CWEventMask;
+
+   win = XCreateWindow( dpy, root, 0, 0, width, height,
+		        0, visinfo->depth, InputOutput,
+		        visinfo->visual, mask, &attr );
+
+   /* set hints and properties */
+   {
+      XSizeHints sizehints;
+      sizehints.x = x;
+      sizehints.y = y;
+      sizehints.width  = width;
+      sizehints.height = height;
+      sizehints.flags = USSize | USPosition;
+      XSetNormalHints(dpy, win, &sizehints);
+      XSetStandardProperties(dpy, win, name, name,
+                              None, (char **)NULL, 0, &sizehints);
+   }
+
+   ctx = glXCreateContext( dpy, visinfo, NULL, True );
+   if (!ctx) {
+      printf("Error: glXCreateContext failed\n");
+      exit(1);
+   }
+
+   XFree(visinfo);
+
+   *winRet = win;
+   *ctxRet = ctx;
+}
+
+
+static void
+destroy_window( Display *dpy, Window win, GLXContext ctx )
+{
+   glXMakeCurrent(dpy, None, NULL);
+   glXDestroyContext(dpy, ctx);
+   XDestroyWindow(dpy, win);
+   XCloseDisplay(dpy);
+}
+
+
+int
+main(int argc, char *argv[])
+{
+   Display *dpy;
+   Window win;
+   GLXContext ctx;
+   char *dpyName = NULL;
+   int i;
+
+   for (i = 1; i < argc; i++) {
+      if (strcmp(argv[i], "-display") == 0) {
+         dpyName = argv[i+1];
+         i++;
+      }
+   }
+
+   printf("If this program segfaults, then Mesa bug #508473 is probably "
+	  "back.\n");
+   make_window(dpyName, "Open-close-open", 0, 0, 300, 300, &dpy, &win, &ctx);
+   XMapWindow(dpy, win);
+   glXMakeCurrent(dpy, win, ctx);
+
+   draw();
+   glXSwapBuffers(dpy, win);
+   sleep(2);
+
+   destroy_window(dpy, win, ctx);
+
+   make_window(dpyName, "Open-close-open", 0, 0, 300, 300, &dpy, &win, &ctx);
+   XMapWindow(dpy, win);
+   glXMakeCurrent(dpy, win, ctx);
+   destroy_window(dpy, win, ctx);
+
+   return 0;
+}
