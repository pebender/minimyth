diff -Naur -x mytharchive mythtv-0.20-old/bindings/perl/MythTV/Channel.pm mythtv-0.20-new/bindings/perl/MythTV/Channel.pm
--- mythtv-0.20-old/bindings/perl/MythTV/Channel.pm	2006-04-16 01:05:27.000000000 -0700
+++ mythtv-0.20-new/bindings/perl/MythTV/Channel.pm	2007-04-17 10:23:47.000000000 -0700
@@ -3,8 +3,8 @@
 #
 # Object containing info about a particular MythTV channel.
 #
-# @url       $URL: svn+ssh://ijr@cvs.mythtv.org/var/lib/svn/trunk/mythtv/bindings/perl/MythTV/Channel.pm $
-# @date      $Date: 2006-04-16 04:05:27 -0400 (Sun, 16 Apr 2006) $
+# @url       $URL: http://svn.mythtv.org/svn/branches/release-0-20-fixes/mythtv/bindings/perl/MythTV/Channel.pm $
+# @date      $Date: 2006-04-16 01:05:27 -0700 (Sun, 16 Apr 2006) $
 # @version   $Revision: 9725 $
 # @author    $Author: xris $
 #
diff -Naur -x mytharchive mythtv-0.20-old/bindings/perl/MythTV/Program.pm mythtv-0.20-new/bindings/perl/MythTV/Program.pm
--- mythtv-0.20-old/bindings/perl/MythTV/Program.pm	2006-04-16 01:05:27.000000000 -0700
+++ mythtv-0.20-new/bindings/perl/MythTV/Program.pm	2007-04-17 10:23:47.000000000 -0700
@@ -3,9 +3,9 @@
 #
 # Object containing info about a particular MythTV program.
 #
-# @url       $URL: svn+ssh://ijr@cvs.mythtv.org/var/lib/svn/trunk/mythtv/bindings/perl/MythTV/Program.pm $
-# @date      $Date: 2006-04-16 04:05:27 -0400 (Sun, 16 Apr 2006) $
-# @version   $Revision: 9725 $
+# @url       $URL: http://svn.mythtv.org/svn/branches/release-0-20-fixes/mythtv/bindings/perl/MythTV/Program.pm $
+# @date      $Date: 2006-11-18 21:37:30 -0800 (Sat, 18 Nov 2006) $
+# @version   $Revision: 11780 $
 # @author    $Author: xris $
 #
 
@@ -84,6 +84,7 @@
         $self->{'hasairdate'}      = $rows->[38]; #
         $self->{'timestretch'}     = $rows->[39]; #
         $self->{'recpriority2'}    = $rows->[40]; #
+        $self->{'parentid'}        = $rows->[41]; #
 
     # Load the channel data
         if ($self->{'chanid'}) {
@@ -112,6 +113,7 @@
         my $separator   = (shift or '-');
         my $replacement = (shift or '-');
         my $allow_dirs  = (shift) ? 1 : 0;
+        my $underscores = (shift) ? 1 : 0;
     # Escape where necessary
         my $safe_sep = $separator;
            $safe_sep =~ s/([^\w\s])/\\$1/sg;
@@ -149,6 +151,8 @@
         elsif ($hour < 1) {
             $hour = 12;
         }
+        $shour   = "0$shour"   if ($shour < 10);
+        $sminute = "0$sminute" if ($sminute < 10);
         # End time
         $eyear += 1900;
         $emonth++;
@@ -162,6 +166,8 @@
         elsif ($ethour < 1) {
             $ethour = 12;
         }
+        $ehour   = "0$ehour"   if ($ehour < 10);
+        $eminute = "0$eminute" if ($eminute < 10);
     # Original airdate
         my ($oday, $omonth, $oyear) = (localtime($self->{'airdate'}))[3,4,5];
         $oyear += 1900;
diff -Naur -x mytharchive mythtv-0.20-old/bindings/perl/MythTV/Recording.pm mythtv-0.20-new/bindings/perl/MythTV/Recording.pm
--- mythtv-0.20-old/bindings/perl/MythTV/Recording.pm	2006-07-19 19:20:17.000000000 -0700
+++ mythtv-0.20-new/bindings/perl/MythTV/Recording.pm	2007-04-17 10:23:47.000000000 -0700
@@ -3,9 +3,9 @@
 #
 # Object containing info about a particular MythTV recording.
 #
-# @url       $URL: svn+ssh://ijr@cvs.mythtv.org/var/lib/svn/trunk/mythtv/bindings/perl/MythTV/Recording.pm $
-# @date      $Date: 2006-07-19 22:20:17 -0400 (Wed, 19 Jul 2006) $
-# @version   $Revision: 10602 $
+# @url       $URL: http://svn.mythtv.org/svn/branches/release-0-20-fixes/mythtv/bindings/perl/MythTV/Recording.pm $
+# @date      $Date: 2006-10-07 23:48:26 -0700 (Sat, 07 Oct 2006) $
+# @version   $Revision: 11472 $
 # @author    $Author: xris $
 #
 
@@ -50,6 +50,10 @@
                 $self->{'file_port'} = ($2 or 6543);
                 $self->{'basename'}  = $3;
             }
+            else {
+                $self->{'basename'}  = $self->{'filename'};
+                $self->{'basename'} =~ s/^$self->{'video_dir'}\/+//sg;
+            }
         }
 
     # Pull the cutlist info from the database
@@ -231,6 +235,10 @@
     # Make sure some things are actually numbers
         $info{'width'}  += 0;
         $info{'height'} += 0;
+    # HD fix
+        if ($info{'height'} == 1080) {
+            $info{'height'} = 1088;
+        }
     # Make some corrections for myth bugs
         $info{'audio_sample_rate'} = 44100 if ($info{'audio_sample_rate'} == 42501 || $info{'audio_sample_rate'} =~ /^44\d\d\d$/);
         $info{'aspect'} = '4:3';
@@ -297,6 +305,19 @@
                ."    $program -v -v -v -v -nolirc -nojoystick -vo null -ao null \\\n"
                ."             -frames 0 -identify '$file'\n\n";
         }
+    # HD fix
+        if ($info{'height'} == 1080) {
+            $info{'height'} = 1088;
+        }
+    # mplayer is confused and we need to detect the aspect on our own
+        if ($info{'aspect'} =~ /^0.0/) {
+            if ($info{'height'} == 1088 || $info{'height'} == 720) {
+                $info{'aspect'} = 16 / 9;
+            }
+            else {
+                $info{'aspect'} = 4 / 3;
+            }
+        }
     # Cleanup
         $info{'aspect'}   = aspect_str($info{'aspect'});
         $info{'aspect_f'} = aspect_float($info{'aspect'});
@@ -330,7 +351,7 @@
             return $w / $h;
         }
     # Parse out decimal formats
-        if ($aspect == 1)          { return  1;     }
+        if ($aspect eq '1')        { return  1;     }
         elsif ($aspect =~ m/^1.3/) { return  4 / 3; }
         elsif ($aspect =~ m/^1.7/) { return 16 / 9; }
     # Unknown aspect
diff -Naur -x mytharchive mythtv-0.20-old/bindings/perl/MythTV.pm mythtv-0.20-new/bindings/perl/MythTV.pm
--- mythtv-0.20-old/bindings/perl/MythTV.pm	2006-07-04 13:30:37.000000000 -0700
+++ mythtv-0.20-new/bindings/perl/MythTV.pm	2007-04-17 10:23:47.000000000 -0700
@@ -1,14 +1,14 @@
 #
 # MythTV bindings for perl.
 #
-# @url       $URL: svn+ssh://ijr@cvs.mythtv.org/var/lib/svn/trunk/mythtv/bindings/perl/MythTV.pm $
-# @date      $Date: 2006-07-04 16:30:37 -0400 (Tue, 04 Jul 2006) $
-# @version   $Revision: 10390 $
+# @url       $URL: http://svn.mythtv.org/svn/branches/release-0-20-fixes/mythtv/bindings/perl/MythTV.pm $
+# @date      $Date: 2006-10-04 22:46:03 -0700 (Wed, 04 Oct 2006) $
+# @version   $Revision: 11444 $
 # @author    $Author: xris $
 #
 
 # Version
-    $VERSION = '.20svn';
+    $VERSION = '.20';
 
 # Load sub libraries
     use MythTV::Program;
@@ -48,12 +48,12 @@
 
 # MYTH_PROTO_VERSION is defined in libmyth in mythtv/libs/libmyth/mythcontext.h
 # and should be the current MythTV protocol version.
-    our $PROTO_VERSION = 29;
+    our $PROTO_VERSION = 31;
 
 # NUMPROGRAMLINES is defined in mythtv/libs/libmythtv/programinfo.h and is
 # the number of items in a ProgramInfo QStringList group used by
 # ProgramInfo::ToSringList and ProgramInfo::FromStringList.
-    our $NUMPROGRAMLINES = 41;
+    our $NUMPROGRAMLINES = 42;
 
 # Reasons a recording wouldn't be happening (from libs/libmythtv/programinfo.h)
     our %RecStatus_Types = (
diff -Naur -x mytharchive mythtv-0.20-old/configfiles/lircrc.native.example.mceusb2 mythtv-0.20-new/configfiles/lircrc.native.example.mceusb2
--- mythtv-0.20-old/configfiles/lircrc.native.example.mceusb2	2006-06-11 22:18:38.000000000 -0700
+++ mythtv-0.20-new/configfiles/lircrc.native.example.mceusb2	2007-04-17 10:23:29.000000000 -0700
@@ -2,7 +2,7 @@
 # lircrc config file for the Microsoft Media Center Edition Remote, model 1039
 #
 # @url       $URL$
-# @date      $Date: 2006-06-12 01:18:38 -0400 (Mon, 12 Jun 2006) $
+# @date      $Date: 2006-06-11 22:18:38 -0700 (Sun, 11 Jun 2006) $
 # @version   $Revision: 10187 $
 # @author    $Author: xris $
 #
diff -Naur -x mytharchive mythtv-0.20-old/contrib/myth_archive_job.pl mythtv-0.20-new/contrib/myth_archive_job.pl
--- mythtv-0.20-old/contrib/myth_archive_job.pl	2005-11-29 08:28:53.000000000 -0800
+++ mythtv-0.20-new/contrib/myth_archive_job.pl	2007-04-17 10:23:47.000000000 -0700
@@ -72,7 +72,7 @@
 			printf( "    Curr Free: %6d MB\n", $freeSpace );
 		}
 
-		if (( $freeSpace - ($size / 1024.0 / 1024.0)) > $keepFree ) {
+		if (( $freeSpace - $size) > $keepFree ) {
 			printf( "Attempting archive to %s\nStatus: ", $archiveDir );
 			if (MoveFileToArchiveDir( $file, $directory, $archiveDir )) {
 				printf( "Success.\n" );
@@ -97,7 +97,7 @@
 	if ( ! -r $dir ) {
 		return 0;
 	} else {
-		my( $freeSpace ) = `df -m $dir | grep -v Available | awk '{print \$4}'`;
+		my( $freeSpace ) = `df -Pm $dir | grep -v Available | awk '{print \$4}'`;
 
 		return $freeSpace;
 	}
diff -Naur -x mytharchive mythtv-0.20-old/contrib/mythrename.pl mythtv-0.20-new/contrib/mythrename.pl
--- mythtv-0.20-old/contrib/mythrename.pl	2006-02-27 23:40:08.000000000 -0800
+++ mythtv-0.20-new/contrib/mythrename.pl	2007-04-17 10:23:47.000000000 -0700
@@ -1,6 +1,6 @@
 #!/usr/bin/perl -w
 #
-# $Date: 2006-02-28 02:40:08 -0500 (Tue, 28 Feb 2006) $
+# $Date: 2006-02-27 23:40:08 -0800 (Mon, 27 Feb 2006) $
 # $Revision: 9198 $
 # $Author: xris $
 #
diff -Naur -x mytharchive mythtv-0.20-old/contrib/optimize_mythdb.pl mythtv-0.20-new/contrib/optimize_mythdb.pl
--- mythtv-0.20-old/contrib/optimize_mythdb.pl	2006-08-05 14:51:46.000000000 -0700
+++ mythtv-0.20-new/contrib/optimize_mythdb.pl	2007-04-17 10:23:47.000000000 -0700
@@ -1,6 +1,6 @@
 #!/usr/bin/perl -w
 #
-# $Date: 2006-08-05 17:51:46 -0400 (Sat, 05 Aug 2006) $
+# $Date: 2006-08-05 14:51:46 -0700 (Sat, 05 Aug 2006) $
 # $Revision: 10685 $
 # $Author: xris $
 #
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/dbsettings.cpp mythtv-0.20-new/libs/libmyth/dbsettings.cpp
--- mythtv-0.20-old/libs/libmyth/dbsettings.cpp	2006-04-07 12:14:30.000000000 -0700
+++ mythtv-0.20-new/libs/libmyth/dbsettings.cpp	2007-04-17 10:23:36.000000000 -0700
@@ -4,40 +4,6 @@
 #include <qfile.h>
 #include <qdir.h>
 
-class TransientSetting: public TransientStorage, virtual public Configurable {
-public:
-    TransientSetting() { };
-};
-
-class TransientSpinBox: public SpinBoxSetting, public TransientSetting {
-  public:
-    TransientSpinBox(int min, int max, int step, 
-                   bool allow_single_step = false) :
-        SpinBoxSetting(min, max, step, allow_single_step) { };
-};
-
-class TransientCheckBox: public CheckBoxSetting, public TransientSetting {
-  public:
-    TransientCheckBox() { };
-};
-
-class TransientLineEdit: public LineEditSetting, public TransientSetting {
-  public:
-    TransientLineEdit(bool rw = true) :
-        LineEditSetting(rw) { };
-};
-
-class TransientComboBox: public ComboBoxSetting, public TransientSetting {
-  public:
-    TransientComboBox(bool rw = true) :
-        ComboBoxSetting(rw) { };
-};
-
-class TransientLabel: public LabelSetting, public TransientSetting {
-  public:
-    TransientLabel() { };
-};
-
 class MythDbSettings1: public VerticalConfigurationGroup {
 public:
     MythDbSettings1();
@@ -46,12 +12,12 @@
     void save();
     
 protected:
-    TransientLabel    *info;
-    TransientLineEdit *dbHostName;
-    TransientLineEdit *dbName;
-    TransientLineEdit *dbUserName;
-    TransientLineEdit *dbPassword;
-    TransientComboBox *dbType;
+    TransLabelSetting    *info;
+    TransLineEditSetting *dbHostName;
+    TransLineEditSetting *dbName;
+    TransLineEditSetting *dbUserName;
+    TransLineEditSetting *dbPassword;
+    TransComboBoxSetting *dbType;
 }; 
 
 class MythDbSettings2: public VerticalConfigurationGroup {
@@ -62,12 +28,12 @@
     void save();
     
 protected:
-    TransientCheckBox *localEnabled;
-    TransientLineEdit *localHostName;
-    TransientCheckBox *wolEnabled;
-    TransientSpinBox  *wolReconnect;
-    TransientSpinBox  *wolRetry;
-    TransientLineEdit *wolCommand;
+    TransCheckBoxSetting *localEnabled;
+    TransLineEditSetting *localHostName;
+    TransCheckBoxSetting *wolEnabled;
+    TransSpinBoxSetting  *wolReconnect;
+    TransSpinBoxSetting  *wolRetry;
+    TransLineEditSetting *wolCommand;
 }; 
 
 
@@ -115,7 +81,7 @@
     setLabel(QObject::tr("Database Configuration") + " 1/2");
     setUseLabel(false);
     
-    info = new TransientLabel();
+    info = new TransLabelSetting();
 
     MSqlQuery query(MSqlQuery::InitCon());
     if (query.isConnected())
@@ -127,34 +93,33 @@
                                    "below."));
     addChild(info);
     
-    dbHostName = new TransientLineEdit(true);
+    dbHostName = new TransLineEditSetting(true);
     dbHostName->setLabel(QObject::tr("Host name"));
     dbHostName->setHelpText(QObject::tr("The host name or IP address of "
                                         "the machine hosting the database. "
                                         "This information is required."));
     addChild(dbHostName);
-    
-    dbName = new TransientLineEdit(true);
+    dbName = new TransLineEditSetting(true);
     dbName->setLabel(QObject::tr("Database"));
     dbName->setHelpText(QObject::tr("The name of the database. "
                                     "This information is required."));
     addChild(dbName);
 
-    dbUserName = new TransientLineEdit(true);
+    dbUserName = new TransLineEditSetting(true);
     dbUserName->setLabel(QObject::tr("User"));
     dbUserName->setHelpText(QObject::tr("The user name to use while "
                                         "connecting to the database. "
                                         "This information is required."));
     addChild(dbUserName);
     
-    dbPassword = new TransientLineEdit(true);
+    dbPassword = new TransLineEditSetting(true);
     dbPassword->setLabel(QObject::tr("Password"));
     dbPassword->setHelpText(QObject::tr("The password to use while "
                                         "connecting to the database. "
                                         "This information is required."));
     addChild(dbPassword);
     
-    dbType = new TransientComboBox(false);
+    dbType = new TransComboBoxSetting(false);
     dbType->setLabel(QObject::tr("Database type"));
     dbType->addSelection(QObject::tr("MySQL"), "QMYSQL3");
     //dbType->addSelection(QObject::tr("PostgreSQL"), "QPSQL7");
@@ -171,7 +136,7 @@
     setLabel(QObject::tr("Database Configuration") + " 2/2");
     setUseLabel(false);
     
-    localEnabled = new TransientCheckBox();
+    localEnabled = new TransCheckBoxSetting();
     localEnabled->setLabel(QObject::tr("Use custom identifier for frontend "
                                        "preferences"));
     localEnabled->setHelpText(QObject::tr("If this frontend's host name "
@@ -183,7 +148,7 @@
                                           "be used to save preferences in "
                                           "the database."));
     
-    localHostName = new TransientLineEdit(true);
+    localHostName = new TransLineEditSetting(true);
     localHostName->setLabel(QObject::tr("Custom identifier"));
     localHostName->setHelpText(QObject::tr("An identifier to use while "
                                            "saving the settings for this "
@@ -197,24 +162,24 @@
         new LocalHostNameSettings(localEnabled, group1);
     addChild(sub3);
     
-    wolEnabled = new TransientCheckBox();
+    wolEnabled = new TransCheckBoxSetting();
     wolEnabled->setLabel(QObject::tr("Use Wake-On-LAN to wake database"));
     wolEnabled->setHelpText(QObject::tr("If checked, the frontend will use "
                                         "Wake-On-LAN parameters to "
                                         "reconnect to the database server."));
     
-    wolReconnect = new TransientSpinBox(0, 60, 1, true);
+    wolReconnect = new TransSpinBoxSetting(0, 60, 1, true);
     wolReconnect->setLabel(QObject::tr("Reconnect time"));
     wolReconnect->setHelpText(QObject::tr("The time in seconds to wait for "
                                           "the server to wake up."));
     
-    wolRetry = new TransientSpinBox(1, 10, 1, true);
+    wolRetry = new TransSpinBoxSetting(1, 10, 1, true);
     wolRetry->setLabel(QObject::tr("Retry attempts"));
     wolRetry->setHelpText(QObject::tr("The number of retries to wake the "
                                       "server before the frontend gives "
                                       "up."));
     
-    wolCommand = new TransientLineEdit(true);
+    wolCommand = new TransLineEditSetting(true);
     wolCommand->setLabel(QObject::tr("Wake command"));
     wolCommand->setHelpText(QObject::tr("The command executed on this "
                                         "frontend to wake up the database "
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/mythcdrom.cpp mythtv-0.20-new/libs/libmyth/mythcdrom.cpp
--- mythtv-0.20-old/libs/libmyth/mythcdrom.cpp	2006-05-31 22:26:52.000000000 -0700
+++ mythtv-0.20-new/libs/libmyth/mythcdrom.cpp	2007-04-17 10:23:36.000000000 -0700
@@ -70,12 +70,12 @@
     m_Status = MEDIASTAT_MOUNTED;
 
     DetectPath.sprintf("%s%s", (const char*)m_MountPath, PATHTO_DVD_DETECT);
-    VERBOSE(VB_IMPORTANT, QString("Looking for: '%1'").arg(DetectPath));
+    VERBOSE(VB_MEDIA, QString("Looking for: '%1'").arg(DetectPath));
 
     struct stat sbuf;
     if (stat(DetectPath, &sbuf) == 0)
     {
-        VERBOSE(VB_GENERAL, "Probable DVD detected.");
+        VERBOSE(VB_MEDIA, "Probable DVD detected.");
         m_MediaType = MEDIATYPE_DVD;
         // HACK make it possible to eject a DVD by unmounting it
         performMountCmd(false);
@@ -83,14 +83,14 @@
     }
     
     DetectPath.sprintf("%s%s", (const char*)m_MountPath, PATHTO_VCD_DETECT);
-    VERBOSE(VB_IMPORTANT, QString("Looking for: '%1'").arg(DetectPath));
+    VERBOSE(VB_MEDIA, QString("Looking for: '%1'").arg(DetectPath));
 
     DetectPath2.sprintf("%s%s", (const char*)m_MountPath, PATHTO_SVCD_DETECT);
-    VERBOSE(VB_IMPORTANT, QString("Looking for: '%1'").arg(DetectPath2));
+    VERBOSE(VB_MEDIA, QString("Looking for: '%1'").arg(DetectPath2));
 
     if (stat(DetectPath, &sbuf) == 0 || stat(DetectPath2, &sbuf) == 0)
     {
-        VERBOSE(VB_GENERAL, "Probable VCD/SVCD detected.");
+        VERBOSE(VB_MEDIA, "Probable VCD/SVCD detected.");
         m_MediaType = MEDIATYPE_VCD;
         // HACK make it possible to eject a VCD/SVCD by unmounting it
         performMountCmd(false);
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/mythcdrom-linux.cpp mythtv-0.20-new/libs/libmyth/mythcdrom-linux.cpp
--- mythtv-0.20-old/libs/libmyth/mythcdrom-linux.cpp	2006-03-14 15:43:28.000000000 -0800
+++ mythtv-0.20-new/libs/libmyth/mythcdrom-linux.cpp	2007-04-17 10:23:36.000000000 -0700
@@ -10,12 +10,24 @@
 
 MediaError MythCDROMLinux::eject(bool open_close)
 {
+    if (!isDeviceOpen())
+        openDevice();
+
     if (open_close)
         return (ioctl(m_DeviceHandle, CDROMEJECT) == 0) ? MEDIAERR_OK
                                                         : MEDIAERR_FAILED;
     else
-        return (ioctl(m_DeviceHandle, CDROMCLOSETRAY) == 0) ? MEDIAERR_OK
-                                                            : MEDIAERR_FAILED;
+    {
+        // If the tray is empty, this will fail (Input/Output error)
+        ioctl(m_DeviceHandle, CDROMCLOSETRAY);
+
+        // This allows us to catch any drives that the OS has problems
+        // detecting the status of (some always report OPEN when empty)
+        if (ioctl(m_DeviceHandle, CDROM_DRIVE_STATUS) == CDS_TRAY_OPEN)
+            return MEDIAERR_FAILED;
+        else
+            return MEDIAERR_OK;
+    }
 }
 
 bool MythCDROMLinux::mediaChanged()
@@ -39,18 +51,14 @@
         //cout << "Device is not open - ";
         if (!openDevice()) 
         {
-            //cout << "failed to open device - ";
+            //VERBOSE(VB_MEDIA, "MythCDROMLinux::testMedia - failed to open "
+            //                  + getDevicePath() + ENO);
             if (errno == EBUSY)
-            {
-                //cout << "errno == EBUSY" << endl;
                 return isMounted(true) ? MEDIAERR_OK : MEDIAERR_FAILED;
-            } 
             else 
-            { 
                 return MEDIAERR_FAILED; 
-            }
         }
-        //cout << "Opened it - ";
+        //VERBOSE(VB_MEDIA, "MythCDROMLinux::testMedia - Opened device");
         OpenedHere = true;
     }
 
@@ -60,8 +68,16 @@
     // Be nice and close the device if we opened it, otherwise it might be locked when the user doesn't want it to be.
     if (OpenedHere)
         closeDevice();
-    //cout << "Stat == " << Stat << endl;
-    return (Stat >= 0) ? MEDIAERR_OK : MEDIAERR_FAILED;    
+
+    if (Stat == -1)
+    {
+        VERBOSE(VB_MEDIA,
+                "MythCDROMLinux::testMedia - Failed to get drive status of "
+                + getDevicePath() + ENO);
+        return MEDIAERR_FAILED;    
+    }
+
+    return MEDIAERR_OK;
 }
 
 MediaStatus MythCDROMLinux::checkMedia()
@@ -70,25 +86,22 @@
    
     if (testMedia() != MEDIAERR_OK) 
     {
-        //cout << "MythCDROMLinux::checkMedia - ";
-        //cout << "Test Media result != MEDIAERR_OK" << endl;
         m_MediaType = MEDIATYPE_UNKNOWN;
         return setStatus(MEDIASTAT_UNKNOWN, OpenedHere);
     }
 
-    //cout << "MythCDROMLinux::checkMedia - ";
     // If it's not already open we need to at least TRY to open it for most of these checks to work.
     if (!isDeviceOpen())
         OpenedHere = openDevice();
 
     if (isDeviceOpen()) 
     {
-        //cout << "device is open - ";
+        //VERBOSE(VB_MEDIA, "MythCDROMLinux::checkMedia - Device is open...");
         int ret = ioctl(m_DeviceHandle, CDROM_DRIVE_STATUS, CDSL_CURRENT);
         switch (ret) 
         {
             case CDS_DISC_OK:
-                //cout << "disk ok - ";
+                VERBOSE(VB_MEDIA, getDevicePath() + " Disk OK...");
                 // If the disc is ok and we already know it's mediatype
                 // returns MOUNTED.
                 if (isMounted(true) && m_MediaType != MEDIATYPE_UNKNOWN)
@@ -96,43 +109,51 @@
                 // If the disk is ok but not yet mounted we'll test it further down after this switch exits.
                 break;
             case CDS_TRAY_OPEN:
-            case CDS_NO_DISC:
-                //cout << "Tray open or no disc" << endl;
+                VERBOSE(VB_MEDIA, getDevicePath() + " Tray open");
                 m_MediaType = MEDIATYPE_UNKNOWN;
                 return setStatus(MEDIASTAT_OPEN, OpenedHere);
                 break;
+            case CDS_NO_DISC:
+                VERBOSE(VB_MEDIA, getDevicePath() + " No disc");
+                m_MediaType = MEDIATYPE_UNKNOWN;
+                return setStatus(MEDIASTAT_NODISK, OpenedHere);
+                break;
             case CDS_NO_INFO:
             case CDS_DRIVE_NOT_READY:
-                //cout << "No info or drive not ready" << endl;
+                VERBOSE(VB_MEDIA, getDevicePath()
+                                  + " No info or drive not ready");
                 m_MediaType = MEDIATYPE_UNKNOWN;
                 return setStatus(MEDIASTAT_UNKNOWN, OpenedHere);
             default:
-                //cout << "unknown result from ioctl (" << ret << ")" << endl;
+                VERBOSE(VB_IMPORTANT, "Failed to get drive status of "
+                                      + getDevicePath() + " : " + ENO);
                 m_MediaType = MEDIATYPE_UNKNOWN;
                 return setStatus(MEDIASTAT_UNKNOWN, OpenedHere);
         }
 
         if (mediaChanged()) 
         {
-            //cout << "media changed - ";
+            VERBOSE(VB_MEDIA, getDevicePath() + " Media changed");
             // Regardless of the actual status lie here and say
             // it's open for now, so we can cover the case of a missed open.
             return setStatus(MEDIASTAT_OPEN, OpenedHere);
         } 
         else 
         {
-            //cout << "media unchanged - ";
+            //VERBOSE(VB_MEDIA, getDevicePath() + " Media unchanged...");
             if ((m_Status == MEDIASTAT_OPEN) || 
                 (m_Status == MEDIASTAT_UNKNOWN)) 
             {
-                //cout << "Current status == " << MythMediaDevice::MediaStatusStrings[m_Status]  << endl;
-                int type = ioctl(m_DeviceHandle, CDROM_DISC_STATUS, CDSL_CURRENT);
+                VERBOSE(VB_MEDIA, getDevicePath() + " Current status " +
+                        MythMediaDevice::MediaStatusStrings[m_Status]);
+                int type = ioctl(m_DeviceHandle,
+                                 CDROM_DISC_STATUS, CDSL_CURRENT);
                 switch (type) 
                 {
                     case CDS_DATA_1:
                     case CDS_DATA_2:
                         m_MediaType = MEDIATYPE_DATA;
-                        //cout << "found a data disk" << endl;
+                        VERBOSE(VB_MEDIA, "Found a data disk");
                         //grab information from iso9660 (& udf)
                         struct iso_primary_descriptor buf;
                         lseek(this->m_DeviceHandle,(off_t) 2048*16,SEEK_SET);
@@ -143,10 +164,12 @@
                                       .arg(this->m_VolumeID)
                                       .arg(QString(buf.creation_date).left(16));
 
-                        // attempt to mount the disc
                         // the base class's onDeviceMounted will do fine
                         // grained detection of the type of data on this disc
-                        mount();
+                        if (isMounted(true))
+                            onDeviceMounted();
+                        else
+                            mount(); // onDeviceMounted() called as side-effect
 
                         if (isMounted(true))
                         {
@@ -166,13 +189,13 @@
                             return setStatus(MEDIASTAT_NOTMOUNTED, OpenedHere);
                         break;
                     case CDS_AUDIO:
-                        //cout << "found an audio disk" << endl;
+                        VERBOSE(VB_MEDIA, "found an audio disk");
                         m_MediaType = MEDIATYPE_AUDIO;
                         return setStatus(MEDIASTAT_USEABLE, OpenedHere);
                         break;
                     case CDS_MIXED:
                         m_MediaType = MEDIATYPE_MIXED;
-                        //cout << "found a mixed CD" << endl;
+                        VERBOSE(VB_MEDIA, "found a mixed CD");
                         // Note: Mixed mode CDs require an explixit mount call since we'll usually want the audio portion.
                         //         undefine ASSUME_WANT_AUDIO to change this behavior.
                         #ifdef ASSUME_WANT_AUDIO
@@ -196,13 +219,13 @@
                         break;
                     case CDS_NO_INFO:
                     case CDS_NO_DISC:
-                        //cout << "found no disk" << endl;
+                        VERBOSE(VB_MEDIA, "found no disk");
                         m_MediaType = MEDIATYPE_UNKNOWN;
                         return setStatus(MEDIASTAT_UNKNOWN, OpenedHere);
                         break;
                     default:
-                        //cout << "found unknown disk type" << endl;
-                        fprintf(stderr, "Unknown data type: %d\n", type);
+                        VERBOSE(VB_MEDIA, "found unknown disk type: "
+                                          + QString().setNum(type));
                         m_MediaType = MEDIATYPE_UNKNOWN;
                         return setStatus(MEDIASTAT_UNKNOWN, OpenedHere);
                 }            
@@ -210,7 +233,9 @@
             else if (m_Status == MEDIASTAT_MOUNTED || 
                      m_Status == MEDIASTAT_NOTMOUNTED) 
             {
-                //cout << "current status == " << MythMediaDevice::MediaStatusStrings[m_Status] << " setting status to not mounted - ";
+                VERBOSE(VB_MEDIA, QString("Current status == ") +
+                        MythMediaDevice::MediaStatusStrings[m_Status]);
+                VERBOSE(VB_MEDIA, "Setting status to not mounted?");
                 if (isMounted(true))
                     setStatus(MEDIASTAT_MOUNTED, OpenedHere);
                 else
@@ -223,7 +248,7 @@
     } // isDeviceOpen();
     else 
     {
-        //cout << "device not open returning unknown" << endl;
+        VERBOSE(VB_MEDIA, "Device not open - returning UNKNOWN");
         m_MediaType = MEDIATYPE_UNKNOWN;
         return setStatus(MEDIASTAT_UNKNOWN, OpenedHere);
     }
@@ -231,7 +256,8 @@
     if (OpenedHere)
         closeDevice();
 
-    //cout << "returning " << MythMediaDevice::MediaStatusStrings[m_Status] << endl;
+    //VERBOSE(VB_MEDIA, QString("Returning ")
+    //                  + MythMediaDevice::MediaStatusStrings[m_Status]);
     return m_Status;
 }
 
@@ -248,7 +274,7 @@
 {
     if (isDeviceOpen() || openDevice()) 
     { 
-        //cout <<  "Unlocking CDROM door" << endl;
+        //VERBOSE(VB_MEDIA, "MythCDROMLinux::unlock - Unlocking CDROM door");
         ioctl(m_DeviceHandle, CDROM_LOCKDOOR, 0);
     }
     else
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/mythcontext.h mythtv-0.20-new/libs/libmyth/mythcontext.h
--- mythtv-0.20-old/libs/libmyth/mythcontext.h	2006-08-28 13:47:26.000000000 -0700
+++ mythtv-0.20-new/libs/libmyth/mythcontext.h	2007-04-17 10:23:36.000000000 -0700
@@ -99,6 +99,8 @@
       "upnp debugging messages")                 \
     F(VB_SOCKET,    0x00100000, "socket",    1,  \
       "socket debugging messages")               \
+    F(VB_MEDIA,     0x00800000, "media",     1,  \
+      "Media Manager debugging messages")        \
     F(VB_TIMESTAMP, 0x80000000, "timestamp", 1,  \
       "Conditional data driven messages")        \
     F(VB_NONE,      0x00000000, "none",      0,  \
@@ -222,14 +224,14 @@
 
 /// Update this whenever the plug-in API changes.
 /// Including changes in the libmythtv class methods used by plug-ins.
-#define MYTH_BINARY_VERSION "0.20.20060828-3"
+#define MYTH_BINARY_VERSION "0.20.20060828-4"
 
 /** \brief Increment this whenever the MythTV network protocol changes.
  *
  *   You must also update this value in
  *   mythplugins/mythweb/includes/mythbackend.php
  */
-#define MYTH_PROTO_VERSION "30"
+#define MYTH_PROTO_VERSION "31"
 
 /** \class MythContext
  *  \brief This class contains the runtime context for MythTV.
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/mythhdd.cpp mythtv-0.20-new/libs/libmyth/mythhdd.cpp
--- mythtv-0.20-old/libs/libmyth/mythhdd.cpp	2006-03-14 15:43:28.000000000 -0800
+++ mythtv-0.20-new/libs/libmyth/mythhdd.cpp	2007-04-17 10:23:36.000000000 -0700
@@ -33,6 +33,10 @@
 {
     if (isMounted(true))
     {
+        // A lazy way to present volume name for the user to eject.
+        // Hotplug devices are usually something like /media/VOLUME
+        m_VolumeID = m_MountPath;
+
         // device is mounted, trigger event
         return setStatus(MEDIASTAT_MOUNTED);
     }
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/mythmedia.cpp mythtv-0.20-new/libs/libmyth/mythmedia.cpp
--- mythtv-0.20-old/libs/libmyth/mythmedia.cpp	2006-05-31 22:26:52.000000000 -0700
+++ mythtv-0.20-new/libs/libmyth/mythmedia.cpp	2007-04-17 10:23:36.000000000 -0700
@@ -31,6 +31,7 @@
     "MEDIASTAT_UNKNOWN",
     "MEDIASTAT_UNPLUGGED",
     "MEDIASTAT_OPEN",
+    "MEDIASTAT_NODISK",
     "MEDIASTAT_USEABLE",
     "MEDIASTAT_NOTMOUNTED",
     "MEDIASTAT_MOUNTED"
@@ -117,7 +118,7 @@
                 .arg((DoMount) ? PATHTO_MOUNT : PATHTO_UNMOUNT)
                 .arg(m_DevicePath);
     
-        VERBOSE(VB_IMPORTANT,  QString("Executing '%1'").arg(MountCommand));
+        VERBOSE(VB_MEDIA,  QString("Executing '%1'").arg(MountCommand));
         if (0 == myth_system(MountCommand)) 
         {
             if (DoMount)
@@ -127,7 +128,8 @@
                 isMounted(true);
                 m_Status = MEDIASTAT_MOUNTED;
                 onDeviceMounted();
-                VERBOSE(VB_IMPORTANT, "m_MediaType: "<<m_MediaType);
+                VERBOSE(VB_GENERAL, QString("Detected MediaType ")
+                                    + MediaTypeStrings[m_Status]);
             }
             else
                 onDeviceUnmounted();
@@ -141,14 +143,15 @@
     } 
     else 
     {
-        VERBOSE( VB_IMPORTANT,  "Disk inserted on a supermount device" );
+        VERBOSE(VB_MEDIA,  "Disk inserted on a supermount device" );
         // If it's a super mount then the OS will handle mounting /  unmounting.
         // We just need to give derived classes a chance to perform their 
         // mount / unmount logic.
         if (DoMount)
         {
             onDeviceMounted();
-            VERBOSE(VB_IMPORTANT, "m_MediaType: "<<m_MediaType);
+            VERBOSE(VB_GENERAL, QString("Detected MediaType ")
+                                + MediaTypeStrings[m_Status]);
         }
         else
             onDeviceUnmounted();
@@ -167,7 +170,7 @@
 
     if (!ScanMediaType(m_MountPath, ext_cnt))
     {
-        VERBOSE(VB_GENERAL, QString("No files with extensions found in '%1'")
+        VERBOSE(VB_MEDIA, QString("No files with extensions found in '%1'")
                 .arg(m_MountPath));
         return mediatype;
     }
@@ -317,8 +320,8 @@
             
             // Extract the mount point and device name.
             stream >> DeviceName >> MountPoint;
-            //cout << "Found Device: " << DeviceName
-            //     << "  Mountpoint: " << MountPoint << endl; 
+            //VERBOSE(VB_MEDIA, "Found Device: " << DeviceName
+            //                  << "  Mountpoint: " << MountPoint);
 
             // Skip the rest of the line
             line = stream.readLine();
@@ -357,6 +360,7 @@
             // the disk is not / should not be mounted.
             case MEDIASTAT_ERROR:
             case MEDIASTAT_OPEN:
+            case MEDIASTAT_NODISK:
             case MEDIASTAT_NOTMOUNTED:
                 if (isMounted(true))
                     unmount();
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/mythmedia.h mythtv-0.20-new/libs/libmyth/mythmedia.h
--- mythtv-0.20-old/libs/libmyth/mythmedia.h	2006-05-31 22:26:52.000000000 -0700
+++ mythtv-0.20-new/libs/libmyth/mythmedia.h	2007-04-17 10:23:36.000000000 -0700
@@ -9,7 +9,8 @@
     MEDIASTAT_ERROR,
     MEDIASTAT_UNKNOWN,
     MEDIASTAT_UNPLUGGED,
-    MEDIASTAT_OPEN,
+    MEDIASTAT_OPEN,       /**< CD/DVD tray open. Meaningless for other types */
+    MEDIASTAT_NODISK,     /**< CD/DVD tray closed, SCSI drive unformatted? */
     MEDIASTAT_USEABLE,    
     MEDIASTAT_NOTMOUNTED,
     MEDIASTAT_MOUNTED
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/mythmediamonitor.cpp mythtv-0.20-new/libs/libmyth/mythmediamonitor.cpp
--- mythtv-0.20-old/libs/libmyth/mythmediamonitor.cpp	2006-05-31 22:26:52.000000000 -0700
+++ mythtv-0.20-new/libs/libmyth/mythmediamonitor.cpp	2007-04-17 10:23:36.000000000 -0700
@@ -157,6 +157,7 @@
     if (!selected)
         return;
 
+    bool doEject = false;
     int status = selected->getStatus();
     QString dev = selected->getVolumeID();
 
@@ -165,10 +166,21 @@
 
     if (MEDIASTAT_OPEN == status)
     {
-        selected->eject(false);
+        VERBOSE(VB_MEDIA,
+                QString("Disk %1's tray is OPEN. Closing tray").arg(dev));
+
+        if (selected->eject(false))
+        {
+            QString msg = "Unable to open or close the empty drive %1.\n\n";
+            msg += "You may have to use the eject button under its tray.";
+            MythPopupBox::showOkPopup(gContext->GetMainWindow(),
+                                      "eject close-tray fail",
+                                      tr(msg).arg(dev));
+        }
     }
     else if (MEDIASTAT_MOUNTED == status)
     {
+        VERBOSE(VB_MEDIA, QString("Disk %1 is mounted? Unmounting").arg(dev));
         selected->unmount();
 
         if (selected->isMounted(true))
@@ -177,9 +189,16 @@
                                       "eject unmount fail",
                                       tr("Failed to unmount %1").arg(dev));
         }
+        else
+            doEject = true;
     }
     else
+        doEject = true;
+
+    if (doEject)
     {
+        VERBOSE(VB_MEDIA,
+                QString("Unlocking disk %1, then eject()ing").arg(dev));
         selected->unlock();
 
         if (selected->eject() == MEDIAERR_UNSUPPORTED)
@@ -340,14 +359,18 @@
             line = stream.readLine();
             if (line.startsWith("drive name:"))
             {
-                QString s = line.section('\t', 2, 2);
-                l.append(s);
+                QStringList  devs = QStringList::split('\t', line); 
+
+                devs.pop_front();   // Remove 'drive name:' field 
+                l += devs;
             }
         }
         file.close();
     }
 #endif // linux
 
+    VERBOSE(VB_MEDIA, "MediaMonitorUnix::GetCDROMBlockDevices() returning " 
+                       + l.join(", "));
     return l;
 }
 
@@ -585,6 +608,11 @@
             if (*pit == "." || *pit == "..")
                 continue;
 
+            // skip some sysfs dirs that are _not_ sub-partitions
+            if (*pit == "device" || *pit == "holders" || *pit == "queue"
+                                 || *pit == "slaves"  || *pit == "subsystem")
+                continue;
+
             found_partitions |= FindPartitions(sysfs.absFilePath(*pit), false);
         }
 
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/settings.h mythtv-0.20-new/libs/libmyth/settings.h
--- mythtv-0.20-old/libs/libmyth/settings.h	2006-09-04 14:01:06.000000000 -0700
+++ mythtv-0.20-new/libs/libmyth/settings.h	2007-04-17 10:23:36.000000000 -0700
@@ -719,11 +719,6 @@
     MythPushButton *button;
 };
 
-class TransButtonSetting: public ButtonSetting, public TransientStorage {
-public:
-    TransButtonSetting(QString name = "button") : ButtonSetting(name) {}
-};
-
 class ConfigPopupDialogWidget: public MythPopupBox {
     Q_OBJECT
 public:
@@ -767,16 +762,6 @@
     int totalSteps;
 };
 
-class TransLabelSetting: public LabelSetting, public TransientStorage {
-public:
-    TransLabelSetting() {};
-};
-
-class TransCheckBoxSetting: public CheckBoxSetting, public TransientStorage {
-public:
-    TransCheckBoxSetting() {};
-};
-
 class HostSetting: public SimpleDBStorage, virtual public Configurable {
 public:
     HostSetting(QString name):
@@ -802,6 +787,57 @@
     virtual QString setClause(MSqlBindings& bindings);
 };
 
+///////////////////////////////////////////////////////////////////////////////
+
+class TransButtonSetting :
+    public ButtonSetting, public TransientStorage
+{
+  public:
+    TransButtonSetting(QString name = "button") : ButtonSetting(name) { }
+};
+
+class TransLabelSetting :
+    public LabelSetting, public TransientStorage
+{
+  public:
+    TransLabelSetting() { }
+};
+
+class TransLineEditSetting :
+    public LineEditSetting, public TransientStorage
+{
+  public:
+    TransLineEditSetting(bool rw = true) : LineEditSetting(rw) { }
+};
+
+class TransCheckBoxSetting :
+    public CheckBoxSetting, public TransientStorage
+{
+  public:
+    TransCheckBoxSetting() { }
+};
+
+class TransComboBoxSetting :
+    public ComboBoxSetting, public TransientStorage
+{
+  public:
+    TransComboBoxSetting(bool rw = true, int _step = 1) :
+        ComboBoxSetting(rw, _step) { }
+};
+
+class TransSpinBoxSetting :
+    public SpinBoxSetting, public TransientStorage
+{
+  public:
+    TransSpinBoxSetting(int min, int max, int step,
+                        bool allow_single_step = false,
+                        QString special_value_text = "") :
+        SpinBoxSetting(min, max, step, allow_single_step,
+                       special_value_text) { }
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
 class HostSlider: public SliderSetting, public HostSetting {
   public:
     HostSlider(const QString &name, int min, int max, int step) :
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/util.cpp mythtv-0.20-new/libs/libmyth/util.cpp
--- mythtv-0.20-old/libs/libmyth/util.cpp	2006-06-09 11:05:49.000000000 -0700
+++ mythtv-0.20-new/libs/libmyth/util.cpp	2007-04-17 10:23:36.000000000 -0700
@@ -34,6 +34,7 @@
 #include "exitcodes.h"
 #include "util.h"
 #include "mythcontext.h"
+#include "mythmediamonitor.h"
 
 #ifdef CONFIG_DARWIN
 #include <mach/mach.h> 
@@ -190,6 +191,8 @@
     (void)flags; /* Kill warning */
 
     bool ready_to_lock = gContext && gContext->GetMainWindow();
+
+    (void) ready_to_lock;  // stop warning
 #ifdef USE_LIRC
     bool lirc_lock_flag = !(flags & MYTH_SYSTEM_DONT_BLOCK_LIRC);
     LircEventLock lirc_lock(lirc_lock_flag && ready_to_lock);
@@ -417,8 +420,8 @@
  */
 bool getMemStats(int &totalMB, int &freeMB, int &totalVM, int &freeVM)
 {
-    size_t MB = (1024*1024);
 #ifdef __linux__
+    size_t MB = (1024*1024);
     struct sysinfo sinfo;
     if (sysinfo(&sinfo) == -1)
     {
@@ -472,3 +475,27 @@
 
     return true;
 }
+
+/**
+ * \brief Eject a disk, unmount a drive, open a tray
+ *
+ * If the Media Monitor is enabled, we use its fully-featured routine.
+ * Otherwise, we guess a drive and use a primitive OS-specific command
+ */
+void myth_eject()
+{
+    MediaMonitor *mon = MediaMonitor::GetMediaMonitor();
+    if (mon)
+        mon->ChooseAndEjectMedia();
+    else
+    {
+        VERBOSE(VB_MEDIA, "CD/DVD Monitor isn't enabled.");
+#ifdef __linux__
+        VERBOSE(VB_MEDIA, "Trying Linux 'eject -T' command");
+        myth_system("eject -T");
+#elif defined(CONFIG_DARWIN)
+        VERBOSE(VB_MEDIA, "Trying 'disktool -e disk1");
+        myth_system("disktool -e disk1");
+#endif
+    }
+}
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmyth/util.h mythtv-0.20-new/libs/libmyth/util.h
--- mythtv-0.20-old/libs/libmyth/util.h	2006-07-18 18:34:13.000000000 -0700
+++ mythtv-0.20-new/libs/libmyth/util.h	2007-04-17 10:23:36.000000000 -0700
@@ -62,4 +62,5 @@
 bool getUptime(time_t &uptime);
 bool getMemStats(int &totalMB, int &freeMB, int &totalVM, int &freeVM);
 
+void myth_eject(void);
 #endif // UTIL_H_
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythdvdnav/vm.c mythtv-0.20-new/libs/libmythdvdnav/vm.c
--- mythtv-0.20-old/libs/libmythdvdnav/vm.c	2006-03-24 05:17:02.000000000 -0800
+++ mythtv-0.20-new/libs/libmythdvdnav/vm.c	2007-04-17 10:23:44.000000000 -0700
@@ -757,11 +757,11 @@
     }
   }
 
-  if((vm->state).domain == VTS_DOMAIN && !((vm->state).SPST_REG & 0x40))
+  if((vm->state).SPST_REG & 0x40)
     /* Bit 7 set means hide, and only let Forced display show */
-    return (streamN | 0x80);
+    return (streamN & 0x1F);
   else
-    return streamN;
+    return -1;
 }
 
 void vm_get_angle_info(vm_t *vm, int *current, int *num_avail) {
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/AAFilter.cpp mythtv-0.20-new/libs/libmythsoundtouch/AAFilter.cpp
--- mythtv-0.20-old/libs/libmythsoundtouch/AAFilter.cpp	2006-05-23 10:40:36.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/AAFilter.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -12,7 +12,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-23 13:40:36 -0400 (Tue, 23 May 2006) $
+// Last changed  : $Date: 2006-05-23 10:40:36 -0700 (Tue, 23 May 2006) $
 // File revision : $Revision: 9996 $
 //
 // $Id: AAFilter.cpp 9996 2006-05-23 17:40:36Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/AAFilter.h mythtv-0.20-new/libs/libmythsoundtouch/AAFilter.h
--- mythtv-0.20-old/libs/libmythsoundtouch/AAFilter.h	2004-11-13 14:29:45.000000000 -0800
+++ mythtv-0.20-new/libs/libmythsoundtouch/AAFilter.h	2007-04-17 10:23:33.000000000 -0700
@@ -13,7 +13,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2004-11-13 17:29:45 -0500 (Sat, 13 Nov 2004) $
+// Last changed  : $Date: 2004-11-13 14:29:45 -0800 (Sat, 13 Nov 2004) $
 // File revision : $Revision: 4714 $
 //
 // $Id: AAFilter.h 4714 2004-11-13 22:29:45Z ijr $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/BPMDetect.h mythtv-0.20-new/libs/libmythsoundtouch/BPMDetect.h
--- mythtv-0.20-old/libs/libmythsoundtouch/BPMDetect.h	2006-05-23 10:40:36.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/BPMDetect.h	2007-04-17 10:23:33.000000000 -0700
@@ -26,7 +26,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-23 13:40:36 -0400 (Tue, 23 May 2006) $
+// Last changed  : $Date: 2006-05-23 10:40:36 -0700 (Tue, 23 May 2006) $
 // File revision : $Revision: 9996 $
 //
 // $Id: BPMDetect.h 9996 2006-05-23 17:40:36Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/cpu_detect.h mythtv-0.20-new/libs/libmythsoundtouch/cpu_detect.h
--- mythtv-0.20-old/libs/libmythsoundtouch/cpu_detect.h	2006-03-16 02:00:28.000000000 -0800
+++ mythtv-0.20-new/libs/libmythsoundtouch/cpu_detect.h	2007-04-17 10:23:33.000000000 -0700
@@ -12,7 +12,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-03-16 05:00:28 -0500 (Thu, 16 Mar 2006) $
+// Last changed  : $Date: 2006-03-16 02:00:28 -0800 (Thu, 16 Mar 2006) $
 // File revision : $Revision: 9376 $
 //
 // $Id: cpu_detect.h 9376 2006-03-16 10:00:28Z ijr $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/cpu_detect_x86_gcc.cpp mythtv-0.20-new/libs/libmythsoundtouch/cpu_detect_x86_gcc.cpp
--- mythtv-0.20-old/libs/libmythsoundtouch/cpu_detect_x86_gcc.cpp	2006-05-23 10:40:36.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/cpu_detect_x86_gcc.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -12,7 +12,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-23 13:40:36 -0400 (Tue, 23 May 2006) $
+// Last changed  : $Date: 2006-05-23 10:40:36 -0700 (Tue, 23 May 2006) $
 // File revision : $Revision: 9996 $
 //
 // $Id: cpu_detect_x86_gcc.cpp 9996 2006-05-23 17:40:36Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/FIFOSampleBuffer.cpp mythtv-0.20-new/libs/libmythsoundtouch/FIFOSampleBuffer.cpp
--- mythtv-0.20-old/libs/libmythsoundtouch/FIFOSampleBuffer.cpp	2006-05-23 10:40:36.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/FIFOSampleBuffer.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -15,7 +15,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-23 13:40:36 -0400 (Tue, 23 May 2006) $
+// Last changed  : $Date: 2006-05-23 10:40:36 -0700 (Tue, 23 May 2006) $
 // File revision : $Revision: 9996 $
 //
 // $Id: FIFOSampleBuffer.cpp 9996 2006-05-23 17:40:36Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/FIFOSampleBuffer.h mythtv-0.20-new/libs/libmythsoundtouch/FIFOSampleBuffer.h
--- mythtv-0.20-old/libs/libmythsoundtouch/FIFOSampleBuffer.h	2006-05-23 10:40:36.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/FIFOSampleBuffer.h	2007-04-17 10:23:33.000000000 -0700
@@ -15,7 +15,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-23 13:40:36 -0400 (Tue, 23 May 2006) $
+// Last changed  : $Date: 2006-05-23 10:40:36 -0700 (Tue, 23 May 2006) $
 // File revision : $Revision: 9996 $
 //
 // $Id: FIFOSampleBuffer.h 9996 2006-05-23 17:40:36Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/FIFOSamplePipe.h mythtv-0.20-new/libs/libmythsoundtouch/FIFOSamplePipe.h
--- mythtv-0.20-old/libs/libmythsoundtouch/FIFOSamplePipe.h	2005-05-23 13:39:12.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/FIFOSamplePipe.h	2007-04-17 10:23:33.000000000 -0700
@@ -17,7 +17,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2005-05-23 16:39:12 -0400 (Mon, 23 May 2005) $
+// Last changed  : $Date: 2005-05-23 13:39:12 -0700 (Mon, 23 May 2005) $
 // File revision : $Revision: 6468 $
 //
 // $Id: FIFOSamplePipe.h 6468 2005-05-23 20:39:12Z ijr $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/FIRFilter.cpp mythtv-0.20-new/libs/libmythsoundtouch/FIRFilter.cpp
--- mythtv-0.20-old/libs/libmythsoundtouch/FIRFilter.cpp	2006-03-31 22:19:12.000000000 -0800
+++ mythtv-0.20-new/libs/libmythsoundtouch/FIRFilter.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -11,7 +11,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-04-01 01:19:12 -0500 (Sat, 01 Apr 2006) $
+// Last changed  : $Date: 2006-03-31 22:19:12 -0800 (Fri, 31 Mar 2006) $
 // File revision : $Revision: 9588 $
 //
 // $Id: FIRFilter.cpp 9588 2006-04-01 06:19:12Z ijr $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/FIRFilter.h mythtv-0.20-new/libs/libmythsoundtouch/FIRFilter.h
--- mythtv-0.20-old/libs/libmythsoundtouch/FIRFilter.h	2004-11-13 14:29:45.000000000 -0800
+++ mythtv-0.20-new/libs/libmythsoundtouch/FIRFilter.h	2007-04-17 10:23:33.000000000 -0700
@@ -11,7 +11,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2004-11-13 17:29:45 -0500 (Sat, 13 Nov 2004) $
+// Last changed  : $Date: 2004-11-13 14:29:45 -0800 (Sat, 13 Nov 2004) $
 // File revision : $Revision: 4714 $
 //
 // $Id: FIRFilter.h 4714 2004-11-13 22:29:45Z ijr $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/mmx_gcc.cpp mythtv-0.20-new/libs/libmythsoundtouch/mmx_gcc.cpp
--- mythtv-0.20-old/libs/libmythsoundtouch/mmx_gcc.cpp	2006-05-23 12:14:24.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/mmx_gcc.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -15,7 +15,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-23 15:14:24 -0400 (Tue, 23 May 2006) $
+// Last changed  : $Date: 2006-05-23 12:14:24 -0700 (Tue, 23 May 2006) $
 // File revision : $Revision: 9998 $
 //
 // $Id: mmx_gcc.cpp 9998 2006-05-23 19:14:24Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/RateTransposer.cpp mythtv-0.20-new/libs/libmythsoundtouch/RateTransposer.cpp
--- mythtv-0.20-old/libs/libmythsoundtouch/RateTransposer.cpp	2006-05-23 12:14:24.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/RateTransposer.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -10,7 +10,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-23 15:14:24 -0400 (Tue, 23 May 2006) $
+// Last changed  : $Date: 2006-05-23 12:14:24 -0700 (Tue, 23 May 2006) $
 // File revision : $Revision: 9998 $
 //
 // $Id: RateTransposer.cpp 9998 2006-05-23 19:14:24Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/RateTransposer.h mythtv-0.20-new/libs/libmythsoundtouch/RateTransposer.h
--- mythtv-0.20-old/libs/libmythsoundtouch/RateTransposer.h	2004-11-13 14:29:45.000000000 -0800
+++ mythtv-0.20-new/libs/libmythsoundtouch/RateTransposer.h	2007-04-17 10:23:33.000000000 -0700
@@ -14,7 +14,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2004-11-13 17:29:45 -0500 (Sat, 13 Nov 2004) $
+// Last changed  : $Date: 2004-11-13 14:29:45 -0800 (Sat, 13 Nov 2004) $
 // File revision : $Revision: 4714 $
 //
 // $Id: RateTransposer.h 4714 2004-11-13 22:29:45Z ijr $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/SoundTouch.cpp mythtv-0.20-new/libs/libmythsoundtouch/SoundTouch.cpp
--- mythtv-0.20-old/libs/libmythsoundtouch/SoundTouch.cpp	2006-05-24 03:48:15.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/SoundTouch.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -41,7 +41,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-24 06:48:15 -0400 (Wed, 24 May 2006) $
+// Last changed  : $Date: 2006-05-24 03:48:15 -0700 (Wed, 24 May 2006) $
 // File revision : $Revision: 10003 $
 //
 // $Id: SoundTouch.cpp 10003 2006-05-24 10:48:15Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/SoundTouch.h mythtv-0.20-new/libs/libmythsoundtouch/SoundTouch.h
--- mythtv-0.20-old/libs/libmythsoundtouch/SoundTouch.h	2006-05-23 10:40:36.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/SoundTouch.h	2007-04-17 10:23:33.000000000 -0700
@@ -41,7 +41,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-23 13:40:36 -0400 (Tue, 23 May 2006) $
+// Last changed  : $Date: 2006-05-23 10:40:36 -0700 (Tue, 23 May 2006) $
 // File revision : $Revision: 9996 $
 //
 // $Id: SoundTouch.h 9996 2006-05-23 17:40:36Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/STTypes.h mythtv-0.20-new/libs/libmythsoundtouch/STTypes.h
--- mythtv-0.20-old/libs/libmythsoundtouch/STTypes.h	2006-05-24 07:56:37.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/STTypes.h	2007-04-17 10:23:33.000000000 -0700
@@ -8,7 +8,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-24 10:56:37 -0400 (Wed, 24 May 2006) $
+// Last changed  : $Date: 2006-05-24 07:56:37 -0700 (Wed, 24 May 2006) $
 // File revision : $Revision: 10005 $
 //
 // $Id: STTypes.h 10005 2006-05-24 14:56:37Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/TDStretch.cpp mythtv-0.20-new/libs/libmythsoundtouch/TDStretch.cpp
--- mythtv-0.20-old/libs/libmythsoundtouch/TDStretch.cpp	2006-05-23 12:14:24.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/TDStretch.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -13,7 +13,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-23 15:14:24 -0400 (Tue, 23 May 2006) $
+// Last changed  : $Date: 2006-05-23 12:14:24 -0700 (Tue, 23 May 2006) $
 // File revision : $Revision: 9998 $
 //
 // $Id: TDStretch.cpp 9998 2006-05-23 19:14:24Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythsoundtouch/TDStretch.h mythtv-0.20-new/libs/libmythsoundtouch/TDStretch.h
--- mythtv-0.20-old/libs/libmythsoundtouch/TDStretch.h	2006-05-23 12:14:24.000000000 -0700
+++ mythtv-0.20-new/libs/libmythsoundtouch/TDStretch.h	2007-04-17 10:23:33.000000000 -0700
@@ -13,7 +13,7 @@
 ///
 ////////////////////////////////////////////////////////////////////////////////
 //
-// Last changed  : $Date: 2006-05-23 15:14:24 -0400 (Tue, 23 May 2006) $
+// Last changed  : $Date: 2006-05-23 12:14:24 -0700 (Tue, 23 May 2006) $
 // File revision : $Revision: 9998 $
 //
 // $Id: TDStretch.h 9998 2006-05-23 19:14:24Z danielk $
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/avformatdecoder.cpp mythtv-0.20-new/libs/libmythtv/avformatdecoder.cpp
--- mythtv-0.20-old/libs/libmythtv/avformatdecoder.cpp	2006-09-03 20:50:52.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/avformatdecoder.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -464,9 +464,13 @@
 void AvFormatDecoder::SeekReset(long long newKey, uint skipFrames,
                                 bool doflush, bool discardFrames)
 {
-    if (ringBuffer->InDVDMenuOrStillFrame())
-        return;
-
+    if (ringBuffer->isDVD())
+    {
+        if (ringBuffer->InDVDMenuOrStillFrame() ||
+            newKey == 0) 
+            return;
+    }
+            
     VERBOSE(VB_PLAYBACK, LOC +
             QString("SeekReset(%1, %2, %3 flush, %4 discard)")
             .arg(newKey).arg(skipFrames)
@@ -931,23 +935,28 @@
     return fps;
 }
 
-void AvFormatDecoder::InitVideoCodec(AVStream *stream, AVCodecContext *enc)
+void AvFormatDecoder::InitVideoCodec(AVStream *stream, AVCodecContext *enc,
+                                     bool selectedStream)
 {
-    fps = normalized_fps(stream, enc);
-
     float aspect_ratio;
-    if (enc->sample_aspect_ratio.num == 0)
-        aspect_ratio = 0.0f;
-    else
-        aspect_ratio = av_q2d(enc->sample_aspect_ratio) *
-            enc->width / enc->height;
 
-    if (aspect_ratio <= 0.0f || aspect_ratio > 6.0f)
-        aspect_ratio = (float)enc->width / (float)enc->height;
+    if (selectedStream)
+    {
+        fps = normalized_fps(stream, enc);
+
+        if (enc->sample_aspect_ratio.num == 0)
+            aspect_ratio = 0.0f;
+        else
+            aspect_ratio = av_q2d(enc->sample_aspect_ratio) *
+                enc->width / enc->height;
+
+        if (aspect_ratio <= 0.0f || aspect_ratio > 6.0f)
+            aspect_ratio = (float)enc->width / (float)enc->height;
 
-    current_width = enc->width;
-    current_height = enc->height;
-    current_aspect = aspect_ratio;
+        current_width = enc->width;
+        current_height = enc->height;
+        current_aspect = aspect_ratio;
+    }
 
     enc->opaque = (void *)this;
     enc->get_buffer = avcodec_default_get_buffer;
@@ -965,7 +974,8 @@
 
     AVCodec *codec = avcodec_find_decoder(enc->codec_id);    
 
-    if (!gContext->GetNumSetting("DecodeExtraAudio", 0) &&
+    if (selectedStream &&
+        !gContext->GetNumSetting("DecodeExtraAudio", 0) &&
         codec->id != CODEC_ID_MPEG2VIDEO_XVMC           &&
         codec->id != CODEC_ID_MPEG2VIDEO_XVMC_VLD)
     {
@@ -981,7 +991,8 @@
         enc->draw_horiz_band = render_slice_xvmc;
         enc->slice_flags = SLICE_FLAG_CODED_ORDER |
             SLICE_FLAG_ALLOW_FIELD;
-        directrendering = true;
+        if (selectedStream)
+            directrendering = true;
     }
     else if (codec && codec->capabilities & CODEC_CAP_DR1 &&
              !(enc->width % 16))
@@ -990,26 +1001,30 @@
         enc->get_buffer = get_avf_buffer;
         enc->release_buffer = release_avf_buffer;
         enc->draw_horiz_band = NULL;
-        directrendering = true;
+        if (selectedStream)
+            directrendering = true;
     }
 
-    uint align_width  = enc->width;
-    uint align_height = enc->height;
+    if (selectedStream)
+    {
+        uint align_width  = enc->width;
+        uint align_height = enc->height;
 
-    align_dimensions(enc, align_width, align_height);
+        align_dimensions(enc, align_width, align_height);
 
-    if (align_width == 0 && align_height == 0)
-    {
-        VERBOSE(VB_PLAYBACK, LOC + "InitVideoCodec "
-                "failed to align dimensions, resetting decoder.");
-        align_width = 640;
-        align_height = 480;
-        fps = 29.97;
-        aspect_ratio = 4.0 / 3;
-    }
+        if (align_width == 0 && align_height == 0)
+        {
+            VERBOSE(VB_PLAYBACK, LOC + "InitVideoCodec "
+                    "failed to align dimensions, resetting decoder.");
+            align_width = 640;
+            align_height = 480;
+            fps = 29.97;
+            aspect_ratio = 4.0 / 3;
+        }
 
-    GetNVP()->SetVideoParams(align_width, align_height, fps,
-                             keyframedist, aspect_ratio, kScan_Detect);
+        GetNVP()->SetVideoParams(align_width, align_height, fps,
+                                 keyframedist, aspect_ratio, kScan_Detect);
+    }
 }
 
 #ifdef USING_XVMC
@@ -1325,7 +1340,7 @@
                             <<") type ("<<codec_type_string(enc->codec_type)
                             <<") already open.");
                 }
-                InitVideoCodec(ic->streams[i], enc);
+
                 // Only use libmpeg2 when not using XvMC
                 if (CODEC_ID_MPEG1VIDEO == enc->codec_id ||
                     CODEC_ID_MPEG2VIDEO == enc->codec_id)
@@ -1336,14 +1351,14 @@
                 enc->decode_cc_dvd  = decode_cc_dvd;
 
                 // Set the default stream to the stream
-                // with the lowest component tag.
-                if (selectedVideoIndex < 0 ||
-                    ic->streams[i]->component_tag <
-                    ic->streams[selectedVideoIndex]->component_tag)
+                // that is found first in the PMT
+                if (selectedVideoIndex < 0)
                 {
                     selectedVideoIndex = i;
                 }
 
+                InitVideoCodec(ic->streams[i], enc, selectedVideoIndex == i);
+
                 ScanATSCCaptionStreams(i);
 
                 break;
@@ -1497,20 +1512,22 @@
                 trackNo = GetTrackCount(kTrackTypeAudio) - 1;
             SetTrack(kTrackTypeAudio, trackNo);
         }
-        if (tracks[kTrackTypeSubtitle].size() > 1)
+        if (tracks[kTrackTypeSubtitle].size() > 0)
         {
             qBubbleSort(tracks[kTrackTypeSubtitle]);
             int trackNo = ringBuffer->DVD()->GetTrack(kTrackTypeSubtitle);
             uint captionmode = GetNVP()->GetCaptionMode();
-            if (captionmode == kDisplayAVSubtitle) {
-                if (trackNo < 0 || trackNo >= (int)GetTrackCount(kTrackTypeSubtitle))
-                {
-                    GetNVP()->SetCaptionsEnabled(false, false);
-                }
-                else
+            if (captionmode == kDisplayAVSubtitle &&
+                (trackNo < 0 || trackNo >= (int)GetTrackCount(kTrackTypeSubtitle)))
+            {
+                GetNVP()->SetCaptionsEnabled(false, false);
+            }
+            else
+            {
+                if (!ringBuffer->InDVDMenuOrStillFrame() && trackNo >= 0)
                 {
-                    if (!ringBuffer->InDVDMenuOrStillFrame() && trackNo >= 0)
-                        GetNVP()->SetCaptionsEnabled(true, false);
+                    SetTrack(kTrackTypeSubtitle, trackNo);
+                    GetNVP()->SetCaptionsEnabled(true, false);
                 }
             }
         }
@@ -3406,3 +3423,5 @@
 
     return fsize;
 }
+
+/* vim: set expandtab tabstop=4 shiftwidth=4: */
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/avformatdecoder.h mythtv-0.20-new/libs/libmythtv/avformatdecoder.h
--- mythtv-0.20-old/libs/libmythtv/avformatdecoder.h	2006-08-23 12:13:05.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/avformatdecoder.h	2007-04-17 10:23:33.000000000 -0700
@@ -168,7 +168,8 @@
 
     void DecodeDTVCC(const uint8_t *buf);
     void InitByteContext(void);
-    void InitVideoCodec(AVStream *stream, AVCodecContext *enc);
+    void InitVideoCodec(AVStream *stream, AVCodecContext *enc,
+                        bool selectedStream = false);
 
     /// Preprocess a packet, setting the video parms if nessesary.
     void MpegPreProcessPkt(AVStream *stream, AVPacket *pkt);
@@ -256,3 +257,5 @@
 };
 
 #endif
+
+/* vim: set expandtab tabstop=4 shiftwidth=4: */
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/cardutil.cpp mythtv-0.20-new/libs/libmythtv/cardutil.cpp
--- mythtv-0.20-old/libs/libmythtv/cardutil.cpp	2006-07-18 05:35:04.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/cardutil.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -735,6 +735,7 @@
 {
     int rcardid = (parentid) ? parentid : cardid;
     QStringList inputs;
+    bool is_dtv = !IsEncoder(cardtype) && !IsUnscanable(cardtype);
 
     if (("FIREWIRE"  == cardtype) ||
         ("FREEBOX"   == cardtype) ||
@@ -753,7 +754,7 @@
     QStringList::iterator it = inputs.begin();
     for (; it != inputs.end(); ++it)
     {
-        CardInput* cardinput = new CardInput(false, cardid);
+        CardInput* cardinput = new CardInput(is_dtv, false, cardid);
         cardinput->loadByInput(rcardid, (*it));
         cardinput->SetChildCardID((parentid) ? cardid : 0);
         inputLabels.push_back(
@@ -774,7 +775,7 @@
         InputNames::const_iterator it;
         for (it = list.begin(); it != list.end(); ++it)
         {
-            CardInput *cardinput = new CardInput(true, rcardid);
+            CardInput *cardinput = new CardInput(is_dtv, true, rcardid);
             cardinput->loadByInput(rcardid, *it);
             cardinput->SetChildCardID(parentid ? cardid : 0);
             inputLabels.push_back(
@@ -786,7 +787,7 @@
         // plus add one "new" input
         if (needs_conf)
         {
-            CardInput *newcard = new CardInput(true, rcardid);
+            CardInput *newcard = new CardInput(is_dtv, true, rcardid);
             QString newname = QString("DVBInput #%1").arg(list.size() + 1);
             newcard->loadByInput(rcardid, newname);
             newcard->SetChildCardID((parentid) ? cardid : 0);
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/channeleditor.cpp mythtv-0.20-new/libs/libmythtv/channeleditor.cpp
--- mythtv-0.20-old/libs/libmythtv/channeleditor.cpp	2006-04-07 12:14:30.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/channeleditor.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -303,17 +303,46 @@
         return;
 
     MSqlQuery query(MSqlQuery::InitCon());
-    if ((currentSourceID == "") || (currentSourceID == "Unassigned"))
+    if (currentSourceID.isEmpty())
     {
         query.prepare("TRUNCATE TABLE channel");
     }
+    else if (currentSourceID == "Unassigned")
+    {
+        query.prepare("SELECT sourceid "
+                      "FROM videosource "
+                      "GROUP BY sourceid");
+
+        if (!query.exec() || !query.isActive())
+        {
+            MythContext::DBError("ChannelEditor Delete Channels", query);
+            return;
+        }
+
+        QString tmp = "";
+        while (query.next())
+            tmp += "'" + query.value(0).toString() + "',";
+
+        if (tmp.isEmpty())
+        {
+            query.prepare("TRUNCATE TABLE channel");
+        }
+        else
+        {
+            tmp = tmp.left(tmp.length() - 1);
+            query.prepare(QString("DELETE FROM channel "
+                                  "WHERE sourceid NOT IN (%1)").arg(tmp));
+        }
+    }
     else
     {
         query.prepare("DELETE FROM channel "
                       "WHERE sourceid = :SOURCEID");
         query.bindValue(":SOURCEID", currentSourceID);
     }
-    query.exec();
+
+    if (!query.exec())
+        MythContext::DBError("ChannelEditor Delete Channels", query);
 
     list->fillSelections();
 }
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/channelutil.cpp mythtv-0.20-new/libs/libmythtv/channelutil.cpp
--- mythtv-0.20-old/libs/libmythtv/channelutil.cpp	2006-08-23 17:52:42.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/channelutil.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -1435,64 +1435,43 @@
     if (it == sorted.end())
         return 0; // no channels..
 
+    DBChanList::const_iterator start = it;
     bool skip_non_visible = true; // TODO make DB selectable
-    if (skip_non_visible)
+
+    if (CHANNEL_DIRECTION_DOWN == direction)
     {
-        DBChanList::const_iterator start = it;
-        if (CHANNEL_DIRECTION_DOWN == direction)
-        {
-            do
-            {
-                if (it == sorted.begin())
-                {
-                    it = find(sorted.begin(), sorted.end(),
-                              sorted.rbegin()->chanid);
-                }
-                else
-                {
-                    it--;
-                }
-            } while ((it != start) && !it->visible);
-        }
-        else if (CHANNEL_DIRECTION_UP == direction)
+        do
         {
-            do
-            {
-                it++;
-                it = (it == sorted.end()) ? sorted.begin() : it;
-            } while ((it != start) && !it->visible);
-        }
-    }
-    else if (CHANNEL_DIRECTION_DOWN == direction)
-    {
-        if (it == sorted.begin())
-            return sorted.rbegin()->chanid;
-        it--;
+            if (it == sorted.begin())
+                it = find(sorted.begin(), sorted.end(),
+                          sorted.rbegin()->chanid);
+            else
+                it--;
+        } while ((it != start) && skip_non_visible && !it->visible);
+
     }
     else if (CHANNEL_DIRECTION_UP == direction)
     {
-        it++;
-        it = (it == sorted.end()) ? sorted.begin() : it;
+        do
+        {
+            it++;
+            if (it == sorted.end())
+                it = sorted.begin();
+        } while ((it != start) && skip_non_visible && !it->visible);
     }
     else if (CHANNEL_DIRECTION_FAVORITE == direction)
     {
-        DBChanList::const_iterator it_orig = it;
-        for (;;++it)
+        do
         {
-            it = (it == sorted.end()) ? sorted.begin() : it;
+            it++;
+            if (it == sorted.end())
+                it = sorted.begin();
 
-            if (it == it_orig)
-            {
-                if (!it->favorite)
-                    ++it;
-                it = (it == sorted.end()) ? sorted.begin() : it;
-                break; // no (other?) favorites
-            }
-
-            if (it->favorite)
-                break; // found next favorite
-        }
+        } while ((it != start) &&
+                 (!it->favorite || (skip_non_visible && !it->visible)));
     }
 
     return it->chanid;
 }
+
+/* vim: set expandtab tabstop=4 shiftwidth=4: */
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dbcheck.cpp mythtv-0.20-new/libs/libmythtv/dbcheck.cpp
--- mythtv-0.20-old/libs/libmythtv/dbcheck.cpp	2006-09-10 21:35:19.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/dbcheck.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -10,7 +10,7 @@
 #include "mythdbcon.h"
 
 /// This is the DB schema version expected by the running MythTV instance.
-const QString currentDatabaseVersion = "1158";
+const QString currentDatabaseVersion = "1160";
 
 static bool UpdateDBVersionNumber(const QString &newnumber);
 static bool performActualUpdate(const QString updates[], QString version,
@@ -2510,6 +2510,41 @@
             return false;
     }
 
+    if (dbver == "1158")
+    {
+        const QString updates[] = {
+"ALTER TABLE recorded ADD COLUMN watched TINYINT NOT NULL DEFAULT '0';",
+""
+};
+
+        if (!performActualUpdate(updates, "1159", dbver))
+            return false;
+    }
+
+    if (dbver == "1159")
+    {
+        MSqlQuery query(MSqlQuery::InitCon());
+        query.prepare("SELECT DISTINCT chanid, starttime FROM recordedmarkup "
+                      "WHERE type = 1;");
+        if (query.exec() && query.isActive() && query.size() > 0)
+        {
+            MSqlQuery fixup(MSqlQuery::InitCon());
+            while (query.next())
+            {
+                fixup.prepare(
+                       "UPDATE recorded SET cutlist = 1 "
+                       "WHERE chanid = :CHANID AND starttime =  :STARTTIME;");
+                fixup.bindValue(":CHANID", query.value(0).toString());
+                fixup.bindValue(":STARTTIME", query.value(1).toDateTime());
+
+                fixup.exec();
+            }
+        }
+
+        const QString updates[] = { "" };
+        if (!performActualUpdate(updates, "1160", dbver))
+            return false;
+    }
 
 //"ALTER TABLE capturecard DROP COLUMN dvb_recordts;" in 0.21
 //"ALTER TABLE capturecard DROP COLUMN dvb_hw_decoder;" in 0.21
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/diseqc.cpp mythtv-0.20-new/libs/libmythtv/diseqc.cpp
--- mythtv-0.20-old/libs/libmythtv/diseqc.cpp	2006-08-08 08:48:57.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/diseqc.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -450,7 +450,7 @@
     ApplyVoltage(settings, tuning);
 
     // turn off tone burst first if commands need to be sent
-    if (m_root->IsCommandNeeded(settings))
+    if (m_root->IsCommandNeeded(settings, tuning))
     {
         SetTone(false);
         usleep(DISEQC_SHORT_WAIT);
@@ -969,41 +969,40 @@
     if (pos < 0)
         return false;
 
-    // determine if switch command needs to be sent based on last pos
-    if ((m_last_pos == (uint)pos) && m_children[pos])
-        return m_children[pos]->Execute(settings, tuning);
-
     // perform switching
-    switch (m_type)
+    if (ShouldSwitch(settings, tuning))
     {
-        case kTypeTone:
-            success = ExecuteTone(settings, tuning, pos);
-            break;
-        case kTypeDiSEqCCommitted:
-        case kTypeDiSEqCUncommitted:
-            success = ExecuteDiseqc(settings, tuning, pos);
-            break;
-        case kTypeLegacySW21:
-        case kTypeLegacySW42:
-        case kTypeLegacySW64:
-            success = ExecuteLegacy(settings, tuning, pos);
-            break;
-        default:
-            success = false;
-            VERBOSE(VB_IMPORTANT, LOC_ERR +
-                    QString("Unknown switch type (%1)")
-                    .arg((uint)m_type));
-            break;
-    }
+        switch (m_type)
+        {
+            case kTypeTone:
+                success = ExecuteTone(settings, tuning, pos);
+                break;
+            case kTypeDiSEqCCommitted:
+            case kTypeDiSEqCUncommitted:
+                success = ExecuteDiseqc(settings, tuning, pos);
+                break;
+            case kTypeLegacySW21:
+            case kTypeLegacySW42:
+            case kTypeLegacySW64:
+                success = ExecuteLegacy(settings, tuning, pos);
+                break;
+            default:
+                success = false;
+                VERBOSE(VB_IMPORTANT, LOC_ERR +
+                        QString("Unknown switch type (%1)")
+                        .arg((uint)m_type));
+                break;
+        }
 
-    // if a child device will be sending a diseqc command, wait 100ms
-    if (m_children[pos]->IsCommandNeeded(settings))
-    {
-        VERBOSE(VB_CHANNEL, LOC + "Waiting for switch");
-        usleep(DISEQC_LONG_WAIT);
-    }
+        // if a child device will be sending a diseqc command, wait 100ms
+        if (m_children[pos]->IsCommandNeeded(settings, tuning))
+        {
+            VERBOSE(VB_CHANNEL, LOC + "Waiting for switch");
+            usleep(DISEQC_LONG_WAIT);
+        }
 
-    m_last_pos = pos;
+        m_last_pos = pos;
+    }
 
     // chain to child if the switch was successful
     if (success)
@@ -1015,6 +1014,8 @@
 void DiSEqCDevSwitch::Reset(void)
 {
     m_last_pos = (uint) -1;
+    m_last_high_band = (uint) -1;
+    m_last_horizontal = (uint) -1;
     dvbdev_vec_t::iterator it = m_children.begin();
     for (; it != m_children.end(); ++it)
     {
@@ -1023,19 +1024,15 @@
     }
 }
 
-bool DiSEqCDevSwitch::IsCommandNeeded(const DiSEqCDevSettings &settings) const
+bool DiSEqCDevSwitch::IsCommandNeeded(const DiSEqCDevSettings &settings,
+                                      const DVBTuning         &tuning) const
 {
-    // sanity check switch position
     int pos = GetPosition(settings);
     if (pos < 0)
         return false;
 
-    // if position is changing, a command is definitely needed
-    if ((uint)pos != m_last_pos)
-        return true;
-
-    // otherwise, the child that will be selected may need a command
-    return m_children[pos]->IsCommandNeeded(settings);
+    return (ShouldSwitch(settings, tuning) ||
+            m_children[pos]->IsCommandNeeded(settings, tuning));
 }
 
 DiSEqCDevDevice *DiSEqCDevSwitch::GetSelectedChild(const DiSEqCDevSettings &settings) const
@@ -1106,7 +1103,7 @@
     // populate switch parameters from db
     MSqlQuery query(MSqlQuery::InitCon());
     query.prepare(
-        "SELECT subtype, switch_ports "
+        "SELECT subtype, switch_ports, cmd_repeat "
         "FROM diseqc_tree "
         "WHERE diseqcid = :DEVID");
     query.bindValue(":DEVID", GetDeviceID());
@@ -1120,6 +1117,7 @@
     {
         m_type = SwitchTypeFromString(query.value(0).toString());
         m_num_ports = query.value(1).toUInt();
+        m_repeat = query.value(2).toUInt();
         m_children.resize(m_num_ports);
         for (uint i = 0; i < m_num_ports; i++)
             m_children[i] = NULL;
@@ -1169,7 +1167,8 @@
             "    type         = 'switch', "
             "    description  = :DESC, "
             "    subtype      = :TYPE, "
-            "    switch_ports = :PORTS "
+            "    switch_ports = :PORTS, "
+            "    cmd_repeat   = :REPEAT "
             "WHERE diseqcid = :DEVID");
     }
     else
@@ -1177,10 +1176,12 @@
         query.prepare(
             "INSERT INTO diseqc_tree"
             " ( parentid,      ordinal,         type, "
-            "   description,   subtype,         switch_ports) "
+            "   description,   subtype,         switch_ports, "
+            "   cmd_repeat )"
             "VALUES "
             " (:PARENT,       :ORDINAL,         'switch', "
-            "  :DESC,         :TYPE,            :PORTS)");
+            "  :DESC,         :TYPE,            :PORTS, "
+            "  :REPEAT )");
     }
 
     if (m_parent)
@@ -1190,6 +1191,7 @@
     query.bindValue(":DESC",    GetDescription());
     query.bindValue(":TYPE",    type);
     query.bindValue(":PORTS",   m_num_ports);
+    query.bindValue(":REPEAT",  m_repeat);
     query.bindValue(":DEVID",   GetDeviceID());
 
     if (!query.exec())
@@ -1348,6 +1350,46 @@
     return false;
 }
 
+bool DiSEqCDevSwitch::ShouldSwitch(const DiSEqCDevSettings &settings,
+                                   const DVBTuning &tuning) const
+{
+    int pos = GetPosition(settings);
+    if (pos < 0)
+        return false;
+
+    // committed switch should change for band and polarity as well
+    if (kTypeDiSEqCCommitted == m_type)
+    {
+        // retrieve LNB info
+        bool high_band  = false;
+        bool horizontal = false;
+        DiSEqCDevLNB *lnb  = m_tree.FindLNB(settings);
+        if (lnb)
+        {
+            high_band   = lnb->IsHighBand(tuning);
+            horizontal  = lnb->IsHorizontal(tuning);
+        }
+
+        if(high_band != m_last_high_band ||
+           horizontal != m_last_horizontal)
+            return true;
+    }
+    else if (kTypeLegacySW42 == m_type ||
+             kTypeLegacySW64 == m_type)
+    {
+        // retrieve LNB info
+        bool horizontal = false;
+        DiSEqCDevLNB *lnb  = m_tree.FindLNB(settings);
+        if (lnb)
+            horizontal  = lnb->IsHorizontal(tuning);
+
+        if (horizontal != m_last_horizontal)
+            return true;
+    }
+
+    return m_last_pos != (uint)pos;
+}
+
 bool DiSEqCDevSwitch::ExecuteDiseqc(const DiSEqCDevSettings &settings,
                                     const DVBTuning &tuning,
                                     uint pos)
@@ -1385,7 +1427,13 @@
     VERBOSE(VB_CHANNEL, LOC + "Changing to DiSEqC switch port " +
             QString("%1/%2").arg(pos + 1).arg(m_num_ports));
 
-    return m_tree.SendCommand(DISEQC_ADR_SW_ALL, cmd, m_repeat, 1, &data);
+    bool ret = m_tree.SendCommand(DISEQC_ADR_SW_ALL, cmd, m_repeat, 1, &data);
+    if(ret)
+    {
+        m_last_high_band = high_band;
+        m_last_horizontal = horizontal;
+    }
+    return ret;
 }
 
 int DiSEqCDevSwitch::GetPosition(const DiSEqCDevSettings &settings) const
@@ -1490,7 +1538,8 @@
         m_child->Reset();
 }
 
-bool DiSEqCDevRotor::IsCommandNeeded(const DiSEqCDevSettings &settings) const
+bool DiSEqCDevRotor::IsCommandNeeded(const DiSEqCDevSettings &settings,
+                                     const DVBTuning         &tuning) const
 {
     double position = settings.GetValue(GetDeviceID());
 
@@ -1498,7 +1547,7 @@
         return true;
 
     if (m_child)
-        return m_child->IsCommandNeeded(settings);
+        return m_child->IsCommandNeeded(settings, tuning);
 
     return false;
 }
@@ -1528,15 +1577,20 @@
     return true;
 }
 
-uint DiSEqCDevRotor::GetVoltage(const DiSEqCDevSettings &settings,
-                                const DVBTuning         &tuning) const
+bool DiSEqCDevRotor::IsMoving(const DiSEqCDevSettings &settings) const
 {
     double position = settings.GetValue(GetDeviceID());
     double completed = GetProgress();
     bool   moving   = (completed < 1.0) || (position != m_last_position);
 
+    return (m_last_pos_known && moving);
+}
+
+uint DiSEqCDevRotor::GetVoltage(const DiSEqCDevSettings &settings,
+                                const DVBTuning         &tuning) const
+{
     // override voltage if the last position is known and the rotor is moving
-    if (m_last_pos_known && moving)
+    if (IsMoving(settings))
     {
         VERBOSE(VB_CHANNEL, LOC +
                 "Overriding voltage to 18V for faster rotor movement");
@@ -1555,7 +1609,8 @@
     MSqlQuery query(MSqlQuery::InitCon());
     query.prepare(
         "SELECT subtype,         rotor_positions, "
-        "       rotor_hi_speed,  rotor_lo_speed "
+        "       rotor_hi_speed,  rotor_lo_speed, "
+        "       cmd_repeat "
         "FROM diseqc_tree "
         "WHERE diseqcid = :DEVID");
     query.bindValue(":DEVID", GetDeviceID());
@@ -1570,6 +1625,7 @@
         m_type     = RotorTypeFromString(query.value(0).toString());
         m_speed_hi = query.value(2).toDouble();
         m_speed_lo = query.value(3).toDouble();
+        m_repeat   = query.value(4).toUInt();
 
         // form of "angle1=index1:angle2=index2:..."
         QString positions = query.value(1).toString();
@@ -1639,7 +1695,8 @@
             "    subtype         = :TYPE,    "
             "    rotor_hi_speed  = :HISPEED, "
             "    rotor_lo_speed  = :LOSPEED, "
-            "    rotor_positions = :POSMAP   "
+            "    rotor_positions = :POSMAP,  "
+            "    cmd_repeat      = :REPEAT   "
             "WHERE diseqcid = :DEVID");
     }
     else
@@ -1648,11 +1705,11 @@
             "INSERT INTO diseqc_tree "
             " ( parentid,       ordinal,         type,   "
             "   description,    subtype,         rotor_hi_speed, "
-            "   rotor_lo_speed, rotor_positions ) "
+            "   rotor_lo_speed, rotor_positions, cmd_repeat ) "
             "VALUES "
             " (:PARENT,         :ORDINAL,        'rotor',  "
             "  :DESC,           :TYPE,           :HISPEED, "
-            "  :LOSPEED,        :POSMAP )");
+            "  :LOSPEED,        :POSMAP,         :REPEAT )");
     }
 
     if (m_parent)
@@ -1664,6 +1721,7 @@
     query.bindValue(":HISPEED", m_speed_hi);
     query.bindValue(":LOSPEED", m_speed_lo);
     query.bindValue(":POSMAP",  posmap);
+    query.bindValue(":REPEAT",  m_repeat);
     query.bindValue(":DEVID",   GetDeviceID());
 
     if (!query.exec())
@@ -1883,7 +1941,8 @@
     MSqlQuery query(MSqlQuery::InitCon());
     query.prepare(
         "SELECT subtype,         lnb_lof_switch, "
-        "       lnb_lof_hi,      lnb_lof_lo "
+        "       lnb_lof_hi,      lnb_lof_lo, "
+        "       cmd_repeat "
         "FROM diseqc_tree "
         "WHERE diseqcid = :DEVID");
     query.bindValue(":DEVID", GetDeviceID());
@@ -1899,6 +1958,7 @@
         m_lof_switch = query.value(1).toInt();
         m_lof_hi     = query.value(2).toInt();
         m_lof_lo     = query.value(3).toInt();
+        m_repeat     = query.value(4).toUInt();
     }
 
     return true;
@@ -1921,7 +1981,8 @@
             "    subtype         = :TYPE,    "
             "    lnb_lof_switch  = :LOFSW,   "
             "    lnb_lof_lo      = :LOFLO,   "
-            "    lnb_lof_hi      = :LOFHI    "
+            "    lnb_lof_hi      = :LOFHI,   "
+            "    cmd_repeat      = :REPEAT   "
             "WHERE diseqcid = :DEVID");
     }
     else
@@ -1930,11 +1991,11 @@
             "INSERT INTO diseqc_tree"
             " ( parentid,      ordinal,         type, "
             "   description,   subtype,         lnb_lof_switch, "
-            "   lnb_lof_lo,    lnb_lof_hi ) "
+            "   lnb_lof_lo,    lnb_lof_hi,      cmd_repeat ) "
             "VALUES "
             " (:PARENT,       :ORDINAL,         'lnb', "
             "  :DESC,         :TYPE,            :LOFSW, "
-            "  :LOFLO,        :LOFHI ) ");
+            "  :LOFLO,        :LOFHI,           :REPEAT ) ");
     }
 
     if (m_parent)
@@ -1946,6 +2007,7 @@
     query.bindValue(":LOFSW",   m_lof_switch);
     query.bindValue(":LOFLO",   m_lof_lo);
     query.bindValue(":LOFHI",   m_lof_hi);
+    query.bindValue(":REPEAT",  m_repeat);
     query.bindValue(":DEVID",   GetDeviceID());
 
     // update dev_id
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/diseqc.h mythtv-0.20-new/libs/libmythtv/diseqc.h
--- mythtv-0.20-old/libs/libmythtv/diseqc.h	2006-07-18 09:18:43.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/diseqc.h	2007-04-17 10:23:32.000000000 -0700
@@ -147,6 +147,7 @@
     void SetParent(DiSEqCDevDevice* parent)  { m_parent   = parent;  }
     void SetOrdinal(uint ordinal)            { m_ordinal  = ordinal; }
     void SetDescription(const QString &desc) { m_desc     = desc;    }
+    void SetRepeatCount(uint repeat)         { m_repeat   = repeat;  }
     virtual bool SetChild(uint, DiSEqCDevDevice*){return false;      }
 
     // Gets
@@ -157,9 +158,11 @@
     DiSEqCDevDevice *GetParent(void)   const { return m_parent;      }
     uint          GetOrdinal(void)     const { return m_ordinal;     }
     QString       GetDescription(void) const { return m_desc;        }
+    uint          GetRepeatCount(void) const { return m_repeat;      }
     virtual uint  GetChildCount(void)  const { return 0;             }
     virtual bool  IsCommandNeeded(
-        const DiSEqCDevSettings&)      const { return false;         }
+        const DiSEqCDevSettings&, const DVBTuning&)
+                                       const { return false;         }
     virtual uint  GetVoltage(
         const DiSEqCDevSettings&, const DVBTuning&) const = 0;
 
@@ -230,8 +233,11 @@
     // Gets
     dvbdev_switch_t GetType(void)       const { return m_type;      }
     uint            GetNumPorts(void)   const { return m_num_ports; }
+    bool            ShouldSwitch(const DiSEqCDevSettings &settings,
+                                 const DVBTuning &tuning) const;
     virtual uint    GetChildCount(void) const;
-    virtual bool    IsCommandNeeded(const DiSEqCDevSettings&) const;
+    virtual bool    IsCommandNeeded(const DiSEqCDevSettings&,
+                                    const DVBTuning&) const;
     virtual uint    GetVoltage(const DiSEqCDevSettings&,
                                const DVBTuning&) const;
 
@@ -257,6 +263,8 @@
     dvbdev_switch_t m_type;
     uint            m_num_ports;
     uint            m_last_pos;
+    uint            m_last_high_band;
+    uint            m_last_horizontal;
     dvbdev_vec_t    m_children;
 
     static const TypeTable SwitchTypeTable[7];
@@ -291,7 +299,9 @@
     double         GetProgress(void)     const;
     bool           IsPositionKnown(void) const;
     virtual uint   GetChildCount(void)   const { return 1;           }
-    virtual bool   IsCommandNeeded(const DiSEqCDevSettings&) const;
+    virtual bool   IsCommandNeeded(const DiSEqCDevSettings&,
+                                   const DVBTuning&) const;
+    bool           IsMoving(const DiSEqCDevSettings&) const;
     virtual uint   GetVoltage(const DiSEqCDevSettings&,
                               const DVBTuning&) const;
 
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/diseqcsettings.cpp mythtv-0.20-new/libs/libmythtv/diseqcsettings.cpp
--- mythtv-0.20-old/libs/libmythtv/diseqcsettings.cpp	2006-08-11 08:20:51.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/diseqcsettings.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -96,6 +96,36 @@
     DiSEqCDevDevice &m_device;
 };
 
+
+//////////////////////////////////////// DeviceRepeatSetting
+
+class DeviceRepeatSetting : public SpinBoxSetting
+{
+  public:
+    DeviceRepeatSetting(DiSEqCDevDevice &device) :
+        SpinBoxSetting(1, 5, 1), m_device(device)
+    {
+        setLabel(DeviceTree::tr("Repeat Count"));
+        QString help = DeviceTree::tr(
+            "Number of times to repeat DiSEqC commands sent to this device. "
+            "Larger values may help with less reliable devices.");
+        setHelpText(help);
+    }
+
+    virtual void load(void)
+    {
+        setValue(m_device.GetRepeatCount());
+    }
+
+    virtual void save(void)
+    {
+        m_device.SetRepeatCount(getValue().toUInt());
+    }
+
+  private:
+    DiSEqCDevDevice &m_device;
+};
+
 //////////////////////////////////////// SwitchTypeSetting
 
 class SwitchTypeSetting : public ComboBoxSetting
@@ -171,6 +201,7 @@
     group->setLabel(DeviceTree::tr("Switch Configuration"));
 
     group->addChild(new DeviceDescrSetting(switch_dev));
+    group->addChild(new DeviceRepeatSetting(switch_dev));
     m_type = new SwitchTypeSetting(switch_dev);
     group->addChild(m_type);
     m_ports = new SwitchPortsSetting(switch_dev);
@@ -408,6 +439,7 @@
     group->setLabel(DeviceTree::tr("Rotor Configuration"));
 
     group->addChild(new DeviceDescrSetting(rotor));
+    group->addChild(new DeviceRepeatSetting(rotor));
 
     ConfigurationGroup *tgroup =
         new HorizontalConfigurationGroup(false, false, true, true);
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dtvconfparserhelpers.cpp mythtv-0.20-new/libs/libmythtv/dtvconfparserhelpers.cpp
--- mythtv-0.20-old/libs/libmythtv/dtvconfparserhelpers.cpp	1969-12-31 16:00:00.000000000 -0800
+++ mythtv-0.20-new/libs/libmythtv/dtvconfparserhelpers.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -0,0 +1,351 @@
+#include "mythcontext.h"
+#include "dtvconfparserhelpers.h"
+
+bool DTVParamHelper::ParseParam(const QString &symbol, int &value,
+                                const DTVParamHelperStruct *table)
+{
+    const DTVParamHelperStruct *p = table;
+
+    while (p->symbol != NULL)
+    {
+        if (p->symbol == symbol.left(p->symbol.length()))
+        {
+            //symbol = symbol.mid(p->symbol.length());
+            value = p->value;
+            return true;
+        }
+        p++;
+    }
+
+    return false;
+}
+
+QString DTVParamHelper::toString(const char *strings[], int index,
+                                 uint strings_size)
+{
+    if ((index < 0) || ((uint)index >= strings_size))
+    {
+        VERBOSE(VB_IMPORTANT,
+                "DTVParamHelper::toString() index out of bounds");
+
+        return QString::null;
+    }
+
+    return strings[index];
+}
+
+const DTVParamHelperStruct DTVInversion::confTable[] =
+{
+   { "INVERSION_AUTO", kInversionAuto },
+   { "INVERSION_OFF",  kInversionOff  },
+   { "INVERSION_ON",   kInversionOn   },
+   { NULL,             kInversionAuto },
+};
+
+const DTVParamHelperStruct DTVInversion::vdrTable[] =
+{
+   { "999", kInversionAuto },
+   { "0",   kInversionOff  },
+   { "1",   kInversionOn   },
+   { NULL,  kInversionAuto },
+};
+
+const DTVParamHelperStruct DTVInversion::parseTable[] =
+{
+   { "a",  kInversionAuto },
+   { "0",  kInversionOff  },
+   { "1",  kInversionOn   },
+   { NULL, kInversionAuto },
+};
+
+const char *DTVInversion::dbStr[DTVInversion::kDBStrCnt] =
+{
+    "0", ///< kInversionOff
+    "1", ///< kInversionOn
+    "a"  ///< kInversionAuto
+};
+
+const DTVParamHelperStruct DTVBandwidth::confTable[] =
+{
+   { "BANDWIDTH_AUTO",  kBandwidthAuto },
+   { "BANDWIDTH_8_MHZ", kBandwidth8Mhz },
+   { "BANDWIDTH_7_MHZ", kBandwidth7Mhz },
+   { "BANDWIDTH_6_MHZ", kBandwidth6Mhz },
+   { NULL,              kBandwidthAuto },
+};
+
+const DTVParamHelperStruct DTVBandwidth::vdrTable[] =
+{
+   { "999", kBandwidthAuto },
+   { "8",   kBandwidth8Mhz },
+   { "7",   kBandwidth7Mhz },
+   { "6",   kBandwidth6Mhz },
+   { NULL,  kBandwidthAuto },
+};
+
+const DTVParamHelperStruct DTVBandwidth::parseTable[] =
+{
+   { "auto", kBandwidthAuto },
+   { "8",    kBandwidth8Mhz },
+   { "7",    kBandwidth7Mhz },
+   { "6",    kBandwidth6Mhz },
+   { NULL,   kBandwidthAuto },
+};
+
+const char *DTVBandwidth::dbStr[DTVBandwidth::kDBStrCnt] =
+{
+    "8",   ///< kBandwidth8Mhz
+    "7",   ///< kBandwidth7Mhz
+    "6",   ///< kBandwidth6Mhz
+    "auto" ///< kBandwidthAUTO
+};
+
+const DTVParamHelperStruct DTVCodeRate::confTable[] =
+{
+    { "FEC_AUTO", kFECAuto },
+    { "FEC_1_2",  kFEC_1_2  },
+    { "FEC_2_3",  kFEC_2_3  },
+    { "FEC_3_4",  kFEC_3_4  },
+    { "FEC_4_5",  kFEC_4_5  },
+    { "FEC_5_6",  kFEC_5_6  },
+    { "FEC_6_7",  kFEC_6_7  },
+    { "FEC_7_8",  kFEC_7_8  },
+    { "FEC_8_9",  kFEC_8_9  },
+    { "FEC_NONE", kFECNone },
+    { NULL,       kFECAuto },
+};
+
+const DTVParamHelperStruct DTVCodeRate::vdrTable[] =
+{
+    { "999", kFECAuto },
+    { "12",  kFEC_1_2 },
+    { "23",  kFEC_2_3 },
+    { "34",  kFEC_3_4 },
+    { "45",  kFEC_4_5 },
+    { "56",  kFEC_5_6 },
+    { "67",  kFEC_6_7 },
+    { "78",  kFEC_7_8 },
+    { "89",  kFEC_8_9 },
+    { "0",   kFECNone },
+    { NULL,  kFECAuto }
+};
+
+const DTVParamHelperStruct DTVCodeRate::parseTable[] =
+{
+    { "auto", kFECAuto },
+    { "1/2",  kFEC_1_2 },
+    { "2/3",  kFEC_2_3 },
+    { "3/4",  kFEC_3_4 },
+    { "4/5",  kFEC_4_5 },
+    { "5/6",  kFEC_5_6 },
+    { "6/7",  kFEC_6_7 },
+    { "7/8",  kFEC_7_8 },
+    { "8/9",  kFEC_8_9 },
+    { "none", kFECNone },
+    { NULL,   kFECAuto }
+};
+
+const char *DTVCodeRate::dbStr[DTVCodeRate::kDBStrCnt] =
+{
+     "none", ///< kFECNone
+     "1/2",  ///< kFEC_1_2
+     "2/3",  ///< kFEC_2_3
+     "3/4",  ///< kFEC_3_4
+     "4/5",  ///< kFEC_4_5
+     "5/6",  ///< kFEC_5_6
+     "6/7",  ///< kFEC_6_7
+     "7/8",  ///< kFEC_7_8
+     "8/9",  ///< kFEC_8_9
+     "auto"  ///< kFECAuto
+};
+
+const DTVParamHelperStruct DTVModulation::confTable[] =
+{
+   { "QAM_AUTO", kModulationQAMAuto },
+   { "QAM_16",   kModulationQAM16   },
+   { "QAM_32",   kModulationQAM32   },
+   { "QAM_64",   kModulationQAM64   },
+   { "QAM_128",  kModulationQAM128  },
+   { "QAM_256",  kModulationQAM256  },
+   { "QPSK",     kModulationQPSK    },
+   { "8PSK",     kModulation8PSK    },
+   { NULL,       kModulationQAMAuto },
+};
+
+const DTVParamHelperStruct DTVModulation::vdrTable[] =
+{
+   { "999", kModulationQAMAuto },
+   { "16",  kModulationQAM16   },
+   { "32",  kModulationQAM32   },
+   { "64",  kModulationQAM64   },
+   { "128", kModulationQAM128  },
+   { "256", kModulationQAM256  },
+   { "0",   kModulationQPSK    },
+   { NULL,  kModulationQAMAuto },
+};
+
+const DTVParamHelperStruct DTVModulation::parseTable[] =
+{
+   { "auto",     kModulationQAMAuto },
+   { "qam_16",   kModulationQAM16   },
+   { "qam_32",   kModulationQAM32   },
+   { "qam_64",   kModulationQAM64   },
+   { "qam_128",  kModulationQAM128  },
+   { "qam_256",  kModulationQAM256  },
+   { "qpsk",     kModulationQPSK    },
+   { "8vsb",     kModulation8VSB    },
+   { "16vsb",    kModulation16VSB   },
+   { "8psk",     kModulation8PSK    },
+   // alternates from dvbtypes
+   { "a",        kModulationQAMAuto },
+   { "qam_auto", kModulationQAMAuto },
+   { "qam-16",   kModulationQAM16   },
+   { "qam-32",   kModulationQAM32   },
+   { "qam-64",   kModulationQAM64   },
+   { "qam-128",  kModulationQAM128  },
+   { "qam-256",  kModulationQAM256  },
+   { "8-vsb",    kModulation8VSB    },
+   { "16-vsb",   kModulation16VSB   },
+   { "8-psk",    kModulation8PSK    },
+   { NULL,       kModulationQAMAuto },
+};
+
+const char *DTVModulation::dbStr[DTVModulation::kDBStrCnt] =
+{
+    "qpsk",    ///< kModulationQPSK,
+    "qam_16",  ///< kModulationQAM16
+    "qam_32",  ///< kModulationQAM32
+    "qam_64",  ///< kModulationQAM64
+    "qam_128", ///< kModulationQAM128
+    "qam_256", ///< kModulationQAM256
+    "auto",    ///< kModulationQAMAuto
+    "8vsb",    ///< kModulation8VSB
+    "16vsb",   ///< kModulation16VSB
+    "8psk",    ///< kModulation8PSK
+};
+
+const DTVParamHelperStruct DTVTransmitMode::confTable[] =
+{
+   { "TRANSMISSION_MODE_AUTO", kTransmissionModeAuto },
+   { "TRANSMISSION_MODE_2K",   kTransmissionMode2K   },
+   { "TRANSMISSION_MODE_8K",   kTransmissionMode8K   },
+   { NULL,                     kTransmissionModeAuto },
+};
+
+const DTVParamHelperStruct DTVTransmitMode::vdrTable[] =
+{
+   { "999", kTransmissionModeAuto },
+   { "2",   kTransmissionMode2K   },
+   { "8",   kTransmissionMode8K   },
+   { NULL,  kTransmissionModeAuto },
+};
+
+const DTVParamHelperStruct DTVTransmitMode::parseTable[] =
+{
+   { "auto", kTransmissionModeAuto },
+   { "2",    kTransmissionMode2K   },
+   { "8",    kTransmissionMode8K   },
+   { NULL,   kTransmissionModeAuto },
+};
+
+const char *DTVTransmitMode::dbStr[DTVTransmitMode::kDBStrCnt] =
+{
+    "2",   ///< kTransmissionMode2K
+    "8",   ///< kTransmissionMode8K
+    "auto" ///< kTransmissionModeAuto
+};
+
+const DTVParamHelperStruct DTVGuardInterval::confTable[] =
+{
+   { "GUARD_INTERVAL_AUTO", kGuardIntervalAuto  },
+   { "GUARD_INTERVAL_1_32", kGuardInterval_1_32 },
+   { "GUARD_INTERVAL_1_16", kGuardInterval_1_16 },
+   { "GUARD_INTERVAL_1_8",  kGuardInterval_1_8  },
+   { "GUARD_INTERVAL_1_4",  kGuardInterval_1_4  },
+   { NULL,                  kGuardIntervalAuto  },
+};
+
+const DTVParamHelperStruct DTVGuardInterval::vdrTable[] =
+{
+   { "999", kGuardIntervalAuto  },
+   { "32",  kGuardInterval_1_32 },
+   { "16",  kGuardInterval_1_16 },
+   { "8",   kGuardInterval_1_8  },
+   { "4",   kGuardInterval_1_4  },
+   { NULL,  kGuardIntervalAuto  },
+};
+
+const DTVParamHelperStruct DTVGuardInterval::parseTable[] =
+{
+   { "auto", kGuardIntervalAuto  },
+   { "1/32", kGuardInterval_1_32 },
+   { "1/16", kGuardInterval_1_16 },
+   { "1/8",  kGuardInterval_1_8  },
+   { "1/4",  kGuardInterval_1_4  },
+   { NULL,   kGuardIntervalAuto  },
+};
+
+const char *DTVGuardInterval::dbStr[DTVGuardInterval::kDBStrCnt] =
+{
+    "1/32", ///< kGuardInterval_1_32
+    "1/16", ///< kGuardInterval_1_16
+    "1/8",  ///< kGuardInterval_1_8
+    "1/4",  ///< kGuardInterval_1_4
+    "auto"  ///< kGuardIntervalAuto
+};
+
+const DTVParamHelperStruct DTVHierarchy::confTable[] =
+{
+   { "HIERARCHY_NONE", kHierarchyNone },
+   { "HIERARCHY_1",    kHierarchy1    },
+   { "HIERARCHY_2",    kHierarchy2    },
+   { "HIERARCHY_4",    kHierarchy4    },
+   { "HIERARCHY_AUTO", kHierarchyAuto },
+   { NULL,             kHierarchyAuto },
+};
+
+const DTVParamHelperStruct DTVHierarchy::vdrTable[] =
+{
+   { "0",   kHierarchyNone },
+   { "1",   kHierarchy1    },
+   { "2",   kHierarchy2    },
+   { "4",   kHierarchy4    },
+   { "999", kHierarchyAuto },
+   { NULL,  kHierarchyAuto },
+};
+
+const DTVParamHelperStruct DTVHierarchy::parseTable[] =
+{
+   { "n",  kHierarchyNone },
+   { "1",  kHierarchy1    },
+   { "2",  kHierarchy2    },
+   { "4",  kHierarchy4    },
+   { "a",  kHierarchyAuto },
+   { NULL, kHierarchyAuto },
+};
+
+const char *DTVHierarchy::dbStr[DTVHierarchy::kDBStrCnt] =
+{
+    "n", ///< kHierarchyNone
+    "1", ///< kHierarchy1
+    "2", ///< kHierarchy2
+    "4", ///< kHierarchy4
+    "a"  ///< kHierarchyAuto
+};
+
+const DTVParamHelperStruct DTVPolarity::parseTable[] =
+{
+    { "v",  kPolarityVertical   },
+    { "h",  kPolarityHorizontal },
+    { "r",  kPolarityRight      },
+    { "l",  kPolarityLeft       },
+    { NULL, kPolarityVertical   },
+};
+
+const char *DTVPolarity::dbStr[DTVPolarity::kDBStrCnt] =
+{
+   "v", ///< kPolarityVertical
+   "h", ///< kPolarityHorizontal
+   "r", ///< kPolarityRight
+   "l"  ///< kPolarityLeft
+};
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dtvconfparserhelpers.h mythtv-0.20-new/libs/libmythtv/dtvconfparserhelpers.h
--- mythtv-0.20-old/libs/libmythtv/dtvconfparserhelpers.h	1969-12-31 16:00:00.000000000 -0800
+++ mythtv-0.20-new/libs/libmythtv/dtvconfparserhelpers.h	2007-04-17 10:23:32.000000000 -0700
@@ -0,0 +1,348 @@
+/* -*- Mode: c++ -*-
+ * vim: set expandtab tabstop=4 shiftwidth=4:
+ *
+ * Original Project
+ *      MythTV      http://www.mythtv.org
+ *
+ * Author(s):
+ *      John Pullan  (john@pullan.org)
+ *
+ * Description:
+ *     Collection of classes to provide dvb channel scanning
+ *     functionallity
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#ifndef _DTVCONFPARSERHELPERS_H_
+#define _DTVCONFPARSERHELPERS_H_
+
+#include <qstring.h>
+
+// The following are a set of helper classes to allow easy translation
+// between the different string representations of various tuning params.
+
+struct DTVParamHelperStruct
+{
+    QString symbol;
+    int     value;
+};
+
+/** \class DTVParamHelper
+ *  \brief Helper abstract template to do some of the mundane portions
+ *         of translating and comparing the paramater strings.
+ */
+class DTVParamHelper
+{
+  public:
+    DTVParamHelper(int _value) : value(_value) { }
+
+    operator int()                const { return value;          }
+    int operator=(int _value)           { return value = _value; }
+    bool operator==(const int& v) const { return value == v;     }
+
+  protected:
+    static bool ParseParam(const QString &symbol, int &value,
+                           const DTVParamHelperStruct *table);
+
+    static QString toString(const char *strings[], int index,
+                            uint strings_size);
+
+  protected:
+    int value;
+};
+
+class DTVInversion : public DTVParamHelper
+{
+  protected:
+    static const DTVParamHelperStruct confTable[];
+    static const DTVParamHelperStruct vdrTable[];
+    static const DTVParamHelperStruct parseTable[];
+    static const uint kDBStrCnt = 3;
+    static const char *dbStr[kDBStrCnt];
+
+  public:
+    enum
+    {
+        kInversionOff,
+        kInversionOn,
+        kInversionAuto,
+    };
+
+    DTVInversion(int _default = kInversionAuto)
+        : DTVParamHelper(_default) { }
+
+    bool ParseConf(const QString &_value)
+       { return ParseParam(_value, value, confTable); }
+    bool ParseVDR(const QString &_value)
+       { return ParseParam(_value, value, vdrTable); }
+    bool Parse(const QString &_value)
+       { return ParseParam(_value, value, parseTable); }
+
+    QString toString() const { return toString(value); }
+
+    static QString toString(int _value)
+        { return DTVParamHelper::toString(dbStr, _value, kDBStrCnt); }
+};
+
+class DTVBandwidth : public DTVParamHelper
+{
+  protected:
+    static const DTVParamHelperStruct confTable[];
+    static const DTVParamHelperStruct vdrTable[];
+    static const DTVParamHelperStruct parseTable[];
+    static const uint kDBStrCnt = 4;
+    static const char *dbStr[kDBStrCnt];
+
+  public:
+    enum
+    {
+        kBandwidth8Mhz,
+        kBandwidth7Mhz,
+        kBandwidth6Mhz,
+        kBandwidthAuto,
+    };
+
+    DTVBandwidth(int _default = kBandwidthAuto) : DTVParamHelper(_default) { }
+
+    bool ParseConf(const QString &_value)
+       { return ParseParam(_value, value, confTable); }
+    bool ParseVDR(const QString &_value)
+       { return ParseParam(_value, value, vdrTable); }
+    bool Parse(const QString &_value)
+       { return ParseParam(_value, value, parseTable); }
+
+    QString toString() const { return toString(value); }
+
+    static QString toString(int _value)
+        { return DTVParamHelper::toString(dbStr, _value, kDBStrCnt); }
+};
+
+class DTVCodeRate : public DTVParamHelper
+{
+  protected:
+    static const DTVParamHelperStruct confTable[];
+    static const DTVParamHelperStruct vdrTable[];
+    static const DTVParamHelperStruct parseTable[];
+    static const uint kDBStrCnt = 10;
+    static const char *dbStr[kDBStrCnt];
+
+  public:
+    enum
+    {
+        kFECNone,
+        kFEC_1_2,
+        kFEC_2_3,
+        kFEC_3_4,
+        kFEC_4_5,
+        kFEC_5_6,
+        kFEC_6_7,
+        kFEC_7_8,
+        kFEC_8_9,
+        kFECAuto,
+    };
+
+    DTVCodeRate(int _default = kFECAuto) : DTVParamHelper(_default) { }
+
+    bool ParseConf(const QString &_value)
+       { return ParseParam(_value, value, confTable); }
+    bool ParseVDR(const QString &_value)
+       { return ParseParam(_value, value, vdrTable); }
+    bool Parse(const QString &_value)
+       { return ParseParam(_value, value, parseTable); }
+
+    QString toString() const { return toString(value); }
+
+    static QString toString(int _value)
+        { return DTVParamHelper::toString(dbStr, _value, kDBStrCnt); }
+};
+
+class DTVModulation : public DTVParamHelper
+{
+  protected:
+    static const DTVParamHelperStruct confTable[];
+    static const DTVParamHelperStruct vdrTable[];
+    static const DTVParamHelperStruct parseTable[];
+    static const uint kDBStrCnt = 10;
+    static const char *dbStr[kDBStrCnt];
+
+  public:
+    enum
+    {
+        kModulationQPSK,
+        kModulationQAM16,
+        kModulationQAM32, 
+        kModulationQAM64, 
+        kModulationQAM128,
+        kModulationQAM256,
+        kModulationQAMAuto,
+        kModulation8VSB,
+        kModulation16VSB,
+        kModulation8PSK, 
+    };
+
+    DTVModulation(int _default = kModulationQAMAuto)
+        : DTVParamHelper(_default) { }
+
+    bool ParseConf(const QString &_value)
+       { return ParseParam(_value, value, confTable); }
+    bool ParseVDR(const QString &_value)
+       { return ParseParam(_value, value, vdrTable); }
+    bool Parse(const QString &_value)
+       { return ParseParam(_value, value, parseTable); }
+
+    QString toString() const { return toString(value); }
+
+    static QString toString(int _value)
+        { return DTVParamHelper::toString(dbStr, _value, kDBStrCnt); }
+};
+
+class DTVTransmitMode : public DTVParamHelper
+{
+  protected:
+    static const DTVParamHelperStruct confTable[];
+    static const DTVParamHelperStruct vdrTable[];
+    static const DTVParamHelperStruct parseTable[];
+    static const uint kDBStrCnt = 3;
+    static const char *dbStr[kDBStrCnt];
+
+  public:
+    enum
+    {
+        kTransmissionMode2K,
+        kTransmissionMode8K,
+        kTransmissionModeAuto,
+    };
+
+    DTVTransmitMode(int _default = kTransmissionModeAuto)
+        : DTVParamHelper(_default) { }
+
+    bool ParseConf(const QString &_value)
+       { return ParseParam(_value, value, confTable); }
+    bool ParseVDR(const QString &_value)
+       { return ParseParam(_value, value, vdrTable); }
+    bool Parse(const QString &_value)
+       { return ParseParam(_value, value, parseTable); }
+
+    QString toString() const { return toString(value); }
+    static QString toString(int _value)
+        { return DTVParamHelper::toString(dbStr, _value, kDBStrCnt); }
+};
+
+class DTVGuardInterval : public DTVParamHelper
+{
+  protected:
+    static const DTVParamHelperStruct confTable[];
+    static const DTVParamHelperStruct vdrTable[];
+    static const DTVParamHelperStruct parseTable[];
+    static const uint kDBStrCnt = 5;
+    static const char *dbStr[kDBStrCnt];
+
+  public:
+    enum
+    {
+        kGuardInterval_1_32,
+        kGuardInterval_1_16,
+        kGuardInterval_1_8,
+        kGuardInterval_1_4,
+        kGuardIntervalAuto,
+    };
+
+    DTVGuardInterval(int _default = kGuardIntervalAuto)
+        : DTVParamHelper(_default) { }
+
+    bool ParseConf(const QString &_value)
+       { return ParseParam(_value, value, confTable); }
+    bool ParseVDR(const QString &_value)
+       { return ParseParam(_value, value, vdrTable); }
+    bool Parse(const QString &_value)
+       { return ParseParam(_value, value, parseTable); }
+
+    QString toString() const { return toString(value); }
+
+    static QString toString(int _value)
+        { return DTVParamHelper::toString(dbStr, _value, kDBStrCnt); }
+};
+
+class DTVHierarchy : public DTVParamHelper
+{
+  protected:
+    static const DTVParamHelperStruct confTable[];
+    static const DTVParamHelperStruct vdrTable[];
+    static const DTVParamHelperStruct parseTable[];
+    static const uint kDBStrCnt = 5;
+    static const char *dbStr[kDBStrCnt];
+
+  public:
+    enum
+    {
+        kHierarchyNone,
+        kHierarchy1,
+        kHierarchy2,
+        kHierarchy4,
+        kHierarchyAuto,
+    };
+
+    DTVHierarchy(int _default = kHierarchyAuto) : DTVParamHelper(_default) { }
+
+    bool ParseConf(const QString &_value)
+       { return ParseParam(_value, value, confTable); }
+    bool ParseVDR(const QString &_value)
+       { return ParseParam(_value, value, vdrTable); }
+    bool Parse(const QString &_value)
+       { return ParseParam(_value, value, parseTable); }
+
+    QString toString() const { return toString(value); }
+
+    static QString toString(int _value)
+        { return DTVParamHelper::toString(dbStr, _value, kDBStrCnt); }
+};
+
+class DTVPolarity : public DTVParamHelper
+{
+  protected:
+    static const DTVParamHelperStruct parseTable[];
+    static const uint kDBStrCnt = 4;
+    static const char *dbStr[kDBStrCnt];
+
+  public:
+    enum PolarityValues
+    {
+        kPolarityVertical,
+        kPolarityHorizontal,
+        kPolarityRight,
+        kPolarityLeft
+    };
+
+    DTVPolarity(int _default = kPolarityVertical)
+        : DTVParamHelper(_default) { }
+
+    bool ParseConf(const QString &_value)
+       { return ParseParam(_value, value, parseTable); }
+    bool ParseVDR(const QString &_value)
+       { return ParseParam(_value, value, parseTable); }
+    bool Parse(const QString &_value)
+       { return ParseParam(_value, value, parseTable); }
+
+    QString toString() const { return toString(value); }
+
+    static QString toString(int _value)
+        { return DTVParamHelper::toString(dbStr, _value, kDBStrCnt); }
+};
+
+#endif // _DTVCONFPARSERHELPERS_H_
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dtvrecorder.cpp mythtv-0.20-new/libs/libmythtv/dtvrecorder.cpp
--- mythtv-0.20-old/libs/libmythtv/dtvrecorder.cpp	2006-05-22 12:08:08.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/dtvrecorder.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -366,8 +366,10 @@
                                           MARK_GOP_BYFRAME);
         _position_map_delta.clear();
 
-        if (ringBuffer)
-            curRecording->SetFilesize(ringBuffer->GetWritePosition());
+        // Stop setting the filesize here until we get the contention issue
+        // between with this thread and the scheduler worked out.
+        //if (ringBuffer)
+        //    curRecording->SetFilesize(ringBuffer->GetWritePosition());
     }
 }
 
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dvbconfparser.cpp mythtv-0.20-new/libs/libmythtv/dvbconfparser.cpp
--- mythtv-0.20-old/libs/libmythtv/dvbconfparser.cpp	2006-03-11 20:31:03.000000000 -0800
+++ mythtv-0.20-new/libs/libmythtv/dvbconfparser.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * $Id: dvbconfparser.cpp 9334 2006-03-12 04:31:03Z danielk $
+ * $Id: dvbconfparser.cpp 13237 2007-04-14 04:59:17Z jarod $
  * vim: set expandtab tabstop=4 shiftwidth=4:
  *
  * Original Project
@@ -29,558 +29,308 @@
  * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
  *
  */
-#include <qobject.h>
+
+// Qt headers
+#include <qstringlist.h>
+#include <qdeepcopy.h>
 #include <qfile.h>
-#include <qapplication.h>
+
+// MythTV headers
 #include "mythcontext.h"
-#include "dvbtypes.h"
-#include "dvbconfparser.h"
 #include "mythdbcon.h"
+#include "dvbconfparser.h"
 #include "channelutil.h"
 
-void DVBConfParser::Multiplex::dump()
+#define PARSE_SKIP(VAR) do { \
+    if (it == tokens.end()) return false; else it++; } while(0)
+
+#define PARSE_CONF(VAR) do { \
+    if (it == tokens.end() || !VAR.ParseConf(*it++)) \
+        return false; } while(0)
+
+#define PARSE_STR(VAR) do { \
+    if (it != tokens.end()) VAR = *it++; else return false; } while(0)
+
+#define PARSE_UINT(VAR) do { \
+    if (it != tokens.end()) \
+         VAR = (*it++).toUInt(); else return false; } while(0)
+
+#define PARSE_UINT_1000(VAR) do { \
+    if (it != tokens.end()) \
+         VAR = (*it++).toUInt() * 1000ULL; else return false; } while(0)
+
+
+QString DTVMultiplex::toString() const
 {
-    cerr << frequency<<" "<<inversion.toString()<<" "<<bandwidth.toString()<<" "<<coderate_hp.toString()<<" "<<coderate_lp.toString()<<" "<<constellation.toString()<<" "<<modulation.toString()<<" "<<transmit_mode.toString()<<" "<<guard_interval.toString()<<" "<<hierarchy.toString()<<" "<<polarity.toString()<<" "<<mplexid<<endl;
+    QString ret = QString("%1 %2 %3 ")
+        .arg(frequency).arg(modulation.toString()).arg(inversion.toString());
+
+    ret += QString("%1 %2 %3 %4 %5 %6 %7 %8")
+        .arg(hp_code_rate.toString()).arg(lp_code_rate.toString())
+        .arg(constellation.toString()).arg(bandwidth.toString())
+        .arg(trans_mode.toString()).arg(guard_interval.toString())
+        .arg(hierarchy.toString()).arg(polarity.toString());
+
+    return ret;
 }
- 
-void DVBConfParser::Channel::dump()
+
+bool DTVMultiplex::operator==(const DTVMultiplex &m) const
 {
-    cerr<<lcn<<" "<<mplexnumber<<" "<<name<<" "<<frequency<<" "<<inversion.toString()<<" "<<bandwidth.toString()<<" "<<coderate_hp.toString()<<" "<<coderate_lp.toString()<<" "<<constellation.toString()<<" "<<transmit_mode.toString()<<" "<<guard_interval.toString()<<" "<<hierarchy.toString()<<" "<<polarity.toString()<<" "<<serviceid<<endl;
+    return ((frequency == m.frequency) &&
+            (modulation == m.modulation) &&
+            (inversion == m.inversion) &&
+            (bandwidth == m.bandwidth) &&
+            (hp_code_rate == m.hp_code_rate) &&
+            (lp_code_rate == m.lp_code_rate) &&
+            (constellation == m.constellation) &&
+            (trans_mode == m.trans_mode) &&
+            (guard_interval == m.guard_interval) &&
+            (fec == m.fec) &&
+            (polarity == m.polarity) &&
+            (hierarchy == m.hierarchy));
 }
 
-bool DVBConfParser::Multiplex::operator==(const Multiplex& m) const
-{
-    if ((frequency == m.frequency) &&
-        (inversion == m.inversion) &&
-        (bandwidth == m.bandwidth) &&
-        (coderate_hp == m.coderate_hp) &&
-        (coderate_lp == m.coderate_lp) &&
-        (constellation == m.constellation) &&
-        (transmit_mode == m.transmit_mode) &&
-        (guard_interval == m.guard_interval) &&
-        (fec == m.fec) &&
-        (polarity == m.polarity) &&
-        (hierarchy == m.hierarchy))
-        return true;
-    else
-        return false;
+QString DTVChannelInfo::toString() const
+{
+    return QString("%1 %2 %3 ").arg(name).arg(serviceid).arg(lcn);
 }
 
-DVBConfParser::DVBConfParser(enum TYPE _type,unsigned _sourceid,
-                             const QString& _file)
+DTVConfParser::DTVConfParser(enum cardtype_t _type, uint _sourceid,
+                             const QString &_file)
+    : type(_type), sourceid(_sourceid), filename(QDeepCopy<QString>(_file))
 {
-    type=_type;
-    filename = _file;
-    sourceid=_sourceid;
 }
 
-int DVBConfParser::parse()
+DTVConfParser::return_t DTVConfParser::Parse(void)
 {
-    QFile file( filename );
-    if (file.open( IO_ReadOnly ) ) 
+    channels.clear();
+
+    QFile file(filename);
+    if (!file.open(IO_ReadOnly))
+        return ERROR_OPEN;
+
+    bool ok = true;
+    QTextStream stream(&file);
+    QString line;
+    while (!stream.atEnd())
     {
-        QTextStream stream( &file );
-        QString line;
-        while ( !stream.atEnd() ) 
+        line = stream.readLine(); // line of text excluding '\n'
+        line.stripWhiteSpace();
+        if (line.startsWith("#"))
+            continue;
+
+        QStringList list = QStringList::split(":", line);
+        QString str = *list.at(0);
+        int channelNo = -1;
+
+        if (str.at(0) == '@')
         {
-            line = stream.readLine(); // line of text excluding '\n'
-            line.stripWhiteSpace();
-            if (line.startsWith("#"))
-                continue;
-            QStringList list=QStringList::split(":",line);
-            QString str = *list.at(0);
-            int channelNo = -1;
-            if (str.at(0)=='@')
-            {
-                channelNo=str.mid(1).toInt();
-                line = stream.readLine(); 
-                list=QStringList::split(":",line);
-            }
-            str = *list.at(3);
-            if ((str == "T") || (str == "C") || (str=="S"))
-            {
-                if ((type == OFDM) && (str=="T"))
-                    parseVDR(list,channelNo);
-                else if ((type == QPSK) && (str=="S"))
-                    parseVDR(list,channelNo);
-                else if ((type == QAM) && (str=="C"))
-                    parseVDR(list,channelNo);
-            }
-            else if (type==OFDM)
-                parseConfOFDM(list);
-            else if (type==ATSC)
-                parseConfATSC(list);
-            else if (type==QPSK)
-                parseConfQPSK(list);
-            else if (type==QAM)
-                parseConfQAM(list);
+            channelNo = str.mid(1).toInt();
+            line = stream.readLine();
+            list = QStringList::split(":", line);
         }
-        file.close();
 
-        processChannels();
-        return OK;
+        str = *list.at(3);
+
+        if ((str == "T") || (str == "C") || (str == "S"))
+        {
+            if ((type == OFDM) && (str == "T"))
+                ok &= ParseVDR(list, channelNo);
+            else if ((type == QPSK) && (str == "S"))
+                ok &= ParseVDR(list, channelNo);
+            else if ((type == QAM) && (str == "C"))
+                ok &= ParseVDR(list, channelNo);
+        }
+        else if (type == OFDM)
+            ok &= ParseConfOFDM(list);
+        else if (type == ATSC)
+            ok &= ParseConfATSC(list);
+        else if (type == QPSK)
+            ok &= ParseConfQPSK(list);
+        else if (type == QAM)
+            ok &= ParseConfQAM(list);
     }
-    return ERROR_OPEN;
+    file.close();
+
+    return (ok) ? OK : ERROR_PARSE;
 }
 
-bool DVBConfParser::parseConfOFDM(QStringList& tokens)
+bool DTVConfParser::ParseConfOFDM(const QStringList &tokens)
 {
-    Channel c;
-    QStringList::Iterator i = tokens.begin();
-    QStringList::Iterator end = tokens.end();
-    if (i != end) c.name = *i++; else return false;
-    if (i != end) c.frequency = (*i++).toInt(); else return false;
-    if (i == end || !c.inversion.parseConf(*i++)) return false;
-    if (i == end || !c.bandwidth.parseConf(*i++)) return false;
-    if (i == end || !c.coderate_hp.parseConf(*i++)) return false;
-    if (i == end || !c.coderate_lp.parseConf(*i++)) return false;
-    if (i == end || !c.constellation.parseConf(*i++)) return false;
-    if (i == end || !c.transmit_mode.parseConf(*i++)) return false;
-    if (i == end || !c.guard_interval.parseConf(*i++)) return false;
-    if (i == end || !c.hierarchy.parseConf(*i++)) return false;
-    if (i == end ) return false; else i++;
-    if (i == end ) return false; else i++;
-    if (i != end) c.serviceid = (*i++).toInt(); else return false;
+    DTVChannelInfo chan;
+    DTVMultiplex   mux;
 
-    channels.append(c);
+    QStringList::const_iterator it = tokens.begin();
 
-    return true;
-}
-
-bool DVBConfParser::parseConfATSC(QStringList& tokens)
-{
-    Channel c;
-    QStringList::Iterator i = tokens.begin();
-    QStringList::Iterator end = tokens.end();
-    if (i != end) c.name = *i++; else return false;
-    if (i != end) c.frequency = (*i++).toInt(); else return false;
-    if (i == end || !c.modulation.parseConf(*i++)) return false;
-    // We need the program number in the transport stream,
-    // otherwise we cannot "tune" to the program.
-    if (i == end ) return false; else i++;   // Ignore video pid
-    if (i == end ) return false; else i++;   // Ignore audio pid
-    if (i != end) c.serviceid = (*i++).toInt(); else return false;
+    PARSE_SKIP(unknown);
+    PARSE_UINT(mux.frequency);
+    PARSE_CONF(mux.inversion);
+    PARSE_CONF(mux.bandwidth);
+    PARSE_CONF(mux.hp_code_rate);
+    PARSE_CONF(mux.lp_code_rate);
+    PARSE_CONF(mux.constellation);
+    PARSE_CONF(mux.trans_mode);
+    PARSE_CONF(mux.guard_interval);
+    PARSE_CONF(mux.hierarchy);
+    PARSE_SKIP(unknown);
+    PARSE_SKIP(unknown);
+    PARSE_UINT(chan.serviceid);
 
-    channels.append(c);
+    AddChannel(mux, chan);
 
     return true;
 }
 
-bool DVBConfParser::parseConfQAM(QStringList& tokens)
+bool DTVConfParser::ParseConfATSC(const QStringList &tokens)
 {
-    Channel c;
-    QStringList::Iterator i = tokens.begin();
-    QStringList::Iterator end = tokens.end();
-
-    if (i != end) c.name = *i++; else return false;
-    if (i != end) c.frequency = (*i++).toInt(); else return false;
-    if (i == end || !c.inversion.parseConf(*i++)) return false;
-    if (i != end) c.symbolrate = (*i++).toInt(); else return false;
-    if (i == end || !c.fec.parseConf(*i++)) return false;
-    if (i == end || !c.modulation.parseConf(*i++)) return false;
-    if (i == end ) return false; else i++;
-    if (i == end ) return false; else i++;
-    if (i != end) c.serviceid = (*i++).toInt(); else return false;
-    
-    channels.append(c);
-    return true;
-}
+    DTVChannelInfo chan;
+    DTVMultiplex   mux;
 
-bool DVBConfParser::parseConfQPSK(QStringList& tokens)
-{
-    Channel c;
-    QStringList::iterator it = tokens.begin();
+    QStringList::const_iterator it = tokens.begin();
 
-    if (it != tokens.end())
-        c.name = *it++;
-    else
-        return false;
+    PARSE_STR(chan.name);
+    PARSE_UINT(mux.frequency);
+    PARSE_CONF(mux.modulation);
+    PARSE_SKIP(Ignore_Video_PID);
+    PARSE_SKIP(Ignore_Audio_PID);
+    PARSE_UINT(chan.serviceid);
 
-    if (it != tokens.end())
-        c.frequency = (*it++).toUInt() * 1000;
-    else
-        return false;
+    AddChannel(mux, chan);
 
-    if (it == tokens.end() || !c.polarity.parseConf(*it++))
-        return false;
+    return true;
+}
 
-    if (it == tokens.end())
-        return false;
-    else
-        it++; //Sat num
+bool DTVConfParser::ParseConfQAM(const QStringList &tokens)
+{
+    DTVChannelInfo chan;
+    DTVMultiplex   mux;
 
-    if (it != tokens.end())
-        c.symbolrate = (*it++).toUInt() * 1000;
-    else
-        return false;
+    QStringList::const_iterator it = tokens.begin();
 
-    if (it == tokens.end())
-        return false;
-    else
-        it++;
+    PARSE_SKIP(unknown);
+    PARSE_UINT(mux.frequency);
+    PARSE_CONF(mux.inversion);
+    PARSE_UINT(mux.symbolrate);
+    PARSE_CONF(mux.fec);
+    PARSE_CONF(mux.modulation);
+    PARSE_SKIP(unknown);
+    PARSE_SKIP(unknown);
+    PARSE_UINT(chan.serviceid);
 
-    if (it == tokens.end())
-        return false;
-    else
-        it++;
+    AddChannel(mux, chan);
 
-    if (it != tokens.end())
-        c.serviceid = (*it++).toInt();
-    else
-        return false;
-    
-    channels.append(c);
     return true;
 }
 
-bool DVBConfParser::parseVDR(QStringList& tokens, int channelNo)
+bool DTVConfParser::ParseConfQPSK(const QStringList &tokens)
 {
-    Channel c;
-    QStringList::Iterator i = tokens.begin();
-    QStringList::Iterator end = tokens.end();
-    c.lcn = channelNo;
-
-//BBC ONE:754166:I999B8C34D34M16T2G32Y0:T:27500:600:601,602:0:0:4168:0:0:0
-    if (i != end) c.name = *i++; else return false;
-    if (i != end) c.frequency = (*i++).toInt()*1000; else return false;
-    if (i == end) return false;
-    QString params = (*i++);
-    while (!params.isEmpty())
-    {
-        QString ori = params;
-        int s = *(const char*)params;
-        params=params.mid(1);
-        switch(s)
-        {
-        case 'I':
-            c.inversion.parseVDR(params);
-            break;
-        case 'B':
-            c.bandwidth.parseVDR(params);
-            break;
-        case 'C':
-            c.coderate_hp.parseVDR(params);
-            break;
-        case 'D':
-            c.coderate_lp.parseVDR(params);
-            break;
-        case 'M':
-            c.constellation.parseVDR(params);
-            break;
-        case 'T':
-            c.transmit_mode.parseVDR(params);
-            break;
-        case 'G':
-            c.guard_interval.parseVDR(params);
-            break;
-        case 'Y':
-            c.hierarchy.parseVDR(params);
-            break;
-        case 'V':
-        case 'H':
-        case 'R':
-        case 'L':
-            c.polarity.parseVDR(ori);
-            break;
-        default:
-            return false;
-        }
-    }
-     
-    if (i == end ) return false; else i++;
-    if (i == end ) return false; else i++;
-    if (i == end ) return false; else i++;
-    if (i == end ) return false; else i++;
-    if (i == end ) return false; else i++;
-    if (i == end ) return false; else i++;
-    if (i != end) c.serviceid = (*i++).toInt(); else return false;
+    DTVChannelInfo chan;
+    DTVMultiplex   mux;
+
+    QStringList::const_iterator it = tokens.begin();
+
+    PARSE_STR(chan.name);
+    PARSE_UINT_1000(mux.frequency);
+    PARSE_CONF(mux.polarity);
+    PARSE_SKIP(Satelite_Number);
+    PARSE_UINT_1000(mux.symbolrate);
+    PARSE_SKIP(unknown);
+    PARSE_SKIP(unknown);
+    PARSE_UINT(chan.serviceid);
+
+    AddChannel(mux, chan);
 
-    channels.append(c);
     return true;
 }
 
-int DVBConfParser::generateNewChanID(int sourceID)
+bool DTVConfParser::ParseVDR(const QStringList &tokens, int channelNo)
 {
-    MSqlQuery query(MSqlQuery::InitCon());
+    DTVChannelInfo chan;
+    DTVMultiplex   mux;
 
-    QString theQuery =
-        QString("SELECT max(chanid) as maxchan "
-                "FROM channel WHERE sourceid=%1").arg(sourceID);
-    query.prepare(theQuery);
+    QStringList::const_iterator it = tokens.begin();
 
-    if (!query.exec())
-        MythContext::DBError("Calculating new ChanID", query);
+    chan.lcn = channelNo;
 
-    if (!query.isActive())
-        MythContext::DBError("Calculating new ChanID for Analog Channel",query);
+// BBC ONE:754166:I999B8C34D34M16T2G32Y0:T:27500:600:601, 602:0:0:4168:0:0:0
 
-    query.next();
+    PARSE_SKIP(unknown);
 
-    // If transport not present add it, and move on to the next
-    if (query.size() <= 0)
-        return sourceID * 1000;
+    PARSE_UINT_1000(mux.frequency);
 
-    int MaxChanID = query.value(0).toInt();
-
-    if (MaxChanID == 0)
-        return sourceID * 1000;
-    else
-        return MaxChanID + 1;
-}
-
-int DVBConfParser::findMultiplex(const DVBConfParser::Multiplex& m)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    QString queryStr=QString("SELECT mplexid FROM dtv_multiplex WHERE "
-             "sourceid= %1 AND frequency=%2 AND inversion=\"%3\" AND ")
-             .arg(sourceid).arg(m.frequency).arg(m.inversion.toString());
+    if (it == tokens.end())
+        return false;
 
-    switch (type)
-    {
-    case OFDM:
-        queryStr+=QString("sistandard=\"dvb\" AND bandwidth=\"%1\" AND "
-                     "hp_code_rate=\"%2\" AND "
-                     "lp_code_rate=\"%3\" AND constellation=\"%4\" AND "
-                     "transmission_mode=\"%5\" AND guard_interval=\"%6\" AND "
-                     "hierarchy=\"%7\";")
-                      .arg(m.bandwidth.toString())
-                      .arg(m.coderate_hp.toString())
-                      .arg(m.coderate_lp.toString())
-                      .arg(m.constellation.toString())
-                      .arg(m.transmit_mode.toString())
-                      .arg(m.guard_interval.toString())
-                      .arg(m.hierarchy.toString());
-        break;
-    case QPSK:
-        queryStr+=QString("sistandard=\"dvb\" AND symbolrate=%1 AND "
-                          "polarity=\"%2\";").arg(m.symbolrate)
-                         .arg(m.polarity.toString());
-        break; 
-    case QAM:
-        queryStr+=QString("symbolrate=%1 AND modulation=\"%2\" AND fec=\"%3\";")
-                         .arg(m.symbolrate)
-                         .arg(m.modulation.toString())
-                         .arg(m.fec.toString());
-        break;
-    case ATSC:
-        queryStr+=QString("modulation=\"%1\";")
-                         .arg(m.modulation.toString());
-        break;
-    } 
-    query.prepare(queryStr);
-    if (!query.exec())
-        MythContext::DBError("searching for transport", query);
-    if (!query.isActive())
-        MythContext::DBError("searching for transport.", query);
-    if (query.size() > 0)
+    QString params = (*it++);
+    while (!params.isEmpty())
     {
-       query.next();
-       return query.value(0).toInt();
+        QString ori = params;
+        int s = *((const char*)params);
+        params = params.mid(1);
+        switch (s)
+        {
+            case 'I':
+                mux.inversion.ParseVDR(params);
+                break;
+            case 'B':
+                mux.bandwidth.ParseVDR(params);
+                break;
+            case 'C':
+                mux.hp_code_rate.ParseVDR(params);
+                break;
+            case 'D':
+                mux.lp_code_rate.ParseVDR(params);
+                break;
+            case 'M':
+                mux.constellation.ParseVDR(params);
+                break;
+            case 'T':
+                mux.trans_mode.ParseVDR(params);
+                break;
+            case 'G':
+                mux.guard_interval.ParseVDR(params);
+                break;
+            case 'Y':
+                mux.hierarchy.ParseVDR(params);
+                break;
+            case 'V':
+            case 'H':
+            case 'R':
+            case 'L':
+                mux.polarity.ParseVDR(ori);
+                break;
+            default:
+                return false;
+        }
     }
-    return -1;
-}
 
-int DVBConfParser::findChannel(const DVBConfParser::Channel &c, int &mplexid)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
+    for (uint i = 0; i < 6; i++)
+        PARSE_SKIP(unknown);
 
-    // try to find exact match first
-    query.prepare("SELECT chanid "
-                  "FROM channel "
-                  "WHERE callsign = :CALLSIGN AND "
-                  "      mplexid  = :MPLEXID  AND "
-                  "      sourceid = :SOURCEID");
-    query.bindValue(":MPLEXID",  multiplexes[c.mplexnumber].mplexid);
-    query.bindValue(":SOURCEID", sourceid);
-    query.bindValue(":CALLSIGN", c.name.utf8());
-
-    if (!query.exec() || !query.isActive())
-        MythContext::DBError("searching for channel", query);
-    else if (query.next())
-    {
-        mplexid = multiplexes[c.mplexnumber].mplexid;
-        return query.value(0).toInt();
-    }
+    PARSE_UINT(chan.serviceid);
 
-    // if we didn't find exact match, try to match just the source & callsign
-    query.prepare("SELECT chanid, mplexid "
-                  "FROM channel "
-                  "WHERE callsign = :CALLSIGN AND "
-                  "      sourceid = :SOURCEID");
-    query.bindValue(":SOURCEID", sourceid);
-    query.bindValue(":CALLSIGN", c.name.utf8());
-
-    if (!query.exec() || !query.isActive())
-        MythContext::DBError("searching for channel", query);
-    else if (query.next())
-    {
-        mplexid = query.value(1).toInt();
-        return query.value(0).toInt();
-    }
+    AddChannel(mux, chan);
 
-    return -1;
-} 
+    return true;
+}
 
-void DVBConfParser::processChannels()
+void DTVConfParser::AddChannel(const DTVMultiplex &mux, DTVChannelInfo &chan)
 {
-    ListChannels::iterator iter;
-    for (iter=channels.begin();iter!=channels.end();iter++)
+    for (uint i = 0; i < channels.size(); i++)
     {
-        bool fFound = false;
-        for (unsigned i=0;i<multiplexes.size() && !fFound;i++ )
-        {
-            if (multiplexes[i] == (Multiplex)(*iter))
-            {
-                (*iter).mplexnumber = i;
-                fFound = true;
-            }
-        } 
-        if (!fFound)
+        if (channels[i] == mux)
         {
-            (*iter).mplexnumber = multiplexes.size();
-            multiplexes.append((Multiplex)(*iter));
+            channels[i].channels.push_back(chan);
+
+            VERBOSE(VB_IMPORTANT, "Imported channel: "<<chan.toString()
+                    <<" on "<<mux.toString());
+            return;
         }
-    } 
-/*
-    for (iter=channels.begin();iter!=channels.end();iter++)
-        (*iter).dump();
-    for (unsigned i=0;i<multiplexes.size() ;i++ )
-        multiplexes[i].dump();
-*/
-    QString standard = (type == ATSC) ? "atsc" : "dvb"; 
-    //create the multiplexes
-    MSqlQuery query(MSqlQuery::InitCon());
-    for (unsigned i=0;i<multiplexes.size() ;i++ )
-    {
-        int mplexid = findMultiplex(multiplexes[i]);
-        if (mplexid < 0)
-        {
-            query.prepare("INSERT into dtv_multiplex (frequency, "
-                "sistandard, sourceid,inversion,bandwidth,hp_code_rate,"
-                "lp_code_rate,constellation,transmission_mode,guard_interval,"
-                "hierarchy,modulation,symbolrate,fec,polarity) "
-                "VALUES (:FREQUENCY,:STANDARD,:SOURCEID,:INVERSION,:BANDWIDTH,"
-                ":CODERATE_HP,:CODERATE_LP,:CONSTELLATION,:TRANS_MODE,"
-                ":GUARD_INTERVAL,:HIERARCHY,:MODULATION,:SYMBOLRATE,"
-                ":FEC,:POLARITY);");
-            query.bindValue(":STANDARD",standard);
-            query.bindValue(":SOURCEID",sourceid);
-            query.bindValue(":FREQUENCY",multiplexes[i].frequency);
-            query.bindValue(":INVERSION",multiplexes[i].inversion.toString());
-            query.bindValue(":BANDWIDTH",multiplexes[i].bandwidth.toString());
-            query.bindValue(":CODERATE_HP",multiplexes[i].coderate_hp.toString());
-            query.bindValue(":CODERATE_LP",multiplexes[i].coderate_lp.toString());
-            query.bindValue(":CONSTELLATION",multiplexes[i].constellation.toString());
-            query.bindValue(":TRANS_MODE",multiplexes[i].transmit_mode.toString());
-            query.bindValue(":GUARD_INTERVAL",multiplexes[i].guard_interval.toString());
-            query.bindValue(":HIERARCHY",multiplexes[i].hierarchy.toString());
-            query.bindValue(":MODULATION",multiplexes[i].modulation.toString());
-            query.bindValue(":SYMBOLRATE",multiplexes[i].symbolrate);
-            query.bindValue(":FEC",multiplexes[i].fec.toString());
-            query.bindValue(":POLARITY",multiplexes[i].polarity.toString());
-
-            if (!query.exec())
-                MythContext::DBError("Inserting new transport", query);
-            if (!query.isActive())
-                MythContext::DBError("Adding transport to Database.", query);
-            query.prepare("select max(mplexid) from dtv_multiplex;");
-            if (!query.exec())
-                MythContext::DBError("Getting ID of new Transport", query);
-            if (!query.isActive())
-                MythContext::DBError("Getting ID of new Transport.", query);
-            if (query.size() > 0)
-            {
-               query.next();
-               multiplexes[i].mplexid = query.value(0).toInt();
-            }
-       }
-       else
-           multiplexes[i].mplexid = mplexid;
     }
 
-    // If the channel number cannot be determined from the config
-    // file, assign temporary unique numbers. First determine the
-    // highest channel number already assigned. This will likely
-    // fail if there are any ATSC channels, since channum is not
-    // really an integer. But in that case 501 is a generally safe
-    // offset for the first unknown channel.
-    int maxchannum = 500;
-    query.prepare("SELECT MAX(channum) FROM channel");
-    if (!query.exec() || !query.isActive())
-        MythContext::DBError("Getting highest channel number.", query);
-    else if (query.next())
-        maxchannum = max(maxchannum, query.value(0).toInt());
-    for (iter = channels.begin(); iter != channels.end(); ++iter)
-        maxchannum = max(maxchannum, (*iter).lcn);
+    channels.push_back(mux);
+    channels.back().channels.push_back(chan);
 
-    // Now insert the channels
-    for (iter=channels.begin();iter!=channels.end();iter++)
-    {
-        int mplexid    = multiplexes[(*iter).mplexnumber].mplexid;
-        int db_mplexid = 0;
-        int chanid     = findChannel(*iter, db_mplexid);
-        if (chanid < 0)
-        {
-            // The channel does not exist in the DB at all, insert it.
-            query.prepare("INSERT INTO channel (chanid, channum, "
-                  "sourceid, callsign, name,  mplexid, "
-                  "serviceid) "
-                  "VALUES (:CHANID,:CHANNUM,:SOURCEID,:CALLSIGN,"
-                  ":NAME,:MPLEXID,:SERVICEID);");
-
-            // If the channel number is unknown, get next unique number
-            int channum = (*iter).lcn;
-            if (-1 == channum)
-                channum = ++maxchannum;
-
-            int chanid = ChannelUtil::CreateChanID(
-                sourceid, QString::number(channum));
-
-            query.bindValue(":CHANID",    chanid);
-            query.bindValue(":CHANNUM",   channum);
-            query.bindValue(":SOURCEID",  sourceid);
-            query.bindValue(":CALLSIGN",  (*iter).name.utf8());
-            query.bindValue(":NAME",      (*iter).name.utf8());
-            query.bindValue(":MPLEXID",   mplexid);
-            query.bindValue(":SERVICEID", (*iter).serviceid);
-            if (!query.exec() || !query.isActive())
-            {
-                MythContext::DBError("Adding new DVB Channel", query);
-                emit updateText(QObject::tr("Failed to add %1: DB error")
-                                .arg((*iter).name));
-            }
-            else
-            {
-                emit updateText(QObject::tr("Adding %1").arg((*iter).name));
-            }
-        }
-        else if (db_mplexid == 32767)
-        {
-            // The channel in the database if from the listings provider amd
-            // does not have tuning information. Just fill in the tuning info.
-            query.prepare("UPDATE channel "
-                          "SET mplexid   = :MPLEXID,  "
-                          "    serviceid = :SERVICEID "
-                          "WHERE chanid   = :CHANID   AND "
-                          "      sourceid = :SOURCEID     ");
-
-            query.bindValue(":MPLEXID",   mplexid);
-            query.bindValue(":SERVICEID", (*iter).serviceid);
-            query.bindValue(":CHANID",    chanid);
-            query.bindValue(":SOURCEID",  sourceid);
-
-            if (!query.exec() || !query.isActive())
-            {
-                MythContext::DBError("Updating DVB Channel", query);
-                emit updateText(QObject::tr("Failed to add %1: DB error")
-                                .arg((*iter).name));
-            }
-            else
-            {
-                emit updateText(QObject::tr("Updating %1").arg((*iter).name));
-            }
-        }
-        else
-            emit updateText(QObject::tr("Skipping %1").arg((*iter).name));
-    }
+    VERBOSE(VB_IMPORTANT, "Imported channel: "<<chan.toString()
+            <<" on "<<mux.toString());
 }
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dvbconfparser.h mythtv-0.20-new/libs/libmythtv/dvbconfparser.h
--- mythtv-0.20-old/libs/libmythtv/dvbconfparser.h	2006-02-07 13:56:06.000000000 -0800
+++ mythtv-0.20-new/libs/libmythtv/dvbconfparser.h	2007-04-17 10:23:32.000000000 -0700
@@ -1,5 +1,5 @@
 /*
- * $Id: dvbconfparser.h 8901 2006-02-07 21:56:06Z danielk $
+ * $Id: dvbconfparser.h 13237 2007-04-14 04:59:17Z jarod $
  * vim: set expandtab tabstop=4 shiftwidth=4:
  *
  * Original Project
@@ -30,91 +30,107 @@
  *
  */
 
-#ifndef DVBCONFPARSER_H
-#define DVBCONFPARSER_H
+#ifndef _DTVCONFPARSER_H_
+#define _DTVCONFPARSER_H_
 
-#include <qobject.h>
-#include <qvaluevector.h>
+// POSIX headers
+#include <stdint.h>
+#include <unistd.h>
+
+// C++ headers
+#include <vector>
+using namespace std;
+
+// Qt headers
 #include <qstring.h>
-#include <dvbtypes.h>
 
-/**
- * class DVBConfParser
- * @brief parses channels.conf files into the mythtv structure
+// MythTV headers
+#include "dtvconfparserhelpers.h"
+
+class QStringList;
+
+class DTVMultiplex
+{
+  public:
+    DTVMultiplex() : frequency(0), symbolrate(0) { }
+
+    bool operator==(const DTVMultiplex &m) const;
+ 
+    QString toString() const;
+
+ public:
+    uint64_t         frequency;
+    uint             symbolrate;
+    DTVInversion     inversion;
+    DTVBandwidth     bandwidth;
+    DTVCodeRate      hp_code_rate;
+    DTVCodeRate      lp_code_rate;
+    DTVModulation    constellation;
+    DTVModulation    modulation;
+    DTVTransmitMode  trans_mode;
+    DTVGuardInterval guard_interval;
+    DTVHierarchy     hierarchy;
+    DTVPolarity      polarity;
+    DTVCodeRate      fec;
+};
+
+class DTVChannelInfo
+{
+  public:
+    DTVChannelInfo() :
+        name(QString::null), serviceid(0), lcn(-1) {}
+
+    QString toString() const;
+
+ public:
+    QString name;
+    uint    serviceid;
+    int     lcn;
+};
+typedef vector<DTVChannelInfo> DTVChannelInfoList;
+
+class DTVTransport : public DTVMultiplex
+{
+  public:
+    DTVTransport(const DTVMultiplex &other) : DTVMultiplex(other) { }
+
+  public:
+    DTVChannelInfoList channels;
+};
+typedef vector<DTVTransport> DTVChannelList;
+
+/** \class DTVConfParser
+ *  \brief Parses dvb-utils channel scanner output files.
  */
-class DVBConfParser : public QObject
+class DTVConfParser
 {
-    Q_OBJECT
-protected:
-    class Multiplex
-    {
-    public:
-        Multiplex() : frequency(0),symbolrate(0),mplexid(0) {}
-        bool operator==(const Multiplex& m) const;
-
-        unsigned frequency;
-        unsigned symbolrate;
-        DVBInversion inversion;
-        DVBBandwidth bandwidth;
-        DVBCodeRate coderate_hp;
-        DVBCodeRate coderate_lp;
-        DVBModulation constellation;
-        DVBModulation modulation;
-        DVBTransmitMode transmit_mode;
-        DVBGuardInterval guard_interval;
-        DVBHierarchy  hierarchy;
-        DVBPolarity  polarity;
-        DVBCodeRate fec;
-        unsigned mplexid;
-
-        void dump();
-    };
-
-    class Channel : public Multiplex
-    {
-    public:
-        Channel() : serviceid(0),mplexnumber(0), lcn(-1) {}
-
-        QString name;
-        unsigned serviceid;
-        unsigned mplexnumber;
-        int lcn;
-
-        void dump();
-    };
-
-    typedef QValueList<Channel> ListChannels;
-
-    ListChannels  channels;
-    QValueVector<Multiplex> multiplexes;
-
-public:
-    enum RETURN {ERROR_OPEN,ERROR_PARSE,OK};
-    enum TYPE {ATSC,OFDM,QPSK,QAM};
-
-    DVBConfParser(enum TYPE _type,unsigned sourceid, const QString& _file);
-    virtual ~DVBConfParser() {};
-    int parse(); 
-
-signals:
-    /** @brief Status message from the scan engine
-        @param status the message
-    */ 
-    void updateText(const QString& status);
-protected:
-    QString filename;
-    TYPE type;
-    unsigned sourceid;
-    bool parseVDR(QStringList& tokens, int channelNo = -1);
-    bool parseConf(QStringList& tokens);
-    bool parseConfOFDM(QStringList& tokens);
-    bool parseConfQPSK(QStringList& tokens);
-    bool parseConfQAM(QStringList& tokens);
-    bool parseConfATSC(QStringList& tokens);
-    void processChannels();
-    int findMultiplex(const Multiplex& m);
-    int findChannel(const Channel& c, int& mplexid);
-    int generateNewChanID(int sourceID);
+  public:
+    enum return_t   { ERROR_OPEN, ERROR_PARSE, OK };
+    enum cardtype_t { ATSC, OFDM, QPSK, QAM, UNKNOWN };
+
+    DTVConfParser(enum cardtype_t _type, uint sourceid, const QString &_file);
+    virtual ~DTVConfParser() { }
+
+    return_t Parse(void);
+
+    DTVChannelList GetChannels(void) const { return channels; }
+
+  private:
+    bool ParseVDR(     const QStringList &tokens, int channelNo = -1);
+    bool ParseConf(    const QStringList &tokens);
+    bool ParseConfOFDM(const QStringList &tokens);
+    bool ParseConfQPSK(const QStringList &tokens);
+    bool ParseConfQAM( const QStringList &tokens);
+    bool ParseConfATSC(const QStringList &tokens);
+
+  private:
+    cardtype_t type;
+    uint       sourceid;
+    QString    filename;
+
+    void AddChannel(const DTVMultiplex &mux, DTVChannelInfo &chan);
+
+    DTVChannelList channels;
 };
 
-#endif
+#endif // _DTVCONFPARSER_H_
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dvbdev/dvbci.h mythtv-0.20-new/libs/libmythtv/dvbdev/dvbci.h
--- mythtv-0.20-old/libs/libmythtv/dvbdev/dvbci.h	2006-02-21 15:20:25.000000000 -0800
+++ mythtv-0.20-new/libs/libmythtv/dvbdev/dvbci.h	2007-04-17 10:23:29.000000000 -0700
@@ -142,6 +142,7 @@
 
 class cCiHandler {
 public:
+  virtual ~cCiHandler() {};
   static cCiHandler *CreateCiHandler(const char *FileName);
   virtual int NumSlots(void) = 0;
   virtual bool Process(void) = 0;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dvbrecorder.cpp mythtv-0.20-new/libs/libmythtv/dvbrecorder.cpp
--- mythtv-0.20-old/libs/libmythtv/dvbrecorder.cpp	2006-09-03 10:04:19.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/dvbrecorder.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -92,6 +92,8 @@
       dvbchannel(advbchannel),
       _stream_data(NULL),
       _reset_pid_filters(true),
+      _open_pid_filters(0),
+      _max_pid_filters(0x1 << 13),
       _pid_lock(true),
       _input_pat(NULL),
       _input_pmt(NULL),
@@ -313,15 +315,20 @@
     PIDInfoMap::iterator it;
     for (it = _pid_infos.begin(); it != _pid_infos.end(); ++it)
     {
-        (*it)->Close();
+        _open_pid_filters = (*it)->Close(_open_pid_filters);
         delete *it;
     }
     _pid_infos.clear();
     _eit_pids.clear();
+    _open_pid_filters = 0;
+    _max_pid_filters  = 0x1 << 13;
 }
 
 int DVBRecorder::OpenFilterFd(uint pid, int pes_type, uint stream_type)
 {
+    if (_open_pid_filters >= _max_pid_filters)
+        return -1;
+
     // bits per millisecond
     uint bpms = (StreamID::IsVideo(stream_type)) ? 19200 : 500;
     // msec of buffering we want
@@ -342,6 +349,7 @@
     if (fd_tmp < 0)
     {
         VERBOSE(VB_IMPORTANT, LOC_ERR + "Could not open demux device." + ENO);
+        _max_pid_filters = _open_pid_filters;
         return -1;
     }
 
@@ -377,9 +385,11 @@
         close(fd_tmp);
 
         VERBOSE(VB_IMPORTANT, LOC_ERR + "Failed to set demux filter." + ENO);
+        _max_pid_filters = _open_pid_filters;
         return -1;
     }
 
+    _open_pid_filters++;
     return fd_tmp;
 }
 
@@ -403,58 +413,63 @@
         if (info->pesType == pes_type)
             fd_tmp = info->filter_fd;
         else
-            info->Close();
+            _open_pid_filters = info->Close(_open_pid_filters);
+
+        _pid_infos.erase(it);
+        delete info;
     }
 
     if (fd_tmp < 0)
+    {
         fd_tmp = OpenFilterFd(pid, pes_type, stream_type);
 
-    // try to close a low priority filter
-    if (fd_tmp < 0)
-    {
-        // no free filters available
-        avail = false;
-        PIDInfoMap::iterator lp_it = _pid_infos.begin();
-        for (;lp_it != _pid_infos.end(); ++lp_it)
+        if (fd_tmp < 0)
         {
-            if (lp_it != it && (*lp_it)->priority < kFilterPriorityHigh)
+            // no free filters, try to close a low priority filter
+            avail = false;
+            int min_priority = kFilterPriorityHigh;
+            PIDInfoMap::iterator min_it;
+
+            PIDInfoMap::iterator lp_it = _pid_infos.begin();
+            for (; lp_it != _pid_infos.end(); ++lp_it)
             {
-                (*lp_it)->Close();
-                break;
+                if ((*lp_it)->priority < kFilterPriorityHigh)
+                {
+                    (*lp_it)->priority--;
+                    if ((*lp_it)->priority < min_priority)
+                    {
+                        min_priority = (*lp_it)->priority;
+                        min_it = lp_it;
+                    }
+                }
             }
-        }
-        if (lp_it != _pid_infos.end())
-        {
-            // PMT PIDs are the only low priority pids
-            uint lp_pid = lp_it.key();
 
-            VERBOSE(VB_RECORD, LOC + "Closing low priority PID filter " +
-                    QString("on PID 0x%1.").arg(lp_pid, 0, 16));
+            if (min_priority < kFilterPriorityHigh)
+            {
+                _open_pid_filters = (*min_it)->Close(_open_pid_filters);
+
+                VERBOSE(VB_RECORD, LOC + "Closing low priority PID filter "
+                        + QString("on PID 0x%1.").arg(min_it.key(), 0, 16));
 
-            _pmt_monitoring_pids.push_back(lp_pid);
-            delete *lp_it;
-            _pid_infos.erase(lp_it);
+                // PMT PIDs are the only low priority pids
+                _pmt_monitoring_pids.push_back(min_it.key());
+                delete *min_it;
+                _pid_infos.erase(min_it);
+            }
+            else
+            {
+                VERBOSE(VB_IMPORTANT, LOC_ERR + "Out of PID filters!");
+                return false;
+            }
 
             fd_tmp = OpenFilterFd(pid, pes_type, stream_type);
         }
-        else
-        {
-            VERBOSE(VB_RECORD, LOC_ERR + "Out of PID filters!");
-        }
     }
 
     if (fd_tmp < 0)
-    {
-        if (info)
-        {
-            delete *it;
-            _pid_infos.erase(it);
-        }
-        return avail;
-    }
-
-    if (!info)
-        info = new PIDInfo();
+        return false;
+    
+    info = new PIDInfo();
 
     // Add the file descriptor to the filter list
     info->filter_fd  = fd_tmp;
@@ -564,7 +579,7 @@
         // Delete pids we are no longer interested in
         _stream_data->RemoveListeningPID(it.key());
         _stream_data->RemoveWritingPID(it.key());
-        (*it)->Close();
+        _open_pid_filters = (*it)->Close(_open_pid_filters);
         delete *it;
         _pid_infos.erase(it);
     }
@@ -639,7 +654,7 @@
     if (VB_RECORD & print_verbose_messages)
     {
         QString tmp0 = ""; 
-        QString tmp1 = QString("%1 PID filters open.").arg(_pid_infos.size());
+        QString tmp1 = QString("%1 PID filters open.").arg(_open_pid_filters);
 
         int sz = _pmt_monitoring_pids.size();
         if (sz)
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dvbrecorder.h mythtv-0.20-new/libs/libmythtv/dvbrecorder.h
--- mythtv-0.20-old/libs/libmythtv/dvbrecorder.h	2006-08-25 08:46:10.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/dvbrecorder.h	2007-04-17 10:23:32.000000000 -0700
@@ -43,7 +43,7 @@
     int    priority;          ///< filters with priority < 0 can be closed
                               //   if a new filter can't be opened
 
-    inline void Close(void);
+    inline uint Close(uint open_filters);
     inline bool CheckCC(uint cc);
 };
 typedef QMap<uint,PIDInfo*> PIDInfoMap;
@@ -134,6 +134,8 @@
     /// Set when we want to generate a new filter set
     MPEGStreamData *_stream_data;
     bool            _reset_pid_filters;
+    uint            _open_pid_filters;
+    uint            _max_pid_filters;
     QMutex          _pid_lock;
     PIDInfoMap      _pid_infos;
     uint_vec_t      _eit_pids;
@@ -186,10 +188,15 @@
     static const int kFilterPriorityLow;
 };
 
-inline void PIDInfo::Close(void)
+inline uint PIDInfo::Close(uint open_filters)
 {
     if (filter_fd >= 0)
+    {
         close(filter_fd);
+        return open_filters - 1;
+    }
+
+    return open_filters;
 }
 
 inline bool PIDInfo::CheckCC(uint new_cnt)
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dvbtypes.cpp mythtv-0.20-new/libs/libmythtv/dvbtypes.cpp
--- mythtv-0.20-old/libs/libmythtv/dvbtypes.cpp	2006-07-18 05:35:04.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/dvbtypes.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -8,317 +8,6 @@
 static QString mod2dbstr(fe_modulation mod);
 static QString coderate(fe_code_rate_t coderate);
 
-DVBParamHelper<PolarityValues>::Table DVBPolarity::parseTable[] =
-{
-    {"v",Vertical},
-    {"h",Horizontal},
-    {"r",Right},
-    {"l",Left},
-    {NULL,Vertical}
-};
-
-char *DVBPolarity::stringLookup[] =
-{
-   "v",   // Vertical
-   "h",   // Horizontal
-   "r",   // Right
-   "l"    // Left
-};
-
-DVBParamHelper<fe_spectral_inversion_t>::Table DVBInversion::confTable[] =
-{
-   {"INVERSION_AUTO",INVERSION_AUTO},
-   {"INVERSION_OFF",INVERSION_OFF},
-   {"INVERSION_ON",INVERSION_ON},
-   {NULL,INVERSION_AUTO}
-};
-
-DVBParamHelper<fe_spectral_inversion_t>::Table DVBInversion::vdrTable[] =
-{
-   {"999",INVERSION_AUTO},
-   {"0",INVERSION_OFF},
-   {"1",INVERSION_ON},
-   {NULL,INVERSION_AUTO}
-};
-
-DVBParamHelper<fe_spectral_inversion_t>::Table DVBInversion::parseTable[] =
-{
-   {"a",INVERSION_AUTO},
-   {"0",INVERSION_OFF},
-   {"1",INVERSION_ON},
-   {NULL,INVERSION_AUTO}
-};
-
-char* DVBInversion::stringLookup[] =
-{
-    "0", // INVERSION_OFF,
-    "1", // INVERSION_ON,
-    "a"  //INVERSION_AUTO
-};
-
-DVBParamHelper<fe_bandwidth_t>::Table DVBBandwidth::confTable[] =
-{
-   {"BANDWIDTH_AUTO",BANDWIDTH_AUTO},
-   {"BANDWIDTH_8_MHZ",BANDWIDTH_8_MHZ},
-   {"BANDWIDTH_7_MHZ",BANDWIDTH_7_MHZ},
-   {"BANDWIDTH_6_MHZ",BANDWIDTH_6_MHZ},
-   {NULL,BANDWIDTH_AUTO}
-};
-
-DVBParamHelper<fe_bandwidth_t>::Table DVBBandwidth::vdrTable[] =
-{
-   {"999",BANDWIDTH_AUTO},
-   {"8",BANDWIDTH_8_MHZ},
-   {"7",BANDWIDTH_7_MHZ},
-   {"6",BANDWIDTH_6_MHZ},
-   {NULL,BANDWIDTH_AUTO},
-};
-
-DVBParamHelper<fe_bandwidth_t>::Table DVBBandwidth::parseTable[] =
-{
-   {"auto",BANDWIDTH_AUTO},
-   {"8",BANDWIDTH_8_MHZ},
-   {"7",BANDWIDTH_7_MHZ},
-   {"6",BANDWIDTH_6_MHZ},
-   {NULL,BANDWIDTH_AUTO}
-};
-
-char *DVBBandwidth::stringLookup[]=
-{
-    "8",   //BANDWIDTH_8_MHZ,
-    "7",   //BANDWIDTH_7_MHZ,
-    "6",   //BANDWIDTH_6_MHZ,
-    "auto" //BANDWIDTH_AUTO
-};
-
-DVBParamHelper<fe_code_rate_t>::Table DVBCodeRate::confTable[] =
-{
-    {"FEC_AUTO",FEC_AUTO},
-    {"FEC_1_2",FEC_1_2},
-    {"FEC_2_3",FEC_2_3},
-    {"FEC_3_4",FEC_3_4},
-    {"FEC_4_5",FEC_4_5},
-    {"FEC_5_6",FEC_5_6},
-    {"FEC_6_7",FEC_6_7},
-    {"FEC_7_8",FEC_7_8},
-    {"FEC_8_9",FEC_8_9},
-    {"FEC_NONE",FEC_NONE},
-    {NULL,FEC_AUTO}
-};
-
-DVBParamHelper<fe_code_rate_t>::Table DVBCodeRate::vdrTable[] =
-{
-    {"999",FEC_AUTO},
-    {"12",FEC_1_2},
-    {"23",FEC_2_3},
-    {"34",FEC_3_4},
-    {"45",FEC_4_5},
-    {"56",FEC_5_6},
-    {"67",FEC_6_7},
-    {"78",FEC_7_8},
-    {"89",FEC_8_9},
-    {"0",FEC_NONE},
-    {NULL,FEC_AUTO}
-};
-
-DVBParamHelper<fe_code_rate_t>::Table DVBCodeRate::parseTable[] =
-{
-    {"auto",FEC_AUTO},
-    {"1/2",FEC_1_2},
-    {"2/3",FEC_2_3},
-    {"3/4",FEC_3_4},
-    {"4/5",FEC_4_5},
-    {"5/6",FEC_5_6},
-    {"6/7",FEC_6_7},
-    {"7/8",FEC_7_8},
-    {"8/9",FEC_8_9},
-    {"none",FEC_NONE},
-    {NULL,FEC_AUTO}
-};
-
-char *DVBCodeRate::stringLookup[] =
-{
-     "none", //FEC_NONE,
-     "1/2",  //FEC_1_2,
-     "2/3",  //FEC_2_3,
-     "3/4",  //FEC_3_4,
-     "4/5",  //FEC_4_5,
-     "5/6",  //FEC_5_6,
-     "6/7",  //FEC_6_7,
-     "7/8",  //FEC_7_8,
-     "8/9",  //FEC_8_9,
-     "auto"  //FEC_AUTO
-};
-
-DVBParamHelper<fe_modulation_t>::Table DVBModulation::confTable[] =
-{
-   {"QAM_AUTO",QAM_AUTO},
-   {"QAM_16",QAM_16},
-   {"QAM_32",QAM_32},
-   {"QAM_64",QAM_64},
-   {"QAM_128",QAM_128},
-   {"QAM_256",QAM_256},
-   {"QPSK",QPSK},
-#ifdef FE_GET_EXTENDED_INFO
-   {"8PSK", MOD_8PSK},
-#endif
-   {NULL,QAM_AUTO},
-};
-
-DVBParamHelper<fe_modulation_t>::Table DVBModulation::vdrTable[] =
-{
-   {"999",QAM_AUTO},
-   {"16",QAM_16},
-   {"32",QAM_32},
-   {"64",QAM_64},
-   {"128",QAM_128},
-   {"256",QAM_256},
-   {"0",QPSK},
-   {NULL,QAM_AUTO},
-};
-
-DVBParamHelper<fe_modulation_t>::Table DVBModulation::parseTable[] =
-{
-   {"auto",QAM_AUTO},
-   {"qam_16",QAM_16},
-   {"qam_32",QAM_32},
-   {"qam_64",QAM_64},
-   {"qam_128",QAM_128},
-   {"qam_256",QAM_256},
-   {"qpsk",QPSK},
-   {"8vsb",VSB_8},
-   {"16vsb",VSB_16},
-#ifdef FE_GET_EXTENDED_INFO
-   {"8psk", MOD_8PSK},
-#endif
-   {NULL,QAM_AUTO},
-};
-
-char *DVBModulation::stringLookup[] =
-{
-    "qpsk",    //QPSK,
-    "qam_16",  //QAM_16,
-    "qam_32",  //QAM_32,
-    "qam_64",  //QAM_64,
-    "qam_128", //QAM_128,
-    "qam_256", //QAM_256,
-    "auto",    //QAM_AUTO,
-    "8vsb",    //VSB_8,
-    "16vsb",   //VSB_16
-#ifdef FE_GET_EXTENDED_INFO
-    "8psk",    //MOD_8PSK
-#endif
-};
-
-DVBParamHelper<fe_transmit_mode_t>::Table DVBTransmitMode::confTable[] =
-{
-   {"TRANSMISSION_MODE_AUTO",TRANSMISSION_MODE_AUTO},
-   {"TRANSMISSION_MODE_2K",TRANSMISSION_MODE_2K},
-   {"TRANSMISSION_MODE_8K",TRANSMISSION_MODE_8K},
-   {NULL,TRANSMISSION_MODE_AUTO},
-};
-
-DVBParamHelper<fe_transmit_mode_t>::Table DVBTransmitMode::vdrTable[] =
-{
-   {"999",TRANSMISSION_MODE_AUTO},
-   {"2",TRANSMISSION_MODE_2K},
-   {"8",TRANSMISSION_MODE_8K},
-   {NULL,TRANSMISSION_MODE_AUTO},
-};
-
-DVBParamHelper<fe_transmit_mode_t>::Table DVBTransmitMode::parseTable[] =
-{
-   {"auto",TRANSMISSION_MODE_AUTO},
-   {"2",TRANSMISSION_MODE_2K},
-   {"8",TRANSMISSION_MODE_8K},
-   {NULL,TRANSMISSION_MODE_AUTO},
-};
-
-char *DVBTransmitMode::stringLookup[] =
-{
-    "2",   //TRANSMISSION_MODE_2K,
-    "8",   //TRANSMISSION_MODE_8K,
-    "auto" //TRANSMISSION_MODE_AUTO
-};
-
-DVBParamHelper<fe_guard_interval_t>::Table DVBGuardInterval::confTable[] =
-{
-   {"GUARD_INTERVAL_AUTO",GUARD_INTERVAL_AUTO},
-   {"GUARD_INTERVAL_1_32",GUARD_INTERVAL_1_32},
-   {"GUARD_INTERVAL_1_16",GUARD_INTERVAL_1_16},
-   {"GUARD_INTERVAL_1_8",GUARD_INTERVAL_1_8},
-   {"GUARD_INTERVAL_1_4",GUARD_INTERVAL_1_4},
-   {NULL,GUARD_INTERVAL_AUTO},
-};
-
-DVBParamHelper<fe_guard_interval_t>::Table DVBGuardInterval::vdrTable[] =
-{
-   {"999",GUARD_INTERVAL_AUTO},
-   {"32",GUARD_INTERVAL_1_32},
-   {"16",GUARD_INTERVAL_1_16},
-   {"8",GUARD_INTERVAL_1_8},
-   {"4",GUARD_INTERVAL_1_4},
-   {NULL,GUARD_INTERVAL_AUTO},
-};
-
-DVBParamHelper<fe_guard_interval_t>::Table DVBGuardInterval::parseTable[] =
-{
-   {"auto",GUARD_INTERVAL_AUTO},
-   {"1/32",GUARD_INTERVAL_1_32},
-   {"1/16",GUARD_INTERVAL_1_16},
-   {"1/8",GUARD_INTERVAL_1_8},
-   {"1/4",GUARD_INTERVAL_1_4},
-   {NULL,GUARD_INTERVAL_AUTO},
-};
-
-char *DVBGuardInterval::stringLookup[] =
-{
-    "1/32", // GUARD_INTERVAL_1_32,
-    "1/16", // GUARD_INTERVAL_1_16,
-    "1/8",  // GUARD_INTERVAL_1_8,
-    "1/4",  // GUARD_INTERVAL_1_4,
-    "auto"  // GUARD_INTERVAL_AUTO
-};
-
-DVBParamHelper<fe_hierarchy_t>::Table DVBHierarchy::confTable[] =
-{
-   {"HIERARCHY_NONE",HIERARCHY_NONE},
-   {"HIERARCHY_1",HIERARCHY_1},
-   {"HIERARCHY_2",HIERARCHY_2},
-   {"HIERARCHY_4",HIERARCHY_4},
-   {"HIERARCHY_AUTO",HIERARCHY_AUTO},
-   {NULL,HIERARCHY_AUTO},
-};
-
-DVBParamHelper<fe_hierarchy_t>::Table DVBHierarchy::vdrTable[] =
-{
-   {"0",HIERARCHY_NONE},
-   {"1",HIERARCHY_1},
-   {"2",HIERARCHY_2},
-   {"4",HIERARCHY_4},
-   {"999",HIERARCHY_AUTO},
-   {NULL,HIERARCHY_AUTO},
-};
-
-DVBParamHelper<fe_hierarchy_t>::Table DVBHierarchy::parseTable[] =
-{
-   {"n",HIERARCHY_NONE},
-   {"1",HIERARCHY_1},
-   {"2",HIERARCHY_2},
-   {"4",HIERARCHY_4},
-   {"a",HIERARCHY_AUTO},
-   {NULL,HIERARCHY_AUTO},
-};
-
-char *DVBHierarchy::stringLookup[] =
-{
-    "n", //HIERARCHY_NONE,
-    "1", //HIERARCHY_1,
-    "2", //HIERARCHY_2,
-    "4", //HIERARCHY_4,
-    "a"  //HIERARCHY_AUTO
-};
-
 bool equal_qpsk(const struct dvb_fe_params &p,
                 const struct dvb_fe_params &op, uint range)
 {
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/dvbtypes.h mythtv-0.20-new/libs/libmythtv/dvbtypes.h
--- mythtv-0.20-old/libs/libmythtv/dvbtypes.h	2006-07-18 05:35:04.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/dvbtypes.h	2007-04-17 10:23:33.000000000 -0700
@@ -67,225 +67,6 @@
 QString toString(fe_status);
 QString toString(const struct dvb_frontend_event&, const fe_type_t);
 
-//The following are a set of helper classes to allow easy translation
-//between the actual dvb enums and db strings.
-
-//Helper abstract template to do some of the mundain bits
-//of translating the DVBParamHelpers
-template <typename V> class DVBParamHelper 
-{
-protected:
-    V value;
-
-    struct Table
-    {
-        QString symbol;
-        V value;
-    };
-
-    static bool parseParam(QString& symbol, V& value, Table *table)
-    {
-        Table *p = table;
-        while (p->symbol!=NULL)
-        {
-            if (p->symbol==symbol.left(p->symbol.length()))
-            {
-                 symbol=symbol.mid(p->symbol.length());
-                 value = p->value;
-                 return true;
-            }
-            p++;
-        }
-        return false;
-    }
-
-public:
-    DVBParamHelper(V _value) : value(_value) {}
-
-    operator V() const { return value; }
-    V operator=(V _value) {return value = _value;}
-    bool operator==(const V& v) const {return value == v;}
-};
-
-class DVBInversion : public DVBParamHelper<fe_spectral_inversion_t>
-{
-protected:
-    static Table confTable[];
-    static Table vdrTable[];
-    static Table parseTable[];
-    static char* stringLookup[];
-
-public:
-    DVBInversion() : DVBParamHelper<fe_spectral_inversion_t>(INVERSION_AUTO) {}
-    bool parseConf(QString& _value) 
-           {return parseParam(_value,value,confTable);}
-    bool parseVDR(QString& _value)
-           {return parseParam(_value,value,vdrTable);}
-    bool parse(QString& _value)
-           {return parseParam(_value,value,parseTable);}
-
-    QString toString() const {return toString(value);}
-    static QString toString(fe_spectral_inversion_t _value)
-           {return stringLookup[_value];}
-};
-
-class DVBBandwidth : public DVBParamHelper<fe_bandwidth_t>
-{
-protected:
-    static Table confTable[];
-    static Table vdrTable[];
-    static Table parseTable[];
-    static char* stringLookup[];
-
-public:
-    DVBBandwidth() : DVBParamHelper<fe_bandwidth_t>(BANDWIDTH_AUTO) {}
-    bool parseConf(QString& _value) 
-           {return parseParam(_value,value,confTable);}
-    bool parseVDR(QString& _value)
-           {return parseParam(_value,value,vdrTable);}
-    bool parse(QString& _value)
-           {return parseParam(_value,value,parseTable);}
-
-    QString toString() const {return toString(value);}
-    static QString toString(fe_bandwidth_t _value)
-           {return stringLookup[_value];}
-};
-
-class DVBCodeRate : public DVBParamHelper<fe_code_rate_t>
-{
-protected:
-    static Table confTable[];
-    static Table vdrTable[];
-    static Table parseTable[];
-    static char* stringLookup[];
-
-public:
-    DVBCodeRate() : DVBParamHelper<fe_code_rate_t>(FEC_AUTO) {}
-
-    bool parseConf(QString& _value) 
-           {return parseParam(_value,value,confTable);}
-    bool parseVDR(QString& _value)
-           {return parseParam(_value,value,vdrTable);}
-    bool parse(QString& _value)
-           {return parseParam(_value,value,parseTable);}
-
-    QString toString() const {return toString(value);}
-    static QString toString(fe_code_rate_t _value)
-           {return stringLookup[_value];}
-};
-
-class DVBModulation : public DVBParamHelper<fe_modulation_t>
-{
-protected:
-    static Table confTable[];
-    static Table vdrTable[];
-    static Table parseTable[];
-    static char* stringLookup[];
-
-public:
-    DVBModulation() : DVBParamHelper<fe_modulation_t>(QAM_AUTO) {}
-
-    bool parseConf(QString& _value) 
-           {return parseParam(_value,value,confTable);}
-    bool parseVDR(QString& _value)
-           {return parseParam(_value,value,vdrTable);}
-    bool parse(QString& _value)
-           {return parseParam(_value,value,parseTable);}
-
-    QString toString() const {return toString(value);}
-    static QString toString(fe_modulation_t _value)
-           {return stringLookup[_value];}
-};
-
-class DVBTransmitMode : public DVBParamHelper<fe_transmit_mode_t>
-{
-protected:
-    static Table confTable[];
-    static Table vdrTable[];
-    static Table parseTable[];
-    static char* stringLookup[];
-
-public:
-    DVBTransmitMode() : DVBParamHelper<fe_transmit_mode_t>(TRANSMISSION_MODE_AUTO) {}
-
-    bool parseConf(QString& _value) 
-           {return parseParam(_value,value,confTable);}
-    bool parseVDR(QString& _value)
-           {return parseParam(_value,value,vdrTable);}
-    bool parse(QString& _value)
-           {return parseParam(_value,value,parseTable);}
-
-    QString toString() const {return toString(value);}
-    static QString toString(fe_transmit_mode_t _value)
-           {return stringLookup[_value];}
-};
-
-class DVBGuardInterval : public DVBParamHelper<fe_guard_interval_t>
-{
-protected:
-    static Table confTable[];
-    static Table vdrTable[];
-    static Table parseTable[];
-    static char* stringLookup[];
-
-public:
-    DVBGuardInterval() : DVBParamHelper<fe_guard_interval_t>(GUARD_INTERVAL_AUTO) {}
-
-    bool parseConf(QString& _value) 
-           {return parseParam(_value,value,confTable);}
-    bool parseVDR(QString& _value)
-           {return parseParam(_value,value,vdrTable);}
-    bool parse(QString& _value)
-           {return parseParam(_value,value,parseTable);}
-
-    QString toString() const {return toString(value);}
-    static QString toString(fe_guard_interval_t _value)
-           {return stringLookup[_value];}
-};
-
-class DVBHierarchy : public DVBParamHelper<fe_hierarchy_t>
-{
-protected:
-    static Table confTable[];
-    static Table vdrTable[];
-    static Table parseTable[];
-    static char* stringLookup[];
-
-public:
-    DVBHierarchy() : DVBParamHelper<fe_hierarchy_t>(HIERARCHY_AUTO) {}
-
-    bool parseConf(QString& _value) 
-           {return parseParam(_value,value,confTable);}
-    bool parseVDR(QString& _value)
-           {return parseParam(_value,value,vdrTable);}
-    bool parse(QString& _value)
-           {return parseParam(_value,value,parseTable);}
-
-    QString toString() const {return toString(value);}
-    static QString toString(fe_hierarchy_t _value)
-           {return stringLookup[_value];}
-};
-
-enum PolarityValues {Vertical,Horizontal,Right,Left};
-class DVBPolarity : public DVBParamHelper<PolarityValues>
-{
-protected:
-    static Table parseTable[];
-    static char* stringLookup[];
-public:
-    DVBPolarity() :  DVBParamHelper<PolarityValues>(Vertical) { }
-
-    bool parseConf(QString& _value) 
-           {return parseParam(_value,value,parseTable);}
-    bool parseVDR(QString& _value)
-           {return parseParam(_value,value,parseTable);}
-    bool parse(QString& _value)
-           {return parseParam(_value,value,parseTable);}
-
-    QString toString() const {return toString(value);}
-    static QString toString(PolarityValues _value) 
-           {return stringLookup[_value];}
-};
 
 typedef vector<uint16_t> dvb_pid_t;
 // needs to add provider id so dvbcam doesnt require parsing
@@ -398,7 +179,6 @@
                     const QString& pol,            const QString& modulation);
 #endif
 
-  private:
     bool ParseTuningParams(
         fe_type_t type,
         QString frequency,    QString inversion,      QString symbolrate,
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/DVDRingBuffer.cpp mythtv-0.20-new/libs/libmythtv/DVDRingBuffer.cpp
--- mythtv-0.20-old/libs/libmythtv/DVDRingBuffer.cpp	2006-08-28 10:11:08.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/DVDRingBuffer.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -315,7 +315,7 @@
                 ClearSubtitlesOSD();
 
                 if (autoselectsubtitle)
-                    curSubtitleTrack = dvdnav_get_active_spu_stream(dvdnav) & 0x1F;
+                    curSubtitleTrack = dvdnav_get_active_spu_stream(dvdnav);
 
                 if (parent)
                 {
@@ -802,6 +802,34 @@
                 decode_rle(bitmap + w, w * 2, w, h / 2,
                             spu_pkt, offset2 * 2, buf_size);
                 guess_palette(sub->rects[0].rgba_palette, palette, alpha);
+                if (!IsInMenu() && y1 < 5)
+                {
+                    uint8_t *tmp_bitmap;
+                    int sy;
+                    bool found = false;
+                    for (sy = 0; sy < h && !found; ++sy)
+                    {
+                        for (int tmpx = 0; tmpx < w; ++tmpx)
+                        {
+                            const uint8_t color = bitmap[sy * w + tmpx];
+                            if (color > 0)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+                    
+                    int newh = h - sy;
+                    tmp_bitmap = (uint8_t*) av_malloc(w * newh);
+                    memcpy(tmp_bitmap, bitmap + (w * sy), (w * newh));
+                    av_free(bitmap);
+                    y1 = sy + y1;
+                    h = newh;
+                    bitmap = (uint8_t*) av_malloc(w * h);
+                    memcpy(bitmap, tmp_bitmap, (w * h));
+                    av_free(tmp_bitmap);
+                }
                 sub->rects[0].bitmap = bitmap;
                 sub->rects[0].x = x1;
                 sub->rects[0].y = y1;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/DVDRingBuffer.h mythtv-0.20-new/libs/libmythtv/DVDRingBuffer.h
--- mythtv-0.20-old/libs/libmythtv/DVDRingBuffer.h	2006-08-08 12:05:25.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/DVDRingBuffer.h	2007-04-17 10:23:33.000000000 -0700
@@ -147,7 +147,7 @@
     /// menu pkt pts is not reliable
     long long      menupktpts;
     int            curAudioTrack;
-    int            curSubtitleTrack;
+    int8_t         curSubtitleTrack;
     bool           autoselectaudio;
     bool           autoselectsubtitle;
     const char     *dvdname;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/eithelper.cpp mythtv-0.20-new/libs/libmythtv/eithelper.cpp
--- mythtv-0.20-old/libs/libmythtv/eithelper.cpp	2006-07-18 03:25:23.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/eithelper.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -1,5 +1,8 @@
 // -*- Mode: c++ -*-
 
+// Std C headers
+#include <time.h>
+
 // Std C++ headers
 #include <algorithm>
 using namespace std;
@@ -215,6 +218,9 @@
     fix |= fixup[(((uint64_t)eit->TSID()) << 32) |
                  (eit->OriginalNetworkID() << 16)];
     fix |= fixup[(eit->OriginalNetworkID() << 16) | eit->ServiceID()];
+    fix |= fixup[(((uint64_t)eit->TSID()) << 32) |
+                 (uint64_t)(eit->OriginalNetworkID() << 16) |
+		 (uint64_t)eit->ServiceID()];
     fix |= EITFixUp::kFixGenericDVB;
 
     uint networkid = eit->OriginalNetworkID();
@@ -364,8 +370,22 @@
         return;
 
     QDateTime starttime;
-    int off = secs_Between_1Jan1970_6Jan1980 + gps_offset + utc_offset;
-    starttime.setTime_t(off + event.start_time, Qt::LocalTime);
+    time_t off = secs_Between_1Jan1970_6Jan1980 + gps_offset + utc_offset;
+    time_t tmp = event.start_time + off;
+    tm result;
+
+    if (gmtime_r(&tmp, &result))
+    {
+        starttime.setDate(QDate(result.tm_year + 1900,
+                                result.tm_mon + 1,
+                                result.tm_mday));
+        starttime.setTime(QTime(result.tm_hour, result.tm_min, result.tm_sec));
+    }
+    else
+    {
+        starttime.setTime_t(tmp - utc_offset, Qt::LocalTime);
+    }
+
     EITFixUp::TimeFix(starttime);
     QDateTime endtime = starttime.addSecs(event.length);
 
@@ -515,9 +535,37 @@
     fix[ 4096 << 16] = EITFixUp::kFixAUStar;
     fix[ 4096 << 16] = EITFixUp::kFixAUStar;
 
-    fix[ 769LL << 32 | 8468 << 16] = EITFixUp::kEFixPro7Sat; // DVB-T Berlin
-    fix[3075LL << 32 | 8468 << 16] = EITFixUp::kEFixPro7Sat; // DVB-T Bremen
-    fix[                133 << 16] = EITFixUp::kEFixPro7Sat; // Premiere and pro7/Sat.1 
+    fix[  769LL << 32 | 8468 << 16] = EITFixUp::kEFixPro7Sat; // DVB-T Berlin
+    fix[ 3074LL << 32 | 8468 << 16] = EITFixUp::kEFixPro7Sat; // DVB-T Hamburg
+    fix[ 3075LL << 32 | 8468 << 16] = EITFixUp::kEFixPro7Sat; // DVB-T Bremen
+    fix[ 8705LL << 32 | 8468 << 16] = EITFixUp::kEFixPro7Sat; // DVB-T Hessen
+    fix[13057LL << 32 | 8468 << 16] = EITFixUp::kEFixPro7Sat; // DVB-T Munich
+
+    // DVB-C germany: Kabel Deutschland encoding fixes
+    fix[   112LL << 32 | 61441U << 16] = EITFixUp::kEFixPro7Sat;
+    fix[ 10000LL << 32 | 61441U << 16] = EITFixUp::kEFixPro7Sat;
+    fix[ 10001LL << 32 | 61441U << 16] = EITFixUp::kEFixPro7Sat;
+    fix[ 10002LL << 32 | 61441U << 16] = EITFixUp::kEFixPro7Sat;
+    fix[ 10003LL << 32 | 61441U << 16] = EITFixUp::kEFixPro7Sat;
+    fix[ 10004LL << 32 | 61441U << 16] = EITFixUp::kEFixPro7Sat;
+    fix[ 10005LL << 32 | 61441U << 16] = EITFixUp::kEFixPro7Sat;
+    fix[ 10006LL << 32 | 61441U << 16] = EITFixUp::kEFixPro7Sat;
+    fix[ 10008LL << 32 | 61441U << 16] = EITFixUp::kEFixPro7Sat;
+    fix[ 10009LL << 32 | 61441U << 16] = EITFixUp::kEFixPro7Sat;
+    // on the multiplex with RTL only following channels must be fixed
+    fix[ 10007LL << 32 | 61441U << 16 | 53605] = EITFixUp::kEFixPro7Sat; //terranova
+    fix[ 10007LL << 32 | 61441U << 16 | 53607] = EITFixUp::kEFixPro7Sat; //Eurosport
+    fix[ 10007LL << 32 | 61441U << 16 | 53608] = EITFixUp::kEFixPro7Sat; //Das Vierte
+    fix[ 10007LL << 32 | 61441U << 16 | 53609] = EITFixUp::kEFixPro7Sat; //Viva
+
+    fix[ 774LL << 32 | 8468 << 16 | 16392] = EITFixUp::kEFixPro7Sat; //DVB-T Berlin dsf
+    fix[1082LL << 32 |    1 << 16 | 20001] = EITFixUp::kEFixPro7Sat; //DVB-S Pro7 Swiss
+    fix[1082LL << 32 |    1 << 16 | 20002] = EITFixUp::kEFixPro7Sat; //DVB-S Pro7 Austria
+    fix[1082LL << 32 |    1 << 16 | 20003] = EITFixUp::kEFixPro7Sat; //DVB-S Kabel1 Swiss
+    fix[1082LL << 32 |    1 << 16 | 20004] = EITFixUp::kEFixPro7Sat; //DVB-S Kabel1 Austria
+    fix[1082LL << 32 |    1 << 16 | 20005] = EITFixUp::kEFixPro7Sat; //DVB-S Sat.1 Austria
+
+    fix[ 133 << 16] = EITFixUp::kEFixPro7Sat; // Premiere and Pro7/Sat.1
 }
 
 static int calc_eit_utc_offset(void)
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/firewirerecorder.cpp mythtv-0.20-new/libs/libmythtv/firewirerecorder.cpp
--- mythtv-0.20-old/libs/libmythtv/firewirerecorder.cpp	2006-06-07 16:29:38.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/firewirerecorder.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -25,7 +25,7 @@
 const int FirewireRecorder::kBroadcastChannel    = 63;
 const int FirewireRecorder::kConnectionP2P       = 0;
 const int FirewireRecorder::kConnectionBroadcast = 1;
-const uint FirewireRecorder::kMaxBufferedPackets = 8000;
+const uint FirewireRecorder::kMaxBufferedPackets = 2000;
 
 // callback function for libiec61883
 int fw_tspacket_handler(unsigned char *tspacket, int /*len*/,
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/frequencies.c mythtv-0.20-new/libs/libmythtv/frequencies.c
--- mythtv-0.20-old/libs/libmythtv/frequencies.c	2006-07-26 07:20:46.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/frequencies.c	2007-04-17 10:23:33.000000000 -0700
@@ -238,268 +238,268 @@
 
 /* US HRC */
 static struct CHANLIST ntsc_hrc[] = {
-    { "1",	  72000 },
+    { "1",	  72004 },
 
-    { "2",	  54000 }, 
-    { "3",	  60000 }, 
-    { "4",	  66000 }, 
-
-    { "5",	  78000 }, 
-    { "6",	  84000 }, 
-
-    { "7",	 174000 },
-    { "8",	 180000 },
-    { "9",	 186000 },
-    { "10",	 192000 },
-    { "11",	 198000 },
-    { "12",	 204000 },
-    { "13",	 210000 },
-    { "14",	 120000 },
-    { "15",	 126000 },
-    { "16",	 132000 },
-    { "17",	 138000 },
-    { "18",	 144000 },
-    { "19",	 150000 },
-    { "20",	 156000 },
-    { "21",	 162000 },
-    { "22",	 168000 },
-    { "23",	 216000 },
-    { "24",	 222000 },
-    { "25",	 228000 },
-    { "26",	 234000 },
-    { "27",	 240000 },
-    { "28",	 246000 },
-    { "29",	 252000 },
-    { "30",	 258000 },
-    { "31",	 264000 },
-    { "32",	 270000 },
-    { "33",	 276000 },
-    { "34",	 282000 },
-    { "35",	 288000 },
-    { "36",	 294000 },
-    { "37",	 300000 },
-    { "38",	 306000 },
-    { "39",	 312000 },
-    { "40",	 318000 },
-    { "41",	 324000 },
-    { "42",	 330000 },
-    { "43",	 336000 },
-    { "44",	 342000 },
-    { "45",	 348000 },
-    { "46",	 354000 },
-    { "47",	 360000 },
-    { "48",	 366000 },
-    { "49",	 372000 },
-    { "50",	 378000 },
-    { "51",	 384000 },
-    { "52",	 390000 },
-    { "53",	 396000 },
-    { "54",	 402000 },
-    { "55",	 408000 },
-    { "56",	 414000 },
-    { "57",	 420000 },
-    { "58",	 426000 },
-    { "59",	 432000 },
-    { "60",	 438000 },
-    { "61",	 444000 },
-    { "62",	 450000 },
-    { "63",	 456000 },
-    { "64",	 462000 },
-    { "65",	 468000 },
-    { "66",	 474000 },
-    { "67",	 480000 },
-    { "68",	 486000 },
-    { "69",	 492000 },
-    { "70",	 498000 },
-    { "71",	 504000 },
-    { "72",	 510000 },
-    { "73",	 516000 },
-    { "74",	 522000 },
-    { "75",	 528000 },
-    { "76",	 534000 },
-    { "77",	 540000 },
-    { "78",	 546000 },
-    { "79",	 552000 },
-    { "80",	 558000 },
-    { "81",	 564000 },
-    { "82",	 570000 },
-    { "83",	 576000 },
-    { "84",	 582000 },
-    { "85",	 588000 },
-    { "86",	 594000 },
-    { "87",	 600000 },
-    { "88",	 606000 },
-    { "89",	 612000 },
-    { "90",	 618000 },
-    { "91",	 624000 },
-    { "92",	 630000 },
-    { "93",	 636000 },
-    { "94",	 642000 },
-
-    { "95",	  90000 },
-    { "96",	  96000 },
-    { "97",	 102000 },
-    { "98",	 108000 },
-    { "99",	 114000 },
-
-    { "100",	 648000 },
-    { "101",	 654000 },
-    { "102",	 660000 },
-    { "103",	 666000 },
-    { "104",	 672000 },
-    { "105",	 678000 },
-    { "106",	 684000 },
-    { "107",	 690000 },
-    { "108",	 696000 },
-    { "109",	 702000 },
-    { "110",	 708000 },
-    { "111",	 714000 },
-    { "112",	 720000 },
-    { "113",	 726000 },
-    { "114",	 732000 },
-    { "115",	 738000 },
-    { "116",	 744000 },
-    { "117",	 750000 },
-    { "118",	 756000 },
-    { "119",	 762000 },
-    { "120",	 768000 },
-    { "121",	 774000 },
-    { "122",	 780000 },
-    { "123",	 786000 },
-    { "124",	 792000 },
-    { "125",	 798000 },
+    { "2",	  54003 }, 
+    { "3",	  60003 }, 
+    { "4",	  66003 }, 
+
+    { "5",	  78004 }, 
+    { "6",	  84004 }, 
+
+    { "7",	 174009 },
+    { "8",	 180009 },
+    { "9",	 186009 },
+    { "10",	 192010 },
+    { "11",	 198010 },
+    { "12",	 204010 },
+    { "13",	 210011 },
+    { "14",	 120006 },
+    { "15",	 126006 },
+    { "16",	 132007 },
+    { "17",	 138007 },
+    { "18",	 144007 },
+    { "19",	 150008 },
+    { "20",	 156008 },
+    { "21",	 162008 },
+    { "22",	 168008 },
+    { "23",	 216011 },
+    { "24",	 222011 },
+    { "25",	 228011 },
+    { "26",	 234012 },
+    { "27",	 240012 },
+    { "28",	 246012 },
+    { "29",	 252013 },
+    { "30",	 258013 },
+    { "31",	 264013 },
+    { "32",	 270014 },
+    { "33",	 276014 },
+    { "34",	 282014 },
+    { "35",	 288014 },
+    { "36",	 294015 },
+    { "37",	 300015 },
+    { "38",	 306015 },
+    { "39",	 312016 },
+    { "40",	 318016 },
+    { "41",	 324016 },
+    { "42",	 330017 },
+    { "43",	 336017 },
+    { "44",	 342017 },
+    { "45",	 348017 },
+    { "46",	 354018 },
+    { "47",	 360018 },
+    { "48",	 366018 },
+    { "49",	 372019 },
+    { "50",	 378019 },
+    { "51",	 384019 },
+    { "52",	 390020 },
+    { "53",	 396020 },
+    { "54",	 402020 },
+    { "55",	 408020 },
+    { "56",	 414021 },
+    { "57",	 420021 },
+    { "58",	 426021 },
+    { "59",	 432022 },
+    { "60",	 438022 },
+    { "61",	 444022 },
+    { "62",	 450023 },
+    { "63",	 456023 },
+    { "64",	 462023 },
+    { "65",	 468023 },
+    { "66",	 474024 },
+    { "67",	 480024 },
+    { "68",	 486024 },
+    { "69",	 492025 },
+    { "70",	 498025 },
+    { "71",	 504025 },
+    { "72",	 510026 },
+    { "73",	 516026 },
+    { "74",	 522026 },
+    { "75",	 528026 },
+    { "76",	 534027 },
+    { "77",	 540027 },
+    { "78",	 546027 },
+    { "79",	 552028 },
+    { "80",	 558028 },
+    { "81",	 564028 },
+    { "82",	 570029 },
+    { "83",	 576029 },
+    { "84",	 582029 },
+    { "85",	 588029 },
+    { "86",	 594030 },
+    { "87",	 600030 },
+    { "88",	 606030 },
+    { "89",	 612031 },
+    { "90",	 618031 },
+    { "91",	 624031 },
+    { "92",	 630032 },
+    { "93",	 636032 },
+    { "94",	 642032 },
+
+    { "95",	  90005 },
+    { "96",	  96005 },
+    { "97",	 102005 },
+    { "98",	 108005 },
+    { "99",	 114006 },
+
+    { "100",	 648032 },
+    { "101",	 654033 },
+    { "102",	 660033 },
+    { "103",	 666033 },
+    { "104",	 672034 },
+    { "105",	 678034 },
+    { "106",	 684034 },
+    { "107",	 690035 },
+    { "108",	 696035 },
+    { "109",	 702035 },
+    { "110",	 708035 },
+    { "111",	 714036 },
+    { "112",	 720036 },
+    { "113",	 726036 },
+    { "114",	 732037 },
+    { "115",	 738037 },
+    { "116",	 744037 },
+    { "117",	 750038 },
+    { "118",	 756038 },
+    { "119",	 762038 },
+    { "120",	 768038 },
+    { "121",	 774039 },
+    { "122",	 780039 },
+    { "123",	 786039 },
+    { "124",	 792040 },
+    { "125",	 798040 },
 };
 
 /** US IRC http://www.jneuhaus.com/fccindex/cablech.html */
 static struct CHANLIST ntsc_irc[] = {
-    { "1",	 73250 },
-    { "2",	 55250 },
-    { "3",	 61250 },
-    { "4",	 67250 },
-    { "5",	 79250 },
-    { "6",	 85250 },
-    { "7",	175250 },
-    { "8",	181250 },
-    { "9",	187250 },
-    { "10",	193250 },
-    { "11",	199250 },
-    { "12",	205250 },
-
-    { "13",	211250 },
-    { "14",	121250 },
-    { "15",	127250 },
-    { "16",	133250 },
-    { "17",	139250 },
-    { "18",	145250 },
-    { "19",	151250 },
-    { "20",	157250 },
+    { "1",	 73263 },
+    { "2",	 55263 },
+    { "3",	 61263 },
+    { "4",	 67263 },
+    { "5",	 79263 },
+    { "6",	 85263 },
+    { "7",	175263 },
+    { "8",	181263 },
+    { "9",	187263 },
+    { "10",	193263 },
+    { "11",	199263 },
+    { "12",	205263 },
+
+    { "13",	211263 },
+    { "14",	121263 },
+    { "15",	127263 },
+    { "16",	133263 },
+    { "17",	139263 },
+    { "18",	145263 },
+    { "19",	151263 },
+    { "20",	157263 },
  
-    { "21",	163250 },
-    { "22",	169250 },
-    { "23",	217250 },
-    { "24",	223250 },
-    { "25",	229250 },
-    { "26",	235250 },
-    { "27",	241250 },
-    { "28",	247250 },
-    { "29",	253250 },
-    { "30",	259250 },
-    { "31",	265250 },
-    { "32",	271250 },
-    { "33",	277250 },
-    { "34",	283250 },
-    { "35",	289250 },
-    { "36",	295250 },
-    { "37",	301250 },
-    { "38",	307250 },
-    { "39",	313250 },
-    { "40",	319250 },
-    { "41",	325250 },
-    { "42",	331250 },
-    { "43",	337250 },
-    { "44",	343250 },
-    { "45",	349250 },
-    { "46",	355250 },
-    { "47",	361250 },
-    { "48",	367250 },
-    { "49",	373250 },
-    { "50",	379250 },
-    { "51",	385250 },
-    { "52",	391250 },
-    { "53",	397250 },
-    { "54",	403250 },
-    { "55",	409250 },
-    { "56",	415250 },
-    { "57",	421250 },
-    { "58",	427250 },
-    { "59",	433250 },
-    { "60",	439250 },
-    { "61",	445250 },
-    { "62",	451250 },
-    { "63",	457250 },
-    { "64",	463250 },
-    { "65",	469250 },
-    { "66",	475250 },
-    { "67",	481250 },
-    { "68",	487250 },
-    { "69",	493250 },
+    { "21",	163263 },
+    { "22",	169263 },
+    { "23",	217263 },
+    { "24",	223263 },
+    { "25",	229263 },
+    { "26",	235263 },
+    { "27",	241263 },
+    { "28",	247263 },
+    { "29",	253263 },
+    { "30",	259263 },
+    { "31",	265263 },
+    { "32",	271263 },
+    { "33",	277263 },
+    { "34",	283263 },
+    { "35",	289263 },
+    { "36",	295263 },
+    { "37",	301263 },
+    { "38",	307263 },
+    { "39",	313263 },
+    { "40",	319263 },
+    { "41",	325263 },
+    { "42",	331275 },
+    { "43",	337263 },
+    { "44",	343263 },
+    { "45",	349263 },
+    { "46",	355263 },
+    { "47",	361263 },
+    { "48",	367263 },
+    { "49",	373263 },
+    { "50",	379263 },
+    { "51",	385263 },
+    { "52",	391263 },
+    { "53",	397263 },
+    { "54",	403263 },
+    { "55",	409263 },
+    { "56",	415263 },
+    { "57",	421263 },
+    { "58",	427263 },
+    { "59",	433263 },
+    { "60",	439263 },
+    { "61",	445263 },
+    { "62",	451263 },
+    { "63",	457263 },
+    { "64",	463263 },
+    { "65",	469263 },
+    { "66",	475263 },
+    { "67",	481263 },
+    { "68",	487263 },
+    { "69",	493263 },
  
-    { "70",	499250 },
-    { "71",	505250 },
-    { "72",	511250 },
-    { "73",	517250 },
-    { "74",	523250 },
-    { "75",	529250 },
-    { "76",	535250 },
-    { "77",	541250 },
-    { "78",	547250 },
-    { "79",	553250 },
-    { "80",	559250 },
-    { "81",	565250 },
-    { "82",	571250 },
-    { "83",	577250 },
-    { "84",	583250 },
-    { "85",	589250 },
-    { "86",	595250 },
-    { "87",	601250 },
-    { "88",	607250 },
-    { "89",	613250 },
-    { "90",	619250 },
-    { "91",	625250 },
-    { "92",	631250 },
-    { "93",	637250 },
-    { "94",	643250 },
-    { "95",	 91250 },
-    { "96",	 97250 },
-    { "97",	103250 },
-    { "98",	109250 },
-    { "99",	115250 },
-    { "100",	649250 },
-    { "101",	655250 },
-    { "102",	661250 },
-    { "103",	667250 },
-    { "104",	673250 },
-    { "105",	679250 },
-    { "106",	685250 },
-    { "107",	691250 },
-    { "108",	697250 },
-    { "109",	703250 },
-    { "110",	709250 },
-    { "111",	715250 },
-    { "112",	721250 },
-    { "113",	727250 },
-    { "114",	733250 },
-    { "115",	739250 },
-    { "116",	745250 },
-    { "117",	751250 },
-    { "118",	757250 },
-    { "119",	763250 },
-    { "120",	769250 },
-    { "121",	775250 },
-    { "122",	781250 },
-    { "123",	787250 },
-    { "124",	793250 },
-    { "125",	799250 },
+    { "70",	499263 },
+    { "71",	505263 },
+    { "72",	511263 },
+    { "73",	517263 },
+    { "74",	523263 },
+    { "75",	529263 },
+    { "76",	535263 },
+    { "77",	541263 },
+    { "78",	547263 },
+    { "79",	553263 },
+    { "80",	559263 },
+    { "81",	565263 },
+    { "82",	571263 },
+    { "83",	577263 },
+    { "84",	583263 },
+    { "85",	589263 },
+    { "86",	595263 },
+    { "87",	601263 },
+    { "88",	607263 },
+    { "89",	613263 },
+    { "90",	619263 },
+    { "91",	625263 },
+    { "92",	631263 },
+    { "93",	637263 },
+    { "94",	643263 },
+    { "95",	 91263 },
+    { "96",	 97263 },
+    { "97",	103263 },
+    { "98",	109275 },
+    { "99",	115275 },
+    { "100",	649263 },
+    { "101",	655263 },
+    { "102",	661263 },
+    { "103",	667263 },
+    { "104",	673263 },
+    { "105",	679263 },
+    { "106",	685263 },
+    { "107",	691263 },
+    { "108",	697263 },
+    { "109",	703263 },
+    { "110",	709263 },
+    { "111",	715263 },
+    { "112",	721263 },
+    { "113",	727263 },
+    { "114",	733263 },
+    { "115",	739263 },
+    { "116",	745263 },
+    { "117",	751263 },
+    { "118",	757263 },
+    { "119",	763263 },
+    { "120",	769263 },
+    { "121",	775263 },
+    { "122",	781263 },
+    { "123",	787263 },
+    { "124",	793263 },
+    { "125",	799263 },
 };
 
 /* --------------------------------------------------------------------- */
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/frequencytables.cpp mythtv-0.20-new/libs/libmythtv/frequencytables.cpp
--- mythtv-0.20-old/libs/libmythtv/frequencytables.cpp	2006-08-16 15:36:37.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/frequencytables.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -55,6 +55,51 @@
 }
 #endif // USING_DVB
 
+
+TransportScanItem::TransportScanItem(int                 _sourceid,
+                                     const QString      &_std,
+                                     const QString      &_name,
+                                     const QString      &_cardtype,
+                                     const DTVTransport &_tuning,
+                                     uint                _timeoutTune)
+    : mplexid(-1),         standard(_std),
+      FriendlyName(_name), friendlyNum(0),
+      SourceID(_sourceid), UseTimer(false),
+      scanning(false),     timeoutTune(_timeoutTune)
+{
+    (void) _cardtype;
+
+    bzero(freq_offsets, sizeof(int) * 3);
+    expectedChannels = _tuning.channels;
+
+#ifdef USING_DVB
+    bzero(&tuning, sizeof(DVBTuning));
+
+    fe_type type = FE_QPSK;
+
+    type = (_cardtype.upper() == "QAM")    ? FE_QAM    : type;
+    type = (_cardtype.upper() == "OFDM")   ? FE_OFDM   : type;
+    type = (_cardtype.upper() == "ATSC")   ? FE_ATSC   : type;
+#ifdef FE_GET_EXTENDED_INFO
+    type = (_cardtype.upper() == "DVB_S2") ? FE_DVB_S2 : type;
+#endif
+
+    tuning.ParseTuningParams(
+        type,
+        QString::number(_tuning.frequency),  _tuning.inversion.toString(),
+        QString::number(_tuning.symbolrate), _tuning.fec.toString(),
+        _tuning.polarity.toString(),         _tuning.hp_code_rate.toString(),
+        _tuning.lp_code_rate.toString(),     _tuning.constellation.toString(),
+        _tuning.trans_mode.toString(),       _tuning.guard_interval.toString(),
+        _tuning.hierarchy.toString(),        _tuning.modulation.toString(),
+        _tuning.bandwidth.toString());
+
+#else
+    frequency  = _tuning.frequency;
+    modulation = _tuning.modulation;
+#endif
+}
+
 TransportScanItem::TransportScanItem(int sourceid,
                                      const QString &std,
                                      const QString &fn,
@@ -356,67 +401,96 @@
     uint    mod[]    = { VSB_8,    QAM_256,    QAM_128,    QAM_64,   };
     QString desc[]   = { "ATSC ", "QAM-256 ", "QAM-128 ", "QAM-64 ", };
 
-#define FREQ(A,B, C,D, E,F,G, H) \
+#define FREQ(A,B, C,D, E,F,G, H, I) \
     fmap[QString("atsc_%1_us%2").arg(A).arg(B)] = \
-        new FrequencyTable(C+D, E, F, G, 6000000, H);
+        new FrequencyTable(C+D, E, F, G, H, I);
 
     for (uint i = 0; i < 4; i++)
     {
         // USA Cable, ch 2 to 159 and T.7 to T.14
         FREQ(modStr[i], "cable0", desc[i], "Channel %1",
-             2,    57000000,   69000000, mod[i]); // 2-4
+             2,    57000000,   69000000, 6000000, mod[i]); // 2-4
         FREQ(modStr[i], "cable1", desc[i], "Channel %1",
-             5,    79000000,   85000000, mod[i]); // 5-6
+             5,    79000000,   85000000, 6000000, mod[i]); // 5-6
         FREQ(modStr[i], "cable2", desc[i], "Channel %1",
-             7,   177000000,  213000000, mod[i]); // 7-13
+             7,   177000000,  213000000, 6000000, mod[i]); // 7-13
         FREQ(modStr[i], "cable3", desc[i], "Channel %1",
-             14,  123000000,  171000000, mod[i]); // 14-22
+             14,  123000000,  171000000, 6000000, mod[i]); // 14-22
         FREQ(modStr[i], "cable4", desc[i], "Channel %1",
-             23,  219000000,  645000000, mod[i]); // 23-94
+             23,  219000000,  645000000, 6000000, mod[i]); // 23-94
         FREQ(modStr[i], "cable5", desc[i], "Channel %1",
-             95,   93000000,  117000000, mod[i]); // 95-99
+             95,   93000000,  117000000, 6000000, mod[i]); // 95-99
+        // The center frequency of any EIA-542 std cable channel over 99 is
+        // Frequency_MHz = ( 6 * ( 8 + channel_designation ) ) + 3
         FREQ(modStr[i], "cable6", desc[i], "Channel %1",
-             100, 651000000, 1005000000, mod[i]); // 100-159
+             100, 651000000, 1005000000, 6000000, mod[i]); // 100-159
         FREQ(modStr[i], "cable7", desc[i], "Channel T-%1",
-             7,    8750000,   50750000, mod[i]); // T7-14
+             7,    8750000,   50750000, 6000000, mod[i]); // T7-14
 
         // USA Cable, QAM 256 ch 78 to 159
         FREQ(modStr[i], "cablehigh0", desc[i], "Channel %1",
-             78,  549000000,  645000000, mod[i]); // 78-94
+             78,  549000000,  645000000, 6000000, mod[i]); // 78-94
         FREQ(modStr[i], "cablehigh1", desc[i], "Channel %1",
-             100, 651000000, 1005000000, mod[i]); // 100-159
-
-        QString std[]   = { "hrc",  "irc"   };
-        QString sdesc[] = { "HRC ", "IRC "  };
-        int     off[]   = { 0,      1250000 };
+             100, 651000000, 1005000000, 6000000, mod[i]); // 100-159
 
-        for (uint j = 0; j < 2; j++)
-        {
-            // USA Cable HRC/IRC, ch 1 to 125
-            FREQ(modStr[i], std[j] + "0", desc[i], sdesc[j] + "%1",
-                 1,    73750000 + off[j],  73750001 + off[j], mod[i]);
-            FREQ(modStr[i], std[j] + "1", desc[i], sdesc[j] + "%1",
-                 2,    55750000 + off[j],  67750000 + off[j], mod[i]);
-            FREQ(modStr[i], std[j] + "2", desc[i], sdesc[j] + "%1",
-                 5,    79750000 + off[j],  85750000 + off[j], mod[i]);
-            FREQ(modStr[i], std[j] + "3", desc[i], sdesc[j] + "%1",
-                 7,   175750000 + off[j], 211750000 + off[j], mod[i]);
-            FREQ(modStr[i], std[j] + "4", desc[i], sdesc[j] + "%1",
-                 14,
-                 121750000 + off[j] - (j ? 100000 : 0),
-                 169750000 + off[j] - (j ? 100000 : 0), mod[i]);
-            FREQ(modStr[i], std[j] + "5", desc[i], sdesc[j] + "%1",
-                 23,  217750000 + off[j], 643750000 + off[j], mod[i]);
-            FREQ(modStr[i], std[j] + "6", desc[i], sdesc[j] + "%1",
-                 95,   91750000 + off[j], 115750000 + off[j], mod[i]);
-            FREQ(modStr[i], std[j] + "7", desc[i], sdesc[j] + "%1",
-                 100, 649750000 + off[j], 799750000 + off[j], mod[i]);
-
-            // USA Cable HRC/IRC, ch 76-125
-            FREQ(modStr[i], std[j] + "high0", desc[i], sdesc[j] + "%1",
-                 76,  535750000 + off[j], 643750000 + off[j], mod[i]);
-            FREQ(modStr[i], std[j] + "high1", desc[i], sdesc[j] + "%1",
-                 100, 649750000 + off[j], 799750000 + off[j], mod[i]);
-        }
+        // USA Cable HRC, ch 1 to 125
+        FREQ(modStr[i], "hrc0", desc[i], "HRC %1",
+             1,    73753600,  73753601, 6000300, mod[i]); // 1
+        FREQ(modStr[i], "hrc1", desc[i], "HRC %1",
+             2,    55752700,  67753300, 6000300, mod[i]); // 2-4
+        FREQ(modStr[i], "hrc2", desc[i], "HRC %1",
+             5,    79753900,  85754200, 6000300, mod[i]); // 5-6
+        FREQ(modStr[i], "hrc3", desc[i], "HRC %1",
+             7,   175758700, 211760500, 6000300, mod[i]); // 7-13
+        FREQ(modStr[i], "hrc4", desc[i], "HRC %1",
+             14,  121756000, 169758400, 6000300, mod[i]); // 14-22
+        FREQ(modStr[i], "hrc5", desc[i], "HRC %1",
+             23,  217760800, 643782100, 6000300, mod[i]); // 23-94
+        FREQ(modStr[i], "hrc6", desc[i], "HRC %1",
+             95,   91754500, 115755700, 6000300, mod[i]); // 95-99
+        // The center frequency of any EIA-542 HRC cable channel over 99 is
+        // Frequency_MHz = ( 6.0003 * ( 8 + channel_designation ) ) + 1.75
+        FREQ(modStr[i], "hrc7", desc[i], "HRC %1",
+             100, 649782400, 799789900, 6000300, mod[i]); // 100-125
+
+        // USA Cable HRC, ch 76-94 and 100-125
+        // Channels 95-99 are low frequency despite high channel numbers
+        FREQ(modStr[i], "hrchigh0", desc[i], "HRC %1",
+             76,  535776700, 643782100, 6000300, mod[i]); // 76-94
+        FREQ(modStr[i], "hrchigh1", desc[i], "HRC %1",
+             100, 649782400, 799789900, 6000300, mod[i]); // 100-125
+
+        // USA Cable IRC, ch 1 to 125
+        FREQ(modStr[i], "irc0", desc[i], "IRC %1",
+             1,    75012500,  75012501, 6000000, mod[i]); // 1
+        FREQ(modStr[i], "irc1", desc[i], "IRC %1",
+             2,    57012500,  69012500, 6000000, mod[i]); // 2-4
+        FREQ(modStr[i], "irc2", desc[i], "IRC %1",
+             5,    81012500,  87012500, 6000000, mod[i]); // 5-6
+        FREQ(modStr[i], "irc3", desc[i], "IRC %1",
+             7,   177012500, 213012500, 6000000, mod[i]); // 7-13
+        FREQ(modStr[i], "irc4", desc[i], "IRC %1",
+             14,  123012500, 171012500, 6000000, mod[i]); // 14-22
+        FREQ(modStr[i], "irc5", desc[i], "IRC %1",
+             23,  219012500, 327012500, 6000000, mod[i]); // 23-41
+        FREQ(modStr[i], "irc6", desc[i], "IRC %1",
+             42,  333025000, 333025001, 6000000, mod[i]); // 42
+        FREQ(modStr[i], "irc7", desc[i], "IRC %1",
+             43,  339012500, 645012500, 6000000, mod[i]); // 43-94
+        FREQ(modStr[i], "irc8", desc[i], "IRC %1",
+             95,   93012500, 105012500, 6000000, mod[i]); // 95-97
+        FREQ(modStr[i], "irc9", desc[i], "IRC %1",
+             98,  111025000, 117025000, 6000000, mod[i]); // 98-99
+        // The center frequency of any EIA-542 IRC cable channel over 99 is
+        // Frequency_MHz = ( 6 * ( 8 + channel_designation ) ) + 3.0125
+        FREQ(modStr[i], "irc10", desc[i], "IRC %1",
+             100, 651012500, 801012500, 6000000, mod[i]); // 100-125
+
+        // USA Cable IRC, ch 76-94 and 100-125
+        // Channels 95-99 are low frequency despite high channel numbers
+        FREQ(modStr[i], "irchigh0", desc[i], "IRC %1",
+             76,  537012500, 645012500, 6000000, mod[i]); // 76-94
+        FREQ(modStr[i], "irchigh1", desc[i], "IRC %1",
+             100, 651012500, 801012500, 6000000, mod[i]); // 100-125
     }
 }
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/frequencytables.h mythtv-0.20-new/libs/libmythtv/frequencytables.h
--- mythtv-0.20-old/libs/libmythtv/frequencytables.h	2006-05-01 09:40:46.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/frequencytables.h	2007-04-17 10:23:33.000000000 -0700
@@ -29,6 +29,7 @@
 #endif // USING_DVB
 
 class FrequencyTable;
+#include "dvbconfparser.h"
 class TransportScanItem;
 
 typedef QMap<QString, const FrequencyTable*> freq_table_map_t;
@@ -130,6 +131,13 @@
                       uint           _timeoutTune);
 #endif // USING_DVB
 
+    TransportScanItem(int                 _sourceid,
+                      const QString      &_std,
+                      const QString      &_name,
+                      const QString      &_cardtype,
+                      const DTVTransport &_tuning,
+                      uint                _timeoutTune);
+
     TransportScanItem(int sourceid,           /* source id in DB */
                       const QString &std,     /* atsc/dvb */
                       const QString &strFmt,  /* fmt for info shown to user  */
@@ -144,6 +152,7 @@
     uint freq_offset(uint i) const;
 
     QString ModulationDB(void) const;
+    QString toString() const;
 
   private:
     int GetMultiplexIdFromDB() const;
@@ -168,7 +177,8 @@
     uint      frequency;        ///< Tuning frequency if mplexid == -1
     uint      modulation;       ///< Tuning frequency if mplexid == -1
 #endif
-    QString toString() const;
+
+    DTVChannelInfoList expectedChannels;
 };
 
 class transport_scan_items_it_t
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/guidegrid.cpp mythtv-0.20-new/libs/libmythtv/guidegrid.cpp
--- mythtv-0.20-old/libs/libmythtv/guidegrid.cpp	2006-09-04 12:00:32.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/guidegrid.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -710,6 +710,9 @@
         m_programInfos[row][x] = NULL;
     }
 
+    if (m_channelInfos.size() == 0)
+        return;
+
     int chanNum = row + m_currentStartChannel;
     if (chanNum >= (int) m_channelInfos.size())
         chanNum -= (int) m_channelInfos.size();
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_config.c mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_config.c
--- mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_config.c	2006-07-25 10:48:19.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_config.c	2007-04-17 10:23:29.000000000 -0700
@@ -18,7 +18,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#include <stdio.h>
 #include "hdhomerun_os.h"
 #include "hdhomerun_pkt.h"
 #include "hdhomerun_discover.h"
@@ -33,6 +32,7 @@
 	printf("\t%s <id|ip> get help\n", appname);
 	printf("\t%s <id|ip> get <item>\n", appname);
 	printf("\t%s <id|ip> set <item> <value>\n", appname);
+	printf("\t%s <id|ip> scan <tuner> <starting channel>\n", appname);
 	printf("\t%s <id|ip> upgrade <filename>\n", appname);
 	return 1;
 }
@@ -234,6 +234,132 @@
 	return 0;
 }
 
+int cmd_scan(struct hdhomerun_control_sock_t *control_sock, const char *tuner_str, const char *start_value)
+{
+	int tuner = atoi(tuner_str);
+
+	/* Test starting channel. */
+	char item[64];
+	sprintf(item, "/tuner%d/channel", tuner);
+	int ret = cmd_set(control_sock, item, start_value);
+	if (ret != 0) {
+		return ret;
+	}
+
+	char channel_value[64];
+	strncpy(channel_value, start_value, sizeof(channel_value));
+	channel_value[sizeof(channel_value) - 8] = 0;
+
+	char *ptr = strrchr(channel_value, ':');
+	if (!ptr) {
+		ptr = channel_value;
+	} else {
+		ptr++;
+	}
+
+	int channel = atol(ptr);
+	if (channel == 0) {
+		fprintf(stderr, "invalid starting channel\n");
+		return 1;
+	}
+
+	while (1) {
+		/* Update channel value */
+		sprintf(ptr, "%d", channel);
+
+		/* Set channel. */
+		sprintf(item, "/tuner%d/channel", tuner);
+		if (hdhomerun_control_send_set_request(control_sock, item, channel_value) < 0) {
+			fprintf(stderr, "communication error sending request to hdhomerun device\n");
+			return 1;
+		}
+	
+		/* Verify set succeeded. */
+		struct hdhomerun_control_data_t result;
+		if (hdhomerun_control_recv(control_sock, &result, 1000) <= 0) {
+			fprintf(stderr, "communication error receiving response from hdhomerun device\n");
+			return 1;
+		}
+		if (result.type != HDHOMERUN_TYPE_GETSET_RPY) {
+			fprintf(stderr, "unexpected reply type from hdhomerun device\n");
+			return 1;
+		}
+		while (result.ptr < result.end) {
+			unsigned char tag;
+			int length;
+			unsigned char *value;
+			if (hdhomerun_read_tlv(&result.ptr, result.end, &tag, &length, &value) < 0) {
+				break;
+			}
+			if (tag == HDHOMERUN_TAG_ERROR_MESSAGE) {
+				return 0;
+			}
+		}
+
+		/* Wait for 1s. */
+		sleep(1);
+
+		/* Get status. */
+		sprintf(item, "/tuner%d/status", tuner);
+		if (hdhomerun_control_send_get_request(control_sock, item) < 0) {
+			fprintf(stderr, "communication error sending request to hdhomerun device\n");
+			return 1;
+		}
+
+		/* Status result. */
+		if (hdhomerun_control_recv(control_sock, &result, 1000) <= 0) {
+			fprintf(stderr, "communication error receiving response from hdhomerun device\n");
+			return 1;
+		}
+		if (result.type != HDHOMERUN_TYPE_GETSET_RPY) {
+			fprintf(stderr, "unexpected reply type from hdhomerun device\n");
+			return 1;
+		}
+		char *status = NULL;
+		while (result.ptr < result.end) {
+			unsigned char tag;
+			int length;
+			unsigned char *value;
+			if (hdhomerun_read_tlv(&result.ptr, result.end, &tag, &length, &value) < 0) {
+				break;
+			}
+			if (tag == HDHOMERUN_TAG_ERROR_MESSAGE) {
+				return 0;
+			}
+			if (tag == HDHOMERUN_TAG_GETSET_VALUE) {
+				status = (char *)value;
+			}
+		}
+		if (!status) {
+			fprintf(stderr, "unexpected reply type from hdhomerun device\n");
+			return 1;
+		}
+
+		/* If no signal then advance to next channel. */
+		char *ss_str = strstr(status, "ss=");
+		if (!ss_str) {
+			printf("%s\n", status);
+			channel++;
+			continue;
+		}
+		int ss = atoi(ss_str + strlen("ss="));
+		if (ss == 0) {
+			printf("%s\n", status);
+			channel++;
+			continue;
+		}
+
+		/* Wait for 2s. */
+		sleep(2);
+
+		/* Display channel status. */
+		cmd_get(control_sock, item);
+
+		/* Advance to next channel. */
+		channel++;
+	}
+}
+
 int cmd_upgrade(struct hdhomerun_control_sock_t *control_sock, const char *filename)
 {
 	FILE *fp = fopen(filename, "rb");
@@ -272,6 +398,7 @@
 		return 1;
 	}
 
+	printf("upgrade complete\n");
 	return 0;
 }
 
@@ -297,6 +424,13 @@
 		return cmd_set(control_sock, argv[0], argv[1]);
 	}
 
+	if (contains(cmd, "scan")) {
+		if (argc < 2) {
+			return help();
+		}
+		return cmd_scan(control_sock, argv[0], argv[1]);
+	}
+
 	if (contains(cmd, "upgrade")) {
 		if (argc < 1) {
 			return help();
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_discover.c mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_discover.c
--- mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_discover.c	2006-07-03 12:12:30.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_discover.c	2007-04-17 10:23:29.000000000 -0700
@@ -22,6 +22,12 @@
 #include "hdhomerun_pkt.h"
 #include "hdhomerun_discover.h"
 
+#if defined(__CYGWIN__)
+#include <windows.h>
+#include <iptypes.h>
+#include <iphlpapi.h>
+#endif
+
 struct hdhomerun_discover_sock_t {
 	int sock;
 };
@@ -71,7 +77,7 @@
 	free(ds);
 }
 
-int hdhomerun_discover_send(struct hdhomerun_discover_sock_t *ds, unsigned long device_type, unsigned long device_id)
+static int hdhomerun_discover_send_packet(struct hdhomerun_discover_sock_t *ds, unsigned long ip_addr, unsigned long device_type, unsigned long device_id)
 {
 	unsigned char buffer[1024];
 	unsigned char *ptr = buffer;
@@ -80,7 +86,7 @@
 	struct sockaddr_in sock_addr;
 	memset(&sock_addr, 0, sizeof(sock_addr));
 	sock_addr.sin_family = AF_INET;
-	sock_addr.sin_addr.s_addr = htonl(INADDR_BROADCAST);
+	sock_addr.sin_addr.s_addr = htonl(ip_addr);
 	sock_addr.sin_port = htons(HDHOMERUN_DISCOVER_UDP_PORT);
 
 	int length = ptr - buffer;
@@ -91,6 +97,115 @@
 	return 0;
 }
 
+#if defined(__CYGWIN__)
+static int hdhomerun_discover_send_internal(struct hdhomerun_discover_sock_t *ds, unsigned long device_type, unsigned long device_id)
+{
+	PIP_ADAPTER_INFO pAdapterInfo = (IP_ADAPTER_INFO *)malloc(sizeof(IP_ADAPTER_INFO));
+	unsigned long ulOutBufLen = sizeof(IP_ADAPTER_INFO);
+
+	DWORD Ret = GetAdaptersInfo(pAdapterInfo, &ulOutBufLen);
+	if (Ret != NO_ERROR) {
+		free(pAdapterInfo);
+		if (Ret != ERROR_BUFFER_OVERFLOW) {
+			return -1;
+		}
+		pAdapterInfo = (IP_ADAPTER_INFO *)malloc(ulOutBufLen); 
+		Ret = GetAdaptersInfo(pAdapterInfo, &ulOutBufLen);
+		if (Ret != NO_ERROR) {
+			free(pAdapterInfo);
+			return -1;
+		}
+	}
+
+	int send_count = 0;
+	PIP_ADAPTER_INFO pAdapter = pAdapterInfo;
+	while (pAdapter) {
+		IP_ADDR_STRING *pIPAddr = &pAdapter->IpAddressList;
+		while (pIPAddr) {
+			unsigned long addr = ntohl(inet_addr(pIPAddr->IpAddress.String));
+			unsigned long mask = ntohl(inet_addr(pIPAddr->IpMask.String));
+			
+			unsigned long broadcast = addr | ~mask;
+			if ((broadcast == 0x00000000) || (broadcast == 0xFFFFFFFF)) {
+				pIPAddr = pIPAddr->Next;
+				continue;
+			}
+
+			hdhomerun_discover_send_packet(ds, broadcast, device_type, device_id);
+			send_count++;
+
+			pIPAddr = pIPAddr->Next;
+		}
+
+		pAdapter = pAdapter->Next;
+	}
+
+	free(pAdapterInfo);
+
+	if (send_count == 0) {
+		return -1;
+	}
+	return 0;
+}
+#endif
+
+#if defined(__linux__)
+static int hdhomerun_discover_send_internal(struct hdhomerun_discover_sock_t *ds, unsigned long device_type, unsigned long device_id)
+{
+	FILE *fp = fopen("/proc/net/route", "r");
+	if (!fp) {
+		return -1;
+	}
+
+	int send_count = 0;
+	while (1) {
+		char line[256];
+		if (!fgets(line, sizeof(line), fp)) {
+			break;
+		}
+		line[255] = 0;
+
+		unsigned long dest;
+		unsigned long mask;
+		if (sscanf(line, "%*s %lx %*x %*x %*d %*d %*d %lx", &dest, &mask) != 2) {
+			continue;
+		}
+		dest = ntohl(dest);
+		mask = ntohl(mask);
+		
+		unsigned long broadcast = dest | ~mask;
+
+		if ((broadcast == 0x00000000) || (broadcast == 0xFFFFFFFF)) {
+			continue;
+		}
+
+		hdhomerun_discover_send_packet(ds, broadcast, device_type, device_id);
+		send_count++;
+	}
+
+	fclose(fp);
+	if (send_count == 0) {
+		return -1;
+	}
+	return 0;
+}
+#endif
+
+#if !defined(__CYGWIN__) && !defined(__linux__)
+static int hdhomerun_discover_send_internal(struct hdhomerun_discover_sock_t *ds, unsigned long device_type, unsigned long device_id)
+{
+	return -1;
+}
+#endif
+
+int hdhomerun_discover_send(struct hdhomerun_discover_sock_t *ds, unsigned long device_type, unsigned long device_id)
+{
+	if (hdhomerun_discover_send_internal(ds, device_type, device_id) < 0) {
+		return hdhomerun_discover_send_packet(ds, 0xFFFFFFFF, device_type, device_id);
+	}
+	return 0;
+}
+
 int hdhomerun_discover_recv(struct hdhomerun_discover_sock_t *ds, struct hdhomerun_discover_device_t *result, unsigned long timeout)
 {
 	struct timeval t;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_os.h mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_os.h
--- mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_os.h	2006-04-17 10:10:52.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_os.h	2007-04-17 10:23:29.000000000 -0700
@@ -19,6 +19,7 @@
  */
 
 #include <stdlib.h>
+#include <stdio.h>
 #include <string.h>
 #include <unistd.h>
 #include <errno.h>
@@ -29,3 +30,10 @@
 #include <netdb.h>
 #include <sys/time.h>
 #include <fcntl.h>
+
+#if !defined(TRUE)
+#define TRUE 1
+#endif
+#if !defined(FALSE)
+#define FALSE 0
+#endif
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_pkt.c mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_pkt.c
--- mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_pkt.c	2006-07-03 12:12:30.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_pkt.c	2007-04-17 10:23:29.000000000 -0700
@@ -182,7 +182,7 @@
 	hdhomerun_write_u16(&ptr, length);
 }
 
-static void hdhomerun_write_crc(unsigned char **pptr, unsigned char *start)
+void hdhomerun_write_crc(unsigned char **pptr, unsigned char *start)
 {
 	unsigned char *ptr = *pptr;
 	unsigned long crc = hdhomerun_calc_crc(start, ptr);
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_pkt.h mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_pkt.h
--- mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_pkt.h	2006-07-03 12:12:30.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_pkt.h	2007-04-17 10:23:29.000000000 -0700
@@ -49,6 +49,7 @@
 extern void hdhomerun_write_u8(unsigned char **pptr, unsigned char v);
 extern void hdhomerun_write_u16(unsigned char **pptr, unsigned short v);
 extern void hdhomerun_write_u32(unsigned char **pptr, unsigned long v);
+extern void hdhomerun_write_crc(unsigned char **pptr, unsigned char *start);
 
 extern int hdhomerun_peek_packet_length(unsigned char *ptr);
 extern int hdhomerun_process_packet(unsigned char **pptr, unsigned char **pend);
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_video.c mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_video.c
--- mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_video.c	2006-07-03 12:12:30.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_video.c	2007-04-17 10:23:29.000000000 -0700
@@ -129,6 +129,11 @@
 	return 1;
 }
 
+int hdhomerun_video_get_sock(struct hdhomerun_video_sock_t *vs)
+{
+	return vs->sock;
+}
+
 static void *hdhomerun_video_thread(void *arg)
 {
 	struct hdhomerun_video_sock_t *vs = (struct hdhomerun_video_sock_t *)arg;
@@ -183,6 +188,18 @@
 	vs->tail = tail;
 }
 
+unsigned long hdhomerun_video_available_length(struct hdhomerun_video_sock_t *vs)
+{
+	unsigned long head = vs->head;
+	unsigned long tail = vs->tail;
+
+	if (head >= tail) {
+		return head - tail - vs->advance;
+	} else {
+		return head + vs->buffer_size - tail - vs->advance;
+	}
+}
+
 unsigned long hdhomerun_video_recv_memcpy(struct hdhomerun_video_sock_t *vs, unsigned char *buffer, unsigned long size)
 {
 	unsigned long head = vs->head;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_video.h mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_video.h
--- mythtv-0.20-old/libs/libmythtv/hdhomerun/hdhomerun_video.h	2006-07-03 12:12:30.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhomerun/hdhomerun_video.h	2007-04-17 10:23:29.000000000 -0700
@@ -30,6 +30,8 @@
 extern void hdhomerun_video_destroy(struct hdhomerun_video_sock_t *vs);
 extern unsigned short hdhomerun_video_get_local_port(struct hdhomerun_video_sock_t *vs);
 extern int hdhomerun_video_get_state(struct hdhomerun_video_sock_t *vs);
+extern int hdhomerun_video_get_sock(struct hdhomerun_video_sock_t *vs);
+extern unsigned long hdhomerun_video_available_length(struct hdhomerun_video_sock_t *vs);
 extern unsigned long hdhomerun_video_recv_memcpy(struct hdhomerun_video_sock_t *vs, unsigned char *buffer, unsigned long size);
 extern unsigned char *hdhomerun_video_recv_inplace(struct hdhomerun_video_sock_t *vs, unsigned long max_size, unsigned long *pactual_size);
 extern void hdhomerun_video_flush(struct hdhomerun_video_sock_t *vs);
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhomerun/Makefile mythtv-0.20-new/libs/libmythtv/hdhomerun/Makefile
--- mythtv-0.20-old/libs/libmythtv/hdhomerun/Makefile	2006-07-03 12:12:30.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhomerun/Makefile	2007-04-17 10:23:29.000000000 -0700
@@ -1,14 +1,19 @@
 
-HDHOMERUN_CONFIG_SRCS += hdhomerun_pkt.c
-HDHOMERUN_CONFIG_SRCS += hdhomerun_discover.c
-HDHOMERUN_CONFIG_SRCS += hdhomerun_control.c
-HDHOMERUN_CONFIG_SRCS += hdhomerun_config.c
+SRCS += hdhomerun_pkt.c
+SRCS += hdhomerun_discover.c
+SRCS += hdhomerun_control.c
+SRCS += hdhomerun_config.c
 
 CFLAGS += -Wall -O2
 
-hdhomerun_config : $(HDHOMERUN_CONFIG_SRCS)
-	gcc $(CFLAGS) $(HDHOMERUN_CONFIG_SRCS) -o hdhomerun_config
-	strip hdhomerun_config
+hdhomerun_config : $(SRCS)
+	gcc $(CFLAGS) $(SRCS) -o $@
+	strip $@
+
+hdhomerun_config.exe : $(SRCS)
+	gcc $(CFLAGS) $(SRCS) -liphlpapi -o $@
+	strip $@
 
 clean :
 	rm -f hdhomerun_config
+	rm -f hdhomerun_config.exe
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhrchannel.cpp mythtv-0.20-new/libs/libmythtv/hdhrchannel.cpp
--- mythtv-0.20-old/libs/libmythtv/hdhrchannel.cpp	2006-07-20 12:54:28.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhrchannel.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -301,12 +301,6 @@
     return TunerSet("target", "0.0.0.0:0");
 }
 
-bool HDHRChannel::TuneTo(uint freqid)
-{
-    VERBOSE(VB_CHANNEL, LOC + "TuneTo("<<freqid<<")");
-    return TunerSet("channel", QString::number(freqid));
-}
-
 bool HDHRChannel::SetChannelByString(const QString &channum)
 {
     QString loc = LOC + QString("SetChannelByString(%1)").arg(channum);
@@ -379,8 +373,10 @@
         }
         else
         {
-            if (!TuneTo(freqid.toInt()))
-                return false;
+            VERBOSE(VB_IMPORTANT, LOC_ERR +
+                    "dtv_multiplex data is required for tuning");
+
+            return false;
         }
     }
     else if (!ChangeExternalChannel(freqid))
@@ -392,6 +388,8 @@
     // Set the major and minor channel for any additional multiplex tuning
     if (atsc_major || atsc_minor)
         SetCachedATSCInfo(QString("%1_%2").arg(atsc_major).arg(atsc_minor));
+    else if (mpeg_prog_num >= 0)
+        SetCachedATSCInfo(QString("0-%1").arg(mpeg_prog_num));
     else
         SetCachedATSCInfo(QString("%1_0").arg(channum));
 
@@ -449,10 +447,18 @@
 
 bool HDHRChannel::Tune(uint frequency, QString /*input*/, QString modulation)
 {
-    int freqid = get_closest_freqid("atsc", modulation, "us", frequency);
-    if (freqid > 0)
-        return TuneTo(freqid);
-    return false;
+    bool ok = false;
+
+    VERBOSE(VB_CHANNEL, LOC + "TuneTo("<<frequency<<","<<modulation<<")");
+
+    if (modulation == "8vsb")
+        ok = TunerSet("channel", QString("8vsb:%1").arg(frequency));
+    else if (modulation == "qam_64")
+        ok = TunerSet("channel", QString("qam64:%1").arg(frequency));
+    else if (modulation == "qam_256")
+        ok = TunerSet("channel", QString("qam256:%1").arg(frequency));
+
+    return ok;
 }
 
 bool HDHRChannel::SwitchToInput(const QString &inputname,
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhrchannel.h mythtv-0.20-new/libs/libmythtv/hdhrchannel.h
--- mythtv-0.20-old/libs/libmythtv/hdhrchannel.h	2006-07-20 12:54:28.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhrchannel.h	2007-04-17 10:23:33.000000000 -0700
@@ -62,7 +62,6 @@
 
     bool DeviceSetTarget(unsigned short localPort);
     bool DeviceClearTarget(void);
-    bool TuneTo(uint freqid);
 
     QString DeviceGet(const QString &name);
     QString DeviceSet(const QString &name, const QString &value);
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhrrecorder.cpp mythtv-0.20-new/libs/libmythtv/hdhrrecorder.cpp
--- mythtv-0.20-old/libs/libmythtv/hdhrrecorder.cpp	2006-07-03 12:12:30.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhrrecorder.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -151,15 +151,12 @@
     }
 }
 
-void HDHRRecorder::SetStreamData(MPEGStreamData *xdata)
+void HDHRRecorder::SetStreamData(MPEGStreamData *data)
 {
-    ATSCStreamData *data = dynamic_cast<ATSCStreamData*>(xdata);
-    VERBOSE(VB_IMPORTANT, LOC + "SetStreamData(xdata: "<<xdata<<") "<<data);
-
     if (data == _stream_data)
         return;
 
-    ATSCStreamData *old_data = _stream_data;
+    MPEGStreamData *old_data = _stream_data;
     _stream_data = data;
     if (old_data)
         delete old_data;
@@ -168,14 +165,20 @@
     {
         data->AddMPEGSPListener(this);
         data->AddMPEGListener(this);
-        data->SetDesiredChannel(data->DesiredMajorChannel(),
-                                data->DesiredMinorChannel());
+
+        ATSCStreamData *atsc = dynamic_cast<ATSCStreamData*>(data);
+
+        if (atsc && atsc->DesiredMinorChannel())
+            atsc->SetDesiredChannel(atsc->DesiredMajorChannel(),
+                                    atsc->DesiredMinorChannel());
+        else if (data->DesiredProgram() >= 0)
+            data->SetDesiredProgram(data->DesiredProgram());
     }
 }
 
-MPEGStreamData *HDHRRecorder::GetStreamData(void)
+ATSCStreamData *HDHRRecorder::GetATSCStreamData(void)
 {
-    return _stream_data;
+    return dynamic_cast<ATSCStreamData*>(_stream_data);
 }
 
 void HDHRRecorder::HandlePAT(const ProgramAssociationTable *_pat)
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/hdhrrecorder.h mythtv-0.20-new/libs/libmythtv/hdhrrecorder.h
--- mythtv-0.20-old/libs/libmythtv/hdhrrecorder.h	2006-06-06 13:12:12.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/hdhrrecorder.h	2007-04-17 10:23:32.000000000 -0700
@@ -39,8 +39,8 @@
     void StartRecording(void);
 
     void SetStreamData(MPEGStreamData*);
-    MPEGStreamData *GetStreamData(void);
-    ATSCStreamData *GetATSCStreamData(void) { return _stream_data; }
+    MPEGStreamData *GetStreamData(void) { return _stream_data; }
+    ATSCStreamData *GetATSCStreamData(void);
 
     // MPEG Stream Listener
     void HandlePAT(const ProgramAssociationTable*);
@@ -69,7 +69,7 @@
   private:
     HDHRChannel                   *_channel;
     struct hdhomerun_video_sock_t *_video_socket;
-    ATSCStreamData                *_stream_data;
+    MPEGStreamData                *_stream_data;
 
     ProgramAssociationTable       *_input_pat;
     ProgramMapTable               *_input_pmt;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/libmythtv.pro mythtv-0.20-new/libs/libmythtv/libmythtv.pro
--- mythtv-0.20-old/libs/libmythtv/libmythtv.pro	2006-07-18 05:35:04.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/libmythtv.pro	2007-04-17 10:23:32.000000000 -0700
@@ -322,10 +322,12 @@
 
     # Channel scanner stuff
     HEADERS += scanwizard.h                scanwizardhelpers.h
+    HEADERS += dvbconfparser.h             dtvconfparserhelpers.h
     HEADERS += siscan.h
     HEADERS += scanwizardscanner.h
     SOURCES += scanwizard.cpp              scanwizardhelpers.cpp
     SOURCES += siscan.cpp
+    SOURCES += dvbconfparser.cpp           dtvconfparserhelpers.cpp
     SOURCES += scanwizardscanner.cpp
 
     # EIT stuff
@@ -449,8 +451,8 @@
         SOURCES += dvbrecorder.cpp
 
         # Misc
-        HEADERS += dvbconfparser.h        dvbdev/dvbci.h
-        SOURCES += dvbconfparser.cpp      dvbdev/dvbci.cpp
+        HEADERS += dvbdev/dvbci.h
+        SOURCES += dvbdev/dvbci.cpp
 
         DEFINES += USING_DVB
     }
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/mpeg/atsctables.h mythtv-0.20-new/libs/libmythtv/mpeg/atsctables.h
--- mythtv-0.20-old/libs/libmythtv/mpeg/atsctables.h	2006-04-23 08:04:23.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/mpeg/atsctables.h	2007-04-17 10:23:31.000000000 -0700
@@ -44,7 +44,7 @@
  */
 
 /** Seconds between start of GPS time and the start of UNIX time. */
-#define secs_Between_1Jan1970_6Jan1980 315982800
+#define secs_Between_1Jan1970_6Jan1980 315964800
 
 /** Leap seconds as of Jan 1st, 2006. */
 #define GPS_LEAP_SECONDS 14
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/mpeg/dvbdescriptors.cpp mythtv-0.20-new/libs/libmythtv/mpeg/dvbdescriptors.cpp
--- mythtv-0.20-old/libs/libmythtv/mpeg/dvbdescriptors.cpp	2006-08-10 14:23:33.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/mpeg/dvbdescriptors.cpp	2007-04-17 10:23:31.000000000 -0700
@@ -80,7 +80,7 @@
 
     // Strip formatting characters
     // Also, if a override encoding is specified copy it in front of the text
-    char dst[raw_length + encoding_override_length];
+    unsigned char dst[raw_length + encoding_override_length];
     uint length = encoding_override_length;
     if (encoding_override)
         memcpy(dst, encoding_override, encoding_override_length);
@@ -93,7 +93,7 @@
             length++;
         }
     }
-    const char *buf = dst;
+    const unsigned char *buf = dst;
 
     // Exit on empty string, sans formatting.
     if (!length)
@@ -102,11 +102,11 @@
     // Decode using the correct text codec
     if (buf[0] >= 0x20)
     {
-        return decode_iso6937((unsigned char*)buf, length);
+        return decode_iso6937(buf, length);
     }
     else if ((buf[0] >= 0x01) && (buf[0] <= 0x0B))
     {
-        return iso8859_codecs[4 + buf[0]]->toUnicode(buf + 1, length - 1);
+        return iso8859_codecs[4 + buf[0]]->toUnicode((char*)(buf + 1), length - 1);
     }
     else if (buf[0] == 0x10)
     {
@@ -118,14 +118,14 @@
 
         uint code = buf[1] << 8 | buf[2];
         if (code <= 15)
-            return iso8859_codecs[code]->toUnicode(buf + 3, length - 3);
+            return iso8859_codecs[code]->toUnicode((char*)(buf + 3), length - 3);
         else
-            return QString::fromLocal8Bit(buf + 3, length - 3);
+            return QString::fromLocal8Bit((char*)(buf + 3), length - 3);
     }
     else
     {
         // Unknown/invalid encoding - assume local8Bit
-        return QString::fromLocal8Bit(buf + 1, length - 1);
+        return QString::fromLocal8Bit((char*)(buf + 1), length - 1);
     }
 }
 
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/mpeg/dvbdescriptors.h mythtv-0.20-new/libs/libmythtv/mpeg/dvbdescriptors.h
--- mythtv-0.20-old/libs/libmythtv/mpeg/dvbdescriptors.h	2006-08-10 14:23:33.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/mpeg/dvbdescriptors.h	2007-04-17 10:23:31.000000000 -0700
@@ -618,7 +618,7 @@
     uint Modulation() const { return _data[8]&0x1f; }
     QString ModulationString() const
     {
-        static QString ms[] = { "qpsk", "qpsk", "qpsk_8", "qam_16" };
+        static QString ms[] = { "qpsk", "qpsk", "8psk", "qam_16" };
         return (Modulation() <= kModulationQAM16) ? ms[Modulation()] : "auto";
     }
     // symbol_rate             28   9.0
@@ -1160,6 +1160,20 @@
         kServiceTypeRCS_FLS                  = 0x0F,
         kServiceTypeDVB_MHP                  = 0x10,
         kServiceTypeHDTV                     = 0x19,
+        kServiceTypeEchoStarTV1              = 0x91,
+        kServiceTypeEchoStarTV2              = 0x9a,
+        kServiceTypeEchoStarTV3              = 0xa4,
+        kServiceTypeEchoStarTV4              = 0xa6,
+        kServiceTypeNimiqTV1                 = 0x81,
+        kServiceTypeNimiqTV2                 = 0x85,
+        kServiceTypeNimiqTV3                 = 0x86,
+        kServiceTypeNimiqTV4                 = 0x89,
+        kServiceTypeNimiqTV5                 = 0x8a,
+        kServiceTypeNimiqTV6                 = 0x8d, 
+        kServiceTypeNimiqTV7                 = 0x8f,
+        kServiceTypeNimiqTV8                 = 0x90,
+        kServiceTypeNimiqTV9                 = 0x96,
+
     };
     // service_type             8   2.0
     uint ServiceType(void) const { return _data[2]; }
@@ -1178,7 +1192,20 @@
                                ServiceNameLength());
     }
     bool IsDTV(void) const
-        { return ServiceType() ==  kServiceTypeDigitalTelevision; }
+        { return ((ServiceType() ==  kServiceTypeDigitalTelevision) ||
+                  (ServiceType() ==  kServiceTypeEchoStarTV1) ||
+                  (ServiceType() ==  kServiceTypeEchoStarTV2) ||
+                  (ServiceType() ==  kServiceTypeEchoStarTV3) ||
+                  (ServiceType() ==  kServiceTypeEchoStarTV4) ||
+                  (ServiceType() ==  kServiceTypeNimiqTV1) ||
+                  (ServiceType() ==  kServiceTypeNimiqTV2) ||
+                  (ServiceType() ==  kServiceTypeNimiqTV3) ||
+                  (ServiceType() ==  kServiceTypeNimiqTV4) ||
+                  (ServiceType() ==  kServiceTypeNimiqTV5) ||
+                  (ServiceType() ==  kServiceTypeNimiqTV6) ||
+                  (ServiceType() ==  kServiceTypeNimiqTV7) ||
+                  (ServiceType() ==  kServiceTypeNimiqTV8) ||
+                  (ServiceType() ==  kServiceTypeNimiqTV9)); }
     bool IsDigitalAudio(void) const
         { return ServiceType() ==  kServiceTypeDigitalRadioSound; }
     bool IsHDTV(void) const
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/mpeg/mpegstreamdata.cpp mythtv-0.20-new/libs/libmythtv/mpeg/mpegstreamdata.cpp
--- mythtv-0.20-old/libs/libmythtv/mpeg/mpegstreamdata.cpp	2006-09-07 11:58:06.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/mpeg/mpegstreamdata.cpp	2007-04-17 10:23:31.000000000 -0700
@@ -406,11 +406,11 @@
     pmt.Parse();
 
     vector<uint> videoPIDs, audioPIDs;
-    vector<uint> videoTypes, audioTypes;
+    vector<uint> videoTypes;
     vector<uint> pids, types;
 
     // Video
-    uint video_cnt = pmt.FindPIDs(StreamID::AnyVideo, videoPIDs, videoTypes);
+    uint video_cnt = pmt.FindPIDs(StreamID::AnyVideo, videoPIDs, videoTypes, true);
     if (video_cnt < _pmt_single_program_num_video) 
     {
         VERBOSE(VB_RECORD, "Only "<<video_cnt<<" video streams seen in PMT, "
@@ -432,7 +432,7 @@
     }
 
     // Audio
-    pmt.FindPIDs(StreamID::AnyAudio, audioPIDs, audioTypes);
+    pmt.FindPIDs(StreamID::AnyAudio, audioPIDs);
     if (audioPIDs.size() < _pmt_single_program_num_audio)
     {
         VERBOSE(VB_RECORD, "Only "<<audioPIDs.size()
@@ -456,7 +456,7 @@
     uint programNumber = 1;
 
     // Construct
-    pmt.FindPIDs(StreamID::AnyAudio, pids, types);
+    pmt.FindPIDs(StreamID::AnyAudio, pids, types, true);
     ProgramMapTable *pmt2 = ProgramMapTable::
         Create(programNumber, _pid_pmt_single_program,
                pmt.PCRPID(), pmt.Version(), pids, types);
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/mpeg/mpegtables.cpp mythtv-0.20-new/libs/libmythtv/mpeg/mpegtables.cpp
--- mythtv-0.20-old/libs/libmythtv/mpeg/mpegtables.cpp	2006-04-20 12:01:31.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/mpeg/mpegtables.cpp	2007-04-17 10:23:31.000000000 -0700
@@ -256,34 +256,37 @@
 
 bool ProgramMapTable::IsEncrypted(void) const
 {
-    desc_list_t descs = MPEGDescriptor::Parse(
-        ProgramInfo(), ProgramInfoLength());
-    const unsigned char* data = MPEGDescriptor::Find(
-        descs, DescriptorID::conditional_access);
+    desc_list_t descs = MPEGDescriptor::ParseOnlyInclude(
+        ProgramInfo(), ProgramInfoLength(), DescriptorID::conditional_access);
 
-    if (data)
+    bool encrypted = false;
+    QMap<uint,uint> encryption_system;
+    for (uint i = 0; i < descs.size(); i++)
     {
-        ConditionalAccessDescriptor ca(data);
-        return 0x0 != ca.SystemID(); // System ID of 0 == no encrytion
+        ConditionalAccessDescriptor cad(descs[i]);
+        encryption_system[cad.PID()] = cad.SystemID();
+        encrypted |= cad.SystemID();
+
+        //VERBOSE(VB_IMPORTANT, "DTVsm: "<<cad.toString());
     }
 
-    return false;
-#if 0
-    QMap<uint,uint> encryption_system;
-    if (data)
+    for (uint i = 0; i < StreamCount(); i++)
     {
-        for (uint i = 0; i < descs.size(); ++i)
+        desc_list_t descs = MPEGDescriptor::ParseOnlyInclude(
+            StreamInfo(i), StreamInfoLength(i),
+            DescriptorID::conditional_access);
+
+        for (uint j = 0; j < descs.size(); j++)
         {
-            MPEGDescriptor mpegdesc(descs[i]);
-            VERBOSE(VB_IMPORTANT, "DTVsm: "<<mpegdesc.toString());
-            if (DescriptorID::conditional_access == mpegdesc.DescriptorTag())
-            {
-                ConditionalAccessDescriptor cad(descs[i]);
-                encryption_system[cad.PID()] = cad.SystemID();
-            }
+            ConditionalAccessDescriptor cad(descs[j]);
+            encryption_system[cad.PID()] = cad.SystemID();
+            encrypted |= cad.SystemID();
+
+            //VERBOSE(VB_IMPORTANT, "DTVsm: "<<cad.toString());
         }
     }
-#endif
+
+    return encrypted;
 }
 
 bool ProgramMapTable::IsStillPicture(void) const
@@ -310,6 +313,8 @@
  */
 uint ProgramMapTable::FindPIDs(uint type, vector<uint>& pids) const
 {
+    uint pids_start = pids.size();
+
     if ((StreamID::AnyMask & type) != StreamID::AnyMask)
     {
         for (uint i=0; i < StreamCount(); i++)
@@ -337,11 +342,14 @@
  *  \param type  StreamType to match
  *  \param pids  vector pids will be added to
  *  \param types vector types will be added to
+ *  \param normalize if set, types will be normalized
  *  \return number of items in pids and types lists.
  */
 uint ProgramMapTable::FindPIDs(uint type, vector<uint>& pids,
-                               vector<uint>& types) const
+                               vector<uint>& types, bool normalize) const
 {
+    uint pids_start = pids.size();
+
     if ((StreamID::AnyMask & type) != StreamID::AnyMask)
     {
         for (uint i=0; i < StreamCount(); i++)
@@ -351,6 +359,7 @@
                 types.push_back(StreamType(i));
             }
     }
+
     else if (StreamID::AnyVideo == type)
     {
         for (uint i=0; i < StreamCount(); i++)
@@ -370,6 +379,20 @@
             }
     }
 
+    if (!normalize)
+        return pids.size();
+
+    for (uint i = pids_start; i < pids.size(); i++)
+    {
+        int index = FindPID(pids[i]);
+        if (index >= 0)
+        {
+            desc_list_t desc = MPEGDescriptor::Parse(
+                StreamInfo(i), StreamInfoLength(i));
+            types[i] = StreamID::Normalize(types[i], desc);
+        }
+    }
+
     return pids.size();
 }
 
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/mpeg/mpegtables.h mythtv-0.20-new/libs/libmythtv/mpeg/mpegtables.h
--- mythtv-0.20-old/libs/libmythtv/mpeg/mpegtables.h	2006-04-20 12:01:31.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/mpeg/mpegtables.h	2007-04-17 10:23:31.000000000 -0700
@@ -541,7 +541,7 @@
     QString GetLanguage(uint i) const;
 
     uint FindPIDs(uint type, vector<uint>& pids) const;
-    uint FindPIDs(uint type, vector<uint>& pids, vector<uint>& types) const;
+    uint FindPIDs(uint type, vector<uint>& pids, vector<uint>& types, bool normalize) const;
 
     /// \brief Locates stream index of pid.
     /// \return stream index if successful, -1 otherwise
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/mpegrecorder.cpp mythtv-0.20-new/libs/libmythtv/mpegrecorder.cpp
--- mythtv-0.20-old/libs/libmythtv/mpegrecorder.cpp	2006-07-18 08:55:57.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/mpegrecorder.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -875,7 +875,9 @@
     {
         curRecording->SetPositionMapDelta(positionMapDelta,
                                           MARK_GOP_START);
-        curRecording->SetFilesize(lastpackheaderpos);
+        // Stop setting the filesize here until we get the contention issue
+        // between with this thread and the scheduler worked out.
+        //curRecording->SetFilesize(lastpackheaderpos);
         positionMapDelta.clear();
     }
 }
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/NuppelVideoPlayer.cpp mythtv-0.20-new/libs/libmythtv/NuppelVideoPlayer.cpp
--- mythtv-0.20-old/libs/libmythtv/NuppelVideoPlayer.cpp	2006-09-04 19:37:19.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/NuppelVideoPlayer.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -573,7 +573,7 @@
 
 void NuppelVideoPlayer::ReinitOSD(void)
 {
-    if (videoOutput)
+    if (videoOutput && !using_null_videoout)
     {
         QRect visible, total;
         float aspect, scaling;
@@ -6314,11 +6314,10 @@
     int numbuttons = ringBuffer->DVD()->NumMenuButtons();
     bool osdshown = osd->IsSetDisplaying("subtitles");
     long long menupktpts = ringBuffer->DVD()->GetMenuPktPts();
-    bool instillframe = ringBuffer->DVD()->InStillFrame();
 
     if ((numbuttons == 0) || 
         (osdshown) ||
-        (instillframe && buffer->timecode > 0) ||
+        (indvdstillframe && buffer->timecode > 0) ||
         ((!osdshown) && 
             (!indvdstillframe) &&
             (hidedvdbutton) &&
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/NuppelVideoRecorder.cpp mythtv-0.20-new/libs/libmythtv/NuppelVideoRecorder.cpp
--- mythtv-0.20-old/libs/libmythtv/NuppelVideoRecorder.cpp	2006-08-29 12:30:22.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/NuppelVideoRecorder.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -2063,7 +2063,9 @@
     if (curRecording && force)
     {
         curRecording->SetPositionMapDelta(positionMapDelta, MARK_KEYFRAME);
-        curRecording->SetFilesize(lastPositionMapPos);
+        // Stop setting the filesize here until we get the contention issue
+        // between with this thread and the scheduler worked out.
+        //curRecording->SetFilesize(lastPositionMapPos);
         positionMapDelta.clear();
     }
 }
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/osd.cpp mythtv-0.20-new/libs/libmythtv/osd.cpp
--- mythtv-0.20-old/libs/libmythtv/osd.cpp	2006-09-09 13:31:14.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/osd.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -2474,6 +2474,13 @@
     totalfadetime = 0;
 }
 
+int OSD::GetRevision(void) const
+{
+    if (drawSurface)
+        return drawSurface->GetRevision();
+    return 0;
+}
+
 OSDSurface *OSD::Display(void)
 {
     bool anytodisplay = false;
@@ -2545,7 +2552,7 @@
 
     m_setsvisible = anytodisplay;
 
-    if (m_setsvisible)
+    if (m_setsvisible && !drawSurface->IsClear())
         return drawSurface;
 
     return NULL;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/osd.h mythtv-0.20-new/libs/libmythtv/osd.h
--- mythtv-0.20-old/libs/libmythtv/osd.h	2006-06-29 11:29:16.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/osd.h	2007-04-17 10:23:33.000000000 -0700
@@ -60,6 +60,8 @@
 
     OSDSurface *Display(void);
 
+    int  GetRevision(void) const;
+
     void ClearAll(const QString &name);
     void ClearAllText(const QString &name);
     void SetText(const QString &name, QMap<QString, QString> &infoMap,
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/osdsurface.cpp mythtv-0.20-new/libs/libmythtv/osdsurface.cpp
--- mythtv-0.20-old/libs/libmythtv/osdsurface.cpp	2006-08-17 08:25:45.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/osdsurface.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -135,6 +135,11 @@
     usedRegions = QRegion();
 }
 
+bool OSDSurface::IsClear(void) const
+{
+    return (usedRegions == QRegion());
+}
+
 bool OSDSurface::IntersectsDrawn(QRect &newrect)
 {
     QMutexLocker lock(&usedRegionsLock);
@@ -799,7 +804,7 @@
 
         if (startline < 0) startline = 0;
         if (endline >= height) endline = height - 1;
-        if (startcol < 0) endcol = 0;
+        if (startcol < 0) startcol = 0;
         if (endcol >= width) endcol = width - 1;
 
         unsigned char *src;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/osdsurface.h mythtv-0.20-new/libs/libmythtv/osdsurface.h
--- mythtv-0.20-old/libs/libmythtv/osdsurface.h	2006-08-17 08:25:45.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/osdsurface.h	2007-04-17 10:23:33.000000000 -0700
@@ -24,6 +24,7 @@
 
     void Clear(void);
     void ClearUsed(void);
+    bool IsClear(void) const;
 
     bool IntersectsDrawn(QRect &newrect);
     void AddRect(QRect &newrect);
@@ -35,7 +36,7 @@
         if (change) 
             ++revision;
     }
-    int GetRevision() { return revision; }
+    int GetRevision(void) const { return revision; }
 
     void BlendToYV12(unsigned char *yptr,
                      unsigned char *uptr,
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/osdtypes.cpp mythtv-0.20-new/libs/libmythtv/osdtypes.cpp
--- mythtv-0.20-old/libs/libmythtv/osdtypes.cpp	2006-09-04 11:33:22.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/osdtypes.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -2146,7 +2146,7 @@
         QPoint((int)round(pos.x() / wmult),
                (int)round(pos.y() / hmult)));
 
-    VERBOSE(VB_IMPORTANT,
+    VERBOSE(VB_OSD,
             "OSDTypePositionImage::AddPosition["<<m_numpositions<<"]("
             <<pos.x()<<"x"<<pos.y()
             <<"  "<<wmult<<", "<<hmult<<")");
@@ -2157,7 +2157,7 @@
 void OSDTypePositionImage::Draw(OSDSurface *surface, int fade, int maxfade,
                                 int xoff, int yoff)
 {
-    VERBOSE(VB_IMPORTANT,
+    VERBOSE(VB_OSD,
             "OSDTypePositionImage::Draw["<<m_curposition<<"]("
             <<m_wmult<<", "<<m_hmult<<")");
 
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/profilegroup.cpp mythtv-0.20-new/libs/libmythtv/profilegroup.cpp
--- mythtv-0.20-old/libs/libmythtv/profilegroup.cpp	2006-04-03 01:58:08.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/profilegroup.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -94,10 +94,13 @@
                          it != cardtypes.end(); it++)
                    if (result.value(4).toString() == *it)
                        match = true;
-                   else if (result.value(4).toString() == "TRANSCODE")
-                       transcodeID = result.value(1).toString();
+
                if (! match)
+               {
+                   if (result.value(4).toString() == "TRANSCODE")
+                       transcodeID = result.value(1).toString();
                    continue;
+               }
             }
             QString value = QString::fromUtf8(result.value(0).toString());
             if (result.value(2).toString() != NULL &&
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/progfind.cpp mythtv-0.20-new/libs/libmythtv/progfind.cpp
--- mythtv-0.20-old/libs/libmythtv/progfind.cpp	2006-09-04 20:08:32.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/progfind.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -516,11 +516,9 @@
 
 void ProgFinder::cursorLeft()
 {
-    inSearch--;
-    if (inSearch == -1 && arrowAccel)
-        escape();
-    else
+    if (inSearch > 0)
     {
+        inSearch--;
         if (inSearch == 0)
             showSearchList();
         else if (inSearch == 1)
@@ -529,6 +527,9 @@
             clearShowData();
         }
     }
+    else if (inSearch == 0 && arrowAccel)
+        escape();
+
     update(infoRect);
     update(listRect);
 }
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/programinfo.cpp mythtv-0.20-new/libs/libmythtv/programinfo.cpp
--- mythtv-0.20-old/libs/libmythtv/programinfo.cpp	2006-09-10 21:35:19.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/programinfo.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -309,6 +309,7 @@
     INT_TO_LIST(hasAirDate)     
     STR_TO_LIST((playgroup != "") ? playgroup : "Default")
     INT_TO_LIST(recpriority2)
+    INT_TO_LIST(parentid)
 }
 
 /** \fn ProgramInfo::FromStringList(QStringList&,int)
@@ -407,6 +408,7 @@
     INT_FROM_LIST(hasAirDate);
     STR_FROM_LIST(playgroup)
     INT_FROM_LIST(recpriority2)
+    INT_FROM_LIST(parentid)
 
     return true;
 }
@@ -1039,7 +1041,11 @@
     query.prepare("UPDATE recorded "
                   "SET recordid = :RECID "
                   "WHERE chanid = :CHANID AND starttime = :START");
-    query.bindValue(":RECID",  getRecordID());
+
+    if (rectype == kOverrideRecord && parentid > 0)
+        query.bindValue(":RECID", parentid);
+    else
+        query.bindValue(":RECID",  getRecordID());
     query.bindValue(":CHANID", chanid);
     query.bindValue(":START",  recstartts);
 
@@ -1419,15 +1425,15 @@
     return true;
 }               
 
-/** \fn ProgramInfo::GetRecordBasename(void) const
+/** \fn ProgramInfo::GetRecordBasename() const
  *  \brief Returns a filename for a recording based on the
  *         recording channel and date.
  */
-QString ProgramInfo::GetRecordBasename(void) const
+QString ProgramInfo::GetRecordBasename(bool fromDB) const
 {
     QString retval = "";
 
-    if (!pathname.isEmpty())
+    if (!fromDB && !pathname.isEmpty())
         retval = pathname.section('/', -1);
     else
     {
@@ -1452,13 +1458,13 @@
     return retval;
 }               
 
-/** \fn ProgramInfo::GetRecordFilename(const QString&) const
+/** \fn ProgramInfo::GetRecordFilename() const
  *  \brief Returns prefix+"/"+GetRecordBasename()
  *  \param prefix Prefix to apply to GetRecordBasename().
  */
-QString ProgramInfo::GetRecordFilename(const QString &prefix) const
+QString ProgramInfo::GetRecordFilename(const QString &prefix, bool fromDB) const
 {
-    return QString("%1/%2").arg(prefix).arg(GetRecordBasename());
+    return QString("%1/%2").arg(prefix).arg(GetRecordBasename(fromDB));
 }               
 
 /** \fn ProgramInfo::GetPlaybackURL(QString) const
@@ -1566,9 +1572,11 @@
 
     query.prepare("REPLACE INTO recordedprogram"
                  " SELECT * from program"
-                 " WHERE chanid = :CHANID AND starttime = :START;");
+                 " WHERE chanid = :CHANID AND starttime = :START"
+                 " AND title = :TITLE;");
     query.bindValue(":CHANID", chanid);
     query.bindValue(":START", startts);
+    query.bindValue(":TITLE", title);
     if (!query.exec() || !query.isActive())
         MythContext::DBError("Copy program data on record", query);
 
@@ -1662,17 +1670,28 @@
     query.bindValue(":PROFILE",     schd->getProfileName());
 
     bool ok = query.exec() && (query.numRowsAffected() > 0);
-    if (!ok && !query.isActive())
+    bool active = query.isActive();
+
+    query.prepare("UNLOCK TABLES");
+    query.exec();
+
+    if (!ok && !active)
         MythContext::DBError("insert_program -- insert", query);
     else
     {
         query.prepare("UPDATE record SET last_record = NOW() "
                       "WHERE recordid = :RECORDID");
-        query.bindValue(":RECORDID",    pg->recordid);
+        query.bindValue(":RECORDID", pg->recordid);
         query.exec();
+
+        if (pg->rectype == kOverrideRecord && pg->parentid > 0)
+        {
+            query.prepare("UPDATE record SET last_record = NOW() "
+                          "WHERE recordid = :PARENTID");
+            query.bindValue(":PARENTID", pg->parentid);
+            query.exec();
+        }
     }
-    query.prepare("UNLOCK TABLES");
-    query.exec();
 
     return ok;
 }
@@ -1710,12 +1729,11 @@
 void ProgramInfo::UpdateRecordingEnd(void)
 {
     MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("UPDATE recorded SET endtime = :ENDTIME, "
-                  "    recordid = :RECORDID "
+    query.prepare("UPDATE recorded SET endtime = :ENDTIME "
                   "WHERE chanid = :CHANID AND "
                   "    starttime = :STARTTIME ");
     query.bindValue(":ENDTIME", recendts);
-    query.bindValue(":RECORDID", recordid);
+
     query.bindValue(":CHANID", chanid);
     query.bindValue(":STARTTIME", recstartts);
 
@@ -2823,6 +2841,8 @@
         return QObject::tr("K", "RecStatusChar rsLowDiskSpace");
     case rsTunerBusy:
         return QObject::tr("B", "RecStatusChar rsTunerBusy");
+    case rsFailed:
+        return QObject::tr("f", "RecStatusChar rsFailed");
     case rsNotListed:
         return QObject::tr("N", "RecStatusChar rsNotListed");
     case rsNeverRecord:
@@ -2879,6 +2899,8 @@
             return QObject::tr("Low Disk Space");
         case rsTunerBusy:
             return QObject::tr("Tuner Busy");
+        case rsFailed:
+            return QObject::tr("Recorder Failed");
         case rsNotListed:
             return QObject::tr("Not Listed");
         case rsNeverRecord:
@@ -2932,6 +2954,9 @@
         case rsTunerBusy:
             message += QObject::tr("the tuner card was already being used.");
             break;
+        case rsFailed:
+            message += QObject::tr("the recording failed.");
+            break;
         default:
             message = QObject::tr("The status of this showing is unknown.");
             break;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/programinfo.h mythtv-0.20-new/libs/libmythtv/programinfo.h
--- mythtv-0.20-old/libs/libmythtv/programinfo.h	2006-07-14 12:31:24.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/programinfo.h	2007-04-17 10:23:33.000000000 -0700
@@ -13,7 +13,7 @@
 typedef QMap<long long, long long> frm_pos_map_t;
 typedef QMap<long long, int> frm_dir_map_t;
 
-#define NUMPROGRAMLINES 41
+#define NUMPROGRAMLINES 42
 
 typedef enum {
     MARK_UNSET = -10,
@@ -59,6 +59,7 @@
 };
 
 enum RecStatusType {
+    rsFailed = -9,
     rsTunerBusy = -8,
     rsLowDiskSpace = -7,
     rsCancelled = -6,
@@ -157,8 +158,8 @@
 
     // Quick gets
     bool SetRecordBasename(QString basename);
-    QString GetRecordBasename(void) const;
-    QString GetRecordFilename(const QString &prefix) const;
+    QString GetRecordBasename(bool fromDB = false) const;
+    QString GetRecordFilename(const QString &prefix, bool fromDB = false) const;
     QString GetPlaybackURL(QString playbackHost = "") const;
     QString MakeUniqueKey(void) const;
     int CalculateLength(void) const;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/scanwizard.cpp mythtv-0.20-new/libs/libmythtv/scanwizard.cpp
--- mythtv-0.20-old/libs/libmythtv/scanwizard.cpp	2006-05-22 15:51:16.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/scanwizard.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -39,6 +39,7 @@
     : paneOFDM(new OFDMPane()),     paneQPSK(new QPSKPane()),
       paneATSC(new ATSCPane()),     paneQAM(new QAMPane()),
       paneSingle(new STPane()),
+      paneDVBUtilsImport(new DVBUtilsImportPane()),
 #ifdef FE_GET_EXTENDED_INFO
       paneDVBS2(new DVBS2Pane()),
 #endif
@@ -111,7 +112,10 @@
     bool vl1 = (configPane->scanConfig->
                 ignoreSignalTimeoutAll->getValue().toInt());
 
-    return (ts0) ? vl0 : ((ts1) ? vl1 : false);
+    bool ts2 = (ScanTypeSetting::DVBUtilsImport == scanType());
+    bool vl2 = paneDVBUtilsImport->DoIgnoreSignalTimeout();
+
+    return (ts0) ? vl0 : ((ts1) ? vl1 : (ts2) ? vl2 : false);
 }
 
 QString ScanWizard::country(void) const
@@ -121,5 +125,5 @@
 
 QString ScanWizard::filename(void) const
 {
-    return configPane->scanConfig->filename->getValue();
+    return paneDVBUtilsImport->GetFilename();
 }
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/scanwizard.h mythtv-0.20-new/libs/libmythtv/scanwizard.h
--- mythtv-0.20-old/libs/libmythtv/scanwizard.h	2006-03-15 14:21:38.000000000 -0800
+++ mythtv-0.20-new/libs/libmythtv/scanwizard.h	2007-04-17 10:23:33.000000000 -0700
@@ -42,6 +42,7 @@
 class ATSCPane;
 class QAMPane;
 class STPane;
+class DVBUtilsImportPane;
 class ScanWizardScanType;
 class ScanWizardScanner;
 
@@ -77,6 +78,8 @@
     ATSCPane     *paneATSC;
     QAMPane      *paneQAM;
     STPane       *paneSingle;
+    DVBUtilsImportPane *paneDVBUtilsImport;
+
     int           nVideoDev;
     unsigned      nCardType;
     int           nCaptureCard;
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/scanwizardhelpers.cpp mythtv-0.20-new/libs/libmythtv/scanwizardhelpers.cpp
--- mythtv-0.20-old/libs/libmythtv/scanwizardhelpers.cpp	2006-08-16 14:47:43.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/scanwizardhelpers.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -1,5 +1,5 @@
 /* -*- Mode: c++ -*-
- * $Id: scanwizardhelpers.cpp 10791 2006-08-16 21:47:43Z danielk $
+ * $Id: scanwizardhelpers.cpp 13237 2007-04-14 04:59:17Z jarod $
  * vim: set expandtab tabstop=4 shiftwidth=4:
  *
  * Original Project
@@ -315,29 +315,27 @@
         addSelection(tr("Full Scan (Tuned)"),
                      QString::number(NITAddScan_OFDM));
         addSelection(tr("Import channels.conf"),
-                     QString::number(Import));
+                     QString::number(DVBUtilsImport));
         break;
     case CardUtil::QPSK:
         addSelection(tr("Full Scan (Tuned)"),
                      QString::number(NITAddScan_QPSK));
         addSelection(tr("Import channels.conf"),
-                     QString::number(Import));
+                     QString::number(DVBUtilsImport));
         break;
     case CardUtil::QAM:
         addSelection(tr("Full Scan (Tuned)"),
                      QString::number(NITAddScan_QAM));
         addSelection(tr("Import channels.conf"),
-                     QString::number(Import));
+                     QString::number(DVBUtilsImport));
         break;
     case CardUtil::ATSC:
     case CardUtil::HDTV:
     case CardUtil::HDHOMERUN:
         addSelection(tr("Full Scan"),
                      QString::number(FullScan_ATSC), true);
-#ifdef USING_DVB
         addSelection(tr("Import channels.conf"),
-                     QString::number(Import));
-#endif
+                     QString::number(DVBUtilsImport));
         break;
     case CardUtil::FREEBOX:
         addSelection(tr("M3U Import"),
@@ -393,8 +391,7 @@
     ConfigurationGroup(false, false, true, true),
     VerticalConfigurationGroup(false, false, true, true),
     country(new ScanCountry()),
-    ignoreSignalTimeoutAll(new IgnoreSignalTimeout()),
-    filename(new ScanFileImport())
+    ignoreSignalTimeoutAll(new IgnoreSignalTimeout())
 {
     setTrigger(scanType);
 
@@ -432,8 +429,8 @@
               scanAllTransports);
     addTarget(QString::number(ScanTypeSetting::FreeBoxImport),
               new BlankSetting());
-    addTarget(QString::number(ScanTypeSetting::Import),
-              filename);
+    addTarget(QString::number(ScanTypeSetting::DVBUtilsImport),
+              wizard->paneDVBUtilsImport);
 }
 
 void ScanOptionalConfig::triggerChanged(const QString& value)
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/scanwizardhelpers.h mythtv-0.20-new/libs/libmythtv/scanwizardhelpers.h
--- mythtv-0.20-old/libs/libmythtv/scanwizardhelpers.h	2006-07-26 06:10:21.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/scanwizardhelpers.h	2007-04-17 10:23:32.000000000 -0700
@@ -1,5 +1,5 @@
 /* -*- Mode: c++ -*-
- * $Id: scanwizardhelpers.h 10645 2006-07-26 13:10:21Z danielk $
+ * $Id: scanwizardhelpers.h 13237 2007-04-14 04:59:17Z jarod $
  * vim: set expandtab tabstop=4 shiftwidth=4:
  *
  * Original Project
@@ -188,16 +188,6 @@
     ScanCountry();
 };
 
-class ScanFileImport : public LineEditSetting, public TransientStorage
-{
-public:
-    ScanFileImport() : LineEditSetting()
-    {
-        setLabel(QObject::tr("File location"));
-        setHelpText(QObject::tr("Location of the channels.conf file."));
-    }
-};
-
 class ScanTypeSetting : public ComboBoxSetting, public TransientStorage
 {
     Q_OBJECT
@@ -222,7 +212,7 @@
         // Freebox import of channels from M3U URL
         FreeBoxImport,
         // Imports lists from dvb-utils scanners
-        Import
+        DVBUtilsImport,
     };
     ScanTypeSetting() : nCaptureCard(-1)
     {
@@ -244,7 +234,7 @@
 
     ScanCountry         *country;
     IgnoreSignalTimeout *ignoreSignalTimeoutAll;
-    ScanFileImport      *filename;
+
   protected slots:
     void triggerChanged(const QString&);
 };
@@ -781,6 +771,43 @@
     IgnoreSignalTimeout     *ignore_signal_timeout;
 };
 
+class DVBUtilsImportPane : public VerticalConfigurationGroup
+{
+  public:
+    DVBUtilsImportPane() :
+        ConfigurationGroup(false,false,true,false),
+        VerticalConfigurationGroup(false,false,true,false),
+        filename(new TransLineEditSetting()),
+        atsc_format(new ScanATSCChannelFormat()),
+        old_channel_treatment(new ScanOldChannelTreatment()),
+        ignore_signal_timeout(new IgnoreSignalTimeout())
+    {
+        filename->setLabel(tr("File location"));
+        filename->setHelpText(tr("Location of the channels.conf file."));
+        addChild(filename);
+
+        addChild(atsc_format);
+        addChild(old_channel_treatment);
+        addChild(ignore_signal_timeout);
+    }
+
+    QString GetFilename(void)   const { return filename->getValue();    }
+    QString GetATSCFormat(void) const { return atsc_format->getValue(); }
+
+    bool DoDeleteChannels(void) const
+        { return old_channel_treatment->getValue() == "delete"; }
+    bool DoRenameChannels(void) const
+        { return old_channel_treatment->getValue() == "rename"; }
+    bool DoIgnoreSignalTimeout(void) const
+        { return ignore_signal_timeout->getValue().toInt(); }
+
+  private:
+    TransLineEditSetting    *filename;
+    ScanATSCChannelFormat   *atsc_format;
+    ScanOldChannelTreatment *old_channel_treatment;
+    IgnoreSignalTimeout     *ignore_signal_timeout;
+};
+
 class ErrorPane : public HorizontalConfigurationGroup
 {
   public:
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/scanwizardscanner.cpp mythtv-0.20-new/libs/libmythtv/scanwizardscanner.cpp
--- mythtv-0.20-old/libs/libmythtv/scanwizardscanner.cpp	2006-07-18 05:35:04.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/scanwizardscanner.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -43,6 +43,7 @@
 #include "channelbase.h"
 #include "dtvsignalmonitor.h"
 #include "siscan.h"
+#include "dvbconfparser.h"
 
 #ifdef USING_V4L
 #include "channel.h"
@@ -53,7 +54,6 @@
 #ifdef USING_DVB
 #include "dvbchannel.h"
 #include "dvbsignalmonitor.h"
-#include "dvbconfparser.h"
 #endif
 
 #ifdef USING_HDHOMERUN
@@ -302,10 +302,9 @@
         do_scan = false;
         ScanAnalog(cardid, nVideoSource);
     }
-    else if (nScanType == ScanTypeSetting::Import)
+    else if (nScanType == ScanTypeSetting::DVBUtilsImport)
     {
-        do_scan = false;
-        Import(nVideoSource, parent->nCardType, parent->filename());
+        ImportDVBUtils(nVideoSource, parent->nCardType, parent->filename());
     }
     else if ((nScanType == ScanTypeSetting::FullScan_ATSC)     ||
              (nScanType == ScanTypeSetting::FullTransportScan) ||
@@ -416,49 +415,36 @@
     }
 }
 
-void ScanWizardScanner::Import(uint sourceid, int cardtype,
-                               const QString &file)
+void ScanWizardScanner::ImportDVBUtils(uint sourceid, int cardtype,
+                                       const QString &file)
 {
-    (void) sourceid;
-    (void) cardtype;
-    (void) file;
+    channels.clear();
 
-#ifdef USING_DVB
-    DVBConfParser *parser = NULL;
-
-    if (CardUtil::OFDM == cardtype)
-        parser = new DVBConfParser(DVBConfParser::OFDM, sourceid, file);
-    else if (CardUtil::QPSK == cardtype)
-        parser = new DVBConfParser(DVBConfParser::QPSK, sourceid, file);
-    else if (CardUtil::QAM == cardtype)
-        parser = new DVBConfParser(DVBConfParser::QAM, sourceid, file);
-    else if ((CardUtil::ATSC == cardtype) ||
-             (CardUtil::HDTV == cardtype))
-        parser = new DVBConfParser(DVBConfParser::ATSC, sourceid, file);
+    DTVConfParser::cardtype_t type = DTVConfParser::UNKNOWN;
+    type = (CardUtil::OFDM == cardtype) ? DTVConfParser::OFDM : type;
+    type = (CardUtil::QPSK == cardtype) ? DTVConfParser::QPSK : type;
+    type = (CardUtil::QAM  == cardtype) ? DTVConfParser::QAM  : type;
+    type = ((CardUtil::ATSC == cardtype) || (CardUtil::HDTV == cardtype) ||
+            (CardUtil::HDHOMERUN == cardtype)) ? DTVConfParser::ATSC : type;
 
-    if (!parser)
+    if (type == DTVConfParser::UNKNOWN)
         return;
 
-    connect(parser, SIGNAL(updateText(const QString&)),
-            this,   SLOT(  updateText(const QString&)));
-
-    int ret = parser->parse();
-    parser->deleteLater();
+    DTVConfParser parser(type, sourceid, file);
 
-    if (DVBConfParser::ERROR_OPEN == ret)
+    DTVConfParser::return_t ret = parser.Parse();
+    if (DTVConfParser::OK != ret)
     {
-        MythPopupBox::showOkPopup(
-            gContext->GetMainWindow(), tr("ScanWizard"),
-            tr("Failed to open '%1'").arg(file));
-    }
+        QString msg = (DTVConfParser::ERROR_PARSE == ret) ?
+            tr("Failed to parse '%1'") : tr("Failed to open '%1'");
 
-    if (DVBConfParser::ERROR_PARSE == ret)
+        MythPopupBox::showOkPopup(gContext->GetMainWindow(),
+                                  tr("ScanWizard"), msg.arg(file));
+    }
+    else
     {
-        MythPopupBox::showOkPopup(
-            gContext->GetMainWindow(), tr("ScanWizard"),
-            tr("Failed to parse '%1'").arg(file));
+        channels = parser.GetChannels();
     }
-#endif // USING_DVB
 }
 
 void ScanWizardScanner::PreScanCommon(uint cardid, uint sourceid)
@@ -734,6 +720,55 @@
                        ScannerEvent::ERROR_TUNE);
         }
     }
+    else if (nScanType == ScanTypeSetting::DVBUtilsImport && channels.size())
+    {
+        ok = true;
+
+        VERBOSE(VB_SIPARSER, LOC + "ScanForChannels("<<nVideoSource<<")");
+
+        scanner->SetChannelFormat(parent->paneDVBUtilsImport->GetATSCFormat());
+
+        if (parent->paneDVBUtilsImport->DoDeleteChannels())
+        {
+            MSqlQuery query(MSqlQuery::InitCon());
+            query.prepare("DELETE FROM channel "
+                          "WHERE sourceid = :SOURCEID");
+            query.bindValue(":SOURCEID", nVideoSource);
+            query.exec();
+        }
+
+        scanner->SetRenameChannels(
+            parent->paneDVBUtilsImport->DoRenameChannels());
+
+        int  ccardid = parent->captureCard();
+        int  pcardid = CardUtil::GetParentCardID(ccardid);
+        int  cardid  = (pcardid) ? pcardid : ccardid;
+        QString card_type = CardUtil::GetRawCardType(cardid, nVideoSource);
+        QString sub_type = card_type;
+        if (card_type == "DVB")
+        {
+            QString device = CardUtil::GetVideoDevice(cardid, nVideoSource);
+            ok = !device.isEmpty();
+            if (ok)
+                sub_type = CardUtil::ProbeDVBType(device.toUInt()).upper();
+        }
+
+        if (ok)
+        {
+            ok = scanner->ScanForChannels(nVideoSource, std,
+                                          sub_type, channels);
+        }
+        if (ok)
+        {
+            post_event(this, ScannerEvent::ServicePct,
+                       TRANSPORT_PCT);
+        }
+        else
+        {
+            post_event(this, ScannerEvent::TuneComplete,
+                       ScannerEvent::ERROR_TUNE);
+        }
+    }
     else if (nScanType == ScanTypeSetting::TransportScan)
     {
         VERBOSE(VB_SIPARSER, LOC + "ScanTransport("<<nMultiplexToTuneTo<<")");
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/scanwizardscanner.h mythtv-0.20-new/libs/libmythtv/scanwizardscanner.h
--- mythtv-0.20-old/libs/libmythtv/scanwizardscanner.h	2006-07-08 10:48:37.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/scanwizardscanner.h	2007-04-17 10:23:33.000000000 -0700
@@ -40,6 +40,7 @@
 
 // MythTV headers
 #include "settings.h"
+#include "dvbconfparser.h"
 
 class ScanWizard;
 class AnalogScan;
@@ -79,7 +80,7 @@
     void serviceScanPctComplete(int pct);
 
   protected:
-    void Import(uint sourceid, int cardtype, const QString &file);
+    void ImportDVBUtils(uint sourceid, int cardtype, const QString &file);
     void PreScanCommon(uint cardid, uint sourceid);
     void TunedScanCommon(uint cardid, uint sourceid, bool ok);
     void ScanAnalog(uint cardid, uint sourceid);
@@ -113,6 +114,9 @@
     uint               frequency;
     QString            modulation;
     QMap<QString,QString> startChan;
+
+    // dvb-utils imported channels
+    DTVChannelList channels;
 };
 
 #endif // _SCANWIZARDSCANNER_H_
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/siscan.cpp mythtv-0.20-new/libs/libmythtv/siscan.cpp
--- mythtv-0.20-old/libs/libmythtv/siscan.cpp	2006-08-18 13:37:07.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/siscan.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -322,7 +322,10 @@
     pat_vec_t pats = sd->GetCachedPATs();
     pmt_map_t pmt_map = sd->GetCachedPMTMap();
     for (uint i = 0; i < pats.size(); i++)
-        UpdatePATinDB(mplexid, fn, freqid, pats[i], pmt_map, true);
+    {
+        UpdatePATinDB(mplexid, fn, freqid, pats[i], pmt_map,
+                      (*current).expectedChannels, true);
+    }
     sd->ReturnCachedPMTTables(pmt_map);
     sd->ReturnCachedPATTables(pats);
 
@@ -354,13 +357,19 @@
     // Insert Terrestrial VCTs
     tvct_vec_t tvcts = sd->GetAllCachedTVCTs();
     for (uint i = 0; i < tvcts.size(); i++)
-        UpdateVCTinDB(mplexid, fn, freqid, tvcts[i], true);
+    {
+        UpdateVCTinDB(mplexid, fn, freqid, tvcts[i],
+                      (*current).expectedChannels, true);
+    }
     sd->ReturnCachedTVCTTables(tvcts);
 
     // Insert Cable VCTs
     cvct_vec_t cvcts = sd->GetAllCachedCVCTs();
     for (uint i = 0; i < cvcts.size(); i++)
-        UpdateVCTinDB(mplexid, fn, freqid, cvcts[i], true);
+    {
+        UpdateVCTinDB(mplexid, fn, freqid, cvcts[i],
+                      (*current).expectedChannels, true);
+    }
     sd->ReturnCachedCVCTTables(cvcts);
 
     // tell UI we are done with these channels
@@ -386,7 +395,10 @@
 
     vector<const ServiceDescriptionTable*> sdts = sd->GetAllCachedSDTs();
     for (uint i = 0; i < sdts.size(); i++)
-        UpdateSDTinDB((*current).mplexid, sdts[i], forceUpdate);
+    {
+        UpdateSDTinDB((*current).mplexid, sdts[i],
+                      (*current).expectedChannels, forceUpdate);
+    }
     sd->ReturnCachedSDTTables(sdts);
 
     emit ServiceScanUpdateText(tr("Finished processing Services"));
@@ -535,20 +547,19 @@
     if (!waitingForTables)
         return true;
 
-    QString offset_str = current.offset() ?
-        QObject::tr(" offset %2").arg(current.offset()) : "";
-    QString cur_chan = QString("%1%2")
-        .arg((*current).FriendlyName).arg(offset_str);
-    QString time_out_table_str =
-        QObject::tr("Timeout Scanning %1 -- no tables").arg(cur_chan);
-    QString time_out_sig_str =
-        QObject::tr("Timeout Scanning %1 -- no signal").arg(cur_chan);
-
     // have the tables have timed out?
     if (timer.elapsed() > (int)channelTimeout)
     { 
+        QString offset_str = current.offset() ?
+            QObject::tr(" offset %2").arg(current.offset()) : "";
+        QString cur_chan = QString("%1%2")
+            .arg((*current).FriendlyName).arg(offset_str);
+        QString time_out_table_str =
+            QObject::tr("Timeout Scanning %1 -- no tables").arg(cur_chan);
+
         emit ServiceScanUpdateText(time_out_table_str);
         VERBOSE(VB_SIPARSER, LOC + time_out_table_str);
+
         return true;
     }
 
@@ -560,6 +571,13 @@
         if (NULL == sm || sm->HasSignalLock())
             return false;
 
+        QString offset_str = current.offset() ?
+            QObject::tr(" offset %2").arg(current.offset()) : "";
+        QString cur_chan = QString("%1%2")
+            .arg((*current).FriendlyName).arg(offset_str);
+        QString time_out_sig_str =
+            QObject::tr("Timeout Scanning %1 -- no signal").arg(cur_chan);
+
         emit ServiceScanUpdateText(time_out_sig_str);
         VERBOSE(VB_SIPARSER, LOC + time_out_sig_str);
 
@@ -787,6 +805,41 @@
     return true;
 }
 
+bool SIScan::ScanForChannels(uint sourceid,
+                             const QString &std,
+                             const QString &cardtype,
+                             const DTVChannelList &channels)
+{
+    scanTransports.clear();
+    nextIt = scanTransports.end();
+
+    DTVChannelList::const_iterator it = channels.begin();
+    for (uint i = 0; it != channels.end(); ++it, i++)
+    {
+        TransportScanItem item(sourceid, std, QString::number(i),
+                               cardtype, *it, signalTimeout);
+
+        scanTransports += item;
+
+        VERBOSE(VB_SIPARSER, LOC + item.toString());
+    }
+
+    if (scanTransports.empty())
+    {
+        VERBOSE(VB_IMPORTANT, LOC_ERR + "ScanForChannels() no transports");
+        return false;
+    }
+
+    timer.start();
+    waitingForTables = false;
+
+    nextIt            = scanTransports.begin();
+    transportsScanned = 0;
+    scanMode          = TRANSPORT_LIST;
+
+    return true;
+}
+
 /** \fn SIScan::ScanTransportsStartingOn(int,const QMap<QString,QString>&)
  *  \brief Generates a list of frequencies to scan and adds it to the
  *   scanTransport list, and then sets the scanMode to TRANSPORT_LIST.
@@ -953,6 +1006,52 @@
 #endif // USING_DVB
 }
 
+/** \fn SIScan::CheckImportedList(const DTVChannelInfoList&,uint,QString&,QString&,QString&)
+ *  \brief If we as scanning a dvb-utils import verify channel is in list..
+ */
+bool SIScan::CheckImportedList(const DTVChannelInfoList &channels,
+                               uint mpeg_program_num,
+                               QString &service_name,
+                               QString &callsign,
+                               QString &common_status_info)
+{
+    if (channels.empty())
+        return true;
+
+    bool found = false;
+    for (uint i = 0; i < channels.size(); i++)
+    {
+        VERBOSE(VB_IMPORTANT,
+                QString("comparing %1 %2 against %3 %4")
+                .arg(channels[i].serviceid).arg(channels[i].name)
+                .arg(mpeg_program_num).arg(common_status_info));
+
+        if (channels[i].serviceid == mpeg_program_num)
+        {
+            found = true;
+            if (!channels[i].name.isEmpty())
+            {
+                service_name = QDeepCopy<QString>(channels[i].name);
+                callsign     = QDeepCopy<QString>(channels[i].name);
+            }
+        }
+    }
+
+    if (found)
+    {
+        common_status_info += QString(" %1 %2")
+            .arg(tr("as")).arg(service_name);
+    }
+    else
+    {
+        emit ServiceScanUpdateText(
+            tr("Skipping %1, not in imported channel map")
+            .arg(common_status_info));
+    }
+
+    return found;
+}
+
 // ///////////////////// DB STUFF /////////////////////
 // ///////////////////// DB STUFF /////////////////////
 // ///////////////////// DB STUFF /////////////////////
@@ -962,7 +1061,8 @@
 void SIScan::UpdatePMTinDB(
     int db_source_id,
     int db_mplexid, const QString &friendlyName, int freqid,
-    int pmt_indx, const ProgramMapTable *pmt, bool /*force_update*/)
+    int pmt_indx, const ProgramMapTable *pmt,
+    const DTVChannelInfoList &channels, bool /*force_update*/)
 {
     // See if service already in database based on program number
     int chanid = ChannelUtil::GetChanID(
@@ -988,10 +1088,16 @@
 
     QString common_status_info = tr("%1%2%3 on %4 (%5)")
         .arg(service_name)
-        .arg(service_name.isEmpty() ? "" : " as ")
+        .arg(service_name.isEmpty() ? "" : QString(" %1 ").arg(tr("as")))
         .arg(chan_num)
         .arg(friendlyName).arg(freqid);
 
+    if (!CheckImportedList(channels, pmt->ProgramNumber(),
+                           service_name, chan_num, common_status_info))
+    {
+        return;
+    }
+
     if (chanid < 0)
     {   // The service is not in database, add it
         emit ServiceScanUpdateText(
@@ -1028,7 +1134,7 @@
 void SIScan::UpdatePATinDB(
     int db_mplexid, const QString &friendlyName, int freqid,
     const ProgramAssociationTable *pat, const pmt_map_t &pmt_map,
-    bool force_update)
+    const DTVChannelInfoList &channels, bool force_update)
 {
     VERBOSE(VB_SIPARSER, LOC +
             QString("UpdatePATinDB(): tsid: 0x%1  mplex: %2")
@@ -1066,7 +1172,7 @@
                 continue;
 
             UpdatePMTinDB(db_source_id, db_mplexid, friendlyName, freqid,
-                          i, *vit, force_update);
+                          i, *vit, channels, force_update);
         }
     }    
 }
@@ -1076,6 +1182,7 @@
 void SIScan::UpdateVCTinDB(int db_mplexid,
                            const QString &friendlyName, int freqid,
                            const VirtualChannelTable *vct,
+                           const DTVChannelInfoList &channels,
                            bool force_update)
 {
     (void) force_update;
@@ -1142,6 +1249,13 @@
             .arg(vct->MajorChannel(i)).arg(vct->MinorChannel(i))
             .arg(chan_num).arg(friendlyName).arg(freqid);
 
+        QString callsign = vct->ShortChannelName(i);
+
+        if (!CheckImportedList(channels, vct->ProgramNumber(i),
+                               longName, callsign, common_status_info))
+        {
+            continue;
+        }
         QString msg = "";
         if (chanid < 0)
         {   // The service is not in database, add it
@@ -1153,7 +1267,7 @@
                     db_mplexid,
                     db_source_id,
                     chanid,
-                    vct->ShortChannelName(i),
+                    callsign,
                     longName,
                     chan_num,
                     vct->ProgramNumber(i),
@@ -1170,7 +1284,7 @@
                 db_mplexid,
                 db_source_id,
                 chanid,
-                vct->ShortChannelName(i),
+                callsign,
                 longName,
                 chan_num,
                 vct->ProgramNumber(i),
@@ -1186,6 +1300,7 @@
  *  \brief Inserts channels from service description table.
  */
 void SIScan::UpdateSDTinDB(int /*mplexid*/, const ServiceDescriptionTable *sdt,
+                           const DTVChannelInfoList &channels,
                            bool force_update)
 {
     if (!sdt->ServiceCount())
@@ -1261,6 +1376,14 @@
             continue;
         }
 
+        QString common_status_info = service_name;
+
+        if (!CheckImportedList(channels, sdt->ServiceID(i),
+                               service_name, service_name, common_status_info))
+        {
+            continue;
+        }
+
         // See if service already in database based on service ID
         int chanid = ChannelUtil::GetChanID(db_mplexid, -1, -1, -1,
                                             sdt->ServiceID(i));
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/siscan.h mythtv-0.20-new/libs/libmythtv/siscan.h
--- mythtv-0.20-old/libs/libmythtv/siscan.h	2006-08-18 13:37:07.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/siscan.h	2007-04-17 10:23:33.000000000 -0700
@@ -14,6 +14,7 @@
 // MythTV includes
 #include "frequencytables.h"
 #include "streamlisteners.h"
+#include "dvbconfparser.h"
 
 class MSqlQuery;
 
@@ -54,6 +55,9 @@
     bool ScanTransportsStartingOn(
         int sourceid, const QMap<QString,QString> &valueMap);
     bool ScanTransport(int mplexid);
+    bool ScanForChannels(
+        uint sourceid, const QString &std, const QString &cardtype,
+        const DTVChannelList&);
 
     bool ScanServicesSourceID(int SourceID);
 
@@ -119,24 +123,34 @@
     /// \brief Updates Transport Scan progress bar
     inline void UpdateScanPercentCompleted(void);
 
+    bool CheckImportedList(const DTVChannelInfoList&,
+                           uint mpeg_program_num,
+                           QString &service_name,
+                           QString &callsign,
+                           QString &common_status_info);
+
     void HandleMPEGDBInsertion(const ScanStreamData *sd, bool wait);
     void UpdatePATinDB(int mplexid, const QString &friendlyName, int freqid,
                        const ProgramAssociationTable*, const pmt_map_t&,
+                       const DTVChannelInfoList&,
                        bool force_update);
 
     void UpdatePMTinDB(int sourceid,
                        int mplexid, const QString &friendlyName, int freqid,
                        int pmt_indx, const ProgramMapTable*,
+                       const DTVChannelInfoList&,
                        bool force_update);
 
     void HandleATSCDBInsertion(const ScanStreamData *sd, bool wait);
     void UpdateVCTinDB(int mplexid, const QString &friendlyName, int freqid,
                        const VirtualChannelTable*,
+                       const DTVChannelInfoList&,
                        bool force_update);
 
     void HandleDVBDBInsertion(const ScanStreamData *sd, bool wait);
     void UpdateSDTinDB(int mplexid,
                        const ServiceDescriptionTable*,
+                       const DTVChannelInfoList&,
                        bool force_update);
 
     bool HandlePostInsertion(void);
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/tv_play.cpp mythtv-0.20-new/libs/libmythtv/tv_play.cpp
--- mythtv-0.20-old/libs/libmythtv/tv_play.cpp	2006-09-07 09:52:11.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/tv_play.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -5445,6 +5445,7 @@
         return;
 
     browsechannum = chan;
+    browsechanid = QString::null;
     BrowseDispInfo(BROWSE_SAME);
 }
 
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/tv_rec.cpp mythtv-0.20-new/libs/libmythtv/tv_rec.cpp
--- mythtv-0.20-old/libs/libmythtv/tv_rec.cpp	2006-09-09 12:45:01.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/tv_rec.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -554,6 +554,10 @@
 
     WaitForEventThreadSleep();
 
+    if ((curRecording) && (curRecording->recstatus == rsFailed) &&
+        (retval == rsRecording))
+        retval = rsFailed;
+
     return retval;
 }
 
@@ -675,20 +679,21 @@
     VERBOSE(VB_RECORD, LOC + QString("FinishedRecording(%1) in recgroup: %2")
                                      .arg(curRec->title).arg(pigrp));
 
-    curRec->recstatus = rsRecorded;
+    if (curRec->recstatus != rsFailed)
+        curRec->recstatus = rsRecorded;
     curRec->recendts = mythCurrentDateTime();
 
     if (tvchain)
         tvchain->FinishedRecording(curRec);
 
+    // Make sure really short recordings have positive run time.
+    if (curRec->recendts <= curRec->recstartts)
+        curRec->recendts = curRec->recstartts.addSecs(60);
+
     curRec->recendts.setTime(QTime(
         curRec->recendts.addSecs(30).time().hour(),
         curRec->recendts.addSecs(30).time().minute()));
 
-    // Make sure really short recordings have positive run time.
-    if (curRec->recendts <= curRec->recstartts)
-        curRec->recendts = mythCurrentDateTime().addSecs(1);
-
     if (pigrp != "LiveTV")
     {
         MythEvent me(QString("UPDATE_RECORDING_STATUS %1 %2 %3 %4 %5")
@@ -699,7 +704,8 @@
                      .arg(curRec->recendts.toString(Qt::ISODate)));
         gContext->dispatch(me);
     }
-    curRec->FinishedRecording(false);
+
+    curRec->FinishedRecording(curRec->recstatus != rsRecorded);
 }
 
 #define TRANSITION(ASTATE,BSTATE) \
@@ -1679,6 +1685,9 @@
         sd->SetCaching(true);
     }
 
+    bool fta = CardUtil::IgnoreEncrypted(
+        GetCaptureCardNum(), channel->GetCurrentInput());
+
     // Check if this is an ATSC Channel
     int major = channel->GetMajorChannel();
     int minor = channel->GetMinorChannel();
@@ -1700,7 +1709,7 @@
         sm->SetStreamData(sd);
         sm->SetChannel(major, minor);
         sd->SetVideoStreamsRequired(1);
-        sm->SetFTAOnly(true);
+        sm->SetFTAOnly(fta);
 
         // Try to get pid of VCT from cache and
         // require MGT if we don't have VCT pid.
@@ -1750,9 +1759,6 @@
         if (GetDVBChannel())
             sd->SetIgnoreCRC(GetDVBChannel()->HasCRCBug());
 
-        bool fta = CardUtil::IgnoreEncrypted(
-            GetCaptureCardNum(), channel->GetCurrentInput());
-
         dsd->Reset(netid, tsid, progNum);
         sm->SetStreamData(sd);
         sm->SetDVBService(netid, tsid, progNum);
@@ -1791,9 +1797,6 @@
             sd->SetIgnoreCRC(GetDVBChannel()->HasCRCBug());
 #endif // USING_DVB
 
-        bool fta = CardUtil::IgnoreEncrypted(
-            GetCaptureCardNum(), channel->GetCurrentInput());
-
         sd->Reset(progNum);
         sm->SetStreamData(sd);
         sm->SetProgramNumber(progNum);
@@ -3443,6 +3446,9 @@
     {
         if (!(request.flags & kFlagLiveTV))
         {
+            if (curRecording)
+                curRecording->recstatus = rsFailed;
+
             VERBOSE(VB_IMPORTANT, LOC_ERR +
                     QString("Failed to set channel to %1. "
                             "Reverting to kState_None")
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/videodev2_myth.h mythtv-0.20-new/libs/libmythtv/videodev2_myth.h
--- mythtv-0.20-old/libs/libmythtv/videodev2_myth.h	2006-07-18 08:55:57.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/videodev2_myth.h	2007-04-17 10:23:33.000000000 -0700
@@ -721,7 +721,7 @@
 		__s64 value64;
 		void *reserved;
 	};
-};
+}  __attribute__ ((packed));
 
 struct v4l2_ext_controls
 {
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/videoout_quartz.cpp mythtv-0.20-new/libs/libmythtv/videoout_quartz.cpp
--- mythtv-0.20-old/libs/libmythtv/videoout_quartz.cpp	2006-08-31 20:25:59.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/videoout_quartz.cpp	2007-04-17 10:23:32.000000000 -0700
@@ -17,7 +17,7 @@
  *   a second time, may cause a crash (backtraces appreciated)
  * 
  * = REVISION
- * $Id: videoout_quartz.cpp 11013 2006-09-01 03:25:59Z nigel $
+ * $Id: videoout_quartz.cpp 13053 2007-03-15 22:34:28Z nigel $
  *
  * = AUTHORS
  * Nigel Pearson, Jeremiah Morris
@@ -1638,10 +1638,8 @@
         accel->DecodeFrame(buffer);
 #endif // CONFIG_MAC_ACCEL
 
-    if (!buffer)
-        buffer = vbuffers.GetScratchFrame();
-
-    framesPlayed = buffer->frameNumber + 1;
+    if (buffer)
+        framesPlayed = buffer->frameNumber + 1;
 }
 
 void VideoOutputQuartz::Show(FrameScanType t)
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/videoout_xv.cpp mythtv-0.20-new/libs/libmythtv/videoout_xv.cpp
--- mythtv-0.20-old/libs/libmythtv/videoout_xv.cpp	2006-08-29 00:13:24.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/videoout_xv.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -2859,9 +2859,7 @@
         VideoFrame *osdframe = NULL;
         int ret = DisplayOSD(xvmc_osd->OSDFrame(), osd, -1,
                              xvmc_osd->GetRevision());
-        OSDSurface *osdsurf = osd->Display();
-        if (osdsurf)
-            xvmc_osd->SetRevision(osdsurf->GetRevision());
+        xvmc_osd->SetRevision(osd->GetRevision());
         if (ret >= 0 && xvmc_osd->NeedFrame())
         {
             // If there are no available buffer, try to toss old
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/videosource.cpp mythtv-0.20-new/libs/libmythtv/videosource.cpp
--- mythtv-0.20-old/libs/libmythtv/videosource.cpp	2006-09-07 08:43:22.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/videosource.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -1477,26 +1477,32 @@
     };
 };
 
-class FreeToAir: public CheckBoxSetting, public CISetting {
+class FreeToAir: public CheckBoxSetting, public CISetting
+{
   public:
     FreeToAir(const CardInput& parent):
         CISetting(parent, "freetoaironly")
     {
         setValue(true);
-        setLabel(QObject::tr("Free to air channels only."));
-        setHelpText(QObject::tr("If set, only free to air channels will be "
-                    "used."));
+        setLabel(QObject::tr("Unencrypted channels only"));
+        setHelpText(QObject::tr(
+                        "If set, only unencrypted channels will be tuned to "
+                        "by MythTV or not be ignored by the MythTV channel "
+                        "scanner."));
     };
 };
 
-class RadioServices: public CheckBoxSetting, public CISetting {
-public:
+class RadioServices: public CheckBoxSetting, public CISetting
+{
+  public:
     RadioServices(const CardInput& parent):
         CISetting(parent, "radioservices")
     {
         setValue(true);
-        setLabel(QObject::tr("Radio channels."));
-        setHelpText(QObject::tr("If set, radio channels will also be included.")); 
+        setLabel(QObject::tr("Allow audio only channels"));
+        setHelpText(QObject::tr(
+                        "If set, audio only channels will not be ignored "
+                        "by the MythTV channel scanner.")); 
     };
 };
 
@@ -1597,7 +1603,7 @@
     };
 };
 
-CardInput::CardInput(bool isDVBcard, int _cardid)
+CardInput::CardInput(bool isDTVcard, bool isDVBcard, int _cardid)
 {
     (void) _cardid;
 
@@ -1621,28 +1627,30 @@
         group->addChild(new PresetTuner(*this));
     }
 
-#ifdef USING_DVB
-    if (isDVBcard)
+    if (isDTVcard)
     {
-        ConfigurationGroup *dvbgroup =
-            new HorizontalConfigurationGroup();
-        dvbgroup->setLabel(QObject::tr("DVB options"));
-
+        // we place this in a group just so the margins match the DVB ones.
         ConfigurationGroup *chgroup = 
-            new VerticalConfigurationGroup(false, false, true, true);
+            new HorizontalConfigurationGroup(false, false, true, true);
+        chgroup->addChild(new FreeToAir(*this));
+        group->addChild(chgroup);
+    }
 
+#ifdef USING_DVB
+    if (isDVBcard)
+    {
         TransButtonSetting *diseqc = new TransButtonSetting();
         diseqc->setLabel(tr("DVB-S"));
         diseqc->setHelpText(tr("Input and satellite settings."));
         diseqc->setVisible(DTVDeviceNeedsConfiguration(_cardid));
-        dvbgroup->addChild(diseqc);
+        group->addChild(diseqc);
         connect(diseqc, SIGNAL(pressed()), SLOT(diseqcConfig()));
    
-        chgroup->addChild(new FreeToAir(*this));
+        ConfigurationGroup *chgroup = 
+            new HorizontalConfigurationGroup(false, false, true, true);
         chgroup->addChild(new RadioServices(*this));
         chgroup->addChild(new DishNetEIT(*this));
-        dvbgroup->addChild(chgroup);
-        group->addChild(dvbgroup);
+        group->addChild(chgroup);
     }
 #endif
 
@@ -2079,6 +2087,30 @@
     if (val == 0)
     {
         MSqlQuery query(MSqlQuery::InitCon());
+
+        // Delete the channels associated with the source
+        query.prepare("DELETE FROM channel "
+                      "WHERE sourceid = :SOURCEID");
+        query.bindValue(":SOURCEID", getValue());
+
+        if (!query.exec() || !query.isActive())
+        {
+            MythContext::DBError("Deleting Channels", query);
+            return;
+        }
+
+        // Delete the inputs associated with the source
+        query.prepare("DELETE FROM cardinput "
+                      "WHERE sourceid = :SOURCEID");
+        query.bindValue(":SOURCEID", getValue());
+
+        if (!query.exec() || !query.isActive())
+        {
+            MythContext::DBError("Deleting cardinputs", query);
+            return;
+        }
+
+        // Delete the source itself
         query.prepare("DELETE FROM videosource "
                       "WHERE sourceid = :SOURCEID");
         query.bindValue(":SOURCEID", getValue());
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/videosource.h mythtv-0.20-new/libs/libmythtv/videosource.h
--- mythtv-0.20-old/libs/libmythtv/videosource.h	2006-07-20 14:24:51.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/videosource.h	2007-04-17 10:23:32.000000000 -0700
@@ -531,7 +531,7 @@
 {
     Q_OBJECT
   public:
-    CardInput(bool is_dvb_card, int cardid);
+    CardInput(bool is_dtv_card, bool is_dvb_card, int cardid);
 
     int getInputID(void) const { return id->intValue(); };
 
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/vsync.cpp mythtv-0.20-new/libs/libmythtv/vsync.cpp
--- mythtv-0.20-old/libs/libmythtv/vsync.cpp	2006-05-24 07:56:37.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/vsync.cpp	2007-04-17 10:23:33.000000000 -0700
@@ -437,12 +437,64 @@
     UpdateNexttrigger();
 }
 
+#ifdef USING_OPENGL_VSYNC
+class OpenGLVideoSyncPrivate
+{
+  public:
+    OpenGLVideoSyncPrivate()
+    {
+        m_glXGetVideoSyncSGI = (PFNGLXGETVIDEOSYNCSGIPROC)
+                glXGetProcAddress("glXGetVideoSyncSGI");
+        m_glXWaitVideoSyncSGI = (PFNGLXWAITVIDEOSYNCSGIPROC)
+                glXGetProcAddress("glXWaitVideoSyncSGI");
+    }
+
+    bool funcsLoaded()
+    {
+        return m_glXGetVideoSyncSGI && m_glXWaitVideoSyncSGI;
+    }
+
+  public:
+    int glXGetVideoSyncSGI(unsigned int *count)
+    {
+        return m_glXGetVideoSyncSGI(count);
+    }
+
+    int glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count)
+    {
+        return m_glXWaitVideoSyncSGI(divisor, remainder, count);
+    }
+
+  private:
+    __GLXextFuncPtr glXGetProcAddress(const char * const procName)
+    {
+        __GLXextFuncPtr ret = glXGetProcAddressARB((const GLubyte *) procName);
+
+        if (!ret)
+        {
+            VERBOSE(VB_PLAYBACK,
+                    QString("Error: glXGetProcAddressARB unable to find %1")
+                    .arg(procName));
+        }
+
+        return ret;
+    }
+
+  private:
+    PFNGLXGETVIDEOSYNCSGIPROC m_glXGetVideoSyncSGI;
+    PFNGLXWAITVIDEOSYNCSGIPROC m_glXWaitVideoSyncSGI;
+};
+#endif // USING_OPENGL_VSYNC
+
 OpenGLVideoSync::OpenGLVideoSync(VideoOutput *video_output,
                                  int frame_interval, int refresh_interval,
                                  bool interlaced)
     : VideoSync(video_output, frame_interval, refresh_interval, interlaced),
-      m_drawable(0), m_context(0)
+      m_drawable(0), m_context(0), m_imp(0)
 {
+#ifdef USING_OPENGL_VSYNC
+    m_imp = new OpenGLVideoSyncPrivate;
+#endif // USING_OPENGL_VSYNC
 }
 
 OpenGLVideoSync::~OpenGLVideoSync()
@@ -457,6 +509,7 @@
         if (m_drawable)
             X11S(XDestroyWindow(vo->XJ_disp, m_drawable));
     }
+    delete m_imp;
 #endif /* USING_OPENGL_VSYNC */
 }
 
@@ -503,6 +556,12 @@
         return false;
     }
 
+    if (!m_imp->funcsLoaded())
+    {
+       VERBOSE(VB_PLAYBACK, QString("GL sync functions not found"));
+       return false;
+    }
+
     int attribList[] = {GLX_RGBA, 
                         GLX_RED_SIZE, 1,
                         GLX_GREEN_SIZE, 1,
@@ -552,7 +611,7 @@
     if (ret != False)
     {
         unsigned int count;
-        X11S(ret = glXGetVideoSyncSGI(&count));
+        X11S(ret = m_imp->glXGetVideoSyncSGI(&count));
         if (ret == 0)
         {
             VERBOSE(VB_PLAYBACK, "Using OpenGLVideoSync");
@@ -631,9 +690,9 @@
 
     // Wait for a refresh so we start out synched
     unsigned int count;
-    err = glXGetVideoSyncSGI(&count);
+    err = m_imp->glXGetVideoSyncSGI(&count);
     checkGLSyncError("OpenGLVideoSync::Start(): Frame Number Query", err);
-    err = glXWaitVideoSyncSGI(2, (count+1)%2 ,&count);
+    err = m_imp->glXWaitVideoSyncSGI(2, (count+1)%2 ,&count);
     checkGLSyncError("OpenGLVideoSync::Start(): A/V Sync", err);
 
     // Initialize next trigger 
@@ -649,13 +708,13 @@
     OffsetTimeval(m_nexttrigger, sync_delay);
 
     unsigned int frameNum = 0;
-    int err = glXGetVideoSyncSGI(&frameNum);
+    int err = m_imp->glXGetVideoSyncSGI(&frameNum);
     checkGLSyncError("Frame Number Query", err);
 
     // Always sync to the next retrace execpt when we are very late.
     if ((m_delay = CalcDelay()) > -(m_refresh_interval/2)) 
     {
-        err = glXWaitVideoSyncSGI(2, (frameNum+1)%2 ,&frameNum);
+        err = m_imp->glXWaitVideoSyncSGI(2, (frameNum+1)%2 ,&frameNum);
         checkGLSyncError(msg1, err);
         m_delay = CalcDelay();
     }
@@ -664,7 +723,7 @@
     if (m_delay > 0)
     {
         uint n = m_delay / m_refresh_interval + 1;
-        err = glXWaitVideoSyncSGI((n+1), (frameNum+n)%(n+1), &frameNum);
+        err = m_imp->glXWaitVideoSyncSGI((n+1), (frameNum+n)%(n+1), &frameNum);
         checkGLSyncError(msg2, err);
         m_delay = CalcDelay();
     }
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythtv/vsync.h mythtv-0.20-new/libs/libmythtv/vsync.h
--- mythtv-0.20-old/libs/libmythtv/vsync.h	2006-05-11 07:50:17.000000000 -0700
+++ mythtv-0.20-new/libs/libmythtv/vsync.h	2007-04-17 10:23:33.000000000 -0700
@@ -214,6 +214,8 @@
   private:
     GLXDrawable m_drawable;
     GLXContext  m_context;
+  private:
+    class OpenGLVideoSyncPrivate *m_imp;
 };
 
 #ifdef __linux__
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythui/mythmainwindow.cpp mythtv-0.20-new/libs/libmythui/mythmainwindow.cpp
--- mythtv-0.20-old/libs/libmythui/mythmainwindow.cpp	2006-08-24 20:17:16.000000000 -0700
+++ mythtv-0.20-new/libs/libmythui/mythmainwindow.cpp	2007-04-17 10:23:36.000000000 -0700
@@ -814,8 +814,6 @@
         else
         {
             QString inskey = keybind;
-            inskey.replace('\\', "\\\\");
-            inskey.replace('\"', "\\\"");
 
             query.prepare("INSERT INTO keybindings (context, action, "
                           "description, keylist, hostname) VALUES "
@@ -936,8 +934,6 @@
         else
         {
             QString inskey = keybind;
-            inskey.replace('\\', "\\\\");
-            inskey.replace('\"', "\\\"");
 
             query.prepare("INSERT INTO jumppoints (destination, description, "
                           "keylist, hostname) VALUES ( :DEST, :DESC, :KEYLIST, "
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythui/myththemedmenu.cpp mythtv-0.20-new/libs/libmythui/myththemedmenu.cpp
--- mythtv-0.20-old/libs/libmythui/myththemedmenu.cpp	2006-09-09 13:59:59.000000000 -0700
+++ mythtv-0.20-new/libs/libmythui/myththemedmenu.cpp	2007-04-17 10:23:36.000000000 -0700
@@ -14,7 +14,6 @@
 #include "mythfontproperties.h"
 #include "mythimage.h"
 #include "mythdialogbox.h"
-#include "mythmediamonitor.h"
 
 #include "lcddevice.h"
 #include "mythplugin.h"
@@ -1870,9 +1869,7 @@
         }
         else if (action == "EJECT")
         {
-            MediaMonitor *mon = MediaMonitor::GetMediaMonitor();
-            if (mon)
-                mon->ChooseAndEjectMedia();
+            myth_eject();
         }
         else
             handled = false;
@@ -2078,9 +2075,7 @@
     }
     else if (action.left(5) == "EJECT")
     {
-        MediaMonitor *mon = MediaMonitor::GetMediaMonitor();
-        if (mon)
-            mon->ChooseAndEjectMedia();
+        myth_eject();
     }
     else if (action.left(5) == "JUMP ")
     {
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythupnp/bufferedsocketdevice.cpp mythtv-0.20-new/libs/libmythupnp/bufferedsocketdevice.cpp
--- mythtv-0.20-old/libs/libmythupnp/bufferedsocketdevice.cpp	2006-06-05 23:51:03.000000000 -0700
+++ mythtv-0.20-new/libs/libmythupnp/bufferedsocketdevice.cpp	2007-04-17 10:23:44.000000000 -0700
@@ -392,6 +392,15 @@
 //
 /////////////////////////////////////////////////////////////////////////////
 
+void BufferedSocketDevice::ClearReadBuffer()
+{
+    m_bufRead.clear();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
 Q_LONG BufferedSocketDevice::ReadBlock( char *data, Q_ULONG maxlen )
 {
     if ( data == 0 && maxlen != 0 ) 
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythupnp/bufferedsocketdevice.h mythtv-0.20-new/libs/libmythupnp/bufferedsocketdevice.h
--- mythtv-0.20-old/libs/libmythupnp/bufferedsocketdevice.h	2006-06-05 23:51:03.000000000 -0700
+++ mythtv-0.20-new/libs/libmythupnp/bufferedsocketdevice.h	2007-04-17 10:23:44.000000000 -0700
@@ -68,6 +68,7 @@
         Q_ULONG             WaitForMore         ( int msecs, bool *timeout = NULL );
         Q_ULONG             BytesToWrite        () const;
         void                ClearPendingData    ();
+        void                ClearReadBuffer     ();
 
         Q_LONG              ReadBlock           ( char *data, Q_ULONG maxlen );
         Q_LONG              WriteBlock          ( const char *data, Q_ULONG len );
diff -Naur -x mytharchive mythtv-0.20-old/libs/libmythupnp/httprequest.cpp mythtv-0.20-new/libs/libmythupnp/httprequest.cpp
--- mythtv-0.20-old/libs/libmythupnp/httprequest.cpp	2006-06-07 08:41:00.000000000 -0700
+++ mythtv-0.20-new/libs/libmythupnp/httprequest.cpp	2007-04-17 10:23:44.000000000 -0700
@@ -28,6 +28,7 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+#include "util.h"
 #include "mythcontext.h"
 #include "upnp.h"
 
@@ -238,7 +239,9 @@
                                                               .arg( llStart )
                                                               .arg( llEnd   )
                                                               .arg( llSize  );
-                llSize = (llEnd - llStart) + 1;
+                //llSize = (llEnd - llStart) + 1;
+                llSize = (llEnd - llStart);
+
             }
         }
         
@@ -257,12 +260,16 @@
     else
         m_nResponseStatus = 404;
 
+    QString sDate = QDateTime::currentDateTime().toString( "d MMM yyyy hh:mm:ss" );  
+
     sHeader   = QString("HTTP/%1.%2 %3\r\n"
-                        "Content-Type: %4\r\n"
-                        "Content-Length: %5\r\n" )
+                        "Date: %4\r\n"
+                        "Content-Type: %5\r\n"
+                        "Content-Length: %6\r\n" )
                         .arg( m_nMajor )
                         .arg( m_nMinor )
                         .arg( GetResponseStatus())
+                        .arg( sDate )
                         .arg( sContentType )
                         .arg( llSize       ).utf8();
 
@@ -281,7 +288,19 @@
     {
         __off64_t offset = llStart;
         int       file   = open( sFileName.ascii(), O_RDONLY | O_LARGEFILE );
-        sendfile64( getSocketHandle(), file, &offset, llSize );
+        ssize_t   sent   = 0;  
+
+        do 
+        {  
+            // SSIZE_MAX should work in kernels 2.6.16 and later.  
+            // The loop is needed in any case.  
+
+            sent = sendfile64( getSocketHandle(), file, &offset, 
+                               (size_t)(llSize > INT_MAX ? INT_MAX : llSize));  
+
+            llSize -= sent;  
+        } 
+        while (( sent >= 0 ) && ( llSize > 0 ));  
 
         close( file );
     }
@@ -1163,6 +1182,7 @@
 QString BufferedSocketDeviceRequest::ReadLine( int msecs )
 {
     QString sLine;
+    MythTimer timeout;
 
     if (m_pSocket)
     {
@@ -1177,13 +1197,24 @@
         {
             bool bTimeout = false;
 
+            timeout.start();
+
             while ( !m_pSocket->CanReadLine() && !bTimeout )
             {
                 m_pSocket->WaitForMore( msecs, &bTimeout );
+
+                if ( timeout.elapsed() >= msecs ) 
+                {
+                    bTimeout = true;
+                    m_pSocket->ClearReadBuffer(); 
+                }
+                else 
+                    usleep(20);
             }
             
             if (!bTimeout)
                 sLine = m_pSocket->ReadLine();
+
         }
     }
 
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythbackend/housekeeper.cpp mythtv-0.20-new/programs/mythbackend/housekeeper.cpp
--- mythtv-0.20-old/programs/mythbackend/housekeeper.cpp	2006-07-16 13:56:57.000000000 -0700
+++ mythtv-0.20-new/programs/mythbackend/housekeeper.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -221,16 +221,11 @@
                 }
             }
 
-            if (wantToRun("JobQueueCleanup", 1, 0, 24))
-            {
+            if (wantToRun("DailyCleanup", 1, 0, 24)) {
                 JobQueue::CleanupOldJobsInQueue();
-                updateLastrun("JobQueueCleanup");
-            }
-
-            if (wantToRun("InUseProgramsCleanup", 1, 0, 24))
-            {
                 CleanupAllOldInUsePrograms();
-                updateLastrun("InUseProgramsCleanup");
+                CleanupRecordedTables();
+                updateLastrun("DailyCleanup");
             }
         }
 
@@ -331,6 +326,48 @@
     query.exec();
 }
 
+void HouseKeeper::CleanupRecordedTables(void)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    MSqlQuery deleteQuery(MSqlQuery::InitCon());
+    int tableIndex = 0;
+    QString tables[] = {
+        "recordedprogram",
+        "recordedrating",
+        "recordedcredits",
+        "" }; // This blank entry must exist, do not remove.
+    QString table = tables[tableIndex];
+   
+    while (table != "")
+    {
+        query.prepare(QString("SELECT DISTINCT p.chanid, p.starttime "
+                              "FROM %1 p LEFT JOIN recorded r "
+                              "ON p.chanid = r.chanid "
+                              "AND p.starttime = r.progstart "
+                              "WHERE r.chanid IS NULL;")
+                              .arg(table));
+        if (!query.exec() || !query.isActive())
+        {
+            MythContext::DBError("HouseKeeper Cleaning Recorded Tables", query);
+            return;
+        }
+
+        deleteQuery.prepare(QString("DELETE FROM %1 "
+                                    "WHERE chanid = :CHANID "
+                                    "AND starttime = :STARTTIME;")
+                                    .arg(table));
+        while (query.next())
+        {
+            deleteQuery.bindValue(":CHANID", query.value(0).toString());
+            deleteQuery.bindValue(":STARTTIME", query.value(1).toString());
+            deleteQuery.exec();
+        }
+
+        tableIndex++;
+        table = tables[tableIndex];
+    }
+}
+
 void *HouseKeeper::doHouseKeepingThread(void *param)
 {
     HouseKeeper *hkeeper = (HouseKeeper*)param;
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythbackend/housekeeper.h mythtv-0.20-new/programs/mythbackend/housekeeper.h
--- mythtv-0.20-old/programs/mythbackend/housekeeper.h	2006-05-27 16:03:56.000000000 -0700
+++ mythtv-0.20-new/programs/mythbackend/housekeeper.h	2007-04-17 10:23:47.000000000 -0700
@@ -34,6 +34,7 @@
     void runFillDatabase();
     void CleanupMyOldRecordings(void);
     void CleanupAllOldInUsePrograms(void);
+    void CleanupRecordedTables(void);
     bool threadrunning;
     bool filldbRunning;
     bool isMaster;
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythbackend/httpstatus.cpp mythtv-0.20-new/programs/mythbackend/httpstatus.cpp
--- mythtv-0.20-old/programs/mythbackend/httpstatus.cpp	2006-07-18 18:34:13.000000000 -0700
+++ mythtv-0.20-new/programs/mythbackend/httpstatus.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -913,10 +913,14 @@
 
     ThreadData *pData = (ThreadData *)pThread->GetWorkerData();
 
-    if ((pData != NULL) && (pData->m_eType == ThreadData::DT_Recording))
-    {
-        if (pData->IsSameRecording( sChanId, sStartTime ))
-           pRequest->m_sFileName = pData->m_sFileName;
+    if (pData != NULL)
+    {   
+        if ((pData->m_eType == ThreadData::DT_Recording) && 
+               pData->IsSameRecording( sChanId, sStartTime ))
+        {   
+            pRequest->m_sFileName = pData->m_sFileName;
+
+        }
         else
            pData = NULL;
     }
@@ -1009,10 +1013,14 @@
 
     ThreadData *pData = (ThreadData *)pThread->GetWorkerData();
 
-    if ((pData != NULL) && (pData->m_eType == ThreadData::DT_Music))
-    {
-        if (pData->m_nTrackNumber == nTrack )
-           pRequest->m_sFileName = pData->m_sFileName;
+    if (pData != NULL)
+    {   
+        if ((pData->m_eType == ThreadData::DT_Music) && 
+               (pData->m_nTrackNumber == nTrack))
+        {   
+            pRequest->m_sFileName = pData->m_sFileName;
+
+        }
         else
            pData = NULL;
     }
@@ -1391,7 +1399,8 @@
         acpiTempFile.close(); 
     }                                                  
 
-#ifdef HAVE_LMSENSORS 
+#ifdef HAVE_LMSENSORS
+    tempSettingLock.lock();
     if (!found_acpi) 
     { 
         int chip_nr, a, b; 
@@ -1425,6 +1434,7 @@
         }  
         sensors_cleanup(); 
     } 
+    tempSettingLock.unlock();
 #endif 
 
     // Guide Data ---------------------
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythbackend/httpstatus.h mythtv-0.20-new/programs/mythbackend/httpstatus.h
--- mythtv-0.20-old/programs/mythbackend/httpstatus.h	2006-06-15 13:25:42.000000000 -0700
+++ mythtv-0.20-new/programs/mythbackend/httpstatus.h	2007-04-17 10:23:47.000000000 -0700
@@ -177,6 +177,7 @@
         int     PrintScheduled    ( QTextStream &os, QDomElement scheduled );
         int     PrintJobQueue     ( QTextStream &os, QDomElement jobs );
         int     PrintMachineInfo  ( QTextStream &os, QDomElement info );
+        QMutex  tempSettingLock;
 
     public:
                  HttpStatus( QMap<int, EncoderLink *> *tvList, Scheduler *sched, AutoExpire *expirer, bool bIsMaster );
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythbackend/main.cpp mythtv-0.20-new/programs/mythbackend/main.cpp
--- mythtv-0.20-old/programs/mythbackend/main.cpp	2006-06-08 21:41:00.000000000 -0700
+++ mythtv-0.20-new/programs/mythbackend/main.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -268,6 +268,7 @@
     bool testsched = false;
     bool resched = false;
     bool nosched = false;
+    bool noupnp = false;
     bool nojobqueue = false;
     bool nohousekeeper = false;
     bool noexpirer = false;
@@ -378,6 +379,10 @@
         {
             nosched = true;
         } 
+        else if (!strcmp(a.argv()[argpos],"--noupnp"))
+        {
+            noupnp = true;
+        } 
         else if (!strcmp(a.argv()[argpos],"--nojobqueue"))
         {
             nojobqueue = true;
@@ -422,6 +427,7 @@
                     "--testsched                    Test run scheduler (ignore existing schedule)" << endl <<
                     "--resched                      Force the scheduler to update" << endl <<
                     "--nosched                      Do not perform any scheduling" << endl <<
+                    "--noupnp                       Do not enable the UPNP server" << endl <<
                     "--nojobqueue                   Do not start the JobQueue" << endl <<
                     "--nohousekeeper                Do not start the Housekeeper" << endl <<
                     "--noautoexpire                 Do not start the AutoExpire thread" << endl <<
@@ -626,7 +632,11 @@
     g_pHttpServer->RegisterExtension(new HttpStatus(&tvList, sched, expirer, ismaster ));
 
     // Start UPnP Services For Master Backends Only
-    if (ismaster)
+    if (ismaster && noupnp)
+        cerr << "********* The UPNP service has been DISABLED with the "
+                "--noupnp option *********\n";
+
+    if (ismaster && !noupnp)
     {
         g_pUPnp = new UPnp(ismaster, g_pHttpServer);
 
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythbackend/mainserver.cpp mythtv-0.20-new/programs/mythbackend/mainserver.cpp
--- mythtv-0.20-old/programs/mythbackend/mainserver.cpp	2006-09-10 21:35:19.000000000 -0700
+++ mythtv-0.20-new/programs/mythbackend/mainserver.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -674,6 +674,36 @@
             return;
         }
 
+        if ((me->Message().left(16) == "DELETE_RECORDING") ||
+            (me->Message().left(22) == "FORCE_DELETE_RECORDING"))
+        {
+            QStringList tokens = QStringList::split(" ", me->Message());
+            if (tokens.size() != 3)
+            {
+                VERBOSE(VB_IMPORTANT, QString("Bad %1 message").arg(tokens[0]));
+                return;
+            }
+
+            QDateTime startts = QDateTime::fromString(tokens[2], Qt::ISODate);
+            ProgramInfo *pinfo = ProgramInfo::GetProgramFromRecorded(tokens[1],
+                                                                     startts);
+            if (pinfo)
+            {
+                if (tokens[0] == "FORCE_DELETE_RECORDING")
+                    DoHandleDeleteRecording(pinfo, NULL, true);
+                else
+                    DoHandleDeleteRecording(pinfo, NULL, false);
+            }
+            else
+            {
+                VERBOSE(VB_IMPORTANT,
+                    QString("Cannot find program info for '%1' while "
+                            "attempting to delete.").arg(me->Message()));
+            }
+
+            return;
+        }
+
         if (me->Message().left(21) == "RESCHEDULE_RECORDINGS" && m_sched)
         {
             QStringList tokens = QStringList::split(" ", me->Message());
@@ -1203,7 +1233,8 @@
 
                     proginfo->filesize = size;
 
-                    proginfo->SetFilesize(size);
+                    if (proginfo->recendts < QDateTime::currentDateTime())
+                        proginfo->SetFilesize(size);
                 }
             }
             else
@@ -1225,7 +1256,8 @@
                     {
                         slave->FillProgramInfo(proginfo, playbackhost);
 
-                        proginfo->SetFilesize(proginfo->filesize);
+                        if (proginfo->recendts < QDateTime::currentDateTime())
+                            proginfo->SetFilesize(proginfo->filesize);
                     }
                     else
                     {
@@ -1393,11 +1425,17 @@
     bool followLinks = gContext->GetNumSetting("DeletesFollowLinks", 0);
     bool slowDeletes = gContext->GetNumSetting("TruncateDeletesSlowly", 0);
     int fd = -1;
+    off_t size = 0;
     bool errmsg = false;
 
     /* Delete recording. */
     if (slowDeletes)
     {
+        // Since stat fails after unlinking on some filesystems,
+        // get the filesize first
+        struct stat st;
+        if (stat(ds->filename.ascii(), &st) == 0)
+            size = st.st_size;
         fd = DeleteFile(ds->filename, followLinks);
 
         if ((fd < 0) && checkFile.exists())
@@ -1445,7 +1483,7 @@
     if (slowDeletes && fd != -1)
     {
         m_expirer->TruncatePending();
-        TruncateAndClose(m_expirer, fd, ds->filename);
+        TruncateAndClose(m_expirer, fd, ds->filename, size);
         m_expirer->TruncateFinished();
     }
 }
@@ -1600,7 +1638,8 @@
  *         is running at a time.
  */
 bool MainServer::TruncateAndClose(const AutoExpire *expirer,
-                                  int fd, const QString &filename)
+                                  int fd, const QString &filename,
+                                  off_t fsize)
 {
     QMutexLocker locker(&truncate_and_close_lock);
 
@@ -1621,17 +1660,6 @@
             .arg(increment / (1024.0 * 1024.0), 0, 'f', 2)
             .arg(sleep_time));
 
-    // Get the on disk file size and preferred I/O block size.
-    struct stat buf;
-    fstat(fd, &buf);
-    // Estimate the file size.  Don't use buf.st_blksize * buf.st_blocks
-    // The unit for st_blocks is undefined.  See section "RATIONALE" at
-    // http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html
-    off_t fsize = ((buf.st_size / buf.st_blksize) + 1) * buf.st_blksize;
-
-    // Round truncate increment up to a blocksize, w/min of 1 block.
-    increment = ((increment / buf.st_blksize) + 1) * buf.st_blksize;
-
     while (fsize > 0)
     {
         //VERBOSE(VB_FILE, QString("Truncating '%1' to %2 MB")
@@ -1810,7 +1838,7 @@
         pbssock = pbs->getSocket();
 
     QString fileprefix = gContext->GetFilePrefix();
-    QString filename = pginfo->GetRecordFilename(fileprefix);
+    QString filename = pginfo->GetRecordFilename(fileprefix, true);
 
     // If this recording was made by a another recorder, and that
     // recorder is available, tell it to do the deletion.
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythbackend/mainserver.h mythtv-0.20-new/programs/mythbackend/mainserver.h
--- mythtv-0.20-old/programs/mythbackend/mainserver.h	2006-07-03 11:31:35.000000000 -0700
+++ mythtv-0.20-new/programs/mythbackend/mainserver.h	2007-04-17 10:23:47.000000000 -0700
@@ -152,7 +152,8 @@
     static int  DeleteFile(const QString &filename, bool followLinks);
     static int  OpenAndUnlink(const QString &filename);
     static bool TruncateAndClose(const AutoExpire *expirer,
-                                 int fd, const QString &filename);
+                                 int fd, const QString &filename,
+                                 off_t fsize);
 
     QPtrList<LiveTVChain> liveTVChains;
     QMutex liveTVChainsLock;
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythbackend/scheduler.cpp mythtv-0.20-new/programs/mythbackend/scheduler.cpp
--- mythtv-0.20-old/programs/mythbackend/scheduler.cpp	2006-09-08 21:20:38.000000000 -0700
+++ mythtv-0.20-new/programs/mythbackend/scheduler.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -1384,6 +1384,14 @@
 
             VERBOSE(VB_GENERAL, msg << ": " << details);
             gContext->LogEntry("scheduler", LP_NOTICE, msg, details);
+
+            if (nextRecording->recstatus == rsFailed)
+            {
+                MythEvent me(QString("FORCE_DELETE_RECORDING %1 %2")
+                         .arg(nextRecording->chanid)
+                         .arg(nextRecording->recstartts.toString(Qt::ISODate)));
+                gContext->dispatch(me);
+            }
         }
 
         if (statuschanged)
@@ -1544,7 +1552,7 @@
     if (recIter != reclist.end())
     {
         ProgramInfo *nextRecording = (*recIter);
-        QDateTime restarttime = nextRecording->startts.addSecs((-1) * 
+        QDateTime restarttime = nextRecording->recstartts.addSecs((-1) * 
                                                                prerollseconds);
 
         int add = gContext->GetNumSetting("StartupSecsBeforeRecording", 240);
@@ -1981,17 +1989,15 @@
         {
             MSqlQuery epicnt(dbConn);
 
-            epicnt.prepare("SELECT count(*) FROM recorded "
-                           "WHERE title = :TITLE AND duplicate <> 0;");
-            epicnt.bindValue(":TITLE", qtitle.utf8());
+            epicnt.prepare("SELECT DISTINCT chanid, progstart, progend "
+                           "FROM recorded "
+                           "WHERE recordid = :RECID AND preserve = 0 "
+                               "AND recgroup <> 'LiveTV';");
+            epicnt.bindValue(":RECID", recid);
 
-            epicnt.exec();
-
-            if (epicnt.isActive() && epicnt.size() > 0)
+            if (epicnt.exec() && epicnt.isActive())
             {
-                epicnt.next();
-
-                if (epicnt.value(0).toInt() >= maxEpisodes)
+                if ((epicnt.size() > 0) && (epicnt.size() >= maxEpisodes))
                 {
                     tooManyMap[recid] = true;
                     checkTooMany = true;
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythbackend/upnpcdsmusic.cpp mythtv-0.20-new/programs/mythbackend/upnpcdsmusic.cpp
--- mythtv-0.20-old/programs/mythbackend/upnpcdsmusic.cpp	2006-06-05 23:51:03.000000000 -0700
+++ mythtv-0.20-new/programs/mythbackend/upnpcdsmusic.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -153,7 +153,9 @@
     // Parse out request object's path
     // ----------------------------------------------------------------------
 
-    QStringList idPath = QStringList::split( "/", pRequest->m_sObjectId );
+    QStringList idPath = QStringList::split( "/", pRequest->m_sObjectId.section('=',0,0) );
+
+    QString key = pRequest->m_sObjectId.section('=',1);
 
     if (idPath.count() == 0)
         return( NULL );
@@ -166,6 +168,10 @@
 
     if (pResults != NULL)
     {
+
+        if (key)
+            idPath.last().append(QString("=%1").arg(key));
+
         QString sLast = idPath.last();
 
         pRequest->m_sParentId = RemoveToken( "/", pRequest->m_sObjectId, 1 );
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythbackend/upnpcdstv.cpp mythtv-0.20-new/programs/mythbackend/upnpcdstv.cpp
--- mythtv-0.20-old/programs/mythbackend/upnpcdstv.cpp	2006-06-05 23:51:03.000000000 -0700
+++ mythtv-0.20-new/programs/mythbackend/upnpcdstv.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -155,7 +155,9 @@
     // Parse out request object's path
     // ----------------------------------------------------------------------
 
-    QStringList idPath = QStringList::split( "/", pRequest->m_sObjectId );
+    QStringList idPath = QStringList::split( "/", pRequest->m_sObjectId.section('=',0,0) );
+
+    QString key = pRequest->m_sObjectId.section('=',1);
 
     if (idPath.count() == 0)
         return( NULL );
@@ -168,6 +170,9 @@
 
     if (pResults != NULL)
     {
+        if (key)  
+            idPath.last().append(QString("=%1").arg(key)); 
+
         QString sLast = idPath.last();
 
         pRequest->m_sParentId = RemoveToken( "/", pRequest->m_sObjectId, 1 );
@@ -708,6 +713,8 @@
     QString        sRecGroup    = query.value( 8).toString();
     long long      nFileSize    = stringToLongLong( query.value( 9).toString() );
     QString        sBaseName    = query.value(10).toString();
+    //VERBOSE(VB_UPNP, QString(" %1 : %2 - %3 - %4").arg(sTitle).arg(sSubtitle).arg(sBaseName).arg(nFileSize));
+
     QDateTime      dtProgStart  = query.value(11).toDateTime();
     QDateTime      dtProgEnd    = query.value(12).toDateTime();
 
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythcommflag/ClassicCommDetector.cpp mythtv-0.20-new/programs/mythcommflag/ClassicCommDetector.cpp
--- mythtv-0.20-old/programs/mythcommflag/ClassicCommDetector.cpp	2006-08-17 06:41:53.000000000 -0700
+++ mythtv-0.20-new/programs/mythcommflag/ClassicCommDetector.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -52,7 +52,8 @@
         recordingStartedAt(recordingStartedAt_in),
         recordingStopsAt(recordingStopsAt_in),
         framesProcessed(0),preRoll(0),postRoll(0),
-        logoDetector(0)
+        logoDetector(0),
+        sceneChangeDetector(0)
 {
 
     stillRecording = recordingStopsAt > QDateTime::currentDateTime();
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythfilldatabase/filldata.cpp mythtv-0.20-new/programs/mythfilldatabase/filldata.cpp
--- mythtv-0.20-old/programs/mythfilldatabase/filldata.cpp	2006-09-04 19:54:51.000000000 -0700
+++ mythtv-0.20-new/programs/mythfilldatabase/filldata.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -2574,8 +2574,8 @@
                         xmltv_grabber.ascii(), configfile.ascii(),
                         filename.ascii());
     else if (xmltv_grabber == "tv_grab_nl")
-        command.sprintf("nice %s --output %s",
-                        xmltv_grabber.ascii(),
+        command.sprintf("nice %s --config-file '%s' --output %s",
+                        xmltv_grabber.ascii(), configfile.ascii(),
                         filename.ascii());
     else if (xmltv_grabber == "tv_grab_fi")
         // Use the default of 10 days for Finland's grabber
@@ -2782,24 +2782,6 @@
     query.bindValue(":OFFSET", offset);
     query.exec();
 
-    query.prepare("DELETE p FROM recordedprogram p "
-                  "LEFT JOIN recorded r ON "
-                  "  p.chanid = r.chanid AND p.starttime = r.progstart "
-                  "WHERE r.chanid IS NULL;");
-    query.exec();
-
-    query.prepare("DELETE p FROM recordedrating p "
-                  "LEFT JOIN recorded r ON "
-                  "  p.chanid = r.chanid AND p.starttime = r.progstart "
-                  "WHERE r.chanid IS NULL;");
-    query.exec();
-
-    query.prepare("DELETE p FROM recordedcredits p "
-                  "LEFT JOIN recorded r ON "
-                  "  p.chanid = r.chanid AND p.starttime = r.progstart "
-                  "WHERE r.chanid IS NULL;");
-    query.exec();
-
     query.prepare("DELETE FROM record WHERE (type = :SINGLE "
                   "OR type = :OVERRIDE OR type = :DONTRECORD) "
                   "AND enddate < NOW();");
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythfrontend/playbackbox.cpp mythtv-0.20-new/programs/mythfrontend/playbackbox.cpp
--- mythtv-0.20-old/programs/mythfrontend/playbackbox.cpp	2006-09-08 22:25:45.000000000 -0700
+++ mythtv-0.20-new/programs/mythfrontend/playbackbox.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -325,7 +325,10 @@
     if ((!recGroupPassword.isEmpty()) ||
         ((titleList.count() <= 1) && (progsInDB > 0)) ||
         (initialFilt))
+    {
+        recGroup = "";
         showRecGroupChooser();
+    }
 
     gContext->addCurrentLocation((type == Delete)? "DeleteBox":"PlaybackBox");
 }
@@ -406,6 +409,20 @@
     }
 }
 
+int PlaybackBox::exec(void)
+{
+    if (recGroup != "")
+        return MythDialog::exec();
+    else if (gContext->GetNumSetting("QueryInitialFilter", 0) == 0)
+    {
+        recGroup = "All Programs";
+        showRecGroupChooser();
+        return MythDialog::exec();
+    }
+
+    return 0;
+}
+
 void PlaybackBox::setDefaultView(ViewType defaultView)
 {
     int mask;
@@ -1477,7 +1494,8 @@
                    (p->recgroup != "LiveTV" || LiveTVInAllPrograms))) &&
                  (recGroupPassword == curGroupPassword)) ||
                 ((recGroupType[recGroup] == "category") &&
-                 (p->category == recGroup ) &&
+                 ((p->category == recGroup ) ||
+                  ((p->category == "") && (recGroup == tr("Unknown")))) &&
                  ( !recGroupPwCache.contains(p->recgroup))))
             {
                 if (viewMask != VIEW_NONE)
@@ -3007,10 +3025,12 @@
     else
     {
         ScheduledRecording record;
-        record.loadByProgram(curitem);
+        ProgramInfo *t_pginfo = new ProgramInfo(*curitem);
+        record.loadByProgram(t_pginfo);
         record.exec();
     
         connected = FillList();
+        delete t_pginfo;
     }
 }    
 
@@ -4171,6 +4191,7 @@
     MSqlQuery query(MSqlQuery::InitCon());
     QString itemStr;
     QString dispGroup;
+    QString saveRecGroup = recGroup;
     int items;
     int totalItems = 0;
     bool liveTVInAll = gContext->GetNumSetting("LiveTVInAllPrograms",0);
@@ -4225,13 +4246,23 @@
         "GROUP BY category");
     if (query.exec() && query.isActive() && query.size() > 0)
     {
+        int unknownCount = 0;
         while (query.next())
         {
-            dispGroup = QString::fromUtf8(query.value(0).toString());
             items     = query.value(1).toInt();
             itemStr   = (items == 1) ? tr("item") : tr("items");
 
-            if (!recGroupType.contains(dispGroup))
+            dispGroup = QString::fromUtf8(query.value(0).toString());
+            if (dispGroup == "")
+            {
+                unknownCount += items;
+                dispGroup = tr("Unknown");
+            }
+            else if (dispGroup == tr("Unknown"))
+                unknownCount += items;
+
+            if ((!recGroupType.contains(dispGroup)) &&
+                (dispGroup != tr("Unknown")))
             {
                 groups += QString("%1 [%2 %3]").arg(dispGroup)
                                   .arg(items).arg(itemStr);
@@ -4239,6 +4270,17 @@
                 recGroupType[dispGroup] = "category";
             }
         }
+
+        if (unknownCount)
+        {
+            dispGroup = tr("Unknown");
+            items     = unknownCount;
+            itemStr   = (items == 1) ? tr("item") : tr("items");
+            groups += QString("%1 [%2 %3]").arg(dispGroup)
+                              .arg(items).arg(itemStr);
+
+            recGroupType[dispGroup] = "category";
+        }
     }
 
     // Add the category entries
@@ -4263,6 +4305,9 @@
 
     // select the recGroup in the dialog
     int index = recGroupListBox->index(recGroupListBox->findItem(dispGroup));
+    if (index < 0)
+        index = 0;
+
     // HACK make the selection show up by selecting a different item first.
     recGroupListBox->setCurrentItem((index + 1) % 2);
     recGroupListBox->setCurrentItem(index);
@@ -4310,6 +4355,9 @@
 
 void PlaybackBox::setGroupFilter(void)
 {
+    QString savedPW = recGroupPassword;
+    QString savedRecGroup = recGroup;
+
     recGroup = recGroupListBox->currentText().section(" [", 0, 0);
 
     if (groupnameAsAllProg)
@@ -4336,7 +4384,11 @@
         pwd->exec();
         delete pwd;
         if (!ok)
+        {
+            recGroupPassword = savedPW;
+            recGroup = savedRecGroup;
             return;
+        }
 
         curGroupPassword = recGroupPassword;
     } else
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythfrontend/playbackbox.h mythtv-0.20-new/programs/mythfrontend/playbackbox.h
--- mythtv-0.20-old/programs/mythfrontend/playbackbox.h	2006-07-14 19:15:28.000000000 -0700
+++ mythtv-0.20-new/programs/mythfrontend/playbackbox.h	2007-04-17 10:23:47.000000000 -0700
@@ -102,7 +102,10 @@
    ~PlaybackBox(void);
    
     void customEvent(QCustomEvent *e);
-  
+
+  public slots:
+    int exec();
+
   protected slots:
     void timeout(void);
 
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythtranscode/mpeg2fix.cpp mythtv-0.20-new/programs/mythtranscode/mpeg2fix.cpp
--- mythtv-0.20-old/programs/mythtranscode/mpeg2fix.cpp	2006-07-18 17:24:00.000000000 -0700
+++ mythtv-0.20-new/programs/mythtranscode/mpeg2fix.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -726,7 +726,8 @@
         {
 
             case CODEC_TYPE_VIDEO:
-                vid_id = i;
+                if(vid_id == -1)
+                    vid_id = i;
                 break;
 
             case CODEC_TYPE_AUDIO:
@@ -1134,6 +1135,12 @@
             if (ret < 0)
             {
                 //insert a bogus frame (this won't be written out)
+                if(vFrame.isEmpty())
+                {
+                    VERBOSE(MPF_IMPORTANT, "Found end of file without finding "
+                                           " any frames");
+                    return TRANSCODE_EXIT_UNKNOWN_ERROR;
+                }
                 MPEG2frame *tmpFrame = GetPoolFrame(&vFrame.last()->pkt);
                 if (tmpFrame == NULL)
                     return TRANSCODE_EXIT_UNKNOWN_ERROR;
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythtranscode/replex/element.c mythtv-0.20-new/programs/mythtranscode/replex/element.c
--- mythtv-0.20-old/programs/mythtranscode/replex/element.c	2006-08-28 10:09:05.000000000 -0700
+++ mythtv-0.20-new/programs/mythtranscode/replex/element.c	2007-04-17 10:23:47.000000000 -0700
@@ -480,7 +480,7 @@
 {
 	int c = 0;
 	int fr =0;
-	uint8_t headr[4];
+	uint8_t headr[7];
 
 	af->set=0;
 
@@ -529,7 +529,7 @@
 int get_ac3_info(ringbuffer *rbuf, audio_frame_t *af, int off, int le)
 {
 	int c=0;
-	uint8_t headr[6];
+	uint8_t headr[7];
 	uint8_t frame;
 	int half = 0;
 	int fr;
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythtranscode/replex/multiplex.c mythtv-0.20-new/programs/mythtranscode/replex/multiplex.c
--- mythtv-0.20-old/programs/mythtranscode/replex/multiplex.c	2006-01-03 12:55:58.000000000 -0800
+++ mythtv-0.20-new/programs/mythtranscode/replex/multiplex.c	2007-04-17 10:23:47.000000000 -0700
@@ -31,7 +31,7 @@
 {
 	int i;
 	int started = 0;
-	int pos = 0;
+	int pos = -1;
 	uint64_t tmppts;
 	for(i=0; i < n; i++)
 		if(aok[i]){
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythtranscode/replex/pes.c mythtv-0.20-new/programs/mythtranscode/replex/pes.c
--- mythtv-0.20-old/programs/mythtranscode/replex/pes.c	2005-12-27 15:12:39.000000000 -0800
+++ mythtv-0.20-new/programs/mythtranscode/replex/pes.c	2007-04-17 10:23:47.000000000 -0700
@@ -157,225 +157,231 @@
 
 	int l;
 	unsigned short *pl;
-	int c=0;
+        int done;
 
 	uint8_t headr[3] = { 0x00, 0x00, 0x01} ;
-
-	while (c < count && (!p->mpeg ||
-			     (p->mpeg == 2 && p->found < 9))
-	       &&  (p->found < 5 || !p->done)){
-		switch ( p->found ){
-		case 0:
-		case 1:
-			if (buf[c] == 0x00) p->found++;
-			else p->found = 0;
-			c++;
-			break;
-		case 2:
-			if (buf[c] == 0x01) p->found++;
-			else if (buf[c] == 0){
-				p->found = 2;
-			} else p->found = 0;
-			c++;
-			break;
-		case 3:
-			p->cid = 0;
-			switch (buf[c]){
-			case PROG_STREAM_MAP:
-			case PRIVATE_STREAM2:
-			case PROG_STREAM_DIR:
-			case ECM_STREAM     :
-			case EMM_STREAM     :
-			case PADDING_STREAM :
-			case DSM_CC_STREAM  :
-			case ISO13522_STREAM:
-				p->done = 1;
-			case PRIVATE_STREAM1:
-			case VIDEO_STREAM_S ... VIDEO_STREAM_E:
-			case AUDIO_STREAM_S ... AUDIO_STREAM_E:
-				p->found++;
-				p->cid = buf[c];
+	do {
+		int c=0;
+		done = 1;
+		while (c < count && (!p->mpeg ||
+				     (p->mpeg == 2 && p->found < 9))
+	               &&  (p->found < 5 || !p->done)){
+			switch ( p->found ){
+			case 0:
+			case 1:
+				if (buf[c] == 0x00) p->found++;
+				else p->found = 0;
 				c++;
 				break;
-			default:
-			case PACK_START:
-			case SYS_START:
-				p->found = 0;
+			case 2:
+				if (buf[c] == 0x01) p->found++;
+				else if (buf[c] == 0){
+					p->found = 2;
+				} else p->found = 0;
 				c++;
 				break;
-			}
-			break;
+			case 3:
+				p->cid = 0;
+				switch (buf[c]){
+				case PROG_STREAM_MAP:
+				case PRIVATE_STREAM2:
+				case PROG_STREAM_DIR:
+				case ECM_STREAM     :
+				case EMM_STREAM     :
+				case PADDING_STREAM :
+				case DSM_CC_STREAM  :
+				case ISO13522_STREAM:
+					p->done = 1;
+				case PRIVATE_STREAM1:
+				case VIDEO_STREAM_S ... VIDEO_STREAM_E:
+				case AUDIO_STREAM_S ... AUDIO_STREAM_E:
+					p->found++;
+					p->cid = buf[c];
+					c++;
+					break;
+				default:
+				case PACK_START:
+				case SYS_START:
+					p->found = 0;
+					c++;
+					break;
+				}
+				break;
 			
 
-		case 4:
-			if (count-c > 1){
-				pl = (unsigned short *) (buf+c);
-				p->plength =  ntohs(*pl);
-				p->plen[0] = buf[c];
-				c++;
+			case 4:
+				if (count-c > 1){
+					pl = (unsigned short *) (buf+c);
+					p->plength =  ntohs(*pl);
+					p->plen[0] = buf[c];
+					c++;
+					p->plen[1] = buf[c];
+					c++;
+					p->found+=2;
+				} else {
+					p->plen[0] = buf[c];
+					p->found++;
+					return;
+				}
+				break;
+			case 5:
 				p->plen[1] = buf[c];
 				c++;
-				p->found+=2;
-			} else {
-				p->plen[0] = buf[c];
+				pl = (unsigned short *) p->plen;
+				p->plength = ntohs(*pl);
 				p->found++;
-				return;
-			}
-			break;
-		case 5:
-			p->plen[1] = buf[c];
-			c++;
-			pl = (unsigned short *) p->plen;
-			p->plength = ntohs(*pl);
-			p->found++;
-			break;
+				break;
 
 
-		case 6:
-			if (!p->done){
-				p->flag1 = buf[c];
-				c++;
-				p->found++;
-				if ( (p->flag1 & 0xC0) == 0x80 ) p->mpeg = 2;
-				else {
-					fprintf(stderr, 
-						"Error: THIS IS AN MPEG1 FILE\n");
-					exit(1);
+			case 6:
+				if (!p->done){
+					p->flag1 = buf[c];
+					c++;
+					p->found++;
+					if ( (p->flag1 & 0xC0) == 0x80 ) p->mpeg = 2;
+					else {
+						fprintf(stderr, 
+							"Error: THIS IS AN MPEG1 FILE\n");
+						exit(1);
+					}
 				}
-			}
-			break;
+				break;
 
-		case 7:
-			if ( !p->done && p->mpeg == 2){
-				p->flag2 = buf[c];
-				c++;
-				p->found++;
-			}	
-			break;
+			case 7:
+				if ( !p->done && p->mpeg == 2){
+					p->flag2 = buf[c];
+					c++;
+					p->found++;
+				}	
+				break;
 
-		case 8:
-			if ( !p->done && p->mpeg == 2){
-				p->hlength = buf[c];
-				c++;
-				p->found++;
-			}
-			break;
+			case 8:
+				if ( !p->done && p->mpeg == 2){
+					p->hlength = buf[c];
+					c++;
+					p->found++;
+				}
+				break;
 			
-		default:
+			default:
 
-			break;
+				break;
+			}
 		}
-	}
 
-	if (!p->plength) p->plength = MMAX_PLENGTH-6;
+		if (!p->plength) p->plength = MMAX_PLENGTH-6;
 
 
-	if ( p->done || (p->mpeg == 2 && p->found >= 9) ){
-		switch (p->cid){
+		if ( p->done || (p->mpeg == 2 && p->found >= 9) ){
+			switch (p->cid){
 			
-		case AUDIO_STREAM_S ... AUDIO_STREAM_E:			
-		case VIDEO_STREAM_S ... VIDEO_STREAM_E:
-		case PRIVATE_STREAM1:
-
-			if (p->withbuf){
-				memcpy(p->buf, headr, 3);
-				p->buf[3] = p->cid;
-				memcpy(p->buf+4,p->plen,2);
-			} else {
-				memcpy(p->hbuf, headr, 3);
-				p->hbuf[3] = p->cid;
-				memcpy(p->hbuf+4,p->plen,2);
-			}
+			case AUDIO_STREAM_S ... AUDIO_STREAM_E:			
+			case VIDEO_STREAM_S ... VIDEO_STREAM_E:
+			case PRIVATE_STREAM1:
 
-			if (p->found == 9){
 				if (p->withbuf){
-					p->buf[6] = p->flag1;
-					p->buf[7] = p->flag2;
-					p->buf[8] = p->hlength;
+					memcpy(p->buf, headr, 3);
+					p->buf[3] = p->cid;
+					memcpy(p->buf+4,p->plen,2);
 				} else {
-					p->hbuf[6] = p->flag1;
-					p->hbuf[7] = p->flag2;
-					p->hbuf[8] = p->hlength;
+					memcpy(p->hbuf, headr, 3);
+					p->hbuf[3] = p->cid;
+					memcpy(p->hbuf+4,p->plen,2);
 				}
-			}
 
-			if ( (p->flag2 & PTS_ONLY) &&  p->found < 14){
-				while (c < count && p->found < 14){
-					p->pts[p->found-9] = buf[c];
-					if (p->withbuf)
-						p->buf[p->found] = buf[c];
-					else 
-						p->hbuf[p->found] = buf[c];
-					c++;
-					p->found++;
+				if (p->found == 9){
+					if (p->withbuf){
+						p->buf[6] = p->flag1;
+						p->buf[7] = p->flag2;
+						p->buf[8] = p->hlength;
+					} else {
+						p->hbuf[6] = p->flag1;
+						p->hbuf[7] = p->flag2;
+						p->hbuf[8] = p->hlength;
+					}
 				}
-				if (c == count) return;
-			}
 
-			if (((p->flag2 & PTS_DTS) == 0xC0) && p->found < 19){
-				while (c < count && p->found < 19){
-					p->dts[p->found-14] = buf[c];
-					if (p->withbuf)
-						p->buf[p->found] = buf[c];
-					else 
-						p->hbuf[p->found] = buf[c];
-					c++;
-					p->found++;
+				if ( (p->flag2 & PTS_ONLY) &&  p->found < 14){
+					while (c < count && p->found < 14){
+						p->pts[p->found-9] = buf[c];
+						if (p->withbuf)
+							p->buf[p->found] = buf[c];
+						else 
+							p->hbuf[p->found] = buf[c];
+						c++;
+						p->found++;
+					}
+					if (c == count) return;
 				}
-				if (c == count) return;
-			}
 
+				if (((p->flag2 & PTS_DTS) == 0xC0) && p->found < 19){
+					while (c < count && p->found < 19){
+						p->dts[p->found-14] = buf[c];
+						if (p->withbuf)
+							p->buf[p->found] = buf[c];
+						else 
+							p->hbuf[p->found] = buf[c];
+						c++;
+						p->found++;
+					}
+					if (c == count) return;
+				}
 
-			while (c < count && p->found < p->plength+6){
-				l = count -c;
-				if (l+p->found > p->plength+6)
-					l = p->plength+6-p->found;
-				if (p->withbuf)
-					memcpy(p->buf+p->found, buf+c, l);
-				else {
-					if ( p->found < 
-                                             (unsigned int)p->hlength+9 ){
-						int rest = p->hlength+9-p->found;
-						memcpy(p->hbuf+p->found, buf+c, rest);
-						if (ring_write(p->rbuf, buf+c+rest, 
-							       l-rest) <0){
-							exit(1);
-						}
-					} else {
-						if (ring_write(p->rbuf, buf+c, l)<0){
-							fprintf(stderr,
-								"ring buffer overflow %d\n"
-								,p->rbuf->size);
-							exit(1);
+
+				while (c < count && p->found < p->plength+6){
+					l = count -c;
+					if (l+p->found > p->plength+6)
+						l = p->plength+6-p->found;
+					if (p->withbuf)
+						memcpy(p->buf+p->found, buf+c, l);
+					else {
+						if ( p->found < 
+                                                     (unsigned int)p->hlength+9 ){
+							int rest = p->hlength+9-p->found;
+							memcpy(p->hbuf+p->found, buf+c, rest);
+							if (ring_write(p->rbuf, buf+c+rest, 
+								       l-rest) <0){
+								exit(1);
+							}
+						} else {
+							if (ring_write(p->rbuf, buf+c, l)<0){
+								fprintf(stderr,
+									"ring buffer overflow %d\n"
+									,p->rbuf->size);
+								exit(1);
+							}
 						}
 					}
-				}
 
-				p->found += l;
-				c += l;
-			}			
-			if(p->found == p->plength+6){
-				func(p);
+					p->found += l;
+					c += l;
+				}			
+				if(p->found == p->plength+6){
+					func(p);
+				}
+				break;
 			}
-			break;
-		}
 
-		if ( p->done ){
-			if( p->found + count - c < p->plength+6){
-				p->found += count-c;
-				c = count;
-			} else {
-				c += p->plength+6 - p->found;
-				p->found = p->plength+6;
+			if ( p->done ){
+				if( p->found + count - c < p->plength+6){
+					p->found += count-c;
+					c = count;
+				} else {
+					c += p->plength+6 - p->found;
+					p->found = p->plength+6;
+				}
 			}
-		}
 
-		if (p->plength && p->found == p->plength+6) {
-			init_pes_in(p, p->type, NULL, p->withbuf);
-			if (c < count)
-				get_pes(p, buf+c, count-c, func);
-		}
-	}
+			if (p->plength && p->found == p->plength+6) {
+				init_pes_in(p, p->type, NULL, p->withbuf);
+				if (c < count) {
+					done = 0;
+					count -= c;
+					buf += c;
+				}
+			}
+		} 
+	} while(!done);
 	return;
 }
 
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythtranscode/replex/replex.c mythtv-0.20-new/programs/mythtranscode/replex/replex.c
--- mythtv-0.20-old/programs/mythtranscode/replex/replex.c	2006-08-28 10:09:05.000000000 -0700
+++ mythtv-0.20-new/programs/mythtranscode/replex/replex.c	2007-04-17 10:23:47.000000000 -0700
@@ -294,10 +294,13 @@
 						// add each extra frame required direct to the output file
 						int x;
 						for (x = 0; x < framesdiff; x++){
-							if (type == AC3)
-								write(rx->dmx_out[num+1+rx->apidn], framebuf, aframe->framesize);
-							else
-								write(rx->dmx_out[num+1], framebuf, aframe->framesize);
+							if (type == AC3){
+								if (rx->dmx_out[num+1+rx->apidn])	
+									write(rx->dmx_out[num+1+rx->apidn], framebuf, aframe->framesize);
+							}else{
+								if (rx->dmx_out[num+1])
+									write(rx->dmx_out[num+1], framebuf, aframe->framesize);
+							}
 							*acount += 1;
 						}
 						
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythtranscode/replex/ringbuffer.c mythtv-0.20-new/programs/mythtranscode/replex/ringbuffer.c
--- mythtv-0.20-old/programs/mythtranscode/replex/ringbuffer.c	2006-05-26 19:55:41.000000000 -0700
+++ mythtv-0.20-new/programs/mythtranscode/replex/ringbuffer.c	2007-04-17 10:23:47.000000000 -0700
@@ -423,3 +423,18 @@
 
 	return dsize;
 }
+void dummy_print(dummy_buffer *dbuf)
+{
+   int i;
+   uint64_t rtime;
+   uint32_t size;
+   int avail = ring_avail(&dbuf->time_index) / sizeof(uint64_t);
+   for(i = 0; i < avail; i++) {
+       ring_peek(&dbuf->time_index,(uint8_t *) &rtime, 
+			      sizeof(uint64_t), i * sizeof(uint64_t));
+       ring_peek(&dbuf->data_index,(uint8_t *) &size, 
+			      sizeof(uint32_t), i * sizeof(uint32_t));
+       printf("%d : %llu %u\n", i, rtime, size);
+   }
+   printf("Used: %d Free: %d data-free: %d\n", avail, 1000-avail, dbuf->size - dbuf->fill);
+}
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythtranscode/replex/ringbuffer.h mythtv-0.20-new/programs/mythtranscode/replex/ringbuffer.h
--- mythtv-0.20-old/programs/mythtranscode/replex/ringbuffer.h	2006-01-24 20:08:01.000000000 -0800
+++ mythtv-0.20-new/programs/mythtranscode/replex/ringbuffer.h	2007-04-17 10:23:47.000000000 -0700
@@ -97,10 +97,10 @@
 
 	static inline unsigned int ring_free(ringbuffer *rbuf){
 		int free;
-		free = rbuf->read_pos - rbuf->write_pos-1;
+		free = rbuf->read_pos - rbuf->write_pos;
 		if (free <= 0) free += rbuf->size;
-		
-		return free;
+		//Note: free is gauranteed to be >=1 from the above
+		return free - 1;
 	}
 
 	static inline unsigned int ring_avail(ringbuffer *rbuf){
diff -Naur -x mytharchive mythtv-0.20-old/programs/mythwelcome/welcomedialog.cpp mythtv-0.20-new/programs/mythwelcome/welcomedialog.cpp
--- mythtv-0.20-old/programs/mythwelcome/welcomedialog.cpp	2006-07-25 01:40:11.000000000 -0700
+++ mythtv-0.20-new/programs/mythwelcome/welcomedialog.cpp	2007-04-17 10:23:47.000000000 -0700
@@ -465,7 +465,7 @@
     QStringList strlist;
     
     // get list of current recordings
-    QString querytext = QString("SELECT cardid FROM capturecard;");
+    QString querytext = QString("SELECT cardid FROM capturecard WHERE parentid = 0;");
     MSqlQuery query(MSqlQuery::InitCon());
     query.exec(querytext);
     QString Status = "";
