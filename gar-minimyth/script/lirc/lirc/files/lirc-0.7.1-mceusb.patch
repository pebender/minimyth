diff -Naur lirc-0.7.1-old/drivers/lirc_mceusb/lirc_mceusb.c lirc-0.7.1-new/drivers/lirc_mceusb/lirc_mceusb.c
--- lirc-0.7.1-old/drivers/lirc_mceusb/lirc_mceusb.c	2005-03-12 03:32:21.000000000 -0800
+++ lirc-0.7.1-new/drivers/lirc_mceusb/lirc_mceusb.c	2005-07-02 07:56:39.000000000 -0700
@@ -1,1020 +1,621 @@
 /*
- * USB Microsoft IR Transceiver driver - 0.2
- *
- * Copyright (c) 2003-2004 Dan Conti (dconti@acm.wwu.edu)
- *
- * This driver is based on the USB skeleton driver packaged with the
- * kernel, and the notice from that package has been retained below.
- *
- * The Microsoft IR Transceiver is a neat little IR receiver with two
- * emitters on it designed for Windows Media Center. This driver might
- * work for all media center remotes, but I have only tested it with
- * the philips model. The first revision of this driver only supports
- * the receive function - the transmit function will be much more
- * tricky due to the nature of the hardware. Microsoft chose to build
- * this device inexpensively, therefore making it extra dumb.
- * There is no interrupt endpoint on this device; all usb traffic
- * happens over two bulk endpoints. As a result of this, poll() for
- * this device is an actual hardware poll (instead of a receive queue
- * check) and is rather expensive.
- *
- * All trademarks property of their respective owners. This driver was
- * originally based on the USB skeleton driver, although significant
- * portions of that code have been removed as the driver has evolved.
- *
- * 2003_11_11 - Restructured to minimalize code interpretation in the
- *              driver. The normal use case will be with lirc.
- *
- * 2004_01_01 - Removed all code interpretation. Generate mode2 data
- *              for passing off to lirc. Cleanup
- *
- * 2004_01_04 - Removed devfs handle. Put in a temporary workaround
- *              for a known issue where repeats generate two
- *              sequential spaces (last_was_repeat_gap)
- *
- * 2004_02_17 - Changed top level api to no longer use fops, and
- *              instead use new interface for polling via
- *              lirc_thread. Restructure data read/mode2 generation to
- *              a single pass, reducing number of buffers. Rev to .2
- *
- * 2004_02_27 - Last of fixups to plugin->add_to_buf API. Properly
- *              handle broken fragments from the receiver. Up the
- *              sample rate and remove any pacing from
- *              fetch_more_data. Fixes all known issues.
+ * LIRC driver for Philips eHome USB Infrared Transciever
+ * and the Microsoft MCE 2005 Remote Control
  * 
- * TODO
- *   - Fix up minor number, registration of major/minor with usb subsystem
- *
- */
-/*
- * USB Skeleton driver - 1.1
- *
- * Copyright (C) 2001-2003 Greg Kroah-Hartman (greg@kroah.com)
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License as
- *	published by the Free Software Foundation, version 2.
+ * (C) by Martin A. Blatter <martin_a_blatter@yahoo.com>
  *
+ * Derived from ATI USB driver by Paul Miller and the original
+ * MCE USB driver by Dan Corti
  *
- * This driver is to be used as a skeleton driver to be able to create a
- * USB driver quickly.  The design of it is based on the usb-serial and
- * dc2xx drivers.
+ * This driver will only work reliably with kernel version 2.6.10
+ * or higher, probably because of differences in USB device enumeration
+ * in the kernel code. Device initialization fails most of the time
+ * with earlier kernel versions.
  *
- * Thanks to Oliver Neukum, David Brownell, and Alan Stern for their help
- * in debugging this driver.
+ **********************************************************************
  *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
  *
- * History:
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
- * 2003-05-06 - 1.1 - changes due to usb core changes with usb_register_dev()
- * 2003-02-25 - 1.0 - fix races involving urb->status, unlink_urb(), and
- *			disconnect.  Fix transfer amount in read().  Use
- *			macros instead of magic numbers in probe().  Change
- *			size variables to size_t.  Show how to eliminate
- *			DMA bounce buffer.
- * 2002_12_12 - 0.9 - compile fixes and got rid of fixed minor array.
- * 2002_09_26 - 0.8 - changes due to USB core conversion to struct device
- *			driver.
- * 2002_02_12 - 0.7 - zero out dev in probe function for devices that do
- *			not have both a bulk in and bulk out endpoint.
- *			Thanks to Holger Waechtler for the fix.
- * 2001_11_05 - 0.6 - fix minor locking problem in skel_disconnect.
- *			Thanks to Pete Zaitcev for the fix.
- * 2001_09_04 - 0.5 - fix devfs bug in skel_disconnect. Thanks to wim delvaux
- * 2001_08_21 - 0.4 - more small bug fixes.
- * 2001_05_29 - 0.3 - more bug fixes based on review from linux-usb-devel
- * 2001_05_24 - 0.2 - bug fixes based on review from linux-usb-devel people
- * 2001_05_01 - 0.1 - first version
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  */
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 5)
+#error "*******************************************************"
+#error "Sorry, this driver needs kernel version 2.6.5 or higher"
+#error "*******************************************************"
+#endif
+
 #include <linux/config.h>
+
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/module.h>
+#include <linux/kmod.h>
 #include <linux/smp_lock.h>
-#include <linux/usb.h>
-#ifdef KERNEL_2_5
 #include <linux/completion.h>
 #include <asm/uaccess.h>
-#else
-#include <linux/spinlock.h>
-#include <linux/list.h>
-#include <linux/fcntl.h>
+#include <linux/usb.h>
 #include <linux/poll.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
-#endif
+#include <linux/wait.h>
 
+#include "drivers/lirc.h"
+#include "drivers/kcompat.h"
+#include "drivers/lirc_dev/lirc_dev.h"
+
+#define DRIVER_VERSION		"0.22"
+#define DRIVER_AUTHOR		"Martin Blatter <martin_a_blatter@yahoo.com>"
+#define DRIVER_DESC		"USB remote driver for LIRC"
+#define DRIVER_NAME		"lirc_mceusb"
+
+#define USB_BUFLEN		16
+#define LIRCBUF_SIZE            256
+
+#define MCE_CODE_LENGTH		5
+#define MCE_TIME_UNIT           50
+#define MCE_PACKET_SIZE 	4
+#define MCE_PACKET_HEADER 	0x84
+
+/* module parameters */
 #ifdef CONFIG_USB_DEBUG
 	static int debug = 1;
 #else
 	static int debug = 0;
 #endif
-
-#include "drivers/kcompat.h"
-#include "drivers/lirc.h"
-#include "drivers/lirc_dev/lirc_dev.h"
-
-/* Use our own dbg macro */
-#define dprintk(fmt, args...)                             \
-	do{                                               \
-		if(debug) printk(KERN_DEBUG __FILE__ ": " \
-				 fmt "\n", ## args);      \
+#define dprintk(fmt, args...)                                 \
+	do{                                                   \
+		if(debug) printk(KERN_DEBUG fmt, ## args);    \
 	}while(0)
 
-/* Version Information */
-#define DRIVER_VERSION "v0.2"
-#define DRIVER_AUTHOR "Dan Conti, dconti@acm.wwu.edu"
-#define DRIVER_DESC "USB Microsoft IR Transceiver Driver"
-#define DRIVER_NAME "lirc_mceusb"
-
-/* Define these values to match your device */
-#define USB_MCEUSB_VENDOR_ID	0x045e
-#define USB_MCEUSB_PRODUCT_ID	0x006d
-
-/* table of devices that work with this driver */
-static struct usb_device_id mceusb_table [] = {
-	{ USB_DEVICE(USB_MCEUSB_VENDOR_ID, USB_MCEUSB_PRODUCT_ID) },
+/* lock irctl structure */
+#define IRLOCK			down_interruptible(&ir->lock)
+#define IRUNLOCK		up(&ir->lock)
+
+/* general constants */
+#define SUCCESS			0
+#define SEND_FLAG_IN_PROGRESS	1
+#define SEND_FLAG_COMPLETE	2
+#define RECV_FLAG_IN_PROGRESS	3
+#define RECV_FLAG_COMPLETE	4
+
+#define PHILUSB_INBOUND		1
+#define PHILUSB_OUTBOUND	2
+
+#define VENDOR_PHILIPS		0x0471
+#define VENDOR_SMK              0x0609
+
+static struct usb_device_id usb_remote_table [] = {
+	{ USB_DEVICE(VENDOR_PHILIPS, 0x0815) },	/* Philips eHome Infrared Transciever */
+	{ USB_DEVICE(VENDOR_SMK, 0x031d) },	/* SMK/Toshiba G83C0004D410 */
 	{ }					/* Terminating entry */
 };
 
-/* we can have up to this number of device plugged in at once */
-#define MAX_DEVICES		16
-
-/* Structure to hold all of our device specific stuff */
-struct usb_skel {
-	struct usb_device *	    udev;		/* save off the usb device pointer */
-	struct usb_interface *	interface;		/* the interface for this device */
-	unsigned char   minor;				/* the starting minor number for this device */
-	unsigned char   num_ports;			/* the number of ports this device has */
-	char            num_interrupt_in;		/* number of interrupt in endpoints we have */
-	char            num_bulk_in;			/* number of bulk in endpoints we have */
-	char            num_bulk_out;			/* number of bulk out endpoints we have */
-
-	unsigned char *    bulk_in_buffer;		/* the buffer to receive data */
-	int                bulk_in_size;		/* the size of the receive buffer */
-	__u8               bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
-
-	unsigned char *    bulk_out_buffer;		/* the buffer to send data */
-	int	               bulk_out_size;		/* the size of the send buffer */
-	struct urb *       write_urb;			/* the urb used to send data */
-	__u8               bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
-
-	atomic_t		write_busy;		/* true iff write urb is busy */
-	struct completion	write_finished;		/* wait for the write to finish */
-	
-	wait_queue_head_t  wait_q;			/* for timeouts */
-	int                open_count;			/* number of times this port has been opened */
-	struct semaphore   sem;				/* locks this structure */
-	
-	int			present;		/* if the device is not disconnected */		
+/* data structure for each usb remote */
+struct irctl {
 
-	struct lirc_plugin* plugin;
-	
-	lirc_t lircdata[256];          			/* place to store values until lirc processes them */
-	int    lircidx;                			/* current index */
-	int    lirccnt;                			/* remaining values */
-	
-	int    usb_valid_bytes_in_bulk_buffer;		/* leftover data from a previous read */
-	int    mce_bytes_left_in_packet;		/* for packets split across multiple reads */
-	
-	/* Value to hold the last received space; 0 if last value
-	 * received was a pulse
-	 */
-	int    last_space;
-	
-#ifdef KERNEL_2_5
+	/* usb */
+	struct usb_device *usbdev;
+	struct urb *urb_in;
+	int devnum;
+
+	/* buffers and dma */
+	unsigned char *buf_in;
+	unsigned int len_in;
 	dma_addr_t dma_in;
 	dma_addr_t dma_out;
-#endif
-};
-
-#define MCE_TIME_UNIT 50
 
-/* driver api */
-#ifdef KERNEL_2_5
-static int mceusb_probe		(struct usb_interface *interface, const struct usb_device_id *id);
-static void mceusb_disconnect	(struct usb_interface *interface);
-static void mceusb_write_bulk_callback	(struct urb *urb, struct pt_regs *regs);
-#else
-static void * mceusb_probe	(struct usb_device *dev, unsigned int ifnum, const struct usb_device_id *id);
-static void mceusb_disconnect	(struct usb_device *dev, void *ptr);
-static void mceusb_write_bulk_callback	(struct urb *urb);
-#endif
-
-/* read data from the usb bus; convert to mode2 */
-static int msir_fetch_more_data( struct usb_skel* dev, int dont_block );
-
-/* helper functions */
-static void msir_cleanup( struct usb_skel* dev );
-static void set_use_dec( void* data );
-static int set_use_inc( void* data );
-    
-/* array of pointers to our devices that are currently connected */
-static struct usb_skel		*minor_table[MAX_DEVICES];
-
-/* lock to protect the minor_table structure */
-static DECLARE_MUTEX (minor_table_mutex);
-static void mceusb_setup( struct usb_device *udev );
-
-/* usb specific object needed to register this driver with the usb subsystem */
-static struct usb_driver mceusb_driver = {
-	.owner =	THIS_MODULE,
-	.name =		DRIVER_NAME,
-	.probe =	mceusb_probe,
-	.disconnect =	mceusb_disconnect,
-	.id_table =	mceusb_table,
+	/* lirc */
+	struct lirc_plugin *p;
+	lirc_t lircdata[LIRCBUF_SIZE];
+	int lirccnt;
+	int connected;
+	int last_space;
+
+	/* handle sending (init strings) */
+	int send_flags;
+	wait_queue_head_t wait_out;
+   
+	struct semaphore lock;
 };
 
+/* init strings */
+static char init1[] = {0x00, 0xff, 0xaa, 0xff, 0x0b};
+static char init2[] = {0xff, 0x18};
 
-/**
- *	usb_mceusb_debug_data
- */
-static inline void usb_mceusb_debug_data (const char *function, int size,
-					  const unsigned char *data)
+
+static void usb_remote_printdata(struct irctl *ir, char *buf, int len)
 {
+	char codes[USB_BUFLEN*3 + 1];
 	int i;
-	if (!debug)
+
+	if (len <= 0)
 		return;
-	
-	printk(KERN_DEBUG __FILE__": %s - length = %d, data = ", 
-	       function, size);
-	for (i = 0; i < size; ++i) {
-		printk(KERN_DEBUG "%.2x ", data[i]);
+
+	for (i = 0; i < len && i < USB_BUFLEN; i++) {
+		snprintf(codes+i*3, 4, "%02x ", buf[i] & 0xFF);
 	}
-	printk(KERN_DEBUG "\n");
+	printk(DRIVER_NAME "[%d]: data received %s (length=%d)\n",
+		ir->devnum, codes, len);
 }
 
-/**
- *mceusb_delete
- */
-static inline void mceusb_delete (struct usb_skel *dev)
+static void usb_async_callback(struct urb *urb, struct pt_regs *regs)
 {
-	dprintk("%s", __func__);
-	minor_table[dev->minor] = NULL;
-#ifdef KERNEL_2_5
-	usb_buffer_free(dev->udev, dev->bulk_in_size, dev->bulk_in_buffer, dev->dma_in);
-	usb_buffer_free(dev->udev, dev->bulk_out_size, dev->bulk_out_buffer, dev->dma_out);
-#else
-	if (dev->bulk_in_buffer != NULL)
-		kfree (dev->bulk_in_buffer);
-	if (dev->bulk_out_buffer != NULL)
-		kfree (dev->bulk_out_buffer);
-#endif
-	if (dev->write_urb != NULL)
-		usb_free_urb (dev->write_urb);
-	kfree (dev);
-}
+	struct irctl *ir;
+	int len;
 
-static void mceusb_setup( struct usb_device *udev )
-{
-	char data[8];
-	int res;
+	if (!urb)
+		return;
 	
-	memset( data, 0, 8 );
-
-	/* Get Status */
-	res = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
-			      USB_REQ_GET_STATUS, USB_DIR_IN,
-			      0, 0, data, 2, HZ * 3);
-    
-	/*    res = usb_get_status( udev, 0, 0, data ); */
-	dprintk("%s - res = %d status = 0x%x 0x%x", __func__,
-		res, data[0], data[1]);
-    
-	/* This is a strange one. They issue a set address to the device
-	 * on the receive control pipe and expect a certain value pair back
-	 */
-	memset( data, 0, 8 );
-
-	res = usb_control_msg( udev, usb_rcvctrlpipe(udev, 0),
-			       5, USB_TYPE_VENDOR, 0, 0,
-			       data, 2, HZ * 3 );
-	dprintk("%s - res = %d, devnum = %d", __func__, res, udev->devnum);
-	dprintk("%s - data[0] = %d, data[1] = %d", __func__,
-		data[0], data[1] );
-
-    
-	/* set feature */
-	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
-			       USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
-			       0xc04e, 0x0000, NULL, 0, HZ * 3 );
-    
-	dprintk("%s - res = %d", __func__, res);
-
-	/* These two are sent by the windows driver, but stall for
-	 * me. I dont have an analyzer on the linux side so i can't
-	 * see what is actually different and why the device takes
-	 * issue with them
-	 */
-#if 0
-	/* this is some custom control message they send */
-	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
-			       0x04, USB_TYPE_VENDOR,
-			       0x0808, 0x0000, NULL, 0, HZ * 3 );
-    
-	dprintk("%s - res = %d", __func__, res);
-    
-	/* this is another custom control message they send */
-	res = usb_control_msg( udev, usb_sndctrlpipe(udev, 0),
-			       0x02, USB_TYPE_VENDOR,
-			       0x0000, 0x0100, NULL, 0, HZ * 3 );
-    
-	dprintk("%s - res = %d", __func__, res);
-#endif
-}
-
-static void msir_cleanup( struct usb_skel* dev )
-{
-	memset( dev->bulk_in_buffer, 0, dev->bulk_in_size );
+	if ((ir = urb->context)) {
+		len = urb->actual_length;
 
-	dev->usb_valid_bytes_in_bulk_buffer = 0;
+		dprintk(DRIVER_NAME "[%d]: callback called (status=%d len=%d)\n",ir->devnum,urb->status,len);
 
-	dev->last_space = PULSE_MASK;
-    
-	dev->mce_bytes_left_in_packet = 0;
-	dev->lircidx = 0;
-	dev->lirccnt = 0;
-	memset( dev->lircdata, 0, sizeof(dev->lircdata) );
-}
+		if (debug)
+			usb_remote_printdata(ir,urb->transfer_buffer,len);
+	}
 
-static int set_use_inc(void* data)
-{
-	MOD_INC_USE_COUNT;
-	return 0;
+//	usb_unlink_urb(urb);
+//	usb_free_urb(urb);
+//	kfree(urb->transfer_buffer);
 }
 
-static void set_use_dec(void* data)
-{
-	MOD_DEC_USE_COUNT;
-}
 
-/*
- * msir_fetch_more_data
- *
- * The goal here is to read in more remote codes from the remote. In
- * the event that the remote isn't sending us anything, the caller
- * will block until a key is pressed (i.e. this performs phys read,
- * filtering, and queueing of data) unless dont_block is set to 1; in
- * this situation, it will perform a few reads and will exit out if it
- * does not see any appropriate data
- *
- * dev->sem should be locked when this function is called - fine grain
- * locking isn't really important here anyways
- *
- * This routine always returns the number of words available
- *
- */
-static int msir_fetch_more_data( struct usb_skel* dev, int dont_block )
+/* request incoming or send outgoing usb packet - used to initialize remote */
+static void request_packet_async(struct irctl *ir, struct usb_endpoint_descriptor *ep, unsigned char* data, int size, int urb_type)
 {
-	int retries = 0;
-	int words_to_read = 
-		(sizeof(dev->lircdata)/sizeof(lirc_t)) - dev->lirccnt;
-	int partial, this_read = 0;
-	int bulkidx = 0;
-	int bytes_left_in_packet = 0;
-	signed char* signedp = (signed char*)dev->bulk_in_buffer;
-	
-	if( words_to_read == 0 )
-		return dev->lirccnt;
-
-	/* this forces all existing data to be read by lirc before we
-	 * issue another usb command. this is the only form of
-	 * throttling we have
-	 */
-	if( dev->lirccnt )
-	{
-		return dev->lirccnt;
-	}
-
-	/* reserve room for our leading space */
-	if( dev->last_space )
-		words_to_read--;
-		
-	while( words_to_read )
-	{
-		/* handle signals and USB disconnects */
-		if( signal_pending(current) )
-		{
-			return dev->lirccnt ? dev->lirccnt : -EINTR;
-		}
-		if( !dev->udev )
-		{
-			return -ENODEV;
-		}
+	int res;
+	struct urb *async_urb;
+	unsigned char *async_buf;
 
-		bulkidx = 0;
+	if (urb_type) {
+	    	if ((async_urb = usb_alloc_urb(0, GFP_KERNEL))) {
+			/* alloc buffer */
+			if ((async_buf = kmalloc(size, GFP_KERNEL))) {
+				if (urb_type==PHILUSB_OUTBOUND) {
+					/* outbound data */
+					usb_fill_int_urb(async_urb, ir->usbdev, usb_sndintpipe(ir->usbdev, ep->bEndpointAddress), async_buf,
+					size, usb_async_callback, ir, ep->bInterval);
 
-		/*
-		 * perform data read (phys or from previous buffer)
-		 */
-        
-		/* use leftovers if present, otherwise perform a read */
-		if( dev->usb_valid_bytes_in_bulk_buffer )
-		{
-			this_read = partial = 
-				dev->usb_valid_bytes_in_bulk_buffer;
-			dev->usb_valid_bytes_in_bulk_buffer = 0;
-		}
-		else
-		{
-			int retval;
-            
-			this_read = dev->bulk_in_size;
-			partial = 0;
-			retval = usb_bulk_msg
-				(dev->udev,
-				 usb_rcvbulkpipe
-				 (dev->udev, dev->bulk_in_endpointAddr),
-				 (unsigned char*)dev->bulk_in_buffer,
-				 this_read, &partial, HZ*10);
-			
-			/* retry a few times on overruns; map all
-			   other errors to -EIO */
-			if( retval )
-			{
-				if( retval == -EOVERFLOW && 
-				    retries < 5 )
-				{
-					retries++;
-					interruptible_sleep_on_timeout
-						( &dev->wait_q, HZ );
-					continue;
+					memcpy(async_buf, data, size);
+					async_urb->transfer_flags=URB_ASYNC_UNLINK;
 				}
-				else
-				{
-					return -EIO;
+				else {
+					/* inbound data */
+					usb_fill_int_urb(async_urb, ir->usbdev, usb_rcvintpipe(ir->usbdev, ep->bEndpointAddress), async_buf,
+					size, usb_async_callback, ir, ep->bInterval);
+
+					async_urb->transfer_flags=URB_ASYNC_UNLINK;
+//					async_urb->transfer_flags=URB_SHORT_NOT_OK;
 				}
 			}
-            
-			retries = 0;
-			if( partial )
-				this_read = partial;
-
-			/* skip the header */
-			bulkidx += 2;
-            
-			/* check for empty reads (header only) */
-			if( this_read == 2 )
-			{
-				/* assume no data */
-				if( dont_block )
-				{
-					break;
-				}
-
-				/* sleep for a bit before performing
-				   another read */
-				interruptible_sleep_on_timeout
-					( &dev->wait_q, 1 );
-				continue;
+			else {
+				usb_free_urb(async_urb);
+				return;
 			}
 		}
+	}
+	else {
+		/* standard request */
+		async_urb=ir->urb_in;
+		ir->send_flags = RECV_FLAG_IN_PROGRESS;
+	}
+	dprintk(DRIVER_NAME "[%d]: receive request called (size=%#x)\n", ir->devnum, size);
 
-		/*
-		 * process data
-		 */
-        
-		/* at this point this_read is > 0 */
-		while( bulkidx < this_read &&
-		       (words_to_read > (dev->last_space ? 1 : 0)) )
-			//while( bulkidx < this_read && words_to_read )
-		{
-			int keycode;
-			int pulse = 0;
-            
-			/* read packet length if needed */
-			if( !bytes_left_in_packet )
-			{
-				
-				/* we assume we are on a packet length
-				 * value. it is possible, in some
-				 * cases, to get a packet that does
-				 * not start with a length, apparently
-				 * due to some sort of fragmenting,
-				 * but occaisonally we do not receive
-				 * the second half of a fragment
-				 */
-				bytes_left_in_packet = 
-					128 + signedp[bulkidx++];
-
-				/* unfortunately rather than keep all
-				 * the data in the packetized format,
-				 * the transceiver sends a trailing 8
-				 * bytes that aren't part of the
-				 * transmittion from the remote,
-				 * aren't packetized, and dont really
-				 * have any value. we can basically
-				 * tell we have hit them if 1) we have
-				 * a loooong space currently stored
-				 * up, and 2) the bytes_left value for
-				 * this packet is obviously wrong
-				 */
-				if( bytes_left_in_packet > 4  )
-				{
-					if( dev->mce_bytes_left_in_packet )
-					{
-						bytes_left_in_packet = dev->mce_bytes_left_in_packet;
-						bulkidx--;
-					}
-					bytes_left_in_packet = 0;
-					bulkidx = this_read;
-				}
+	async_urb->transfer_buffer_length = size;
+	async_urb->dev = ir->usbdev;
 
-				/* always clear this if we have a
-				   valid packet */
-				dev->mce_bytes_left_in_packet = 0;
-                    
-				/* continue here to verify we haven't
-				   hit the end of the bulk_in */
-				continue;
-				
-			}
+	if ((res=usb_submit_urb(async_urb, SLAB_ATOMIC))) {
+	    dprintk(DRIVER_NAME "[%d]: receive request FAILED! (res=%d)\n", ir->devnum, res);
+	    return;
+	}
+	dprintk(DRIVER_NAME "[%d]: receive request complete (res=%d)\n", ir->devnum, res);
+}
 
-			/*
-			 * generate mode2
-			 */
-            
-			keycode = signedp[bulkidx++];
-			if( keycode < 0 )
-			{
-				pulse = 1;
-				keycode += 128;
-			}
-			keycode *= MCE_TIME_UNIT;
+static int unregister_from_lirc(struct irctl *ir)
+{
+	struct lirc_plugin *p = ir->p;
+	int devnum;
+	int rtn;
 
-			bytes_left_in_packet--;
-            
-			if( pulse )
-			{
-				if( dev->last_space )
-				{
-					dev->lircdata[dev->lirccnt++] =
-						dev->last_space;
-					dev->last_space = 0;
-					words_to_read--;
+	devnum = ir->devnum;
+	dprintk(DRIVER_NAME "[%d]: unregister from lirc called\n", devnum);
 
-					/* clear the lirc_t for the pulse */
-					dev->lircdata[dev->lirccnt] = 0;
-				}
-				dev->lircdata[dev->lirccnt] += keycode;
-				dev->lircdata[dev->lirccnt] |= PULSE_BIT;
-			}
-			else
-			{
-				/* on pulse->space transition, add one
-				   for the existing pulse */
-				if( dev->lircdata[dev->lirccnt] &&
-				    !dev->last_space )
-				{
-					dev->lirccnt++;
-					words_to_read--;
-				}
-                
-				dev->last_space += keycode;
-			}
+	if ((rtn = lirc_unregister_plugin(p->minor)) > 0) {
+		printk(DRIVER_NAME "[%d]: error in lirc_unregister minor: %d\n"
+			"Trying again...\n", devnum, p->minor);
+		if (rtn == -EBUSY) {
+			printk(DRIVER_NAME
+				"[%d]: device is opened, will unregister"
+				" on close\n", devnum);
+			return -EAGAIN;
 		}
-	}
-	
-	/* save off some info if we are exiting mid-packet, or with
-	   leftovers */
-	if( bytes_left_in_packet )
-	{
-		dev->mce_bytes_left_in_packet = bytes_left_in_packet;
-	}
-	if( bulkidx < this_read )
-	{
-		dev->usb_valid_bytes_in_bulk_buffer = (this_read - bulkidx);
-		memcpy( dev->bulk_in_buffer, &(dev->bulk_in_buffer[bulkidx]),
-			dev->usb_valid_bytes_in_bulk_buffer );
-	}
-	return dev->lirccnt;
-}
-
-/* mceusb_add_to_buf: called by lirc_dev to fetch all available keys
- * this is used as a polling interface for us: since we set
- * plugin->sample_rate we will periodically get the below call to
- * check for new data returns 0 on success, or -ENODATA if nothing is
- * available
- */
-static int mceusb_add_to_buf(void* data, struct lirc_buffer* buf )
-{
-	struct usb_skel* dev = (struct usb_skel*) data;
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ);
 
-	down( &dev->sem );
+		if ((rtn = lirc_unregister_plugin(p->minor)) > 0) {
+			printk(DRIVER_NAME "[%d]: lirc_unregister failed\n",
+			devnum);
+		}
+	}
 
-	/* verify device still present */
-	if( dev->udev == NULL )
-	{
-		up( &dev->sem );
-		return -ENODEV;
+	if (rtn != SUCCESS) {
+		printk(DRIVER_NAME "[%d]: didn't free resources\n", devnum);
+		return -EAGAIN;
 	}
 
-	if( !dev->lirccnt )
-	{
-		int res;
-		dev->lircidx = 0;
-        
-		res = msir_fetch_more_data( dev, 1 );
-		
-		if( res == 0 )
-			res = -ENODATA;
-		if( res < 0 ) {
-			up( &dev->sem );
-			return res;
-		}
+	printk(DRIVER_NAME "[%d]: usb remote disconnected\n", devnum);
+
+	lirc_buffer_free(p->rbuf);
+	kfree(p->rbuf);
+	kfree(p);
+	kfree(ir);
+	return SUCCESS;
+}
+
+static int set_use_inc(void *data)
+{
+	struct irctl *ir = data;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_inc called with no context\n");
+		return -EIO;
 	}
+	dprintk(DRIVER_NAME "[%d]: set use inc\n", ir->devnum);
 
-	if( dev->lirccnt )
-	{
-		int keys_to_copy;
-
-		/* determine available buffer space and available data */
-		keys_to_copy = lirc_buffer_available( buf );
-		if( keys_to_copy > dev->lirccnt )
-		{
-			keys_to_copy = dev->lirccnt;
-		}
-        
-		lirc_buffer_write_n( buf, (unsigned char*) &(dev->lircdata[dev->lircidx]), keys_to_copy );
-		dev->lircidx += keys_to_copy;
-		dev->lirccnt -= keys_to_copy;
-        
-		up( &dev->sem );
-		return 0;
+	MOD_INC_USE_COUNT;
+
+	if (!ir->connected) {
+		if (!ir->usbdev)
+			return -ENOENT;
+		ir->connected = 1;
 	}
 
-	up( &dev->sem );
-	return -ENODATA;
+	return SUCCESS;
 }
 
-/**
- *	mceusb_write_bulk_callback
- */
-#ifdef KERNEL_2_5 
-static void mceusb_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
-#else
-static void mceusb_write_bulk_callback (struct urb *urb)
-#endif
+static void set_use_dec(void *data)
 {
-	struct usb_skel *dev = (struct usb_skel *)urb->context;
-
-	dprintk("%s - minor %d", __func__, dev->minor);
+	struct irctl *ir = data;
 
-	if ((urb->status != -ENOENT) && 
-	    (urb->status != -ECONNRESET)) {
-		dprintk("%s - nonzero write buld status received: %d",
-			__func__, urb->status);
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_dec called with no context\n");
 		return;
 	}
+	dprintk(DRIVER_NAME "[%d]: set use dec\n", ir->devnum);
 
-	return;
+	if (ir->connected) {
+		IRLOCK;
+		ir->connected = 0;
+		IRUNLOCK;
+	}
+	MOD_DEC_USE_COUNT;
 }
 
-/**
- *	mceusb_probe
- *
- *	Called by the usb core when a new device is connected that it 
- *	thinks this driver might be interested in.
- */
-#ifdef KERNEL_2_5 
-static int mceusb_probe(struct usb_interface *interface, const struct usb_device_id *id)
+static void send_packet_to_lirc(struct irctl *ir)
 {
-	struct usb_device *udev = interface_to_usbdev(interface);
-	struct usb_host_interface *iface_desc;
-#else
-static void * mceusb_probe(struct usb_device *udev, unsigned int ifnum,
-			   const struct usb_device_id *id)
+    if ( ir->lirccnt ) {
+	lirc_buffer_write_n(ir->p->rbuf,(unsigned char *) ir->lircdata,ir->lirccnt);
+
+	wake_up(&ir->p->rbuf->wait_poll);
+	ir->lirccnt=0;
+    }
+}
+
+static void usb_remote_recv(struct urb *urb, struct pt_regs *regs)
 {
-	struct usb_interface *interface = &udev->actconfig->interface[ifnum];
-	struct usb_interface_descriptor *iface_desc;	
-#endif
-	struct usb_skel *dev = NULL;
-	struct usb_endpoint_descriptor *endpoint;
-	
-	struct lirc_plugin* plugin;
-	struct lirc_buffer* rbuf;
+	struct irctl *ir;
+	int len;
 
-	int minor;
-	size_t buffer_size;
-	int i;
-	int retval = -ENOMEM;
-	
-	/* See if the device offered us matches what we can accept */
-	if ((udev->descriptor.idVendor != USB_MCEUSB_VENDOR_ID) ||
-	    (udev->descriptor.idProduct != USB_MCEUSB_PRODUCT_ID)) {
-	    	dprintk("Wrong Vendor/Product IDs");
-#ifdef KERNEL_2_5
-		return -ENODEV;
-#else
-		return NULL;
-#endif
+	if (!urb)
+		return;
+
+	if (!(ir = urb->context)) {
+		urb->transfer_flags |= URB_ASYNC_UNLINK;
+		usb_unlink_urb(urb);
+		return;
 	}
 
-	/* select a "subminor" number (part of a minor number) */
-	down (&minor_table_mutex);
-	for (minor = 0; minor < MAX_DEVICES; ++minor) {
-		if (minor_table[minor] == NULL)
-			break;
-	}
-	if (minor >= MAX_DEVICES) {
-		info ("Too many devices plugged in, "
-		      "can not handle this device.");
-		goto error;
-	}
-
-	/* allocate memory for our device state and initialize it */
-	dev = kmalloc (sizeof(struct usb_skel), GFP_KERNEL);
-	if (dev == NULL) {
-		err ("Out of memory");
-#ifdef KERNEL_2_5
-		retval = -ENOMEM;
-#endif
-		goto error;
+	len = urb->actual_length;
+	if (debug)
+		usb_remote_printdata(ir,urb->transfer_buffer,len);
+
+	if (ir->send_flags==RECV_FLAG_IN_PROGRESS) {
+	  	ir->send_flags = SEND_FLAG_COMPLETE;
+		dprintk(DRIVER_NAME "[%d]: setup answer received %d bytes\n",ir->devnum,len);
 	}
-	minor_table[minor] = dev;
-	
-	memset (dev, 0x00, sizeof (*dev));
-	init_MUTEX (&dev->sem);
-	dev->udev = udev;
-	dev->interface = interface;
-	dev->minor = minor;
-
-	/* set up the endpoint information */
-	/* check out the endpoints */
-	/* use only the first bulk-in and bulk-out endpoints */
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,4)
-	iface_desc = interface->cur_altsetting;
-#else
-	iface_desc = &interface->altsetting[0];
-#endif
 
-#ifdef KERNEL_2_5
-	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
-		endpoint = &iface_desc->endpoint[i].desc;
-#else
-	for (i = 0; i < iface_desc->bNumEndpoints; ++i) {
-		endpoint = &iface_desc->endpoint[i];
-#endif
-		if ((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) &&
-		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
-		     USB_ENDPOINT_XFER_BULK)) {
-			dprintk("we found a bulk in endpoint");
-			buffer_size = endpoint->wMaxPacketSize;
-			dev->bulk_in_size = buffer_size;
-			dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;
-#ifdef KERNEL_2_5
-			dev->bulk_in_buffer = usb_buffer_alloc
-				(udev, buffer_size, SLAB_ATOMIC, &dev->dma_in);
-#else
-			dev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
-#endif
-			if (!dev->bulk_in_buffer) {
-				err("Couldn't allocate bulk_in_buffer");
-				goto error;
+	switch (urb->status) {
+
+	/* success */
+	case SUCCESS:
+
+	    if ((len==MCE_CODE_LENGTH)) {
+
+		if ((ir->buf_in[0]==MCE_PACKET_HEADER)) {
+
+		    int i,keycode,pulse;
+			
+			/* buffer exhausted? */
+			if (ir->lirccnt>(LIRCBUF_SIZE-MCE_CODE_LENGTH))
+				send_packet_to_lirc(ir);
+
+		    for(i=0;i<MCE_PACKET_SIZE;i++) {
+			pulse = 0;
+			keycode=(signed char)ir->buf_in[i+1];
+			if ( keycode < 0 ) {
+			    pulse = 1;
+			    keycode += 128;
 			}
-		}
-		
-		if (((endpoint->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == 0x00) &&
-		    ((endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
-		     USB_ENDPOINT_XFER_BULK)) {
-			dprintk("we found a bulk out endpoint");
-#ifdef KERNEL_2_5
-			dev->write_urb = usb_alloc_urb(0, GFP_KERNEL);
-#else
-			dev->write_urb = usb_alloc_urb(0);
-#endif
-			if (!dev->write_urb) {
-				err("No free urbs available");
-				goto error;
+			keycode *= MCE_TIME_UNIT;
+
+			if ( pulse ) {
+			    if ( ir->last_space ) {
+				ir->lircdata[ir->lirccnt++] = ir->last_space;
+				ir->last_space = 0;
+				ir->lircdata[ir->lirccnt] = 0;
+			    }
+			    ir->lircdata[ir->lirccnt] += keycode;
+			    ir->lircdata[ir->lirccnt] |= PULSE_BIT;
 			}
-			buffer_size = endpoint->wMaxPacketSize;
-			dev->bulk_out_size = buffer_size;
-			dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;
-#ifdef KERNEL_2_5
-			dev->bulk_out_buffer = usb_buffer_alloc(udev, buffer_size, SLAB_ATOMIC, &dev->dma_out);
-#else
-			dev->bulk_out_buffer = kmalloc (buffer_size, GFP_KERNEL);
-#endif
-			if (!dev->bulk_out_buffer) {
-				err("Couldn't allocate bulk_out_buffer");
-				goto error;
+			else {
+			    if ( ir->lircdata[ir->lirccnt] &&
+				!ir->last_space ) {
+				ir->lirccnt++;
+			    }
+			    ir->last_space += keycode;
 			}
-#ifdef KERNEL_2_5
-			usb_fill_bulk_urb(dev->write_urb, udev, 
-				      usb_sndbulkpipe
-				      (udev, endpoint->bEndpointAddress),
-				      dev->bulk_out_buffer, buffer_size,
-				      mceusb_write_bulk_callback, dev);
-#else
-			FILL_BULK_URB(dev->write_urb, udev,
-				      usb_sndbulkpipe
-				      (udev, endpoint->bEndpointAddress),
-				      dev->bulk_out_buffer, buffer_size,
-				      mceusb_write_bulk_callback, dev);
-#endif 
+		    }
 		}
-	}
+	    }
+	    else {
+		/* transmission finished (long packet) */
+		send_packet_to_lirc(ir);
+	    }
+	    
+	    break;
+
+	/* unlink */
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		urb->transfer_flags |= URB_ASYNC_UNLINK;
+		usb_unlink_urb(urb);
+		return;
 
-	if (!(dev->bulk_in_endpointAddr && dev->bulk_out_endpointAddr)) {
-		err("Couldn't find both bulk-in and bulk-out endpoints");
-		goto error;
-	}
-
-	/* init the waitq */
-	init_waitqueue_head( &dev->wait_q );
-
-
-	/* Set up our lirc plugin */
-	if(!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
-		err("out of memory");
-		goto error;
-	}
-	memset( plugin, 0, sizeof(struct lirc_plugin) );
-
-	if(!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
-		err("out of memory");
-		kfree( plugin );
-		goto error;
-	}
-    
-	/* the lirc_atiusb module doesn't memset rbuf here ... ? */
-	if( lirc_buffer_init( rbuf, sizeof(lirc_t), 128)) {
-		err("out of memory");
-		kfree( plugin );
-		kfree( rbuf );
-		goto error;
-	}
-
-	strcpy(plugin->name, DRIVER_NAME " ");
-	plugin->minor       = minor;
-	plugin->code_length = sizeof(lirc_t) * 8;
-	plugin->features    = LIRC_CAN_REC_MODE2; // | LIRC_CAN_SEND_MODE2;
-	plugin->data        = dev;
-	plugin->rbuf        = rbuf;
-	plugin->ioctl       = NULL;
-	plugin->set_use_inc = &set_use_inc;
-	plugin->set_use_dec = &set_use_dec;
-	plugin->sample_rate = 80;   // sample at 100hz (10ms)
-	plugin->add_to_buf  = &mceusb_add_to_buf;
-	//    plugin->fops        = &mceusb_fops;
-	plugin->owner       = THIS_MODULE;
-	if( lirc_register_plugin(plugin) < 0 )
-	{
-		kfree( plugin );
-		lirc_buffer_free( rbuf );
-		kfree( rbuf );
-		goto error;
-	}
-	dev->plugin = plugin;
-	
-	/* clear off the first few messages. these look like
-	 * calibration or test data, i can't really tell
-	 * this also flushes in case we have random ir data queued up
-	 */
-	{
-		char junk[64];
-		int partial = 0, retval, i;
-		for( i = 0; i < 40; i++ )
-		{
-			retval = usb_bulk_msg
-				(udev, usb_rcvbulkpipe
-				 (udev, dev->bulk_in_endpointAddr),
-				 junk, 64,
-				 &partial, HZ*10);
+	case -EPIPE:
+	default:
+		break;
+	}
+
+	/* resubmit urb */
+	usb_submit_urb(urb, SLAB_ATOMIC);
+}
+
+static int usb_remote_probe(struct usb_interface *intf,
+				const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct usb_host_interface *idesc;
+	struct usb_endpoint_descriptor *ep=NULL, *ep_in=NULL, *ep_out=NULL;
+	struct usb_host_config *config;
+	struct irctl *ir = NULL;
+	struct lirc_plugin *plugin = NULL;
+	struct lirc_buffer *rbuf = NULL;
+	int devnum, pipe, maxp;
+	int minor = 0;
+	int i;
+	char buf[63], name[128]="";
+	int mem_failure = 0;
+
+	dprintk(DRIVER_NAME ": usb probe called\n");
+
+	config=dev->actconfig;
+
+	idesc = intf->cur_altsetting;
+
+	/* step through the endpoints to find first bulk in and out endpoint */
+	for (i = 0; i < idesc->desc.bNumEndpoints; ++i) {
+		ep = &idesc->endpoint[i].desc;
+
+		if ((ep_in == NULL)
+			&& ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
+			&& ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK)) {
+
+			dprintk(DRIVER_NAME ": acceptable inbound endpoint found\n");
+			ep_in = ep;
+			ep_in->bmAttributes=USB_ENDPOINT_XFER_INT;
+			ep_in->bInterval=1;
+		}
+
+		if ((ep_out == NULL)
+			&& ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
+			&& ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK)) {
+
+			dprintk(DRIVER_NAME ": acceptable outbound endpoint found\n");
+			ep_out = ep;
+			ep_out->bmAttributes=USB_ENDPOINT_XFER_INT;
+			ep_out->bInterval=1;
 		}
 	}
-    
-	msir_cleanup( dev );
-	mceusb_setup( udev );
-	
-#ifdef KERNEL_2_5
-	/* we can register the device now, as it is ready */
-	usb_set_intfdata (interface, dev);
-#endif	
-	/* let the user know what node this device is now attached to */
-	//info ("USB Microsoft IR Transceiver device now attached to msir%d", dev->minor);
-	up (&minor_table_mutex);
-#ifdef KERNEL_2_5
-	return 0;
-#else
-	return dev;
-#endif
- error:
-	mceusb_delete (dev);
-	dev = NULL;
-	dprintk("%s: retval = %x", __func__, retval);
-	up (&minor_table_mutex);
-#ifdef KERNEL_2_5
-	return retval;
-#else
-	return NULL;
-#endif
-}
+	if (ep_in == NULL) {
+		dprintk(DRIVER_NAME ": inbound and/or endpoint not found\n");
+		return -ENODEV;
+	}
 
-/**
- *	mceusb_disconnect
- *
- *	Called by the usb core when the device is removed from the system.
- *
- *	This routine guarantees that the driver will not submit any more urbs
- *	by clearing dev->udev.  It is also supposed to terminate any currently
- *	active urbs.  Unfortunately, usb_bulk_msg(), used in skel_read(), does
- *	not provide any way to do this.  But at least we can cancel an active
- *	write.
- */
-#ifdef KERNEL_2_5 
-static void mceusb_disconnect(struct usb_interface *interface)
-#else
-static void mceusb_disconnect(struct usb_device *udev, void *ptr)
-#endif
-{
-	struct usb_skel *dev;
-	int minor;
-#ifdef KERNEL_2_5
-	dev = usb_get_intfdata (interface);
-	usb_set_intfdata (interface, NULL);
-#else
-	dev = (struct usb_skel *)ptr;
-#endif
-	
-	down (&minor_table_mutex);
-	down (&dev->sem);
-	minor = dev->minor;
-
-	/* unhook lirc things */
-	lirc_unregister_plugin( minor );
-	lirc_buffer_free( dev->plugin->rbuf );
-	kfree( dev->plugin->rbuf );
-	kfree( dev->plugin );
-#ifdef KERNEL_2_5
-	/* terminate an ongoing write */
-	if (atomic_read (&dev->write_busy)) {
-		usb_unlink_urb (dev->write_urb);
-		wait_for_completion (&dev->write_finished);
+	devnum = dev->devnum;
+	pipe = usb_rcvintpipe(dev, ep_in->bEndpointAddress);
+	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
+
+	/* allocate kernel memory */
+	mem_failure = 0;
+	if (!(ir = kmalloc(sizeof(struct irctl), GFP_KERNEL))) {
+		mem_failure = 1;
+	} else {
+		memset(ir, 0, sizeof(struct irctl));
+
+		if (!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
+			mem_failure = 2;
+		} else if (!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
+			mem_failure = 3;
+		} else if (lirc_buffer_init(rbuf, sizeof(lirc_t), LIRCBUF_SIZE)) {
+			mem_failure = 4;
+		} else if (!(ir->buf_in = usb_buffer_alloc(dev, maxp, SLAB_ATOMIC, &ir->dma_in))) {
+			mem_failure = 5;
+		} else if (!(ir->urb_in = usb_alloc_urb(0, GFP_KERNEL))) {
+			mem_failure = 7;
+		} else {
+
+			memset(plugin, 0, sizeof(struct lirc_plugin));
+
+			strcpy(plugin->name, DRIVER_NAME " ");
+			plugin->minor = -1;
+			plugin->features = LIRC_CAN_REC_MODE2;
+			plugin->data = ir;
+			plugin->rbuf = rbuf;
+			plugin->set_use_inc = &set_use_inc;
+			plugin->set_use_dec = &set_use_dec;
+			plugin->code_length = sizeof(lirc_t) * 8;
+			plugin->ioctl = NULL;
+
+			init_MUTEX(&ir->lock);
+			init_waitqueue_head(&ir->wait_out);
+
+			if ((minor = lirc_register_plugin(plugin)) < 0) {
+				mem_failure = 9;
+			}
+		}
 	}
 
-	/* prevent device read, write and ioctl */
-	dev->present = 0;
-#endif
-	
-	mceusb_delete (dev);
-	
-	info("Microsoft IR Transceiver #%d now disconnected", minor);
-	up (&dev->sem);
-	up (&minor_table_mutex);
+	/* free allocated memory incase of failure */
+	switch (mem_failure) {
+	case 9:
+		lirc_buffer_free(rbuf);
+	case 7:
+		usb_free_urb(ir->urb_in);
+	case 5:
+		usb_buffer_free(dev, maxp, ir->buf_in, ir->dma_in);
+	case 4:
+		kfree(rbuf);
+	case 3:
+		kfree(plugin);
+	case 2:
+		kfree(ir);
+	case 1:
+		printk(DRIVER_NAME "[%d]: out of memory (code=%d)\n",
+			devnum, mem_failure);
+		return -ENOMEM;
+	}
+
+	plugin->minor = minor;
+	ir->p = plugin;
+	ir->devnum = devnum;
+	ir->usbdev = dev;
+	ir->len_in = maxp;
+	ir->last_space = PULSE_MASK;
+	ir->connected = 0;
+
+	if (dev->descriptor.iManufacturer
+		&& usb_string(dev, dev->descriptor.iManufacturer, buf, 63) > 0)
+		strncpy(name, buf, 128);
+	if (dev->descriptor.iProduct
+		&& usb_string(dev, dev->descriptor.iProduct, buf, 63) > 0)
+		snprintf(name, 128, "%s %s", name, buf);
+	printk(DRIVER_NAME "[%d]: %s on usb%d:%d\n", devnum, name,
+	       dev->bus->busnum, devnum);
+
+	/* inbound data */
+	usb_fill_int_urb(ir->urb_in, dev, pipe, ir->buf_in,
+		maxp, usb_remote_recv, ir, ep_in->bInterval);
+
+	/* initialize device */
+	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
+	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
+	request_packet_async( ir, ep_out, init1, sizeof(init1), PHILUSB_OUTBOUND );
+	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
+	request_packet_async( ir, ep_out, init2, sizeof(init2), PHILUSB_OUTBOUND );
+	request_packet_async( ir, ep_in, NULL, maxp, 0);
+
+	usb_set_intfdata(intf, ir);
+	return SUCCESS;
 }
 
 
+static void usb_remote_disconnect(struct usb_interface *intf)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct irctl *ir = usb_get_intfdata(intf);
+	usb_set_intfdata(intf, NULL);
 
-/**
- *	usb_mceusb_init
- */
-static int __init usb_mceusb_init(void)
+	if (!ir || !ir->p)
+		return;
+
+	ir->usbdev = NULL;
+	wake_up_all(&ir->wait_out);
+
+	IRLOCK;
+	usb_unlink_urb(ir->urb_in);
+	usb_free_urb(ir->urb_in);
+
+	usb_buffer_free(dev, ir->len_in, ir->buf_in, ir->dma_in);
+	IRUNLOCK;
+
+	unregister_from_lirc(ir);
+}
+
+static struct usb_driver usb_remote_driver = {
+	.owner =	THIS_MODULE,
+	.name =		DRIVER_NAME,
+	.probe =	usb_remote_probe,
+	.disconnect =	usb_remote_disconnect,
+	.id_table =	usb_remote_table
+};
+
+static int __init usb_remote_init(void)
 {
-	int result;
+	int i;
 
-	/* register this driver with the USB subsystem */
-	result = usb_register(&mceusb_driver);
-#ifdef KERNEL_2_5	
-	if ( result ) {
-#else
-	if ( result < 0 ) {
-#endif
-		err("usb_register failed for the " DRIVER_NAME " driver. error number %d",result);
-#ifdef KERNEL_2_5
-		return result;
-#else
-		return -1;
-#endif
+	printk("\n" DRIVER_NAME ": " DRIVER_DESC " v" DRIVER_VERSION "\n");
+	printk(DRIVER_NAME ": " DRIVER_AUTHOR "\n");
+	dprintk(DRIVER_NAME ": debug mode enabled\n");
+
+	request_module("lirc_dev");
+
+	if ((i = usb_register(&usb_remote_driver)) < 0) {
+		printk(DRIVER_NAME ": usb register failed, result = %d\n", i);
+		return -ENODEV;
 	}
 
-	info(DRIVER_DESC " " DRIVER_VERSION);
-	return 0;
+	return SUCCESS;
 }
 
-
-/**
- *	usb_mceusb_exit
- */
-static void __exit usb_mceusb_exit(void)
+static void __exit usb_remote_exit(void)
 {
-	/* deregister this driver with the USB subsystem */
-	usb_deregister(&mceusb_driver);
+	usb_deregister(&usb_remote_driver);
 }
 
- module_init (usb_mceusb_init);
-module_exit (usb_mceusb_exit);
+module_init(usb_remote_init);
+module_exit(usb_remote_exit);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_LICENSE("GPL");
-MODULE_DEVICE_TABLE (usb, mceusb_table);
+MODULE_DEVICE_TABLE(usb, usb_remote_table);
 
-module_param(debug, int, 0644);
+module_param(debug, bool, 0644);
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
 EXPORT_NO_SYMBOLS;
diff -Naur lirc-0.7.1-old/remotes/mceusb/lircd.conf.mceusb lirc-0.7.1-new/remotes/mceusb/lircd.conf.mceusb
--- lirc-0.7.1-old/remotes/mceusb/lircd.conf.mceusb	2004-08-20 14:38:02.000000000 -0700
+++ lirc-0.7.1-new/remotes/mceusb/lircd.conf.mceusb	2005-07-02 07:57:17.000000000 -0700
@@ -12,6 +12,7 @@
 # For use with the USB MCE ir receiver
 #
 # Dan Conti  dconti|acm.wwu.edu
+# Martin A. Blatter  mblatter@gmail.com (additions for european version)
 #
 # Radio, Print, RecTV are only available on the HP Media Center remote control
 #
@@ -36,7 +37,12 @@
 
       begin codes
 
-# starts at af
+# starts at a1
+        Blue     0x00007ba1
+        Yellow   0x00007ba2
+        Green    0x00007ba3
+        Red      0x00007ba4
+        Teletext 0x00007ba5
         Radio    0x00007baf
         Print    0x00007bb1
         Videos   0x00007bb5
@@ -55,6 +61,8 @@
         Down     0x00007be0
         Up       0x00007be1
 # no e2,e3
+        Star     0x00007be2
+        Hash     0x00007be3
         Replay   0x00007be4
         Skip     0x00007be5
         Stop     0x00007be6
