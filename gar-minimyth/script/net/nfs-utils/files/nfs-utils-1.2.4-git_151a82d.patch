diff -Naur nfs-utils-1.2.4-old/configure.ac nfs-utils-1.2.4-new/configure.ac
--- nfs-utils-1.2.4-old/configure.ac	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/configure.ac	2011-08-03 20:04:46.000000000 -0700
@@ -114,14 +114,14 @@
 	rpcgen_path=$withval,
 	rpcgen_path=yes )
 	RPCGEN_PATH=
-	if test "$rpcgen_path" == "yes"; then
+	if test "$rpcgen_path" = "yes"; then
 	    for p in /usr/local/bin/rpcgen /usr/bin/rpcgen /bin/rpcgen
 	    do if test -f $p ; then RPCGEN_PATH=$p ; break; fi ; done
 	elif test "$rpcgen_path" != "internal"; then
 	    RPCGEN_PATH=$rpcgen_path
 	fi
 	AC_SUBST(RPCGEN_PATH)
-	AM_CONDITIONAL(CONFIG_RPCGEN, [test "$RPCGEN_PATH" == ""])
+	AM_CONDITIONAL(CONFIG_RPCGEN, [test "$RPCGEN_PATH" = ""])
 AC_ARG_ENABLE(uuid,
 	[AC_HELP_STRING([--disable-uuid], [Exclude uuid support to avoid buggy libblkid])],
 	if test "$enableval" = "yes" ; then choose_blkid=yes; else choose_blkid=no; fi,
@@ -137,7 +137,7 @@
 	AC_ARG_ENABLE(libmount-mount,
 		[AC_HELP_STRING([--enable-libmount-mount],
 				[Link mount.nfs with libmount (EXPERIMENTAL)])],
-		enable_libmount=yes,
+		enable_libmount=$enableval,
 		enable_libmount=no)
 fi
 
@@ -256,9 +256,6 @@
   dnl check for nfsidmap libraries and headers
   AC_LIBNFSIDMAP
 
-  dnl enable nfsidmap when its support by libnfsidmap
-  AM_CONDITIONAL(CONFIG_NFSIDMAP, [test "$enable_nfsidmap" = "yes"])
-
   dnl check for the keyutils libraries and headers
   AC_KEYUTILS
 
@@ -268,6 +265,9 @@
     AC_RPCSEC_VERSION
   fi
 fi
+dnl enable nfsidmap when its support by libnfsidmap
+AM_CONDITIONAL(CONFIG_NFSIDMAP, [test "$enable_nfsidmap" = "yes"])
+
 
 if test "$knfsd_cv_glibc2" = no; then
     AC_CHECK_LIB(bsd, daemon, [LIBBSD="-lbsd"])
diff -Naur nfs-utils-1.2.4-old/support/include/rpcmisc.h nfs-utils-1.2.4-new/support/include/rpcmisc.h
--- nfs-utils-1.2.4-old/support/include/rpcmisc.h	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/support/include/rpcmisc.h	2011-08-03 20:04:46.000000000 -0700
@@ -53,6 +53,7 @@
 void		rpc_dispatch(struct svc_req *rq, SVCXPRT *xprt,
 				struct rpc_dtable *dtable, int nvers,
 				void *argp, void *resp);
+int		getservport(u_long number, const char *proto);
 
 extern int	_rpcpmstart;
 extern int	_rpcfdtype;
diff -Naur nfs-utils-1.2.4-old/support/nfs/exports.c nfs-utils-1.2.4-new/support/nfs/exports.c
--- nfs-utils-1.2.4-old/support/nfs/exports.c	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/support/nfs/exports.c	2011-08-03 20:04:46.000000000 -0700
@@ -784,8 +784,9 @@
 	fd = open(path, O_RDONLY);
 	if (fd == -1)
 		goto good;
-	fd = read(fd, buf, 50);
-	if (fd == -1)
+	c = read(fd, buf, 50);
+	close(fd);
+	if (c == -1)
 		goto err;
 	c = sscanf(buf, "%x %x", &ef.flags, &ef.secinfo_flags);
 	if (c != 2)
diff -Naur nfs-utils-1.2.4-old/support/nfs/svc_create.c nfs-utils-1.2.4-new/support/nfs/svc_create.c
--- nfs-utils-1.2.4-old/support/nfs/svc_create.c	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/support/nfs/svc_create.c	2011-08-03 20:04:46.000000000 -0700
@@ -393,7 +393,7 @@
 	const struct sigaction create_sigaction = {
 		.sa_handler	= SIG_IGN,
 	};
-	unsigned int visible, up;
+	unsigned int visible, up, servport;
 	struct netconfig *nconf;
 	void *handlep;
 
@@ -417,8 +417,13 @@
 		if (!(nconf->nc_flag & NC_VISIBLE))
 			continue;
 		visible++;
+		if (port == 0)
+			servport = getservport(program, nconf->nc_proto);
+		else
+			servport = port;
+
 		up += svc_create_nconf(name, program, version, dispatch,
-						port, nconf);
+						servport, nconf);
 	}
 
 	if (visible == 0)
diff -Naur nfs-utils-1.2.4-old/support/nfs/svc_socket.c nfs-utils-1.2.4-new/support/nfs/svc_socket.c
--- nfs-utils-1.2.4-old/support/nfs/svc_socket.c	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/support/nfs/svc_socket.c	2011-08-03 20:04:46.000000000 -0700
@@ -35,14 +35,43 @@
 # define __close(f)		close ((f))
 #endif
 
+int getservport(u_long number, const char *proto)
+{
+	char rpcdata[1024], servdata[1024];
+	struct rpcent rpcbuf, *rpcp;
+	struct servent servbuf, *servp = NULL;
+	int ret;
+
+	ret = getrpcbynumber_r(number, &rpcbuf, rpcdata, sizeof rpcdata,
+				&rpcp);
+	if (ret == 0 && rpcp != NULL) {
+		/* First try name.  */
+		ret = getservbyname_r(rpcp->r_name, proto, &servbuf, servdata,
+					sizeof servdata, &servp);
+		if ((ret != 0 || servp == NULL) && rpcp->r_aliases) {
+			const char **a;
+
+			/* Then we try aliases.  */
+			for (a = (const char **) rpcp->r_aliases; *a != NULL; a++) {
+				ret = getservbyname_r(*a, proto, &servbuf, servdata,
+							sizeof servdata, &servp);
+				if (ret == 0 && servp != NULL)
+					break;
+			}
+		}
+	}
+
+	if (ret == 0 && servp != NULL)
+		return ntohs(servp->s_port);
+
+	return 0;
+}
+
 static int
 svc_socket (u_long number, int type, int protocol, int reuse)
 {
   struct sockaddr_in addr;
   socklen_t len = sizeof (struct sockaddr_in);
-  char rpcdata [1024], servdata [1024];
-  struct rpcent rpcbuf, *rpcp;
-  struct servent servbuf, *servp = NULL;
   int sock, ret;
   const char *proto = protocol == IPPROTO_TCP ? "tcp" : "udp";
 
@@ -66,48 +95,13 @@
 
   memset (&addr, 0, sizeof (addr));
   addr.sin_family = AF_INET;
+  addr.sin_port = htons(getservport(number, proto));
 
-  ret = getrpcbynumber_r (number, &rpcbuf, rpcdata, sizeof rpcdata,
-			  &rpcp);
-  if (ret == 0 && rpcp != NULL)
+  if (bind(sock, (struct sockaddr *) &addr, len) < 0)
     {
-      /* First try name.  */
-      ret = getservbyname_r (rpcp->r_name, proto, &servbuf, servdata,
-			     sizeof servdata, &servp);
-      if ((ret != 0 || servp == NULL) && rpcp->r_aliases)
-	{
-	  const char **a;
-
-	  /* Then we try aliases.  */
-	  for (a = (const char **) rpcp->r_aliases; *a != NULL; a++) 
-	    {
-	      ret = getservbyname_r (*a, proto, &servbuf, servdata,
-				     sizeof servdata, &servp);
-	      if (ret == 0 && servp != NULL)
-		break;
-	    }
-	}
-    }
-
-  if (ret == 0 && servp != NULL)
-    {
-      addr.sin_port = servp->s_port;
-      if (bind (sock, (struct sockaddr *) &addr, len) < 0)
-	{
-	  perror (_("svc_socket: bind problem"));
-	  (void) __close (sock);
-	  sock = -1;
-	}
-    }
-  else
-    {
-	  addr.sin_port = 0;
-	  if (bind (sock, (struct sockaddr *) &addr, len) < 0)
-	    {
-	      perror (_("svc_socket: bind problem"));
-	      (void) __close (sock);
-	      sock = -1;
-	    }
+      perror (_("svc_socket: bind problem"));
+      (void) __close(sock);
+      sock = -1;
     }
 
   if (sock >= 0)
diff -Naur nfs-utils-1.2.4-old/support/nsm/file.c nfs-utils-1.2.4-new/support/nsm/file.c
--- nfs-utils-1.2.4-old/support/nsm/file.c	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/support/nsm/file.c	2011-08-03 20:04:46.000000000 -0700
@@ -395,18 +395,18 @@
 		return false;
 	}
 
-	if (st.st_uid == 0) {
-		xlog_warn("Running as root.  "
-			"chown %s to choose different user", nsm_base_dirname);
-		return true;
-	}
-
 	if (chdir(nsm_base_dirname) == -1) {
 		xlog(L_ERROR, "Failed to change working directory to %s: %m",
 				nsm_base_dirname);
 		return false;
 	}
 
+	if (st.st_uid == 0) {
+		xlog_warn("Running as root.  "
+			"chown %s to choose different user", nsm_base_dirname);
+		return true;
+	}
+
 	/*
 	 * If the pidfile happens to reside on NFS, dropping privileges
 	 * will probably cause us to lose access, even though we are
diff -Naur nfs-utils-1.2.4-old/utils/gssd/context_lucid.c nfs-utils-1.2.4-new/utils/gssd/context_lucid.c
--- nfs-utils-1.2.4-old/utils/gssd/context_lucid.c	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/utils/gssd/context_lucid.c	2011-08-03 20:04:46.000000000 -0700
@@ -305,7 +305,7 @@
 
 	maj_stat = gss_free_lucid_sec_context(&min_stat, ctx, return_ctx);
 	if (maj_stat != GSS_S_COMPLETE) {
-		pgsserr("gss_export_lucid_sec_context",
+		pgsserr("gss_free_lucid_sec_context",
 			maj_stat, min_stat, &krb5oid);
 		printerr(0, "WARN: failed to free lucid sec context\n");
 	}
diff -Naur nfs-utils-1.2.4-old/utils/gssd/svcgssd_krb5.c nfs-utils-1.2.4-new/utils/gssd/svcgssd_krb5.c
--- nfs-utils-1.2.4-old/utils/gssd/svcgssd_krb5.c	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/utils/gssd/svcgssd_krb5.c	2011-08-03 20:04:46.000000000 -0700
@@ -45,6 +45,7 @@
 #include "gss_oids.h"
 #include "err_util.h"
 #include "svcgssd_krb5.h"
+#include "../mount/version.h"
 
 #define MYBUFLEN 1024
 
@@ -169,22 +170,44 @@
 {
 #ifdef HAVE_SET_ALLOWABLE_ENCTYPES
 	u_int maj_stat, min_stat;
-	krb5_enctype default_enctypes[] = { ENCTYPE_DES_CBC_CRC,
-					    ENCTYPE_DES_CBC_MD5,
-					    ENCTYPE_DES_CBC_MD4 };
-	int default_num_enctypes =
-		sizeof(default_enctypes) / sizeof(default_enctypes[0]);
-	krb5_enctype *enctypes;
-	int num_enctypes;
+	krb5_enctype old_kernel_enctypes[] = {
+		ENCTYPE_DES_CBC_CRC,
+		ENCTYPE_DES_CBC_MD5,
+		ENCTYPE_DES_CBC_MD4 };
+	krb5_enctype new_kernel_enctypes[] = {
+		ENCTYPE_AES256_CTS_HMAC_SHA1_96,
+		ENCTYPE_AES128_CTS_HMAC_SHA1_96,
+		ENCTYPE_DES3_CBC_SHA1,
+		ENCTYPE_ARCFOUR_HMAC,
+		ENCTYPE_DES_CBC_CRC,
+		ENCTYPE_DES_CBC_MD5,
+		ENCTYPE_DES_CBC_MD4 };
+	krb5_enctype *default_enctypes, *enctypes;
+	int default_num_enctypes, num_enctypes;
+
+
+	if (linux_version_code() < MAKE_VERSION(2, 6, 35)) {
+		default_enctypes = old_kernel_enctypes;
+		default_num_enctypes =
+			sizeof(old_kernel_enctypes) / sizeof(old_kernel_enctypes[0]);
+	} else {
+		default_enctypes = new_kernel_enctypes;
+		default_num_enctypes =
+			sizeof(new_kernel_enctypes) / sizeof(new_kernel_enctypes[0]);
+	}
 
 	get_kernel_supported_enctypes();
 
 	if (parsed_enctypes != NULL) {
 		enctypes = parsed_enctypes;
 		num_enctypes = parsed_num_enctypes;
+		printerr(2, "%s: Calling gss_set_allowable_enctypes with %d "
+			"enctypes from the kernel\n", __func__, num_enctypes);
 	} else {
 		enctypes = default_enctypes;
 		num_enctypes = default_num_enctypes;
+		printerr(2, "%s: Calling gss_set_allowable_enctypes with %d "
+			"enctypes from defaults\n", __func__, num_enctypes);
 	}
 
 	maj_stat = gss_set_allowable_enctypes(&min_stat, gssd_creds,
diff -Naur nfs-utils-1.2.4-old/utils/mount/mount_libmount.c nfs-utils-1.2.4-new/utils/mount/mount_libmount.c
--- nfs-utils-1.2.4-old/utils/mount/mount_libmount.c	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/utils/mount/mount_libmount.c	2011-08-03 20:04:46.000000000 -0700
@@ -61,10 +61,19 @@
  * managed by libmount at all. We have to use "mount attributes" that are
  * private for mount.<type> helpers.
  */
-static void store_mount_options(struct libmnt_fs *fs, const char *opts)
+static void store_mount_options(struct libmnt_fs *fs, const char *nfs_opts)
 {
-	mnt_fs_set_fs_options(fs, opts);	/* for mtab */
-	mnt_fs_set_attributes(fs, opts);	/* for non-mtab systems */
+	char *o = NULL;
+
+	mnt_fs_set_attributes(fs, nfs_opts);	/* for non-mtab systems */
+
+	/* for mtab create a new options list */
+	mnt_optstr_append_option(&o, mnt_fs_get_vfs_options(fs), NULL);
+	mnt_optstr_append_option(&o, nfs_opts, NULL);
+	mnt_optstr_append_option(&o, mnt_fs_get_user_options(fs), NULL);
+
+	mnt_fs_set_options(fs, o);
+	free(o);
 }
 
 /*
diff -Naur nfs-utils-1.2.4-old/utils/mount/version.h nfs-utils-1.2.4-new/utils/mount/version.h
--- nfs-utils-1.2.4-old/utils/mount/version.h	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/utils/mount/version.h	2011-08-03 20:04:46.000000000 -0700
@@ -23,8 +23,8 @@
 #ifndef _NFS_UTILS_MOUNT_VERSION_H
 #define _NFS_UTILS_MOUNT_VERSION_H
 
-#include <stdlib.h>
-#include <string.h>
+#include <stdio.h>
+#include <limits.h>
 
 #include <sys/utsname.h>
 
@@ -37,14 +37,16 @@
 static inline unsigned int linux_version_code(void)
 {
 	struct utsname my_utsname;
-	unsigned int p, q, r;
+	unsigned int p, q = 0, r = 0;
 
+	/* UINT_MAX as backward compatibility code should not be run */
 	if (uname(&my_utsname))
-		return 0;
+		return UINT_MAX;
 
-	p = (unsigned int)atoi(strtok(my_utsname.release, "."));
-	q = (unsigned int)atoi(strtok(NULL, "."));
-	r = (unsigned int)atoi(strtok(NULL, "."));
+	/* UINT_MAX as future versions might not start with an integer */
+	if (sscanf(my_utsname.release, "%u.%u.%u", &p, &q, &r) < 1)
+		return UINT_MAX;
+	
 	return MAKE_VERSION(p, q, r);
 }
 
diff -Naur nfs-utils-1.2.4-old/utils/mountd/mountd.c nfs-utils-1.2.4-new/utils/mountd/mountd.c
--- nfs-utils-1.2.4-old/utils/mountd/mountd.c	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/utils/mountd/mountd.c	2011-08-03 20:04:46.000000000 -0700
@@ -633,7 +633,7 @@
 	struct groupnode *g;
 
 	for (g = e->ex_groups; g; g = g->gr_next)
-		if (strcmp(g->gr_name, newname))
+		if (!strcmp(g->gr_name, newname))
 			return;
 
 	g = xmalloc(sizeof(*g));
diff -Naur nfs-utils-1.2.4-old/utils/mountd/mountd.man nfs-utils-1.2.4-new/utils/mountd/mountd.man
--- nfs-utils-1.2.4-old/utils/mountd/mountd.man	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/utils/mountd/mountd.man	2011-08-03 20:04:46.000000000 -0700
@@ -122,7 +122,10 @@
 Specifies the port number used for RPC listener sockets.
 If this option is not specified,
 .B rpc.mountd
-chooses a random ephemeral port for each listener socket.
+will try to consult
+.IR /etc/services ,
+if gets port succeed, set the same port for all listener socket,
+otherwise chooses a random ephemeral port for each listener socket.
 .IP
 This option can be used to fix the port value of
 .BR rpc.mountd 's
diff -Naur nfs-utils-1.2.4-old/utils/nfsidmap/nfsidmap.man nfs-utils-1.2.4-new/utils/nfsidmap/nfsidmap.man
--- nfs-utils-1.2.4-old/utils/nfsidmap/nfsidmap.man	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/utils/nfsidmap/nfsidmap.man	2011-08-03 20:04:46.000000000 -0700
@@ -25,9 +25,9 @@
 can properly direct the upcall. The following line should be added before a call
 to keyctl negate:
 .PP
-create	nfs_idmap	*	*	/usr/sbin/nfsidmap %k %d 600
+create	id_resolver	*	*	/usr/sbin/nfsidmap %k %d 600
 .PP
-This will direct all nfs_idmap requests to the program
+This will direct all id_resolver requests to the program
 .I /usr/sbin/nfsidmap
 The last parameter, 600, defines how many seconds into the future the key will
 expire.  This is an optional parameter for
@@ -48,9 +48,9 @@
 generic upcall program.  If you would like to use your own program for a uid
 lookup then you would edit your request-key.conf so it looks similar to this:
 .PP
-create	nfs_idmap	uid:*	*	/some/other/program %k %d 600
+create	id_resolver	uid:*	*	/some/other/program %k %d 600
 .br
-create	nfs_idmap	*		*	/usr/sbin/nfsidmap %k %d 600
+create	id_resolver	*		*	/usr/sbin/nfsidmap %k %d 600
 .PP
 Notice that the new line was added above the line for the generic program.
 request-key will find the first matching line and run the corresponding program.
diff -Naur nfs-utils-1.2.4-old/utils/statd/rmtcall.c nfs-utils-1.2.4-new/utils/statd/rmtcall.c
--- nfs-utils-1.2.4-old/utils/statd/rmtcall.c	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/utils/statd/rmtcall.c	2011-08-03 20:04:46.000000000 -0700
@@ -85,7 +85,7 @@
 
 		memset(&sin, 0, sizeof(sin));
 		sin.sin_family = AF_INET;
-		sin.sin_addr.s_addr = INADDR_ANY;
+		sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 
 		if (bindresvport(sockfd, &sin) < 0) {
 			xlog(D_GENERAL, "%s: can't bind to reserved port",
diff -Naur nfs-utils-1.2.4-old/utils/statd/statd.man nfs-utils-1.2.4-new/utils/statd/statd.man
--- nfs-utils-1.2.4-old/utils/statd/statd.man	2011-06-30 06:00:42.000000000 -0700
+++ nfs-utils-1.2.4-new/utils/statd/statd.man	2011-08-03 20:04:46.000000000 -0700
@@ -219,7 +219,10 @@
 Specifies the port number used for RPC listener sockets.
 If this option is not specified,
 .B rpc.statd
-chooses a random ephemeral port for each listener socket.
+will try to consult
+.IR /etc/services ,
+if gets port succeed, set the same port for all listener socket,
+otherwise chooses a random ephemeral port for each listener socket.
 .IP
 This option can be used to fix the port value of its listeners when
 SM_NOTIFY requests must traverse a firewall between clients and servers.
