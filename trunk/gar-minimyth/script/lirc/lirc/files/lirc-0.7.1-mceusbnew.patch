diff -Naur lirc-0.7.1-old/configure lirc-0.7.1-new/configure
--- lirc-0.7.1-old/configure	2005-04-17 05:07:46.000000000 -0700
+++ lirc-0.7.1-new/configure	2005-07-03 10:12:49.000000000 -0700
@@ -203,7 +203,7 @@
                           irdeo, irdeo_remote, irman, irreal, it87,
                           knc_one, kworld, leadtek_0007, leadtek_0010,
                           leadtek_pvr2000, livedrive_midi,
-                          livedrive_seq, logitech, lptX, mceusb,
+                          livedrive_seq, logitech, lptX, mceusb, mceusbnew
                           mediafocusI, mouseremote, mouseremote_ps2,
                           mp3anywhere, packard_bell, parallel, pcmak,
                           pcmak_usb, pctv, pixelview_bt878,
@@ -8003,7 +8003,7 @@
   possible_drivers="${possible_drivers} (lirc_dev) (lirc_dev lirc_atiusb) \
 	(lirc_dev lirc_bt829) (lirc_dev lirc_gpio) (lirc_dev lirc_i2c) \
 	(lirc_dev lirc_igorplugusb) (lirc_dev lirc_imon) \
-	(lirc_dev lirc_it87) (lirc_dev lirc_mceusb) \
+	(lirc_dev lirc_it87) (lirc_dev lirc_mceusb) (lirc_dev lirc_mceusbnew) \
 	(lirc_dev lirc_parallel) (lirc_dev lirc_sasem) \
 	(lirc_dev lirc_serial) (lirc_dev lirc_sir) \
 	(lirc_dev lirc_streamzap)"
@@ -8581,6 +8581,8 @@
 		;;
 	lirc_dev-lirc_mceusb)
 		;;
+	lirc_dev-lirc_mceusbnew)
+		;;
 	lirc_dev-lirc_parallel)
 		;;
 	lirc_dev-lirc_sasem)
@@ -9006,6 +9008,11 @@
   lircd_conf="mceusb/lircd.conf.mceusb"
 fi
 
+if test "$driver" = "mceusbnew"; then
+  lirc_driver="lirc_dev lirc_mceusbnew"
+  lircd_conf="mceusbnew/lircd.conf.mceusbnew"
+fi
+
 if test "$driver" = "mediafocusI"; then
   lirc_driver="none"
   lircd_conf="technisat/lircd.conf.mediafocusI"
@@ -9693,6 +9700,7 @@
   drivers/lirc_imon/Makefile
   drivers/lirc_it87/Makefile
   drivers/lirc_mceusb/Makefile
+  drivers/lirc_mceusbnew/Makefile
   drivers/lirc_parallel/Makefile
   drivers/lirc_sasem/Makefile
   drivers/lirc_serial/Makefile
@@ -9862,6 +9870,7 @@
   drivers/lirc_imon/Makefile
   drivers/lirc_it87/Makefile
   drivers/lirc_mceusb/Makefile
+  drivers/lirc_mceusbnew/Makefile
   drivers/lirc_parallel/Makefile
   drivers/lirc_sasem/Makefile
   drivers/lirc_serial/Makefile
diff -Naur lirc-0.7.1-old/drivers/lirc_mceusbnew/lirc_mceusbnew.c lirc-0.7.1-new/drivers/lirc_mceusbnew/lirc_mceusbnew.c
--- lirc-0.7.1-old/drivers/lirc_mceusbnew/lirc_mceusbnew.c	1969-12-31 16:00:00.000000000 -0800
+++ lirc-0.7.1-new/drivers/lirc_mceusbnew/lirc_mceusbnew.c	2005-07-03 10:03:08.000000000 -0700
@@ -0,0 +1,621 @@
+/*
+ * LIRC driver for Philips eHome USB Infrared Transciever
+ * and the Microsoft MCE 2005 Remote Control
+ * 
+ * (C) by Martin A. Blatter <martin_a_blatter@yahoo.com>
+ *
+ * Derived from ATI USB driver by Paul Miller and the original
+ * MCE USB driver by Dan Corti
+ *
+ * This driver will only work reliably with kernel version 2.6.10
+ * or higher, probably because of differences in USB device enumeration
+ * in the kernel code. Device initialization fails most of the time
+ * with earlier kernel versions.
+ *
+ **********************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 5)
+#error "*******************************************************"
+#error "Sorry, this driver needs kernel version 2.6.5 or higher"
+#error "*******************************************************"
+#endif
+
+#include <linux/config.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/wait.h>
+
+#include "drivers/lirc.h"
+#include "drivers/kcompat.h"
+#include "drivers/lirc_dev/lirc_dev.h"
+
+#define DRIVER_VERSION		"0.22"
+#define DRIVER_AUTHOR		"Martin Blatter <martin_a_blatter@yahoo.com>"
+#define DRIVER_DESC		"USB remote driver for LIRC"
+#define DRIVER_NAME		"lirc_mceusbnew"
+
+#define USB_BUFLEN		16
+#define LIRCBUF_SIZE            256
+
+#define MCE_CODE_LENGTH		5
+#define MCE_TIME_UNIT           50
+#define MCE_PACKET_SIZE 	4
+#define MCE_PACKET_HEADER 	0x84
+
+/* module parameters */
+#ifdef CONFIG_USB_DEBUG
+	static int debug = 1;
+#else
+	static int debug = 0;
+#endif
+#define dprintk(fmt, args...)                                 \
+	do{                                                   \
+		if(debug) printk(KERN_DEBUG fmt, ## args);    \
+	}while(0)
+
+/* lock irctl structure */
+#define IRLOCK			down_interruptible(&ir->lock)
+#define IRUNLOCK		up(&ir->lock)
+
+/* general constants */
+#define SUCCESS			0
+#define SEND_FLAG_IN_PROGRESS	1
+#define SEND_FLAG_COMPLETE	2
+#define RECV_FLAG_IN_PROGRESS	3
+#define RECV_FLAG_COMPLETE	4
+
+#define PHILUSB_INBOUND		1
+#define PHILUSB_OUTBOUND	2
+
+#define VENDOR_PHILIPS		0x0471
+#define VENDOR_SMK              0x0609
+
+static struct usb_device_id usb_remote_table [] = {
+	{ USB_DEVICE(VENDOR_PHILIPS, 0x0815) },	/* Philips eHome Infrared Transciever */
+	{ USB_DEVICE(VENDOR_SMK, 0x031d) },	/* SMK/Toshiba G83C0004D410 */
+	{ }					/* Terminating entry */
+};
+
+/* data structure for each usb remote */
+struct irctl {
+
+	/* usb */
+	struct usb_device *usbdev;
+	struct urb *urb_in;
+	int devnum;
+
+	/* buffers and dma */
+	unsigned char *buf_in;
+	unsigned int len_in;
+	dma_addr_t dma_in;
+	dma_addr_t dma_out;
+
+	/* lirc */
+	struct lirc_plugin *p;
+	lirc_t lircdata[LIRCBUF_SIZE];
+	int lirccnt;
+	int connected;
+	int last_space;
+
+	/* handle sending (init strings) */
+	int send_flags;
+	wait_queue_head_t wait_out;
+   
+	struct semaphore lock;
+};
+
+/* init strings */
+static char init1[] = {0x00, 0xff, 0xaa, 0xff, 0x0b};
+static char init2[] = {0xff, 0x18};
+
+
+static void usb_remote_printdata(struct irctl *ir, char *buf, int len)
+{
+	char codes[USB_BUFLEN*3 + 1];
+	int i;
+
+	if (len <= 0)
+		return;
+
+	for (i = 0; i < len && i < USB_BUFLEN; i++) {
+		snprintf(codes+i*3, 4, "%02x ", buf[i] & 0xFF);
+	}
+	printk(DRIVER_NAME "[%d]: data received %s (length=%d)\n",
+		ir->devnum, codes, len);
+}
+
+static void usb_async_callback(struct urb *urb, struct pt_regs *regs)
+{
+	struct irctl *ir;
+	int len;
+
+	if (!urb)
+		return;
+	
+	if ((ir = urb->context)) {
+		len = urb->actual_length;
+
+		dprintk(DRIVER_NAME "[%d]: callback called (status=%d len=%d)\n",ir->devnum,urb->status,len);
+
+		if (debug)
+			usb_remote_printdata(ir,urb->transfer_buffer,len);
+	}
+
+//	usb_unlink_urb(urb);
+//	usb_free_urb(urb);
+//	kfree(urb->transfer_buffer);
+}
+
+
+/* request incoming or send outgoing usb packet - used to initialize remote */
+static void request_packet_async(struct irctl *ir, struct usb_endpoint_descriptor *ep, unsigned char* data, int size, int urb_type)
+{
+	int res;
+	struct urb *async_urb;
+	unsigned char *async_buf;
+
+	if (urb_type) {
+	    	if ((async_urb = usb_alloc_urb(0, GFP_KERNEL))) {
+			/* alloc buffer */
+			if ((async_buf = kmalloc(size, GFP_KERNEL))) {
+				if (urb_type==PHILUSB_OUTBOUND) {
+					/* outbound data */
+					usb_fill_int_urb(async_urb, ir->usbdev, usb_sndintpipe(ir->usbdev, ep->bEndpointAddress), async_buf,
+					size, usb_async_callback, ir, ep->bInterval);
+
+					memcpy(async_buf, data, size);
+					async_urb->transfer_flags=URB_ASYNC_UNLINK;
+				}
+				else {
+					/* inbound data */
+					usb_fill_int_urb(async_urb, ir->usbdev, usb_rcvintpipe(ir->usbdev, ep->bEndpointAddress), async_buf,
+					size, usb_async_callback, ir, ep->bInterval);
+
+					async_urb->transfer_flags=URB_ASYNC_UNLINK;
+//					async_urb->transfer_flags=URB_SHORT_NOT_OK;
+				}
+			}
+			else {
+				usb_free_urb(async_urb);
+				return;
+			}
+		}
+	}
+	else {
+		/* standard request */
+		async_urb=ir->urb_in;
+		ir->send_flags = RECV_FLAG_IN_PROGRESS;
+	}
+	dprintk(DRIVER_NAME "[%d]: receive request called (size=%#x)\n", ir->devnum, size);
+
+	async_urb->transfer_buffer_length = size;
+	async_urb->dev = ir->usbdev;
+
+	if ((res=usb_submit_urb(async_urb, SLAB_ATOMIC))) {
+	    dprintk(DRIVER_NAME "[%d]: receive request FAILED! (res=%d)\n", ir->devnum, res);
+	    return;
+	}
+	dprintk(DRIVER_NAME "[%d]: receive request complete (res=%d)\n", ir->devnum, res);
+}
+
+static int unregister_from_lirc(struct irctl *ir)
+{
+	struct lirc_plugin *p = ir->p;
+	int devnum;
+	int rtn;
+
+	devnum = ir->devnum;
+	dprintk(DRIVER_NAME "[%d]: unregister from lirc called\n", devnum);
+
+	if ((rtn = lirc_unregister_plugin(p->minor)) > 0) {
+		printk(DRIVER_NAME "[%d]: error in lirc_unregister minor: %d\n"
+			"Trying again...\n", devnum, p->minor);
+		if (rtn == -EBUSY) {
+			printk(DRIVER_NAME
+				"[%d]: device is opened, will unregister"
+				" on close\n", devnum);
+			return -EAGAIN;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ);
+
+		if ((rtn = lirc_unregister_plugin(p->minor)) > 0) {
+			printk(DRIVER_NAME "[%d]: lirc_unregister failed\n",
+			devnum);
+		}
+	}
+
+	if (rtn != SUCCESS) {
+		printk(DRIVER_NAME "[%d]: didn't free resources\n", devnum);
+		return -EAGAIN;
+	}
+
+	printk(DRIVER_NAME "[%d]: usb remote disconnected\n", devnum);
+
+	lirc_buffer_free(p->rbuf);
+	kfree(p->rbuf);
+	kfree(p);
+	kfree(ir);
+	return SUCCESS;
+}
+
+static int set_use_inc(void *data)
+{
+	struct irctl *ir = data;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_inc called with no context\n");
+		return -EIO;
+	}
+	dprintk(DRIVER_NAME "[%d]: set use inc\n", ir->devnum);
+
+	MOD_INC_USE_COUNT;
+
+	if (!ir->connected) {
+		if (!ir->usbdev)
+			return -ENOENT;
+		ir->connected = 1;
+	}
+
+	return SUCCESS;
+}
+
+static void set_use_dec(void *data)
+{
+	struct irctl *ir = data;
+
+	if (!ir) {
+		printk(DRIVER_NAME "[?]: set_use_dec called with no context\n");
+		return;
+	}
+	dprintk(DRIVER_NAME "[%d]: set use dec\n", ir->devnum);
+
+	if (ir->connected) {
+		IRLOCK;
+		ir->connected = 0;
+		IRUNLOCK;
+	}
+	MOD_DEC_USE_COUNT;
+}
+
+static void send_packet_to_lirc(struct irctl *ir)
+{
+    if ( ir->lirccnt ) {
+	lirc_buffer_write_n(ir->p->rbuf,(unsigned char *) ir->lircdata,ir->lirccnt);
+
+	wake_up(&ir->p->rbuf->wait_poll);
+	ir->lirccnt=0;
+    }
+}
+
+static void usb_remote_recv(struct urb *urb, struct pt_regs *regs)
+{
+	struct irctl *ir;
+	int len;
+
+	if (!urb)
+		return;
+
+	if (!(ir = urb->context)) {
+		urb->transfer_flags |= URB_ASYNC_UNLINK;
+		usb_unlink_urb(urb);
+		return;
+	}
+
+	len = urb->actual_length;
+	if (debug)
+		usb_remote_printdata(ir,urb->transfer_buffer,len);
+
+	if (ir->send_flags==RECV_FLAG_IN_PROGRESS) {
+	  	ir->send_flags = SEND_FLAG_COMPLETE;
+		dprintk(DRIVER_NAME "[%d]: setup answer received %d bytes\n",ir->devnum,len);
+	}
+
+	switch (urb->status) {
+
+	/* success */
+	case SUCCESS:
+
+	    if ((len==MCE_CODE_LENGTH)) {
+
+		if ((ir->buf_in[0]==MCE_PACKET_HEADER)) {
+
+		    int i,keycode,pulse;
+			
+			/* buffer exhausted? */
+			if (ir->lirccnt>(LIRCBUF_SIZE-MCE_CODE_LENGTH))
+				send_packet_to_lirc(ir);
+
+		    for(i=0;i<MCE_PACKET_SIZE;i++) {
+			pulse = 0;
+			keycode=(signed char)ir->buf_in[i+1];
+			if ( keycode < 0 ) {
+			    pulse = 1;
+			    keycode += 128;
+			}
+			keycode *= MCE_TIME_UNIT;
+
+			if ( pulse ) {
+			    if ( ir->last_space ) {
+				ir->lircdata[ir->lirccnt++] = ir->last_space;
+				ir->last_space = 0;
+				ir->lircdata[ir->lirccnt] = 0;
+			    }
+			    ir->lircdata[ir->lirccnt] += keycode;
+			    ir->lircdata[ir->lirccnt] |= PULSE_BIT;
+			}
+			else {
+			    if ( ir->lircdata[ir->lirccnt] &&
+				!ir->last_space ) {
+				ir->lirccnt++;
+			    }
+			    ir->last_space += keycode;
+			}
+		    }
+		}
+	    }
+	    else {
+		/* transmission finished (long packet) */
+		send_packet_to_lirc(ir);
+	    }
+	    
+	    break;
+
+	/* unlink */
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		urb->transfer_flags |= URB_ASYNC_UNLINK;
+		usb_unlink_urb(urb);
+		return;
+
+	case -EPIPE:
+	default:
+		break;
+	}
+
+	/* resubmit urb */
+	usb_submit_urb(urb, SLAB_ATOMIC);
+}
+
+static int usb_remote_probe(struct usb_interface *intf,
+				const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct usb_host_interface *idesc;
+	struct usb_endpoint_descriptor *ep=NULL, *ep_in=NULL, *ep_out=NULL;
+	struct usb_host_config *config;
+	struct irctl *ir = NULL;
+	struct lirc_plugin *plugin = NULL;
+	struct lirc_buffer *rbuf = NULL;
+	int devnum, pipe, maxp;
+	int minor = 0;
+	int i;
+	char buf[63], name[128]="";
+	int mem_failure = 0;
+
+	dprintk(DRIVER_NAME ": usb probe called\n");
+
+	config=dev->actconfig;
+
+	idesc = intf->cur_altsetting;
+
+	/* step through the endpoints to find first bulk in and out endpoint */
+	for (i = 0; i < idesc->desc.bNumEndpoints; ++i) {
+		ep = &idesc->endpoint[i].desc;
+
+		if ((ep_in == NULL)
+			&& ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
+			&& ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK)) {
+
+			dprintk(DRIVER_NAME ": acceptable inbound endpoint found\n");
+			ep_in = ep;
+			ep_in->bmAttributes=USB_ENDPOINT_XFER_INT;
+			ep_in->bInterval=1;
+		}
+
+		if ((ep_out == NULL)
+			&& ((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
+			&& ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK)) {
+
+			dprintk(DRIVER_NAME ": acceptable outbound endpoint found\n");
+			ep_out = ep;
+			ep_out->bmAttributes=USB_ENDPOINT_XFER_INT;
+			ep_out->bInterval=1;
+		}
+	}
+	if (ep_in == NULL) {
+		dprintk(DRIVER_NAME ": inbound and/or endpoint not found\n");
+		return -ENODEV;
+	}
+
+	devnum = dev->devnum;
+	pipe = usb_rcvintpipe(dev, ep_in->bEndpointAddress);
+	maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));
+
+	/* allocate kernel memory */
+	mem_failure = 0;
+	if (!(ir = kmalloc(sizeof(struct irctl), GFP_KERNEL))) {
+		mem_failure = 1;
+	} else {
+		memset(ir, 0, sizeof(struct irctl));
+
+		if (!(plugin = kmalloc(sizeof(struct lirc_plugin), GFP_KERNEL))) {
+			mem_failure = 2;
+		} else if (!(rbuf = kmalloc(sizeof(struct lirc_buffer), GFP_KERNEL))) {
+			mem_failure = 3;
+		} else if (lirc_buffer_init(rbuf, sizeof(lirc_t), LIRCBUF_SIZE)) {
+			mem_failure = 4;
+		} else if (!(ir->buf_in = usb_buffer_alloc(dev, maxp, SLAB_ATOMIC, &ir->dma_in))) {
+			mem_failure = 5;
+		} else if (!(ir->urb_in = usb_alloc_urb(0, GFP_KERNEL))) {
+			mem_failure = 7;
+		} else {
+
+			memset(plugin, 0, sizeof(struct lirc_plugin));
+
+			strcpy(plugin->name, DRIVER_NAME " ");
+			plugin->minor = -1;
+			plugin->features = LIRC_CAN_REC_MODE2;
+			plugin->data = ir;
+			plugin->rbuf = rbuf;
+			plugin->set_use_inc = &set_use_inc;
+			plugin->set_use_dec = &set_use_dec;
+			plugin->code_length = sizeof(lirc_t) * 8;
+			plugin->ioctl = NULL;
+
+			init_MUTEX(&ir->lock);
+			init_waitqueue_head(&ir->wait_out);
+
+			if ((minor = lirc_register_plugin(plugin)) < 0) {
+				mem_failure = 9;
+			}
+		}
+	}
+
+	/* free allocated memory incase of failure */
+	switch (mem_failure) {
+	case 9:
+		lirc_buffer_free(rbuf);
+	case 7:
+		usb_free_urb(ir->urb_in);
+	case 5:
+		usb_buffer_free(dev, maxp, ir->buf_in, ir->dma_in);
+	case 4:
+		kfree(rbuf);
+	case 3:
+		kfree(plugin);
+	case 2:
+		kfree(ir);
+	case 1:
+		printk(DRIVER_NAME "[%d]: out of memory (code=%d)\n",
+			devnum, mem_failure);
+		return -ENOMEM;
+	}
+
+	plugin->minor = minor;
+	ir->p = plugin;
+	ir->devnum = devnum;
+	ir->usbdev = dev;
+	ir->len_in = maxp;
+	ir->last_space = PULSE_MASK;
+	ir->connected = 0;
+
+	if (dev->descriptor.iManufacturer
+		&& usb_string(dev, dev->descriptor.iManufacturer, buf, 63) > 0)
+		strncpy(name, buf, 128);
+	if (dev->descriptor.iProduct
+		&& usb_string(dev, dev->descriptor.iProduct, buf, 63) > 0)
+		snprintf(name, 128, "%s %s", name, buf);
+	printk(DRIVER_NAME "[%d]: %s on usb%d:%d\n", devnum, name,
+	       dev->bus->busnum, devnum);
+
+	/* inbound data */
+	usb_fill_int_urb(ir->urb_in, dev, pipe, ir->buf_in,
+		maxp, usb_remote_recv, ir, ep_in->bInterval);
+
+	/* initialize device */
+	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
+	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
+	request_packet_async( ir, ep_out, init1, sizeof(init1), PHILUSB_OUTBOUND );
+	request_packet_async( ir, ep_in, NULL, maxp, PHILUSB_INBOUND );
+	request_packet_async( ir, ep_out, init2, sizeof(init2), PHILUSB_OUTBOUND );
+	request_packet_async( ir, ep_in, NULL, maxp, 0);
+
+	usb_set_intfdata(intf, ir);
+	return SUCCESS;
+}
+
+
+static void usb_remote_disconnect(struct usb_interface *intf)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct irctl *ir = usb_get_intfdata(intf);
+	usb_set_intfdata(intf, NULL);
+
+	if (!ir || !ir->p)
+		return;
+
+	ir->usbdev = NULL;
+	wake_up_all(&ir->wait_out);
+
+	IRLOCK;
+	usb_unlink_urb(ir->urb_in);
+	usb_free_urb(ir->urb_in);
+
+	usb_buffer_free(dev, ir->len_in, ir->buf_in, ir->dma_in);
+	IRUNLOCK;
+
+	unregister_from_lirc(ir);
+}
+
+static struct usb_driver usb_remote_driver = {
+	.owner =	THIS_MODULE,
+	.name =		DRIVER_NAME,
+	.probe =	usb_remote_probe,
+	.disconnect =	usb_remote_disconnect,
+	.id_table =	usb_remote_table
+};
+
+static int __init usb_remote_init(void)
+{
+	int i;
+
+	printk("\n" DRIVER_NAME ": " DRIVER_DESC " v" DRIVER_VERSION "\n");
+	printk(DRIVER_NAME ": " DRIVER_AUTHOR "\n");
+	dprintk(DRIVER_NAME ": debug mode enabled\n");
+
+	request_module("lirc_dev");
+
+	if ((i = usb_register(&usb_remote_driver)) < 0) {
+		printk(DRIVER_NAME ": usb register failed, result = %d\n", i);
+		return -ENODEV;
+	}
+
+	return SUCCESS;
+}
+
+static void __exit usb_remote_exit(void)
+{
+	usb_deregister(&usb_remote_driver);
+}
+
+module_init(usb_remote_init);
+module_exit(usb_remote_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(usb, usb_remote_table);
+
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+EXPORT_NO_SYMBOLS;
diff -Naur lirc-0.7.1-old/drivers/lirc_mceusbnew/Makefile.am lirc-0.7.1-new/drivers/lirc_mceusbnew/Makefile.am
--- lirc-0.7.1-old/drivers/lirc_mceusbnew/Makefile.am	1969-12-31 16:00:00.000000000 -0800
+++ lirc-0.7.1-new/drivers/lirc_mceusbnew/Makefile.am	2005-07-03 10:02:53.000000000 -0700
@@ -0,0 +1,13 @@
+## $Id: Makefile.am,v 1.3 2004/04/25 16:29:26 lirc Exp $
+
+## Process this file with automake to produce Makefile.in
+
+## this is so that Automake includes the C compiling definitions, and
+## includes the source files in the distribution.
+EXTRA_PROGRAMS = automake_dummy
+automake_dummy_SOURCES = lirc_mceusbnew.c
+
+## there is no *just* object file support in automake.  This is close enough
+module_DATA = lirc_mceusbnew.o
+
+include ../Makefile.common
diff -Naur lirc-0.7.1-old/drivers/lirc_mceusbnew/Makefile.in lirc-0.7.1-new/drivers/lirc_mceusbnew/Makefile.in
--- lirc-0.7.1-old/drivers/lirc_mceusbnew/Makefile.in	1969-12-31 16:00:00.000000000 -0800
+++ lirc-0.7.1-new/drivers/lirc_mceusbnew/Makefile.in	2005-07-03 10:02:41.000000000 -0700
@@ -0,0 +1,394 @@
+# Makefile.in generated automatically by automake 1.5 from Makefile.am.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+# $Id: Makefile.common,v 5.1 2004/04/27 16:55:24 lirc Exp $
+
+# where the kernel sources are located
+
+SHELL = @SHELL@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+sbindir = @sbindir@
+libexecdir = @libexecdir@
+datadir = @datadir@
+sysconfdir = @sysconfdir@
+sharedstatedir = @sharedstatedir@
+localstatedir = @localstatedir@
+libdir = @libdir@
+infodir = @infodir@
+mandir = @mandir@
+includedir = @includedir@
+oldincludedir = /usr/include
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+
+ACLOCAL = @ACLOCAL@
+AUTOCONF = @AUTOCONF@
+AUTOMAKE = @AUTOMAKE@
+AUTOHEADER = @AUTOHEADER@
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = @program_transform_name@
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_alias = @host_alias@
+host_triplet = @host@
+AMTAR = @AMTAR@
+AS = @AS@
+AWK = @AWK@
+CC = @CC@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+ECHO = @ECHO@
+EXEEXT = @EXEEXT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LIBTOOL = @LIBTOOL@
+LIBUSB_CONFIG = @LIBUSB_CONFIG@
+LN_S = @LN_S@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+RANLIB = @RANLIB@
+STRIP = @STRIP@
+VERSION = @VERSION@
+X_CFLAGS = @X_CFLAGS@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_LIBS = @X_LIBS@
+X_PRE_LIBS = @X_PRE_LIBS@
+ac_pkss_mktemp = @ac_pkss_mktemp@
+alsa_lib = @alsa_lib@
+am__include = @am__include@
+am__quote = @am__quote@
+atilibusb_lib = @atilibusb_lib@
+caraca_lib = @caraca_lib@
+daemon = @daemon@
+depmod = @depmod@
+devdir = @devdir@
+driver = @driver@
+forkpty = @forkpty@
+hw_module = @hw_module@
+install_sh = @install_sh@
+irman_lib = @irman_lib@
+irtty = @irtty@
+kernelcc = @kernelcc@
+kerneldir = @kerneldir@
+kernelext = @kernelext@
+lirc_driver = @lirc_driver@
+lirc_major = @lirc_major@
+lircd_conf = @lircd_conf@
+lircmd_conf = @lircmd_conf@
+maintmode_daemons_extra = @maintmode_daemons_extra@
+mkfifo = @mkfifo@
+mknod = @mknod@
+moduledir = @moduledir@
+portaudio_lib = @portaudio_lib@
+vga_progs = @vga_progs@
+x_progs = @x_progs@
+
+EXTRA_PROGRAMS = automake_dummy
+automake_dummy_SOURCES = lirc_mceusbnew.c
+
+module_DATA = lirc_mceusbnew.o
+
+KERNEL_LOCATION = @kerneldir@
+
+LIRC_DEVDIR = $(shell pwd)
+
+# some magic for using linux kernel settings
+# when compiling module(s)
+KBUILD_VERBOSE = 1
+LIRC_EXTRA_CFLAGS = -DIRCTL_DEV_MAJOR=$(lirc_major) -DEXPORT_SYMTAB $(DEFS) \
+		$(DEFAULT_INCLUDES) -I $(LIRC_DEVDIR)/../.. \
+		-I $(KERNEL_LOCATION)/include/
+
+
+CLEANFILES = $(module_DATA) .$(module_DATA).flags $(module_DATA:.o=.mod.c) $(module_DATA:.o=.@kernelext@) *~
+subdir = drivers/lirc_mceusbnew
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+EXTRA_PROGRAMS = automake_dummy$(EXEEXT)
+am_automake_dummy_OBJECTS = lirc_mceusbnew.$(OBJEXT)
+automake_dummy_OBJECTS = $(am_automake_dummy_OBJECTS)
+automake_dummy_LDADD = $(LDADD)
+automake_dummy_DEPENDENCIES =
+automake_dummy_LDFLAGS =
+
+DEFS = @DEFS@
+DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
+CPPFLAGS = @CPPFLAGS@
+LDFLAGS = @LDFLAGS@
+LIBS = @LIBS@
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+@AMDEP_TRUE@DEP_FILES = $(DEPDIR)/lirc_mceusbnew.Po
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) \
+	$(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+CFLAGS = @CFLAGS@
+DIST_SOURCES = $(automake_dummy_SOURCES)
+DATA = $(module_DATA)
+
+DIST_COMMON = Makefile.am Makefile.in
+SOURCES = $(automake_dummy_SOURCES)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+$(srcdir)/Makefile.in:  Makefile.am $(srcdir)/../Makefile.common $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  drivers/lirc_mceusbnew/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && \
+	  CONFIG_HEADERS= CONFIG_LINKS= \
+	  CONFIG_FILES=$(subdir)/$@ $(SHELL) ./config.status
+automake_dummy$(EXEEXT): $(automake_dummy_OBJECTS) $(automake_dummy_DEPENDENCIES) 
+	@rm -f automake_dummy$(EXEEXT)
+	$(LINK) $(automake_dummy_LDFLAGS) $(automake_dummy_OBJECTS) $(automake_dummy_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT) core *.core
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/lirc_mceusbnew.Po@am__quote@
+
+distclean-depend:
+	-rm -rf $(DEPDIR)
+
+.c.o:
+@AMDEP_TRUE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+	$(COMPILE) -c `test -f $< || echo '$(srcdir)/'`$<
+
+.c.obj:
+@AMDEP_TRUE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+	$(COMPILE) -c `cygpath -w $<`
+
+.c.lo:
+@AMDEP_TRUE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Plo' tmpdepfile='$(DEPDIR)/$*.TPlo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+	$(LTCOMPILE) -c -o $@ `test -f $< || echo '$(srcdir)/'`$<
+CCDEPMODE = @CCDEPMODE@
+uninstall-info-am:
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique $(LISP)
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || etags $(ETAGS_ARGS) $$tags  $$unique $(LISP)
+
+GTAGS:
+	here=`CDPATH=: && cd $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
+
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@for file in $(DISTFILES); do \
+	  if test -f $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    $(mkinstalldirs) "$(distdir)/$$dir"; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    cp -pR $$d/$$file $(distdir) \
+	    || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(DATA)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(moduledir)
+
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES) stamp-h stamp-h[0-9]*
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-compile distclean-depend \
+	distclean-generic distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-data-local install-moduleDATA
+
+install-exec-am: install-exec-local
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+uninstall-am: uninstall-info-am uninstall-local uninstall-moduleDATA
+
+.PHONY: GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool distclean distclean-compile distclean-depend \
+	distclean-generic distclean-libtool distclean-tags distdir dvi \
+	dvi-am info info-am install install-am install-data \
+	install-data-am install-data-local install-exec install-exec-am \
+	install-exec-local install-info install-info-am install-man \
+	install-moduleDATA install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool tags uninstall uninstall-am \
+	uninstall-info-am uninstall-local uninstall-moduleDATA
+
+export LIRC_EXTRA_CFLAGS KERNEL_LOCATION module_DATA
+
+$(module_DATA): $(automake_dummy_SOURCES) $(top_srcdir)/config.h ../lirc.h
+	mv Makefile Makefile.automake
+	cp ../Makefile.kernel Makefile
+	$(MAKE) -C $(KERNEL_LOCATION) SUBDIRS=$(LIRC_DEVDIR) modules \
+		KBUILD_VERBOSE=$(KBUILD_VERBOSE)
+	mv Makefile.automake Makefile
+
+install-moduleDATA: $(module_DATA)
+	$(mkinstalldirs) $(DESTDIR)$(moduledir)
+	@list='$(module_DATA:.o=.@kernelext@)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(INSTALL_DATA) $$d$$p $(DESTDIR)$(moduledir)/$$f"; \
+	  $(INSTALL_DATA) $$d$$p $(DESTDIR)$(moduledir)/$$f; \
+	done
+
+uninstall-moduleDATA:
+	@list='$(module_DATA:.o=.@kernelext@)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(moduledir)/$$f"; \
+	  rm -f $(DESTDIR)$(moduledir)/$$f; \
+	done
+
+@SANDBOXED_FALSE@install-exec-local: mkdev
+@SANDBOXED_FALSE@uninstall-local: rmdev
+
+mkdev:
+	test -c $(DESTDIR)$(devdir)/lirc || ($(mkinstalldirs) $(DESTDIR)$(devdir) && @mknod@ $(DESTDIR)$(devdir)/lirc c @lirc_major@ 0)
+
+rmdev:
+	-test -c $(DESTDIR)$(devdir)/lirc && $(RM) $(DESTDIR)$(devdir)/lirc
+
+@SANDBOXED_FALSE@install-data-local: install-moduleDATA
+@SANDBOXED_FALSE@	-@depmod@ -a
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur lirc-0.7.1-old/drivers/Makefile.am lirc-0.7.1-new/drivers/Makefile.am
--- lirc-0.7.1-old/drivers/Makefile.am	2005-02-12 06:20:23.000000000 -0800
+++ lirc-0.7.1-new/drivers/Makefile.am	2005-07-03 10:09:58.000000000 -0700
@@ -8,7 +8,7 @@
 EXTRA_DIST = lirc.h kcompat.h Makefile.kernel Makefile.common
 
 DIST_SUBDIRS = lirc_atiusb lirc_bt829 lirc_dev lirc_gpio lirc_i2c \
-	lirc_igorplugusb lirc_imon lirc_it87 lirc_mceusb lirc_parallel \
+	lirc_igorplugusb lirc_imon lirc_it87 lirc_mceusb lirc_mceusbnew lirc_parallel \
 	lirc_sasem lirc_serial lirc_sir lirc_streamzap
 
 SUBDIRS = @lirc_driver@
diff -Naur lirc-0.7.1-old/drivers/Makefile.in lirc-0.7.1-new/drivers/Makefile.in
--- lirc-0.7.1-old/drivers/Makefile.in	2005-04-17 05:07:44.000000000 -0700
+++ lirc-0.7.1-new/drivers/Makefile.in	2005-07-03 10:09:46.000000000 -0700
@@ -112,7 +112,7 @@
 EXTRA_DIST = lirc.h kcompat.h Makefile.kernel Makefile.common
 
 DIST_SUBDIRS = lirc_atiusb lirc_bt829 lirc_dev lirc_gpio lirc_i2c \
-	lirc_igorplugusb lirc_imon lirc_it87 lirc_mceusb lirc_parallel \
+	lirc_igorplugusb lirc_imon lirc_it87 lirc_mceusb lirc_mceusbnew lirc_parallel \
 	lirc_sasem lirc_serial lirc_sir lirc_streamzap
 
 
diff -Naur lirc-0.7.1-old/remotes/mceusbnew/lircd.conf.mceusbnew lirc-0.7.1-new/remotes/mceusbnew/lircd.conf.mceusbnew
--- lirc-0.7.1-old/remotes/mceusbnew/lircd.conf.mceusbnew	1969-12-31 16:00:00.000000000 -0800
+++ lirc-0.7.1-new/remotes/mceusbnew/lircd.conf.mceusbnew	2005-07-03 10:06:30.000000000 -0700
@@ -0,0 +1,96 @@
+#
+# RC-6 config file
+#
+# source: http://home.hccnet.nl/m.majoor/projects__remote_control.htm
+#         http://home.hccnet.nl/m.majoor/pronto.pdf
+#
+# used by: Philips
+#
+#########
+#
+# Philips Media Center Edition remote control
+# For use with the USB MCE ir receiver
+#
+# Dan Conti  dconti|acm.wwu.edu
+# Martin A. Blatter  mblatter@gmail.com (additions for european version)
+#
+# Radio, Print, RecTV are only available on the HP Media Center remote control
+#
+
+begin remote
+
+  name mceusbnew
+  bits           16
+  flags RC6|CONST_LENGTH
+  eps            30
+  aeps          100
+
+  header       2667   889
+  one           444   444
+  zero          444   444
+  pre_data_bits 21
+  pre_data      0x37FF0
+  gap          105000
+  toggle_bit     22
+  rc6_mask     0x100000000
+
+
+      begin codes
+
+# starts at a1
+        Blue     0x00007ba1
+        Yellow   0x00007ba2
+        Green    0x00007ba3
+        Red      0x00007ba4
+        Teletext 0x00007ba5
+        Radio    0x00007baf
+        Print    0x00007bb1
+        Videos   0x00007bb5
+        Pictures 0x00007bb6
+        RecTV    0x00007bb7
+        Music    0x00007bb8
+        TV       0x00007bb9
+# no ba - d8
+        Guide    0x00007bd9
+        LiveTV   0x00007bda
+        DVD      0x00007bdb
+        Back     0x00007bdc
+        OK       0x00007bdd
+        Right    0x00007bde
+        Left     0x00007bdf
+        Down     0x00007be0
+        Up       0x00007be1
+# no e2,e3
+        Star     0x00007be2
+        Hash     0x00007be3
+        Replay   0x00007be4
+        Skip     0x00007be5
+        Stop     0x00007be6
+        Pause    0x00007be7
+        Record   0x00007be8
+        Play     0x00007be9
+        Rewind   0x00007bea
+        Forward  0x00007beb
+        ChanDown 0x00007bec
+        ChanUp   0x00007bed
+        VolDown  0x00007bee
+        VolUp    0x00007bef
+        More     0x00007bf0
+        Mute     0x00007bf1
+        Home     0x00007bf2
+        Power    0x00007bf3
+        Enter    0x00007bf4
+        Clear    0x00007bf5
+        Nine     0x00007bf6
+        Eight    0x00007bf7
+        Seven    0x00007bf8
+        Six      0x00007bf9
+        Five     0x00007bfa
+        Four     0x00007bfb
+        Three    0x00007bfc
+        Two      0x00007bfd
+        One      0x00007bfe
+        Zero     0x00007bff
+      end codes
+
+end remote
diff -Naur lirc-0.7.1-old/setup.data lirc-0.7.1-new/setup.data
--- lirc-0.7.1-old/setup.data	2005-04-17 04:39:24.000000000 -0700
+++ lirc-0.7.1-new/setup.data	2005-07-03 10:07:45.000000000 -0700
@@ -116,6 +116,7 @@
 	imon_rsc: "Soundgraph iMON RSC"
 	streamzap: "Streamzap PC Remote"
 	mceusb: "Windows Media Center Remotes"
+	mceusbnew: "New Windows Media Center Remotes"
 
 param_type: \
 	act200l \
@@ -193,6 +194,7 @@
 	livedrive_midi \
 	livedrive_seq \
 	mceusb \
+	mceusbnew \
 	mediafocusI \
 	mouseremote_ps2 \
 	none \
@@ -247,6 +249,7 @@
 	livedrive_midi \
 	livedrive_seq \
 	mceusb \
+	mceusbnew \
 	mediafocusI \
 	mouseremote_ps2 \
 	none \
diff -Naur lirc-0.7.1-old/setup-driver.sh lirc-0.7.1-new/setup-driver.sh
--- lirc-0.7.1-old/setup-driver.sh	2005-04-17 05:07:48.000000000 -0700
+++ lirc-0.7.1-new/setup-driver.sh	2005-07-03 10:08:09.000000000 -0700
@@ -266,6 +266,7 @@
                 elif test "$1" = "b"; then LIRC_DRIVER=imon_rsc;	DRIVER_PARAMETER=none; DRIVER_PARAM_TYPE=none;
                 elif test "$1" = "c"; then LIRC_DRIVER=streamzap;	DRIVER_PARAMETER=none; DRIVER_PARAM_TYPE=none;
                 elif test "$1" = "d"; then LIRC_DRIVER=mceusb;		DRIVER_PARAMETER=none; DRIVER_PARAM_TYPE=none;
+                elif test "$1" = "d"; then LIRC_DRIVER=mceusbnew;	DRIVER_PARAMETER=none; DRIVER_PARAM_TYPE=none;
                 fi
                 }
                 else
