diff -Naur lirc-0.8.5-old/daemons/lircmd.c lirc-0.8.5-new/daemons/lircmd.c
--- lirc-0.8.5-old/daemons/lircmd.c	2006-10-09 00:22:14.000000000 -0700
+++ lirc-0.8.5-new/daemons/lircmd.c	2009-06-03 20:39:25.000000000 -0700
@@ -32,6 +32,12 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 
+#if defined(__linux__)
+#include <linux/input.h>
+#include <linux/uinput.h>
+#include "input_map.h"
+#endif
+
 #define CLICK_DELAY 50000 /* usecs */
 #define PACKET_SIZE 256
 #define WHITE_SPACE " \t"
@@ -49,6 +55,9 @@
 #define MAP_BUTTON2 1
 #define MAP_BUTTON3 2
 
+static int uinputfd = -1;
+static int useuinput = 0;
+
 inline int map_buttons(int b)
 {
 	switch(b)
@@ -167,9 +176,21 @@
 	
 	shutdown(lircd,2);
 	close(lircd);
-	shutdown(lircm,2);
-	close(lircm);
+
+	if(uinputfd != -1)
+	{
+		shutdown(lircm,2);
+		close(lircm);
+		lircm = -1;
+	}
 	
+	if(uinputfd != -1)
+	{
+		ioctl(uinputfd, UI_DEV_DESTROY);
+		close(uinputfd);
+		uinputfd = -1;
+	}
+
 	signal(sig,SIG_DFL);
 	raise(sig);
 }
@@ -217,6 +238,89 @@
 }
 #endif /* DAEMONIZE */
 
+int setup_uinputfd(const char *name)
+{
+#if defined(__linux__)
+	int fd;
+	int key;
+	struct uinput_user_dev dev;
+	
+	/* Open a uinput device. */
+	fd = open("/dev/input/uinput", O_RDWR);
+	if(fd == -1)
+	{
+		fd = open("/dev/uinput", O_RDWR);
+		if(fd == -1)
+		{
+			fd = open("/dev/misc/uinput", O_RDWR);
+			if(fd == -1)
+			{
+				fprintf(stderr, "could not open %s\n",
+					"uinput");
+				perror(NULL);
+				return -1;
+			}
+		}
+	}
+	memset(&dev, 0, sizeof(dev));
+	strncpy(dev.name, name, sizeof(dev.name));
+	dev.name[sizeof(dev.name)-1] = 0;
+	if(write(fd, &dev, sizeof(dev)) != sizeof(dev))
+	{
+		goto setup_error;
+	}
+
+	/* Configure support for the left, right and middle mouse buttons. */
+	if( (ioctl(fd, UI_SET_EVBIT , EV_KEY    ) != 0) ||
+	    (ioctl(fd, UI_SET_KEYBIT, BTN_LEFT  ) != 0) ||
+	    (ioctl(fd, UI_SET_KEYBIT, BTN_MIDDLE) != 0) ||
+	    (ioctl(fd, UI_SET_KEYBIT, BTN_RIGHT ) != 0) )
+	{
+		goto setup_error;
+	}
+
+	/* Configure support for the relative mouse location and scroll wheel */
+	if( (ioctl(fd, UI_SET_EVBIT , EV_REL   ) != 0) ||
+	    (ioctl(fd, UI_SET_RELBIT, REL_X    ) != 0) ||
+	    (ioctl(fd, UI_SET_RELBIT, REL_Y    ) != 0) ||
+	    (ioctl(fd, UI_SET_RELBIT, REL_WHEEL) != 0) )
+	{
+		goto setup_error;
+	}
+
+	/* Register the device with the input subsystem. */
+	if(ioctl(fd, UI_DEV_CREATE) != 0)
+	{
+		goto setup_error;
+	}
+	return fd;
+	
+ setup_error:
+	fprintf(stderr, "could not setup %s\n", "uinput");
+	perror(NULL);
+	close(fd);
+#endif
+	return -1;
+}
+
+int write_uinput(__u16 type, __u16 code, __s32 value)
+{
+#ifdef __linux__
+	struct input_event event;
+
+	memset(&event, 0, sizeof(event));
+	event.type = type;
+	event.code = code;
+	event.value = value;
+
+	if(write(uinputfd, &event, sizeof(event)) != sizeof(event))
+	{
+		fprintf(stderr,"%s: writing to uinput failed\n",progname);
+		perror(progname);
+	}
+#endif
+}
+
 void msend(int dx,int dy,int dz,int rep,int buttp,int buttr)
 {
 	static int buttons=0;
@@ -290,6 +394,67 @@
 		}
 		break;
 	}
+
+	if(uinputfd != -1)
+	{
+		int f=1;
+		if(rep>=ms.acc_start)
+		{
+			if(rep*ms.acc_fak>=ms.acc_max)
+			{
+				f=ms.acc_max;
+			}
+			else
+			{
+				f=rep*ms.acc_fak;
+			}
+		}
+		while(f>0)
+		{
+			f--;
+			if((dx != 0) || (dy != 0))
+			{
+				write_uinput(EV_REL, REL_X, dx);
+				write_uinput(EV_REL, REL_Y, dy);
+				write_uinput(EV_SYN, SYN_REPORT, 0);
+			}
+        		if(dz != 0)
+			{
+				write_uinput(EV_REL, REL_WHEEL, dz);
+				write_uinput(EV_SYN, SYN_REPORT, 0);
+			}
+			if(buttp&BUTTON1)
+			{
+				write_uinput(EV_KEY, BTN_LEFT, 1);
+				write_uinput(EV_SYN, SYN_REPORT, 0);
+			}
+			if(buttr&BUTTON1)
+			{
+				write_uinput(EV_KEY, BTN_LEFT, 0);
+				write_uinput(EV_SYN, SYN_REPORT, 0);
+			}
+			if(buttp&BUTTON2)
+			{
+				write_uinput(EV_KEY, BTN_MIDDLE, 1);
+				write_uinput(EV_SYN, SYN_REPORT, 0);
+			}
+			if(buttr&BUTTON2)
+			{
+				write_uinput(EV_KEY, BTN_MIDDLE, 0);
+				write_uinput(EV_SYN, SYN_REPORT, 0);
+			}
+			if(buttp&BUTTON3)
+			{
+				write_uinput(EV_KEY, BTN_RIGHT, 1);
+				write_uinput(EV_SYN, SYN_REPORT, 0);
+			}
+			if(buttr&BUTTON3)
+			{
+				write_uinput(EV_KEY, BTN_RIGHT, 0);
+				write_uinput(EV_SYN, SYN_REPORT, 0);
+			}
+		}
+	}
 }
 
 void mouse_move(int dx,int dy,int dz,int rep)
@@ -725,6 +890,9 @@
 			{"help",no_argument,NULL,'h'},
 			{"version",no_argument,NULL,'v'},
 			{"nodaemon",no_argument,NULL,'n'},
+#                       if defined(__linux__)
+			{"uinput",no_argument,NULL,'u'},
+#                       endif
 			{0, 0, 0, 0}
 		};
 		c = getopt_long(argc,argv,"hvn",long_options,NULL);
@@ -737,6 +905,9 @@
 			printf("\t -h --help\t\tdisplay this message\n");
 			printf("\t -v --version\t\tdisplay version\n");
 			printf("\t -n --nodaemon\t\tdon't fork to background\n");
+#                       if defined(__linux__)
+			printf("\t -u --uinput\t\tgenerate Linux input events\n");
+#                       endif
 			return(EXIT_SUCCESS);
 		case 'v':
 			printf("%s %s\n",progname,VERSION);
@@ -744,6 +915,11 @@
 		case 'n':
 			nodaemon=1;
 			break;
+#               if defined(__linux__)
+		case 'u':
+			useuinput=1;
+			break;
+#               endif
 		default:
 			printf("Usage: %s [options] [config-file]\n",progname);
 			return(EXIT_FAILURE);
@@ -777,25 +953,37 @@
 		exit(EXIT_FAILURE);
 	};
 
-	/* open fifo */
-	
-	if(mkfifo(LIRCM,0644)==-1)
+	/* either create uinput device or fifo device */
+	uinputfd = -1;
+	lircm = -1;
+	if(useuinput)
 	{
-		if(errno!=EEXIST)
+		/* create uinput device */
+
+		uinputfd = setup_uinputfd(progname);
+	}
+	else
+	{
+		/* open fifo */
+
+		if(mkfifo(LIRCM,0644)==-1)
 		{
-			fprintf(stderr,"%s: could not create fifo\n",progname);
+			if(errno!=EEXIST)
+			{
+				fprintf(stderr,"%s: could not create fifo\n",progname);
+				perror(progname);
+				exit(EXIT_FAILURE);
+			}
+		}
+	
+		lircm=open(LIRCM,O_RDWR|O_NONBLOCK);
+		if(lircm==-1)
+		{
+			fprintf(stderr,"%s: could not open fifo\n",progname);
 			perror(progname);
 			exit(EXIT_FAILURE);
 		}
 	}
-	
-	lircm=open(LIRCM,O_RDWR|O_NONBLOCK);
-	if(lircm==-1)
-	{
-		fprintf(stderr,"%s: could not open fifo\n",progname);
-		perror(progname);
-		exit(EXIT_FAILURE);
-	}
 
 	/* read config file */
 
@@ -817,6 +1005,7 @@
 	{
 		ms=new_ms;
 	}
+
 #ifdef DAEMONIZE
 	if(!nodaemon) daemonize();
 #endif
