diff -Naur lcdproc-0.5.2-old/acinclude.m4 lcdproc-0.5.2-new/acinclude.m4
--- lcdproc-0.5.2-old/acinclude.m4	2008-12-12 14:36:54.000000000 -0800
+++ lcdproc-0.5.2-new/acinclude.m4	2008-12-12 14:40:33.000000000 -0800
@@ -10,13 +10,13 @@
 	[                    irman,joy,lb216,lcdm001,lcterm,lirc,MD8800,ms6931,]
 	[                    mtc_s16209x,MtxOrb,NoritakeVFD,picolcd,pyramid,sed1330]
 	[                    sed1520,serialPOS,serialVFD,sli,stv5730,svga,t6963,text,]
-	[                    tyan,ula200,xosd,dm140]
+	[                    tyan,ula200,xosd,dm140,irtrans]
 	[                  'all' compiles all drivers;]
 	[                  'all,!xxx,!yyy' de-selects previously selected drivers],
 	drivers="$enableval",
 	drivers=[bayrad,CFontz,CFontz633,curses,CwLnx,glk,lb216,lcdm001,MtxOrb,pyramid,text])
 
-allDrivers=[bayrad,CFontz,CFontz633,CFontzPacket,curses,CwLnx,ea65,EyeboxOne,g15,glcdlib,glk,hd44780,icp_a106,imon,imonlcd,IOWarrior,irman,joy,lb216,lcdm001,lcterm,lirc,MD8800,ms6931,mtc_s16209x,MtxOrb,NoritakeVFD,picolcd,pyramid,sed1330,sed1520,serialPOS,serialVFD,sli,stv5730,svga,t6963,text,tyan,ula200,xosd,dm140]
+allDrivers=[bayrad,CFontz,CFontz633,CFontzPacket,curses,CwLnx,ea65,EyeboxOne,g15,glcdlib,glk,hd44780,icp_a106,imon,imonlcd,IOWarrior,irman,joy,lb216,lcdm001,lcterm,lirc,MD8800,ms6931,mtc_s16209x,MtxOrb,NoritakeVFD,picolcd,pyramid,sed1330,sed1520,serialPOS,serialVFD,sli,stv5730,svga,t6963,text,tyan,ula200,xosd,dm140,irtrans]
 
 drivers=`echo $drivers | sed -e 's/,/ /g'`
 
@@ -34,6 +34,10 @@
 			driver=`echo "$driver" | sed -e 's/^.//'`
 			selectdrivers=[`echo " $selectdrivers " | sed -r -e "s/ $driver / /g"`]
 			;;
+		irtrans)
+			DRIVERS="$DRIVERS irtrans${SO}"
+			actdrivers="$actdrivers irtrans"
+			;;
 		*)
 			selectdrivers=["$selectdrivers $driver "]
 			;;
diff -Naur lcdproc-0.5.2-old/LCDd.conf lcdproc-0.5.2-new/LCDd.conf
--- lcdproc-0.5.2-old/LCDd.conf	2008-12-12 14:36:00.000000000 -0800
+++ lcdproc-0.5.2-new/LCDd.conf	2008-12-12 14:39:49.000000000 -0800
@@ -959,4 +959,13 @@
 
 # end d140
 
+[irtrans]
+#IrTrans driver
+
+Arguments="-hostname localhost -lcdw 16 -lcdh 2 -backlight -timeout 1"
+#hostname: IP / Hostname of irserver
+#lcdw: Breite des LCD Displays (default=16)
+#lcdh: HÃ¶he des LCD Displays (default=4)
+
+
 # EOF
diff -Naur lcdproc-0.5.2-old/LCDd.conf.orig lcdproc-0.5.2-new/LCDd.conf.orig
--- lcdproc-0.5.2-old/LCDd.conf.orig	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.2-new/LCDd.conf.orig	2008-12-12 14:39:30.000000000 -0800
@@ -0,0 +1,962 @@
+# LCDd.conf -- configuration file for the LCDproc server daemon LCDd
+#
+# This file contains the configuration for the LCDd server.
+# 
+# The format is ini-file-like. It is divided into sections that start at
+# markers that look like [section]. Comments are all line-based comments,
+# and are lines that start with '#' or ';'.
+#
+# The server has a 'central' section named [server]. For the menu there is
+# a section called [menu]. Further each driver has a section which
+# defines how the driver acts.
+#
+# The drivers are activated by specifiying them in a driver= line in the
+# server section, like:
+#
+#   Driver=curses
+#
+# This tells LCDd to use the curses driver.
+# The first driver that is loaded and is capable of output defines the
+# size of the display. The default driver to use is curses.
+# If the driver is specified using the -d <driver> command line option,
+# the Driver= options in the config file are ignored.
+#
+# The drivers read their own options from the respective sections.
+
+
+
+## Server section with all kinds of settings for the LCDd server ##
+[server]
+
+# Tells the server to load the given drivers. Multiple lines can be given.
+# The name of the driver is case sensitive and determines the section
+# where to look for further configuration options of the specific driver
+# as well as the name of the dynamic driver module to load at runtime.
+# The latter one can be changed by giving af File= directive in the
+# driver specific section.
+#
+# The following drivers are supported:
+#   bayrad, CFontz, CFontz633, CFontzPacket, curses, CwLnx, ea65, 
+#   EyeboxOne, g15, glcdlib, glk, hd44780, icp_a106, imon, IOWarrior,
+#   irman, joy, lb216, lcdm001, lcterm, lirc, MD8800, ms6931, mtc_s16209x,
+#   MtxOrb, NoritakeVFD, picolcd, pyramid, sed1330, sed1520, serialPOS,
+#   serialVFD, sli, stv5730, svga, t6963, text, tyan, ula200, xosd
+Driver=curses
+
+# Tells the driver to bind to the given interface
+Bind=127.0.0.1
+
+# Listen on this specified port; defaults to 13666.
+Port=13666
+
+# Sets the reporting level; defaults to 2 (warnings and errors only).
+#ReportLevel=3
+
+# Should we report to syslog instead of stderr ? Default: no
+#ReportToSyslog=yes
+
+# Sets the default time in seconds to displays a screen.
+WaitTime=5
+
+# User to run as.  LCDd will drop its root priviledges,
+# if any, and run as this user instead.
+User=nobody
+
+# If yes, the the serverscreen will be rotated as a usual info screen. If no,
+# it will be a background screen, only visible when no other screens are
+# active.
+#ServerScreen=no
+
+# The server will stay in the foreground if set to true.
+#Foreground=no
+
+# Where can we find the driver modules ?
+# IMPORTANT: Make sure to change this setting to reflect your
+#            specific setup! Otherwise LCDd won't be able to find
+#            the driver modules and will thus not be able to
+#            function properly.
+# NOTE: Always place a slash as last character !
+DriverPath=server/drivers/
+
+# GoodBye message: each entry represents a display line; default: builtin
+#GoodBye="Thanks for using"
+#GoodBye="   LCDproc!"
+
+# The "...Key=" lines define what the server does with keypresses that
+# don't go to any client.
+# These are the defaults:
+ToggleRotateKey=Enter
+PrevScreenKey=Left
+NextScreenKey=Right
+#ScrollUpKey=Up
+#ScrollDownKey=Down
+
+# If you have only 4 keys, you can choose to use this:
+#ToggleRotateKey=Enter
+#PrevScreenKey=Up
+#NextScreenKey=Down
+
+# If you have only 3 keys, you can choose to use this:
+#ToggleRotateKey=Enter
+#PrevScreenKey=Up
+
+
+
+## The menu section. The menu is an internal LCDproc client. ##
+[menu]
+# You can configure what keys the menu should use. Note that the MenuKey
+# will be reserved exclusively, the others work in shared mode.
+
+# The following works excellent with 4 keys or more.
+MenuKey=Escape
+EnterKey=Enter
+UpKey=Up
+DownKey=Down
+# If you have 6 keys you may define these as well
+#LeftKey=Left
+#RightKey=Right
+
+# If you have only 3 keys, you could use something like this:
+#MenuKey=Escape
+#EnterKey=Enter
+#DownKey=Down
+
+
+
+### Driver sections are below this line, in alphabetical order  ###
+
+
+## EMAC BayRAD driver ##
+[bayrad]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# Set the communication speed [default: 9600; legal:  1200, 2400, 9600, 19200]
+Speed=9600
+
+
+
+## CrystalFontz driver (for CF632 & CF634) ##
+[CFontz]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/ttyS0
+# Select the LCD size [default: 20x4]
+Size=20x4
+# Set the initial contrast [default: 560; legal: 0 - 1000]
+Contrast=350
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=0
+# Set the communication speed [default: 9600; legal: 1200, 2400, 9600, 19200 or 115200]
+Speed=9600
+# Set the firmware version (New means >= 2.0) [default: no; legal: yes, no]
+NewFirmware=no
+# Reinitialize the LCD's BIOS [default: no; legal: yes, no]
+# normally you shouldn't need this
+Reboot=no
+
+
+
+## CrystalFontz633 driver (for CF633 only) ##
+[CFontz633]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/ttyS0
+# Select the LCD type (size) [default: 16x2]
+Size=16x2
+# Set the initial contrast [default: 560; legal: 0 - 1000]
+Contrast=350
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=50
+# Set the communication speed [default: 9600; legal: 1200, 2400, 9600, 19200, 115200]
+Speed=19200
+# Set the firmware version (New means >= 2.0) [default: no; legal: yes, no]
+# Currently this flag is not in use, there is no such thing as NewFirmware. ;=)
+#NewFirmware=no
+# Reinitialize the LCD's BIOS [default: no; legal: yes, no]
+# I want to reboot the LCD to make sure we start from a known state
+Reboot=yes
+
+
+
+## CrystalFontz packet driver (for CF631, CF633 & CF635) ##
+[CFontzPacket]
+
+# Select the LCD model [default: 633; legal: 631, 633, 635]
+Model=635
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/ttyUSB0
+# Select the LCD size [default: depending on model: 635: 20x4, 631: 20x2, 633: 16x2]
+Size=20x4
+# Set the initial contrast [default: 560; legal: 0 - 1000]
+Contrast=350
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=50
+# Set the communication speed [default: 9600; legal: 1200, 2400, 9600, 19200, 115200]
+Speed=115200
+# Set the firmware version (New means >= 2.0) [default: no; legal: yes, no]
+# Currently this flag is not in use, there is no such thing as NewFirmware. ;=)
+#NewFirmware=no
+# Reinitialize the LCD's BIOS [default: no; legal: yes, no]
+# I want to reboot the LCD to make sure we start from a known state
+Reboot=yes
+
+
+
+## Curses driver ##
+[curses]
+
+# color settings
+# foreground color [default: blue]
+Foreground=blue
+# background color when "backlight" is off [default: cyan]
+Background=cyan
+# background color when "backlight" is on [default: red]
+Backlight=red
+
+# display size [default: 20x4]
+Size=20x4
+
+# What position (X,Y) to start the left top corner at...
+# Default: (7,7)
+TopLeftX=7
+TopLeftY=7
+
+# use ASC symbols for icons & bars [default: no; legal, yes, no]
+UseACS=no
+
+
+
+## Cwlinux driver ##
+[CwLnx]
+
+# Select the LCD model [default: 12232; legal: 12232, 1602]
+Model=12232
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/ttyUSB0
+
+# Select the LCD size [default: depending on model: 12232: 20x4, 1602: 16x2]
+Size=20x4
+
+# Set the communication speed [default: 19200; legal: 9600, 19200]
+Speed=19200
+
+# Reinitialize the LCD's BIOS [default: no; legal: yes, no]
+# normally you shouldn't need this
+Reboot=no
+
+# If you have a keypad connected. Keypad layout is currently not
+# configureable from the config file.
+Keypad=yes
+
+# If you have a non-standard keypad you can associate any keystrings to keys.
+# There are 6 input keys in the CwLnx hardware that generate characters
+# from 'A' to 'F'.
+#
+# The following is the built-in default mapping hardcoded in the driver.
+# You can leave those unchanged if you have a standard keypad.
+# You can change it if you want to report other keystrings or have a non
+# standard keypad.
+# KeyMap_A=Up
+# KeyMap_B=Down
+# KeyMap_C=Left
+# KeyMap_D=Right
+# KeyMap_E=Enter
+# KeyMap_F=Escape
+
+# keypad_test_mode permits to test keypad assignement
+# Default value is no
+#keypad_test_mode=yes
+
+
+
+## ea65 driver for the display in AOpen XC Cube AV EA65 media barebones ##
+[ea65]
+
+# Device is fixed /dev/ttyS1
+# Width and Height are fixed 9x1
+
+# As the VFD is self luminescent we don't have a backlight
+# But we can use the backlight functions to control the front LEDs
+# Brightness 0 to 299 -> LEDs off
+# Brightness 300 to 699 -> LEDs half bright
+# Brightness 700 to 1000 -> LEDs full bright
+Brightness=500
+# OffBrightness is the the value used for the 'backlight off' state
+OffBrightness=0
+
+
+
+## EyeboxOne driver ##
+[EyeboxOne]
+
+# Select the output device to use [default: /dev/ttyS1]
+#Device=/dev/cua01
+Device=/dev/ttyS1
+
+# Set the display size [default: 20x4]
+Size=20x4
+
+# Switch on the backlight? [default: yes]
+Backlight=yes
+
+# Switch on the cursor? [default: no]
+Cursor=no
+
+# Set the communication speed [default: 19200; legal: 1200, 2400, 9600, 19200]
+Speed=19200
+
+# Enter Key is a \r character, so it's hardcoded in the driver
+LeftKey=D
+RightKey=C
+UpKey=A
+DownKey=B
+EscapeKey=P
+
+# You can find out which key of your display sends which
+# character by setting keypad_test_mode to yes and running
+# LCDd. LCDd will output all characters it receives.
+# Afterwards you can modify the settings above and set
+# keypad_set_mode to no again.
+keypad_test_mode=no
+
+
+
+## g15 driver for Logitech G15 Keyboard LCDs ##
+[g15]
+
+# Display size (currently unused)
+size=20x5
+
+## glcdlib meta driver for graphical LCDs ##
+[glcdlib]
+
+## mandatory:
+
+# which graphical display supported by graphlcd-base to use [default: image]
+# (see /etc/graphlcd.conf for possible drivers)
+Driver=noritake800
+
+# no=use graphlcd bitmap fonts (they have only one size / font file)
+# yes=use fonts supported by FreeType2 (needs Freetype2 support in libglcdprocdriver and its dependants)
+UseFT2=yes
+
+# text resolution in fixed width characters [default: 16x4]
+# (if it won't fit according to available physical pixel resolutioni
+# and the minimum available font face size in pixels, then 
+# 'DebugBorder' will automatically be turned on)
+TextResolution=20x4
+
+# path to font file to use
+FontFile=/usr/share/fonts/corefonts/courbd.ttf
+
+## these only apply if UseFT2=yes:
+
+# character encoding to use
+CharEncoding=iso8859-2
+
+# minumum size in pixels in which fonts should be rendered
+MinFontFaceSize=7x12
+
+## optional:
+Brightness=50                   # Brightness (in %) if applicable
+Contrast=50                     # Contrast (in %) if applicable
+Backlight=no                    # Backlight if applicable
+UpsideDown=no                   # flip image upside down
+Invert=no                       # invert light/dark pixels
+ShowDebugFrame=no               # turns on/off 1 pixel thick debugging
+                                # border whithin the usable text area,
+                                # for setting up TextResolution and
+                                # MinFontFaceSize (if using FT2);
+ShowBigBorder=no                # border around the unused area
+ShowThinBorder=yes              # border around the unused area
+PixelShiftX=0
+PixelShiftY=2
+
+
+
+## Matrix Orbital GLK driver ##
+[glk]
+
+# select the serial device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# set the initial contrast value [default: 560; legal: 0 - 1000]
+Contrast=560
+
+# set the serial port speed [default: 19200; legal: 9600, 19200, 38400]
+Speed=19200
+
+
+
+## Hitachi HD44780 driver ##
+[hd44780]
+
+# Select what type of connection. See documentation for types.
+ConnectionType=4bit
+
+# Port where the LPT is. Usual values are 0x278, 0x378 and 0x3BC
+Port=0x378
+
+# Device of the serial interface (default is /dev/lcd)
+Device=/dev/ttyS0
+
+# Bitrate of the serial port (0 for interface default)
+Speed=0
+
+# If you have a keypad connected.
+# You may also need to configure the keypad layout further on in this file.
+Keypad=no
+
+# set the initial contrast (for bwctusb only) [default: 0; legal: 0 - 1000]
+Contrast=0
+
+# If you have a switchable backlight.
+Backlight=no
+
+# If you have the additional output port ("bargraph") and you want to
+# be able to control it with the lcdproc OUTPUT command
+OutputPort=no
+
+# Specifies if the last line is pixel addressable or it controls an
+# underline effect. [default: true (= pixel addressable); legal: yes, no]
+#Lastline=true
+
+# Specifies the size of the LCD.
+# In case of multiple combined displays, this should be the total size.
+Size=20x4
+
+# For multiple combined displays: how many lines does each display have.
+# Vspan=2,2 means both displays have 2 lines.
+#vspan=2,2
+
+# If you have an HD66712, a KS0073 or an other 'almost HD44780-compatible',
+# set this flag to get into extended mode (4-line linear).
+# This flag is NOT the old obsolete Extended option.
+#ExtendedMode=yes
+
+# Character map to to map ISO-8859-1 to the LCD's character set
+# [default: hd44780_default; legal: hd44780_default, ea_ks0073, sed1278f_0b ]
+Charmap=hd44780_default
+
+# If your display is slow and cannot keep up with the flow of data from
+# LCDd, garbage can appear on the LCDd. Set this delay factor to 2 or 4
+# to increase the delays. Default: 1.
+#DelayMult=2
+
+# Some displays (e.g. vdr-wakeup) need a message from the driver to that it
+# is still alive. When set to a value bigger then null the character in the
+# upper left corner is updated every <KeepAliveDisplay> seconds. Default: 0.
+#KeepAliveDisplay=0
+
+# If you experience occasional garbage on your display you can use this
+# option as workaround. If set to a value bigger than null it forces a
+# full screen refresh <RefreshDiplay> seconds. Default: 0.
+#RefreshDisplay=5
+
+# You can reduce the inserted delays by setting this to false.
+# On fast PCs it is possible your LCD does not respond correctly.
+# Default: true.
+DelayBus=true
+
+# If you have a keypad you can assign keystrings to the keys.
+# See documentation for used terms and how to wire it.
+# For example to give directly connected key 4 the string "Enter", use:
+#   KeyDirect_4=Enter
+# For matrix keys use the X and Y coordinates of the key:
+#   KeyMatrix_1_3=Enter
+KeyMatrix_4_1=Enter
+KeyMatrix_4_2=Up
+KeyMatrix_4_3=Down
+KeyMatrix_4_4=Escape
+
+
+
+## ICP A106 driver ##
+[icp_a106]
+Device=/dev/ttyS1
+
+
+
+## Code Mercenaries IO-Warrior driver ##
+[IOWarrior]
+
+# display dimensions
+Size=20x4
+
+# serial number [exactly as listed by usbview]
+# (if not given, the 1st IOWarrior found gets used)
+#SerialNumber=00000674
+
+# Specifies if the last line is pixel addressable or it controls an
+# underline effect. [default: true (= pixel addressable); legal: yes, no]
+#Lastline=true
+
+
+
+## Soundgraph/Ahanix/Silverstone/Uneed/Accent iMON driver ##
+[imon]
+
+# select the device to use
+Device=/dev/lcd0
+
+# display dimensions
+Size=16x2
+
+
+
+## IrMan driver ##
+[IrMan]
+#if in trouble with IrMan, try Lirc emulator for IrMan
+
+# Select the input device to use
+#Device=/dev/irman
+
+# Select the configuration file to use
+#Config=/etc/irman.cfg
+
+
+
+## Joystick driver ##
+[joy]
+
+# Select the input device to use [default: /dev/js0]
+Device=/dev/js0
+
+# set the axis map
+Map_Axis1neg=Left
+Map_Axis1pos=Right
+Map_Axis2neg=Up
+Map_Axis2pos=Down
+
+# set the button map
+Map_Button1=Enter
+Map_Button2=Escape
+
+
+
+## LB216 driver ##
+[lb216]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# Set the initial brightness [default: 255; legal: 0 - 255]
+Brightness=255
+
+# Set the communication speed [default: 9600; legal: 2400, 9600]
+Speed=9600
+
+# Reinitialize the LCD's BIOS [default: no; legal: yes, no]
+Reboot=no
+
+
+
+## LCDM001 driver ##
+[lcdm001]
+
+Device=/dev/ttyS1
+
+# keypad settings
+# Keyname      Function
+#              Normal context              Menu context
+# -------      --------------              ------------
+# PauseKey     Pause/Continue              Enter/select
+# BackKey      Back(Go to previous screen) Up/Left
+# ForwardKey   Forward(Go to next screen)  Down/Right
+# MainMenuKey  Open main menu              Exit/Cancel
+PauseKey=LeftKey
+BackKey=UpKey
+ForwardKey=DownKey
+MainMenuKey=RightKey
+
+# You can rearrange the settings here.
+# If your device is broken, have a look at server/drivers/lcdm001.h
+
+
+
+## HNE LCTerm driver ##
+[lcterm]
+Device=/dev/ttyS1
+Size=16x2
+
+
+
+## LIRC input driver ##
+[lirc]
+
+# Specify an alternative location of the lircrc file [default: ~/.lircrc]
+#lircrc=/etc/lircrc.lcdproc
+
+# Must be the same as in your lircrc
+#prog=lcdd
+
+
+
+##The driver for the VFD of the Medion MD8800 PC ##
+[MD8800]
+# device to use [default: /dev/ttyS1]
+#Device=/dev/ttyS1
+
+# display size [default: 16x2]
+#Size=16x2
+
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=50
+
+
+
+## MSI MS-6931 driver for displays in 1HU servers ##
+[ms6931]
+
+# device to use [default: /dev/ttyS1]
+Device=/dev/ttyS1
+
+# display size [default: 16x2]
+#Size=16x2
+
+
+
+## MTC-S16209x driver ##
+[mtc_s16209x]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# Set the initial brightness [default: 255; legal: 0 - 255]
+Brightness=255
+
+# Reinitialize the LCD's BIOS [default: no; legal: yes, no]
+Reboot=no
+
+
+
+## Matrix Orbital driver ##
+[MtxOrb]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/ttyS0
+
+# Set the display size [default: 20x4]
+Size=20x4
+
+# Set the display type [default: lcd; legal: lcd, lkd, vfd, vkd]
+Type=lkd
+
+# Set the initial contrast [default: 480]
+# NOTE: The driver will ignore this if the display
+#       is a vfd or vkd as they don't have this feature
+Contrast=480
+
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=0
+
+# Set the communication speed [default: 19200; legal: 1200, 2400, 9600, 19200]
+Speed=19200
+
+# The following table translates from MtxOrb key letters to logical key names.
+# By default no keys are mapped, meaning the keypad is not used at all.
+#KeyMap_A=Left
+#KeyMap_B=Right
+#KeyMap_C=Up
+#KeyMap_D=Down
+#KeyMap_E=Enter
+#KeyMap_F=Escape
+# See the [menu] section for an explanation of the key mappings
+
+# You can find out which key of your display sends which
+# character by setting keypad_test_mode to yes and running
+# LCDd. LCDd will output all characters it receives.
+# Afterwards you can modify the settings above and set
+# keypad_set_mode to no again.
+keypad_test_mode=no
+
+
+
+## Noritake VFD driver ##
+[NoritakeVFD]
+# device where the VFD is. Usual values are /dev/ttyS0 and /dev/ttyS1 [default: /dev/lcd]
+Device=/dev/ttyS0
+
+# Specifies the size of the LCD.
+Size=20x4
+
+# set the brightness
+Brightness=255
+
+# set the serial port speed [default: 9600, legal: 1200, 2400, 9600, 19200, 115200]
+Speed=9600
+
+# re-initialize VFD ?
+#Reboot=yes
+
+
+
+## Mini-box.com picoLCD (usblcd) driver ##
+[picolcd]
+# This is for the Mini-Box.com usblcd device that ships with the M300.  It can 
+# also be purchased separately but this driver has only been tested on the M300 
+# setup.
+
+# KeyTimeout is the time that LCDd spends waiting for a key press before cycling 
+# through other duties.  Higher values make LCDd use less CPU time and make 
+# key presses more detectable.  Lower values make LCDd more responsive but a 
+# little prone to missing key presses.  500 (.5 second) is the default and a
+# balanced value.
+KeyTimeout=500
+
+# Contrast: [default: 1000; legal: 0 - 1000]
+Contrast=1000
+
+# Light the keys? i[default: on; legal: on, off]
+Keylights=on
+
+# If Keylights is on, the you can unlight specific keys below:
+# Key0 is the directional pad.  Key1 - Key5 correspond to the F1 - F5 keys.  
+# There is no LED for the +/- keys.  This is a handy way to indicate to users 
+# which keys are disabled.  [default: on; legal: on, off]
+Key0Light=on
+Key1Light=on
+Key2Light=on
+Key3Light=on
+Key4Light=on
+Key5Light=on
+
+
+
+## Pyramid LCD driver ##
+[pyramid]
+
+# device to connect to [default: /dev/lcd]
+Device=/dev/ttyUSB0
+
+
+
+## Seiko Epson 1330 driver ##
+[sed1330]
+
+# Port where the LPT is. Common values are 0x278, 0x378 and 0x3BC
+Port=0x378
+
+# Type of LCD module (legal: G321D, G121C, G242C, G191D, G2446, SP14Q002)
+# Note: Currently only tested with G321D & SP14Q002.
+Type=G321D
+
+# Width x Height of a character cell in pixels [legal: 6x7 - 8x16; default: 6x10]
+CellSize=6x10
+
+# Select what type of connection [legal: classic, bitshaker; default: classic]
+ConnectionType=classic
+
+
+## Seiko Epson 1520 driver ##
+[sed1520]
+
+# Port where the LPT is. Usual values are 0x278, 0x378 and 0x3BC
+Port=0x378
+
+
+
+## serial POS display driver ##
+[serialPOS]
+
+# Device to use in serial modea [default: /dev/lcd]
+Device=/dev/lcd
+
+# Specifies the size of the display in characters. [default: 16x2]
+Size=16x2
+
+# Set the communication protocol to use with the POS display.
+# [default: AEDEX; legal: IEE, Epson, Emax, IBM, LogicControls, Ultimate]
+Type=AEDEX
+
+# communication baud rate with the display [default: 9600; legal: 1200, 2400, 19200, 115200]
+Speed=9600
+
+
+
+## Serial VFD driver ##
+## Drives various (see below) serial 5x7dot VFD's.  ##
+[serialVFD]
+
+# Specifies the displaytype.[default: 0]
+# 0 NEC (FIPC8367 based) VFDs.
+# 1 KD Rev 2.1.
+# 2 Noritake VFDs (*).
+# 3 Futaba VFDs
+# (* most should work, not testet yet.)
+Type=0
+
+# "no" if display connected serial, "yes" if connected parallel. [default: no(=serial)]
+use_parallel=no
+
+# Number of Custom-Characters [default: displaytype dependent]
+#Custom-Characters=0
+
+# Portaddress where the LPT is. Used in parallelmode only. Usual values are 0x278, 0x378 and 0x3BC
+Port=0x378
+
+# Device to use in serial mode. Usual values are /dev/ttyS0 and /dev/ttyS1
+Device=/dev/ttyS1
+
+# Specifies the size of the VFD.
+Size=20x2
+
+# Set the initial brightness [default: 1000; legal: 0 - 1000]
+# (4 steps 0-250, 251-500, 501-750, 751-1000)
+Brightness=1000
+# Set the initial off-brightness [default: 0; legal: 0 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+# (4 steps 0-250, 251-500, 501-750, 751-1000)
+OffBrightness=0
+
+# set the serial port speed [default: 9600; legal: 1200, 2400, 9600, 19200, 115200]
+Speed=9600
+
+# enable ISO 8859 1 compatibility [default: yes; legal: yes, no]
+#ISO_8859_1=yes
+
+
+
+## stv5730 driver ##
+[stv5730]
+
+# Port the device is connected to [default: 0x378]
+Port=0x378
+
+
+
+## SVGAlib driver ##
+[svga]
+
+# svgalib mode to use [default: G320x240x256; legal: supported svgalib modes]
+#Mode=G640x480x256
+
+# set display size [default: 20x4]
+Size=20x4
+
+# Set the initial contrast [default: 500; legal: 0 - 1000]
+# Can be set but does not change anything internally
+Contrast=500
+
+# Set the initial brightness [default: 1000; legal: 1 - 1000]
+Brightness=1000
+
+# Set the initial off-brightness [default: 500; legal: 1 - 1000]
+# This value is used when the display is normally
+# switched off in case LCDd is inactive
+OffBrightness=500
+
+
+
+## Text driver ##
+[text]
+# Set the display size [default: 20x4]
+Size=20x4
+
+
+
+## Toshiba T6963 driver ##
+[t6963]
+
+# set display size [default: 20x6]
+Size=20x6
+
+# port to use [default: 0x378; legal: 0x200 - 0x400]
+Port=0x378
+
+# Is ECP mode on? [default: yes; legal: yes, no]
+#ECPlpt=yes
+
+# Use graphics? [default: no; legal: yes, no]
+#graphic=no
+
+
+
+## Tyan Barebones LCD driver (GS10 & GS12 series) ##
+[tyan]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# Set the communication speed [default: 9600; legal: 4800, 9600]
+Speed=9600
+
+# set display size [default: 16x2]
+Size=16x2
+
+
+
+## ELV ula200 driver ##
+[ula200]
+
+# Select the LCD size [default: 20x4]
+Size=20x4
+
+# If you have a non standard keypad you can associate any keystrings to keys.
+# There are 6 input key in the CwLnx hardware that generate characters
+# from 'A' to 'F'.
+#
+# The following it the built-in default mapping hardcoded in the driver.
+# You can leave those unchanged if you have a standard keypad.
+# You can change it if you want to report other keystrings or have a non
+# standard keypad.
+# KeyMap_A=Up
+# KeyMap_B=Down
+# KeyMap_C=Left
+# KeyMap_D=Right
+# KeyMap_E=Enter
+# KeyMap_F=Escape
+
+
+
+## Wirz SLI LCD driver ##
+[sli]
+
+# Select the output device to use [default: /dev/lcd]
+Device=/dev/lcd
+
+# Set the communication speed [default: 19200; legal: 1200, 2400, 9600, 19200, 38400, 57600, 115200]
+Speed=19200
+
+
+
+## OnScreen Display using libxosd ##
+[xosd]
+
+# set display size [default: 20x4]
+Size=20x4
+
+# font to use, in XLFD format, as given by "xfontsel"
+Font=-*-terminus-*-r-*-*-*-320-*-*-*-*-*
+
+## DM140 VFD
+[dm140]
+
+
+# end d140
+
+# EOF
diff -Naur lcdproc-0.5.2-old/server/drivers/irtrans.c lcdproc-0.5.2-new/server/drivers/irtrans.c
--- lcdproc-0.5.2-old/server/drivers/irtrans.c	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.2-new/server/drivers/irtrans.c	2008-12-12 14:39:49.000000000 -0800
@@ -0,0 +1,360 @@
+/*
+ * irtrans driver
+ *
+ * Displays LCD screens, one after another; suitable for hard-copy
+ * terminals.
+ *
+ * Copyright (C) 1998-2007 <info@irtrans.de>
+ *
+ * Copyright (C) 2007 Phant0m <phantom@netkeke.com>
+ * porting the LCDproc 0.4.3 code to LCDproc 0.5.1
+ *
+ * Inspired by:
+ *  TextMode driver (LCDproc authors)
+ *  irtrans driver (Irtrans)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <time.h>
+#include <netdb.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include "lcd.h"
+#include "shared/str.h"
+#include "irtrans.h"
+#include "irtrans_remote.h"
+#include "irtrans_network.h"
+#include "irtrans_errcode.h"
+#include "report.h"
+//#include "drv_base.h"
+
+
+// Variables
+// TODO init
+typedef struct driver_private_data {
+    int width;
+    int height;
+    int socket;
+    int timeout;
+    long last_time;
+    byte backlight;
+    int has_backlight;
+    char hostname[256];
+    char *framebuf;
+    char *shadow_buf;
+} PrivateData;
+
+// Vars for the server core
+MODULE_EXPORT char *api_version = API_VERSION;
+MODULE_EXPORT int stay_in_foreground = 0;
+MODULE_EXPORT int supports_multiple = 0;
+MODULE_EXPORT char *symbol_prefix = "irtrans_";
+
+//////////////////////////////////////////////////////////////////////////
+////////////////////// For Irtrans Output //////////////////////////////
+//////////////////////////////////////////////////////////////////////////
+
+int InitClientSocket(char host[], SOCKET * sock, unsigned long id);
+int SendCommand(Driver * drvthis, LCDCOMMAND * com, STATUSBUFFER * stat);
+
+
+MODULE_EXPORT int irtrans_init(Driver * drvthis)
+{
+    PrivateData *p;
+    char buf[256];
+
+    /* Allocate and store private data */
+    p = (PrivateData *) calloc(1, sizeof(PrivateData));
+    if (p == NULL)
+        return -1;
+    if (drvthis->store_private_ptr(drvthis, p))
+        return -1;
+
+    /* initialize private data */
+    p->has_backlight =
+        drvthis->config_get_bool(drvthis->name, "Backlight", 0, 0);
+    report(RPT_INFO, "%s: Backlight %d", drvthis->name, p->backlight);
+
+    strncpy(p->hostname,
+            drvthis->config_get_string(drvthis->name, "Hostname", 0,
+                                       IRTRANS_DEFAULT_HOSTNAME),
+            sizeof(p->hostname));
+    p->hostname[sizeof(p->hostname) - 1] = '\0';
+    report(RPT_INFO, "%s: Hostname is %s", drvthis->name, p->hostname);
+
+    // Set display sizes
+    if ((drvthis->request_display_width() > 0)
+        && (drvthis->request_display_height() > 0)) {
+        // Use size from primary driver
+        p->width = drvthis->request_display_width();
+        p->height = drvthis->request_display_height();
+    } else {
+        /* Use our own size from config file */
+        strncpy(buf,
+                drvthis->config_get_string(drvthis->name, "Size", 0,
+                                           IRTRANS_DEFAULT_SIZE),
+                sizeof(buf));
+        buf[sizeof(buf) - 1] = '\0';
+        if ((sscanf(buf, "%dx%d", &p->width, &p->height) != 2)
+            || (p->width <= 0) || (p->width > LCD_MAX_WIDTH)
+            || (p->height <= 0) || (p->height > LCD_MAX_HEIGHT)) {
+            report(RPT_WARNING,
+                   "%s: cannot read Size: %s; using default %s",
+                   drvthis->name, buf, IRTRANS_DEFAULT_SIZE);
+            sscanf(IRTRANS_DEFAULT_SIZE, "%dx%d", &p->width, &p->height);
+        }
+    }
+
+    // Allocate the framebuffer and shadow buffer
+    p->framebuf = malloc(p->width * p->height);
+    p->shadow_buf = malloc(p->width * p->height);
+    if (p->framebuf == NULL) {
+        report(RPT_ERR, "%s: unable to create framebuffer", drvthis->name);
+        return -1;
+    }
+    if (p->shadow_buf == NULL) {
+        report(RPT_ERR, "%s: unable to create shadow buffer",
+               drvthis->name);
+        return -1;
+    }
+    memset(p->framebuf, ' ', p->width * p->height);
+    memset(p->shadow_buf, ' ', p->width * p->height);
+
+    // InitClientSocket
+    if (InitClientSocket(p->hostname, &p->socket, 0)) {
+        report(RPT_ERR, "%s: unable to init client socket", drvthis->name);
+        return -1;
+    }
+
+    report(RPT_DEBUG, "%s: init() done", drvthis->name);
+
+    return 1;
+}
+
+/////////////////////////////////////////////////////////////////
+// Closes the device
+//
+MODULE_EXPORT void irtrans_close(Driver * drvthis)
+{
+    PrivateData *p = drvthis->private_data;
+
+    irtrans_clear(drvthis);
+    sleep(5);
+    p->backlight = 0;
+    irtrans_flush(drvthis);
+
+    if (p != NULL) {
+        if (p->framebuf != NULL)
+            free(p->framebuf);
+        free(p);
+    }
+
+    close(p->socket);
+
+    drvthis->store_private_ptr(drvthis, NULL);
+}
+
+/////////////////////////////////////////////////////////////////
+// Returns the display width
+//
+MODULE_EXPORT int irtrans_width(Driver * drvthis)
+{
+    PrivateData *p = drvthis->private_data;
+
+    return p->width;
+}
+
+/////////////////////////////////////////////////////////////////
+// Returns the display height
+//
+MODULE_EXPORT int irtrans_height(Driver * drvthis)
+{
+    PrivateData *p = drvthis->private_data;
+
+    return p->height;
+}
+
+/////////////////////////////////////////////////////////////////
+// Clears the LCD screen
+//
+MODULE_EXPORT void irtrans_clear(Driver * drvthis)
+{
+    PrivateData *p = drvthis->private_data;
+
+    memset(p->framebuf, ' ', p->width * p->height);
+}
+
+//////////////////////////////////////////////////////////////////
+// Flushes all output to the lcd...
+//
+MODULE_EXPORT void irtrans_flush(Driver * drvthis)
+{
+    PrivateData *p = drvthis->private_data;
+
+    LCDCOMMAND buf;
+    STATUSBUFFER stat;
+
+    if (!memcmp(p->shadow_buf, p->framebuf, p->width * p->height))
+        return;
+
+    if ((time(0) - p->last_time) < p->timeout)
+        return;
+
+    memcpy(buf.framebuffer, p->framebuf, p->width * p->height);
+    buf.wid = p->width;
+    buf.hgt = p->height;
+
+    buf.netcommand = COMMAND_LCD;
+    buf.adress = 'L';
+    buf.lcdcommand = LCD_TEXT | p->backlight;
+    buf.protocol_version = IRTRANS_PROTOCOL_VERSION;
+
+    SendCommand(drvthis, &buf, &stat);  // Error Handling
+    memcpy(p->shadow_buf, p->framebuf, p->width * p->height);
+    p->last_time = time(0);
+
+}
+
+/////////////////////////////////////////////////////////////////
+// Prints a string on the lcd display, at position (x,y).  The
+// upper-left is (1,1), and the lower right should be (20,4).
+//
+MODULE_EXPORT void
+irtrans_string(Driver * drvthis, int x, int y, char string[])
+{
+    PrivateData *p = drvthis->private_data;
+    int i;
+
+    x--;
+    y--;                        // Convert 1-based coords to 0-based...
+
+    if ((y < 0) || (y >= p->height))
+        return;
+
+    for (i = 0; (string[i] != '\0') && (x < p->width); i++, x++) {
+        if (x >= 0)             // no write left of left border
+            p->framebuf[(y * p->width) + x] = string[i];
+    }
+}
+
+/////////////////////////////////////////////////////////////////
+// Prints a character on the lcd display, at position (x,y).  The
+// upper-left is (1,1), and the lower right should be (20,4).
+//
+MODULE_EXPORT void irtrans_chr(Driver * drvthis, int x, int y, char c)
+{
+    PrivateData *p = drvthis->private_data;
+
+    y--;
+    x--;
+
+    if ((x >= 0) && (y >= 0) && (x < p->width) && (y < p->height))
+        p->framebuf[(y * p->width) + x] = c;
+}
+
+/////////////////////////////////////////////////////////////////
+// Sets the contrast
+//
+MODULE_EXPORT void irtrans_set_contrast(Driver * drvthis, int promille)
+{
+    //PrivateData *p = drvthis->private_data;
+
+    debug(RPT_DEBUG, "Contrast: %d", promille);
+}
+
+/////////////////////////////////////////////////////////////////
+// Sets the backlight brightness
+//
+MODULE_EXPORT void irtrans_backlight(Driver * drvthis, int on)
+{
+    PrivateData *p = drvthis->private_data;
+    if (on && p->has_backlight)
+        p->backlight = LCD_BACKLIGHT;
+    else
+        p->backlight = 0;
+
+    debug(RPT_DEBUG, "Backlight %s", (on) ? "ON" : "OFF");
+}
+
+int SendCommand(Driver * drvthis, LCDCOMMAND * com, STATUSBUFFER * stat)
+{
+    PrivateData *p = drvthis->private_data;
+    int res;
+
+    res = send(p->socket, (char *) com, sizeof(LCDCOMMAND), 0);
+
+    if (res != sizeof(LCDCOMMAND)) {
+        close(p->socket);
+        return (ERR_SEND);
+    }
+
+    memset(stat, 0, sizeof(STATUSBUFFER));
+
+    do {
+        res = recv(p->socket, (char *) stat, 8, 0);
+        if (stat->statuslen > 8) {
+            res =
+                recv(p->socket, ((char *) stat) + 8, stat->statuslen - 8,
+                     0);
+        } else
+            return (0);
+    } while (stat->statustype == STATUS_RECEIVE);
+    return (0);
+}
+
+int InitClientSocket(char host[], SOCKET * sock, unsigned long id)
+{
+    struct sockaddr_in serv_addr;
+    unsigned long adr;
+    struct hostent *he;
+    struct in_addr addr;
+
+    adr = inet_addr(host);
+    if (adr == INADDR_NONE) {
+        he = gethostbyname(host);
+        if (he == NULL)
+            return (ERR_FINDHOST);
+        memcpy(&addr, he->h_addr_list[0], sizeof(struct in_addr));
+        adr = addr.s_addr;
+    }
+
+
+    *sock = socket(PF_INET, SOCK_STREAM, 0);
+    if (*sock < 0)
+        return (ERR_OPENSOCKET);
+
+    memset(&serv_addr, 0, sizeof(serv_addr));
+    serv_addr.sin_family = AF_INET;
+    serv_addr.sin_addr.s_addr = adr;
+    serv_addr.sin_port = htons(TCP_PORT);
+
+    if (connect(*sock, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) <
+        0)
+        return (ERR_CONNECT);
+    send(*sock, (char *) &id, 4, 0);
+    return (0);
+}
diff -Naur lcdproc-0.5.2-old/server/drivers/irtrans_errcode.h lcdproc-0.5.2-new/server/drivers/irtrans_errcode.h
--- lcdproc-0.5.2-old/server/drivers/irtrans_errcode.h	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.2-new/server/drivers/irtrans_errcode.h	2008-12-12 14:39:49.000000000 -0800
@@ -0,0 +1,65 @@
+/*
+ * irtrans driver
+ *
+ * Displays LCD screens, one after another; suitable for hard-copy
+ * terminals.
+ *
+ * Copyright (C) 1998-2007 <info@irtrans.de>
+ *
+ * Copyright (C) 2007 Phant0m <phantom@netkeke.com>
+ * porting the LCDproc 0.4.3 code to LCDproc 0.5.1
+ *
+ * Inspired by:
+ *  TextMode driver (LCDproc authors)
+ *  irtrans driver (Irtrans)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ */
+
+#define ERR_OPEN			1
+#define ERR_RESET			2
+#define ERR_VERSION			3
+#define ERR_TIMEOUT			4
+#define	ERR_READVERSION		5
+
+#define ERR_DBOPENINPUT		11
+#define ERR_REMOTENOTFOUND	12
+#define ERR_COMMANDNOTFOUND	13
+#define ERR_TIMINGNOTFOUND	14
+#define ERR_OPENASCII		15
+#define ERR_NODATABASE		16
+#define ERR_OPENUSB			17
+#define ERR_RESEND			18
+#define ERR_TOGGLE_DUP		19
+#define ERR_DBOPENINCLUDE	20
+#define ERR_NOFILEOPEN		21
+#define	ERR_FLOCK			22
+#define ERR_STTY			23
+#define ERR_HOTCODE			24
+#define ERR_NOTIMING		25
+
+#define ERR_OPENSOCKET		100
+#define ERR_BINDSOCKET		101
+#define ERR_FINDHOST		103
+#define ERR_CONNECT			104
+#define ERR_SEND			105
+#define ERR_RECV			106
+
+
+#define FATAL				1
+#define IR					2
+#define	IRTIMEOUT			3
+
+void GetError(int res, char st[]);
diff -Naur lcdproc-0.5.2-old/server/drivers/irtrans.h lcdproc-0.5.2-new/server/drivers/irtrans.h
--- lcdproc-0.5.2-old/server/drivers/irtrans.h	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.2-new/server/drivers/irtrans.h	2008-12-12 14:39:49.000000000 -0800
@@ -0,0 +1,54 @@
+/*
+ * irtrans driver
+ *
+ * Displays LCD screens, one after another; suitable for hard-copy
+ * terminals.
+ *
+ * Copyright (C) 1998-2007 <info@irtrans.de>
+ *
+ * Copyright (C) 2007 Phant0m <phantom@netkeke.com>
+ * porting the LCDproc 0.4.3 code to LCDproc 0.5.1
+ *
+ * Inspired by:
+ *  TextMode driver (LCDproc authors)
+ *  irtrans driver (Irtrans)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ */
+
+#ifndef LCD_TEXT_H
+#define LCD_TEXT_H
+
+#include "lcd.h"
+
+MODULE_EXPORT int irtrans_init(Driver * drvthis);
+MODULE_EXPORT void irtrans_close(Driver * drvthis);
+MODULE_EXPORT int irtrans_width(Driver * drvthis);
+MODULE_EXPORT int irtrans_height(Driver * drvthis);
+MODULE_EXPORT void irtrans_clear(Driver * drvthis);
+MODULE_EXPORT void irtrans_flush(Driver * drvthis);
+MODULE_EXPORT void irtrans_string(Driver * drvthis, int x, int y,
+                                  char string[]);
+MODULE_EXPORT void irtrans_chr(Driver * drvthis, int x, int y, char c);
+MODULE_EXPORT void irtrans_set_contrast(Driver * drvthis, int promille);
+MODULE_EXPORT void irtrans_backlight(Driver * drvthis, int on);
+
+typedef int SOCKET;
+typedef int WSAEVENT;
+
+#define IRTRANS_DEFAULT_SIZE "16x2"
+#define IRTRANS_DEFAULT_HOSTNAME "localhost"
+
+#endif
diff -Naur lcdproc-0.5.2-old/server/drivers/irtrans_network.h lcdproc-0.5.2-new/server/drivers/irtrans_network.h
--- lcdproc-0.5.2-old/server/drivers/irtrans_network.h	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.2-new/server/drivers/irtrans_network.h	2008-12-12 14:39:49.000000000 -0800
@@ -0,0 +1,302 @@
+/*
+ * irtrans driver
+ *
+ * Displays LCD screens, one after another; suitable for hard-copy
+ * terminals.
+ *
+ * Copyright (C) 1998-2007 <info@irtrans.de>
+ *
+ * Copyright (C) 2007 Phant0m <phantom@netkeke.com>
+ * porting the LCDproc 0.4.3 code to LCDproc 0.5.1
+ *
+ * Inspired by:
+ *  TextMode driver (LCDproc authors)
+ *  irtrans driver (Irtrans)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ */
+
+#define IRTRANS_PROTOCOL_VERSION	208
+
+#define COMMAND_SEND		1
+#define COMMAND_LRNREM		2
+#define COMMAND_LRNTIM		3
+#define COMMAND_LRNCOM		4
+#define COMMAND_CLOSE		5
+#define COMMAND_STATUS		6
+#define COMMAND_RESEND		7
+#define COMMAND_LRNRAW		8
+#define COMMAND_LRNRPT		9
+#define COMMAND_LRNTOG		10
+#define COMMAND_SETSTAT		11
+#define COMMAND_LRNLONG		12
+#define COMMAND_LRNRAWRPT	13
+#define COMMAND_RELOAD		14
+#define COMMAND_LCD			15
+#define COMMAND_LEARNSTAT	16
+#define COMMAND_TEMP		17
+#define COMMAND_GETREMOTES	18
+#define COMMAND_GETCOMMANDS	19
+#define COMMAND_STORETRANS	20
+#define COMMAND_LOADTRANS	21
+#define COMMAND_SAVETRANS	22
+#define COMMAND_FLASHTRANS	23
+#define	COMMAND_FUNCTIONS	24
+#define	COMMAND_TESTCOM		25
+#define	COMMAND_LONGSEND	26
+#define	COMMAND_SHUTDOWN	27
+#define COMMAND_SENDCCF		28
+#define COMMAND_LCDINIT		29
+#define COMMAND_SETSWITCH	30
+#define COMMAND_STATUSEX	31
+#define COMMAND_RESET		32
+#define	STATUS_MESSAGE		1
+#define	STATUS_TIMING		2
+#define	STATUS_DEVICEMODE	3
+#define	STATUS_RECEIVE		4
+#define STATUS_LEARN		5
+#define STATUS_REMOTELIST	6
+#define STATUS_COMMANDLIST	7
+#define STATUS_TRANSLATE	8
+#define STATUS_FUNCTION		9
+#define	STATUS_DEVICEMODEEX	10
+#pragma pack(1)
+    typedef struct {
+    uint8_t mode;
+    uint8_t time_cnt;
+    uint8_t ir_repeat;
+    uint8_t repeat_pause;
+    uint16_t pause_len[TIME_LEN];
+    uint16_t pulse_len[TIME_LEN];
+    uint8_t data[CODE_LEN];
+} TIMINGDATA;
+typedef struct {
+    uint8_t netcommand;
+    uint8_t mode;
+    uint16_t timeout;
+    int32_t adress;
+    int8_t remote[80];
+    int8_t command[20];
+    uint8_t trasmit_freq;
+} OLD_NETWORKCOMMAND;
+typedef struct {
+    uint8_t netcommand;
+    uint8_t mode;
+    uint8_t lcdcommand;
+    uint8_t timeout;
+    int32_t adress;
+    uint8_t wid;
+    uint8_t hgt;
+    int8_t framebuffer[200];
+} OLD_LCDCOMMAND;
+typedef struct {
+    uint8_t netcommand;
+    uint8_t mode;
+    uint16_t timeout;
+    int32_t adress;
+    int32_t protocol_version;
+    int8_t remote[80];
+    int8_t command[20];
+    uint8_t trasmit_freq;
+} NETWORKCOMMAND;
+typedef struct {
+    uint8_t netcommand;
+    uint8_t mode;
+    uint16_t timeout;
+    int32_t adress;
+    int32_t protocol_version;
+    uint16_t sendmask[32];
+    uint16_t pronto_data[256];
+} CCFCOMMAND;
+typedef struct {
+    uint8_t netcommand;
+    uint8_t mode;
+    uint8_t lcdcommand;
+    uint8_t timeout;
+    int32_t adress;
+    int32_t protocol_version;
+    uint8_t wid;
+    uint8_t hgt;
+    int8_t framebuffer[200];
+} LCDCOMMAND;
+typedef struct {
+    uint8_t netcommand;
+    uint8_t mode;
+    uint16_t timeout;
+    int32_t adress;
+    int32_t protocol_version;
+    int32_t number;
+    uint8_t setup;
+    uint8_t type;
+    uint8_t accelerator_timeout;
+    uint8_t accelerator_repeat;
+    uint16_t wait_timeout;
+    uint8_t remote_num;
+    uint8_t group_num;
+    int8_t remote[80];
+    int8_t command[20];
+    int32_t source_mask;
+    int32_t target_mask;
+} TRANSLATECOMMAND;
+typedef struct {
+    int32_t send_mask;
+    uint8_t device_mode;
+    uint8_t extended_mode;
+    uint16_t switch_mode;
+    uint16_t features;
+    int8_t version[10];
+    int8_t remote[80];
+    int8_t command[20];
+} MODELINE;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int16_t adress;
+    uint8_t align[2];
+    int8_t data[16384];
+} STATUSBUFFER;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int32_t serno;
+    int32_t functions;
+} FUNCTIONBUFFER;
+typedef struct {
+    int32_t target_mask;
+    int32_t source_mask;
+    int8_t name[80];
+} REMOTELINE;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int16_t offset;
+    int16_t count_buffer;
+    int16_t count_total;
+    int16_t count_remaining;
+    REMOTELINE remotes[40];
+} REMOTEBUFFER;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int16_t offset;
+    int16_t count_buffer;
+    int16_t count_total;
+    int16_t count_remaining;
+    int8_t commands[200][20];
+} COMMANDBUFFER;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int16_t offset;
+    int16_t count_buffer;
+    int16_t count_total;
+    int16_t count_remaining;
+    TRANSLATECOMMAND trdata[30];
+} TRANSLATEBUFFER;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int16_t adress;
+    uint8_t align[2];
+    MODELINE stat[16];
+} NETWORKMODE;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int16_t adress;
+    uint8_t align;
+    uint8_t count;
+    uint8_t dev_adr[8];
+    MODELINE stat[8][16];
+} NETWORKMODEEX;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int16_t adress;
+    uint16_t netstatus;
+    uint16_t statuslevel;
+    uint8_t align[2];
+    int8_t message[256];
+} NETWORKSTATUS;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int16_t adress;
+    uint8_t align[2];
+    TIMINGDATA timing;
+} NETWORKTIMING;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int16_t adress;
+    uint16_t command_num;
+    int8_t remote[80];
+    int8_t command[20];
+    int8_t data[200];
+} NETWORKRECV;
+typedef struct {
+    uint32_t clientid;
+    int16_t statuslen;
+    int16_t statustype;
+    int16_t adress;
+    int16_t learnok;
+    int8_t remote[80];
+    int16_t num_timings;
+    int16_t num_commands;
+    int8_t received[CODE_LEN];
+} NETWORKLEARNSTAT;
+typedef struct {
+    SOCKET fd;
+    int32_t type;
+    uint32_t clientid;
+    uint32_t callno;
+    int8_t ip[20];
+    WSAEVENT event;
+    FILE * fp;
+    int32_t timing;
+    uint8_t resend_load;
+    IRDATA ird;
+    NETWORKLEARNSTAT learnstatus;
+    int8_t restdata[sizeof(LCDCOMMAND)];
+    int32_t restlen;
+    int32_t restread;
+}
+NETWORKCLIENT;
+
+#define TCP_PORT		21000
+#define LIRC_PORT		8765
+#define UDP_PORT		6510
+#define WEB_PORT		80
+#define ALTERNATE_WEB	8080
+
+#ifdef WIN32
+#define CLIENT_COUNT	MAXIMUM_WAIT_OBJECTS - 3
+#endif                          /* 
+ */
+
+#ifdef LINUX
+#define CLIENT_COUNT	64
+#endif                          /* 
+ */
diff -Naur lcdproc-0.5.2-old/server/drivers/irtrans_remote.h lcdproc-0.5.2-new/server/drivers/irtrans_remote.h
--- lcdproc-0.5.2-old/server/drivers/irtrans_remote.h	1969-12-31 16:00:00.000000000 -0800
+++ lcdproc-0.5.2-new/server/drivers/irtrans_remote.h	2008-12-12 14:39:49.000000000 -0800
@@ -0,0 +1,193 @@
+/*
+ * irtrans driver
+ *
+ * Displays LCD screens, one after another; suitable for hard-copy
+ * terminals.
+ *
+ * Copyright (C) 1998-2007 <info@irtrans.de>
+ *
+ * Copyright (C) 2007 Phant0m <phantom@netkeke.com>
+ * porting the LCDproc 0.4.3 code to LCDproc 0.5.1
+ *
+ * Inspired by:
+ *  TextMode driver (LCDproc authors)
+ *  irtrans driver (Irtrans)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
+ */
+
+typedef unsigned char byte;
+typedef unsigned short word;
+
+#define CONTROL_LED		4
+
+#define USB_RXREADY		0
+#define USB_TXENABLE	1
+#define USB_WRITE		6
+#define	USB_READ		7
+
+#define	IR_LED			0
+#define	SBUS_DATA		1
+#define SBUS_INPUT		2
+#define	SBUS_TERM		3
+#define IR_INPUT		7
+
+
+#ifndef AVR
+#pragma pack(1)
+#define CODE_LEN	176     // 2 Byte mehr fÃ¼r String-Ende 0
+#else
+#define CODE_LEN	174
+
+#define	USB
+
+#endif
+
+#define TIME_LEN	6
+#define RAW_EXTRA	TIME_LEN * 4 + 2
+#define CODE_LENRAW	(CODE_LEN + RAW_EXTRA - 2)
+
+
+
+typedef struct {
+    byte len;
+    byte checksumme;
+    byte command;
+
+    byte address;
+    word target_mask;
+
+    byte ir_length;
+    byte transmit_freq;
+    byte mode;
+
+    word pause_len[TIME_LEN];
+    word pulse_len[TIME_LEN];
+    byte time_cnt;
+    byte ir_repeat;
+    byte repeat_pause;
+
+    byte data[CODE_LEN];
+} IRDATA;
+
+
+typedef struct {
+    byte len;
+    byte checksumme;
+    byte command;
+
+    byte address;
+    word target_mask;
+
+    byte ir_length;
+    byte transmit_freq;
+    byte mode;
+
+    byte data[CODE_LENRAW];
+} IRRAW;
+
+
+
+#define DEVMODE_PC			0
+#define DEVMODE_SEND		1
+#define DEVMODE_IR			2
+#define DEVMODE_SBUS		4
+#define DEVMODE_IRCODE		8
+#define DEVMODE_SBUSCODE	16
+
+#define DEVMODE_MASK		31
+
+#define DEVMODE_STATUS		128
+
+
+// IR Commands
+#define SBUS_REPEAT			1
+#define HOST_VERSION		2
+#define HOST_NETWORK_STATUS	3
+
+#define SBUS_SEND			4
+#define SBUS_RESEND			5
+#define HOST_SEND			6
+#define HOST_RESEND			7
+
+
+#define SBUS_LEARN			16
+#define HOST_LEARNIR		18
+
+#define SBUS_QUICKPARM		48
+#define HOST_LEARNIRQUICK	50
+
+#define SBUS_RAWMODE		80
+#define HOST_LEARNIRRAW		82
+
+#define SBUS_REPEATMODE		144
+#define HOST_LEARNIRREPEAT	146
+
+#define SBUS_RAWREPEATMODE		208
+#define HOST_LEARNIRRAWREPEAT	210
+
+#define SBUS_RESET			192
+#define SBUS_PING			193
+#define SBUS_PONG			194
+#define SBUS_PARAMETER		196
+#define HOST_SETMODE		197
+
+
+#define ADRESS_MASK			15
+#define ADRESS_LOCAL		16
+#define ADRESS_ALL			32
+
+
+#define	START_BIT			1
+#define REPEAT_START		2
+#define START_MASK			3
+#define RC5_DATA			4
+#define	RC6_DATA			8
+#define	RAW_DATA			16
+
+#define LCD_DATA			32
+#define LCD_BACKLIGHT		1
+#define LCD_TEXT			2
+#define DEFAULT_FREQ		39
+#define RAW_FREQ			38
+#define IR_CORRECT			8       // Entspricht 64 Âµs Korrektur
+#define RCX_TOLERANCE		19      // Entspricht 152 Âµs Toleranz
+#define IR_TOLERANCE		15      // Entspricht 120 Âµs Toleranz
+#define RAW_TOLERANCE		20
+typedef struct {
+    byte sbus_len;
+    byte sbus_checksumme;
+    byte sbus_command;
+    byte sbus_address;
+    byte mode;
+    word target_mask;
+    byte hotcode_len;
+    byte hotcode[100];
+} MODE_BUFFER;
+
+typedef struct {
+    byte sbus_len;
+    byte sbus_checksumme;
+    byte sbus_command;
+    byte sbus_address;
+    byte device_mode;
+    word send_mask;
+    byte version[10];
+} STATUS_LINE;
+
+typedef struct {
+    byte my_adress;
+    STATUS_LINE stat[16];
+} STATUS_BUFFER;
diff -Naur lcdproc-0.5.2-old/server/drivers/Makefile.am lcdproc-0.5.2-new/server/drivers/Makefile.am
--- lcdproc-0.5.2-old/server/drivers/Makefile.am	2008-12-12 14:38:25.000000000 -0800
+++ lcdproc-0.5.2-new/server/drivers/Makefile.am	2008-12-12 14:41:49.000000000 -0800
@@ -19,7 +19,7 @@
 #LIBS =
 
 pkglib_PROGRAMS = @DRIVERS@
-EXTRA_PROGRAMS = bayrad CFontz CFontz633 CFontzPacket curses CwLnx ea65 EyeboxOne g15 glcdlib glk hd44780 icp_a106 imon imonlcd IOWarrior irman joy lb216 lcdm001 lcterm lirc MD8800 ms6931 mtc_s16209x MtxOrb NoritakeVFD picolcd pyramid sed1330 sed1520 serialPOS serialVFD stv5730 svga t6963 text tyan sli ula200 xosd dm140
+EXTRA_PROGRAMS = bayrad CFontz CFontz633 CFontzPacket curses CwLnx ea65 EyeboxOne g15 glcdlib glk hd44780 icp_a106 imon imonlcd IOWarrior irman joy lb216 lcdm001 lcterm lirc MD8800 ms6931 mtc_s16209x MtxOrb NoritakeVFD picolcd pyramid sed1330 sed1520 serialPOS serialVFD stv5730 svga t6963 text tyan sli ula200 xosd dm140 irtrans
 noinst_LIBRARIES = libLCD.a libbignum.a
 
 IOWarrior_CFLAGS =   @libusb_cflags@ $(AM_CFLAGS)
@@ -104,6 +104,7 @@
 sli_SOURCES =        lcd.h lcd_lib.h wirz-sli.h wirz-sli.c report.h
 xosd_SOURCES =       lcd.h xosdlib_drv.c xosdlib_drv.h report.h
 dm140_SOURCES =      lcd.h led.c libvfd.h led.h dm140.c dm140.h report.h
+irtrans_SOURCES =    lcd.h irtrans.c irtrans.h irtrans_network.h irtrans_remote.h irtrans_errcode.h report.h
 
 AM_CPPFLAGS = -I$(top_srcdir)
 
