#!/bin/sh
################################################################################
# functions
################################################################################
/usr/bin/test -n "${MM_DEBUG}" && set -x

. /etc/conf

#===============================================================================
# general functions.
#===============================================================================
mm_command_run() {
    COMMAND=$1

    if /usr/bin/test "${MM_DEBUG}" = "yes" ; then
        LOG_DIR="/var/log"
        LOG_FILE="/var/log/minimyth.log"
    else
        LOG_DIR="/dev"
        LOG_FILE="/dev/null"
    fi

    RETURN=0
    if /usr/bin/test -w "${LOG_FILE}" || /usr/bin/test -w "${LOG_DIR}" ; then
        /bin/echo "--- execution start: ${COMMAND}"  >> "${LOG_FILE}" 2>&1
        ${COMMAND}                              >> "${LOG_FILE}" 2>&1
        RETURN=$?
        /bin/echo "--- execution end  : ${COMMAND}"  >> "${LOG_FILE}" 2>&1
    else
        /bin/echo "--- execution start: ${COMMAND}"                   2>&1
        ${COMMAND}                              2>&1
        RETURN=$?
        /bin/echo "--- execution end  : ${COMMAND}"                   2>&1
    fi

    return ${RETURN}
}

mm_conf_get() {
    REMOTE_FILE=$1
    LOCAL_FILE=$2

    LOCAL_DIR=`/bin/echo "${LOCAL_FILE}" | /bin/sed -e 's%[^/]*$%%' -e 's%/$%%'`
    /usr/bin/test -n "${LOCAL_DIR}" && /bin/mkdir -p "${LOCAL_DIR}"

    TMP_FILE="${LOCAL_FILE}~"

    /bin/rm -f "${TMP_FILE}"
    FILE_GOT=
    if /usr/bin/test -d "/minimyth" ; then
        /usr/bin/test -z "${FILE_GOT}" && /usr/bin/test -n "`/bin/hostname`" && /usr/bin/test -e "/minimyth/conf/`/bin/hostname`/${REMOTE_FILE}" &&
	    /bin/cp          "/minimyth/conf/`/bin/hostname`/${REMOTE_FILE}"                "${TMP_FILE}"                     && 
	    FILE_GOT="retrieved configuration file '${REMOTE_FILE}' from local directory '/minimyth/conf/`/bin/hostname`'"
        /usr/bin/test -z "${FILE_GOT}" &&                             /usr/bin/test -e "/minimyth/conf/default/${REMOTE_FILE}"         &&
	    /bin/cp          "/minimyth/conf/default/${REMOTE_FILE}"                        "${TMP_FILE}"                     &&
	    FILE_GOT="retrieved configuration file '${REMOTE_FILE}' from local directory '/minimyth/conf/default'"
    else
        /usr/bin/test -z "${FILE_GOT}" && /usr/bin/test -n "`/bin/hostname`" &&
            /usr/bin/tftp -g -r "${MM_TFTP_ROOTDIR}/conf/`/bin/hostname`/${REMOTE_FILE}" -l "${TMP_FILE}" "${MM_TFTP_SERVER}" &&
	    FILE_GOT="retrieved configuration file '${REMOTE_FILE}' from remote TFTP directory '${MM_TFTP_SERVER}/conf/`/bin/hostname`'"
        /usr/bin/test -z "${FILE_GOT}" && 
            /usr/bin/tftp -g -r "${MM_TFTP_ROOTDIR}/conf/default/${REMOTE_FILE}"         -l "${TMP_FILE}" "${MM_TFTP_SERVER}" &&
	    FILE_GOT="retrieved configuration file '${REMOTE_FILE}' from remote TFTP directory '${MM_TFTP_ROOTDIR}/conf/default'"
    fi
    if /usr/bin/test -n "${FILE_GOT}" ; then
        /bin/mv -f "${TMP_FILE}" "${LOCAL_FILE}"
        /usr/bin/logger    -t minimyth -p "local0.info" "${FILE_GOT}"
    fi
    /bin/rm -f "${TMP_FILE}"
}

mm_message_output() {
    LEVEL=$1
    MESSAGE=$2

    if /usr/bin/test `mm_splash_running_test ; /bin/echo $?` -eq 0 ; then
        /usr/bin/logger    -t minimyth -p "local0.${LEVEL}" "${MESSAGE}"
        mm_splash_message_output "${MESSAGE}"
    else
        /usr/bin/logger -s -t minimyth -p "local0.${LEVEL}" "${MESSAGE}"
    fi
}

mm_uniq() {
    if /usr/bin/test $# -eq 0 ; then
        ARG=
        while read line ; do
            ARG="${ARG} ${line}"
        done
    else
        ARG=$1
    fi

    /bin/echo `/bin/echo "${ARG}" | /bin/sed -e 's% %\n%g' | /usr/bin/sort | /usr/bin/uniq | /bin/sed -e :a -e '$!N;s/\n/ /;ta' -e 'P;D'`
}

#-------------------------------------------------------------------------------
# mm_update
#-------------------------------------------------------------------------------
mm_update() {
    # Make sure there is not an unrestored backup directory.
    if /usr/bin/test -e /minimyth/backup ; then
        /bin/echo "error: mm_update will not run when the backup directory '/minimyth/backup' exists."
        /bin/false
        return
    fi
    # Make sure that MM_UPDATE_URL protocol is valid.
    PROTOCOL=`/bin/echo "${MM_UPDATE_URL}" | /usr/bin/cut -d? -f1 | /usr/bin/cut -d: -f1`
    case ${PROTOCOL} in
        http)
            ;;
        tftp)
            ;;
        file)
            ;;
        *)
            mm_update_exit 1 "unknown protocol '${PROTOCOL}' used update in URL '${MM_UPDATE_URL}'." || return
            ;;
    esac
    # Make sure that /minimyth is a default local boot MiniMyth configuration.
    if /usr/bin/test ! -d /minimyth ; then
        mm_update_exit 1 "mm_update can only be run on MiniMyth frontends that use local boot." || return
    fi
    if /usr/bin/test ! -f /minimyth/kernel ; then
        mm_update_exit 1 "mm_update requires that the MiniMyth kernel file be located at '/minimyth/kernel'." || return
    fi
    if /usr/bin/test ! -f /minimyth/rootfs ; then
        mm_update_exit 1 "mm_update requires that the MiniMyth root file system image be located at '/minimyth/rootfs'." || return
    fi
    # Perpare update directories.
    if /usr/bin/test -e /tmp/minimyth-update ; then
        /bin/rm -rf /tmp/minimyth-update
    fi
    if /usr/bin/test -e /minimyth/update ; then
        /bin/rm -rf /minimyth/update
    fi
    # Determine old MiniMyth version.
    VERSION_OLD='unknown'
    cd /minimyth ; /usr/bin/test -e version && /usr/bin/test -e checksums.md5 && /usr/bin/md5sum -c -s checksums.md5
    if /usr/bin/test $? -eq 0 ; then
        VERSION_OLD=`/bin/cat /minimyth/version`
    fi
    # Determine new MiniMyth version.
    /bin/mkdir -p /tmp/minimyth-update
    mm_update_fetch ${MM_UPDATE_URL}/version /tmp/minimyth-update/version
    if /usr/bin/test $? -ne 0 || /usr/bin/test ! -e /tmp/minimyth-update/version ; then
        mm_update_exit 1 "failed to retrieve MiniMyth version file from '${MM_UPDATE_URL}'." || return
    fi
    VERSION_NEW=`/bin/cat /tmp/minimyth-update/version`
    # Check whether or not the user wants to update MiniMyth.
    /bin/echo ''
    /bin/echo "current MiniMyth version: ${VERSION_OLD}"
    /bin/echo "new     MiniMyth version: ${VERSION_NEW}"
    /bin/echo ''
    read -p 'update MiniMyth version [N/y]? ' UPDATE
    /bin/echo ''
    if /usr/bin/test ! "${UPDATE}" = "y" && /usr/bin/test ! "${UPDATE}" = "Y" ; then
        mm_update_exit 0 "uptade aborted due to user request."
        return
    fi
    # Create the file lists.
    FILES_UPDATE_REQUIRED="version kernel-${VERSION_NEW} rootfs-${VERSION_NEW}"
    FILES_UPDATE_OPTIONAL="extras-${VERSION_NEW}.sfs"
    FILES_UPDATE="${FILES_UPDATE_REQUIRED} ${FILES_UPDATE_OPTIONAL}"
    FILES_BACKUP=`echo "checksums.md5 ${FILES_UPDATE}" | /bin/sed -e "s%-${VERSION_NEW}%%g"`
    # Retrieve files and corresponding checksum files.
    mkdir -p /tmp/minimyth-update
    mkdir -p /minimyth/update
    for FILE in ${FILES_UPDATE} ; do
        mm_update_fetch ${MM_UPDATE_URL}/${FILE}.md5 /tmp/minimyth-update/${FILE}.md5
        if /usr/bin/test $? -ne 0 || /usr/bin/test ! -e /tmp/minimyth-update/${FILE}.md5 ; then
            /bin/rm -f /tmp/minimyth-update/${FILE}.md5
        fi
        if /usr/bin/test -e /tmp/minimyth-update/${FILE}.md5 ; then
            mm_update_fetch ${MM_UPDATE_URL}/${FILE} /minimyth/update/${FILE}
            if /usr/bin/test $? -ne 0 || /usr/bin/test ! -e /minimyth/update/${FILE} ; then
                /bin/rm -f /minimyth/update/${FILE}
                /bin/rm -f /tmp/minimyth-update/${FILE}.md5
            fi
        fi
    done
    # Make sure that we have the required files.
    for FILE in ${FILES_UPDATE_REQUIRED} ; do
        if /usr/bin/test ! -e /minimyth/update/${FILE} ; then
            mm_update_exit 1 "failed to retrieve file '${FILE}' from '${MM_UPDATE_URL}'." || return
        fi
    done
    # Let the user know which optional files will not be updated.
    for FILE in ${FILES_UPDATE_OPTIONAL} ; do
        if /usr/bin/test ! -e /minimyth/update/${FILE} ; then
            /bin/echo "info: '${FILE}' not retrieved from '${MM_UPDATE_URL}'." || return
        fi
    done
    # Make sure that the checksums pass.
    for FILE in ${FILES_UPDATE} ; do
        if /usr/bin/test -e /minimyth/update/${FILE} ; then
            cd /minimyth/update ; /usr/bin/md5sum -c -s /tmp/minimyth-update/${FILE}.md5
            if /usr/bin/test $? -ne 0 ; then
                mm_update_exit 1 "checksum failed on file '${FILE}' from '${MM_UPDATE_URL}'." || return
            fi
        fi
    done
    # Backup existing files.
    mkdir -p /minimyth/backup
    for FILE in ${FILES_BACKUP} ; do
        if /usr/bin/test -e /minimyth/${FILE} ; then
            mv /minimyth/${FILE} /minimyth/backup/${FILE}
        fi
    done
    # Update files and create checksums file.
    for FILE in ${FILES_UPDATE} ; do
        FILE_OLD=${FILE}
        FILE_NEW=`echo ${FILE} | sed -e "s%-${VERSION_NEW}%%"`
        if   /usr/bin/test -e /minimyth/update/${FILE_OLD} ; then
            cd /minimyth/update ; /usr/bin/md5sum ${FILE_OLD} >> /minimyth/checksums.md5
            /bin/mv /minimyth/update/${FILE_OLD} /minimyth/${FILE_NEW}
            /bin/sed -e "s%${FILE_OLD}%${FILE_NEW}%g" -i /minimyth/checksums.md5
        elif /usr/bin/test -e /minimyth/backup/${FILE_NEW} ; then
            cd /minimyth/backup ; /usr/bin/md5sum ${FILE_NEW} >> /minimyth/checksums.md5
            /bin/cp /minimyth/backup/${FILE_NEW} /minimyth/${FILE_NEW}
        fi
    done
    # Check the checksums.
    cd /minimyth ; /usr/bin/test -e checksums.md5 && /usr/bin/md5sum -c -s checksums.md5
    if /usr/bin/test $? -ne 0 ; then
        mm_update_exit 1 "final checksums failed." || return
    fi
    # Let user know that the update succeeded.
    mm_update_exit 0 "MiniMyth update was successful." || return
}

mm_update_exit() {
    status="$1"
    message="$2"

    if /usr/bin/test ${status} -ne 0 ; then
        if /usr/bin/test -e /minimyth/backup ; then
            /bin/cat /minimyth/checksums.md5 | /bin/sed -e 's%  *% %g' | /usr/bin/cut -d ' ' -f 2 | 
            while read FILE ; do
                /bin/rm -f /minimyth/${FILE}
            done
            /bin/rm -f /minimyth/checksums.md5
            /bin/mv /minimyth/backup/* /minimyth/
        fi
    fi

    /usr/bin/test -e /tmp/minimyth-update && /bin/rm -rf /tmp/minimyth-update
    /usr/bin/test -e /minimyth/update     && /bin/rm -rf /minimyth/update
    /usr/bin/test -e /minimyth/backup     && /bin/rm -rf /minimyth/backup

    if /usr/bin/test ${status} -eq 0 ; then
        /bin/echo "info: ${message}"
        /bin/true
    else
        /bin/echo "error: ${message}"
        /bin/false
    fi

    return
}

mm_update_fetch() {
    URL="$1"
    LOCAL_FILE="$2"

    URL_PROTOCOL=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                  /usr/bin/cut -d: -f1`
    URL_USERNAME=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                  /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//%%' | /bin/sed 's%[^@]*$%%'  | /bin/sed 's%@$%%' | /usr/bin/cut -d: -f1`
    URL_PASSWORD=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                  /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//%%' | /bin/sed 's%[^@]*$%%'  | /bin/sed 's%@$%%' | /usr/bin/cut -d: -f2`
    URL_SERVER=`  /bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                  /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//%%' | /bin/sed 's%^[^@]*@%%' | /bin/sed 's%/[^/]*%%g'`
    URL_PATH=`    /bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                  /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//[^/]*/%/%'`
    URL_OPTIONS=` /bin/echo "${URL}"                        | \
                  /bin/sed 's%^[^?]*%%'  | /bin/sed 's%^?%%'`

    case ${URL_PROTOCOL} in
        http)
            /bin/echo "info: fetching file '${URL}'."
            /usr/bin/wget "${URL}" -O "${LOCAL_FILE}"
            return
            ;;
        tftp)
            /bin/echo "info: fetching file '${URL}'."
            /usr/bin/tftp -g -r "${URL_PATH}" -l "${LOCAL_FILE}" "${URL_SERVER}"
            return
            ;;
        file)
            /bin/echo "info: fetching file '${URL}'."
            /bin/cp -f "${URL_PATH}" "${LOCAL_FILE}"
            return
            ;;
        *)
            /bin/false
            return
            ;;
    esac
}

#-------------------------------------------------------------------------------
# mm_url_mount
#
# This function mounts a remote directory as a local directory.
#
# This function takes three arguments:
#     URL: required argument:
#         A URL that points to the remote directory. A URL must have the
#         following form:
#             <protocol>://<username>:<password>@<server>/<path>?<options>
#         where <options> are additional mount options (-o).
#         For example:
#             nfs://server.home/home/public/music
#             cifs://user:pass@server.home/home/public/music,domain=home
#             conf:themecache.tar.bz2
#         The valid protocol values are: nfs, cifs, tftp, file and conf. For
#         nfs and cifs the URL points to a remote directory. For tftp, the URL
#         points to a tarfile (*.tar.bz2), a cramfs image (*.cmg) or a squashfs
#         image (*.sfs) on a TFTP server that will be downloaded and expanded
#         into (for files) or downloaded and mounted at (for images) the mount
#         point. For file, the URL point to a tarfile (*.tar.bz2), a cramfs
#         image (*.cmg), a squashfs image (*.sfs) or a directory on the local
#         file system that will be copied and expanded into (for files), copied
#         and mounted at (for images) or mounted at (for directories) the mount
#         point. For conf, the URL points to a tarfile (*.tar.bz2), a cramfs
#         image (*.cmg) or squashfs image (*.sfs) in the MiniMyth configuration
#         directory will be downloaded/copied and expanded into (for files) or
#         downloaded/copied and mounted at (for images) the mount point.
#     MOUNT_DIR: required argument:
#         The local directory (e.g. /mnt/music) where the URL will be mounted.
#-------------------------------------------------------------------------------
mm_url_mount() {
    URL="$1"
    MOUNT_DIR="$2"

    /bin/mkdir -p "${MOUNT_DIR}"

    URL_PROTOCOL=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                  /usr/bin/cut -d: -f1`
    URL_USERNAME=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                  /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//%%' | /bin/sed 's%[^@]*$%%'  | /bin/sed 's%@$%%' | /usr/bin/cut -d: -f1`
    URL_PASSWORD=`/bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                  /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//%%' | /bin/sed 's%[^@]*$%%'  | /bin/sed 's%@$%%' | /usr/bin/cut -d: -f2`
    URL_SERVER=`  /bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                  /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//%%' | /bin/sed 's%^[^@]*@%%' | /bin/sed 's%/[^/]*%%g'`
    URL_PATH=`    /bin/echo "${URL}" | /usr/bin/cut -d? -f1 | \
                  /bin/sed 's%^[^:]*:%%' | /bin/sed 's%^//[^/]*/%/%'`
    URL_OPTIONS=` /bin/echo "${URL}"                        | \
                  /bin/sed 's%^[^?]*%%'  | /bin/sed 's%^?%%'`

    URL_FILE=`    /bin/echo "${URL_PATH}" | /bin/sed 's%^.*/%%'`
    URL_EXTMAX=`  /bin/echo "${URL_FILE}" | /bin/sed 's%^.*/%%' |/bin/sed 's%[^.]*%%g' | /usr/bin/wc -c` 
    URL_EXT1=
    /usr/bin/test ${URL_EXTMAX} -ge 1 && URL_EXT1=`/bin/echo ${URL_FILE} | /bin/sed 's%^.*/%%' | /usr/bin/cut -s -d. -f$((${URL_EXTMAX}-0))`
    URL_EXT2=
    /usr/bin/test ${URL_EXTMAX} -ge 2 && URL_EXT2=`/bin/echo ${URL_FILE} | /bin/sed 's%^.*/%%' | /usr/bin/cut -s -d. -f$((${URL_EXTMAX}-1))`

    MOUNT_VFSTYPE=""
    EXTRA_OPTIONS=""
    MOUNT_DEVICE=""
    MOUNT_OPTIONS="${URL_OPTIONS}"
    if   /usr/bin/test "${URL_PROTOCOL}" = "nfs" ; then
        MOUNT_VFSTYPE="nfs"
        MOUNT_DEVICE="${URL_SERVER}:${URL_PATH}"
        MOUNT_OPTIONS="${MOUNT_OPTIONS},rsize=8192,wsize=8192"
    elif /usr/bin/test "${URL_PROTOCOL}" = "cifs" ; then
        MOUNT_VFSTYPE="cifs"
        EXTRA_OPTIONS="-n"
        MOUNT_DEVICE="//${URL_SERVER}${URL_PATH}"
        if /usr/bin/test ! "${URL_USERNAME}" = "" ; then
            MOUNT_OPTIONS="${MOUNT_OPTIONS},username=${URL_USERNAME}"
        fi
        if /usr/bin/test ! "${URL_PASSWORD}" = "" ; then
            MOUNT_OPTIONS="${MOUNT_OPTIONS},password=${URL_PASSWORD}"
        fi
    elif /usr/bin/test "${URL_PROTOCOL}" = "tftp" ; then
        if   /usr/bin/test "${URL_EXT1}" = "sfs" ; then
            DIR="/initrd/rw/loopfs/`/bin/echo ${MOUNT_DIR} | /bin/sed 's%//*%~%g'`"
            FILE="image.sfs"
            /bin/mkdir -p "${DIR}"
            /bin/mkdir -p "${DIR}/ro"
            /bin/mkdir -p "${DIR}/rw"
            cd "${DIR}"
            /usr/bin/tftp -g -r "${URL_PATH}" -l "${FILE}" "${URL_SERVER}"
            /bin/mount -t squashfs -o loop "${DIR}/${FILE}" "${DIR}/ro"
            /bin/mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none "${MOUNT_DIR}"
        elif /usr/bin/test "${URL_EXT1}" = "cmg" ; then
            DIR="/initrd/rw/loopfs/`/bin/echo ${MOUNT_DIR} | /bin/sed 's%//*%~%g'`"
            FILE="image.cmg"
            /bin/mkdir -p "${DIR}"
            /bin/mkdir -p "${DIR}/ro"
            /bin/mkdir -p "${DIR}/rw"
            cd "${DIR}"
            /usr/bin/tftp -g -r "${URL_PATH}" -l "${FILE}" "${URL_SERVER}"
            /bin/mount -t cramfs -o loop "${DIR}/${FILE}" "${DIR}/ro"
            /bin/mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none "${MOUNT_DIR}"
        elif /usr/bin/test "${URL_EXT1}" = "bz2" && /usr/bin/test "${URL_EXT2}" = "tar" ; then
            TARFILE="tmp.tar.bz2~"
            cd "${MOUNT_DIR}"
            /usr/bin/tftp -g -r "${URL_PATH}" -l "${TARFILE}" "${URL_SERVER}"
            /bin/tar -jxf "${TARFILE}"
            /bin/rm -f "${TARFILE}"
        fi
    elif /usr/bin/test "${URL_PROTOCOL}" = "conf" ; then
        if   /usr/bin/test "${URL_EXT1}" = "sfs" ; then
            DIR="/initrd/rw/loopfs/`/bin/echo ${MOUNT_DIR} | /bin/sed 's%//*%~%g'`"
            FILE="image.sfs"
            /bin/mkdir -p "${DIR}"
            /bin/mkdir -p "${DIR}/ro"
            /bin/mkdir -p "${DIR}/rw"
            cd "${DIR}"
            mm_conf_get "${URL_PATH}" "${FILE}"
            /bin/mount -t squashfs -o loop "${DIR}/${FILE}" "${DIR}/ro"
            /bin/mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none "${MOUNT_DIR}"
        elif /usr/bin/test "${URL_EXT1}" = "cmg" ; then
            DIR="/initrd/rw/loopfs/`/bin/echo ${MOUNT_DIR} | /bin/sed 's%//*%~%g'`"
            FILE="image.cmg"
            /bin/mkdir -p "${DIR}"
            /bin/mkdir -p "${DIR}/ro"
            /bin/mkdir -p "${DIR}/rw"
            cd "${DIR}"
            mm_conf_get "${URL_PATH}" "${FILE}"
            /bin/mount -t cramfs -o loop "${DIR}/${FILE}" "${DIR}/ro"
            /bin/mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none "${MOUNT_DIR}"
        elif /usr/bin/test "${URL_EXT1}" = "bz2" && /usr/bin/test "${URL_EXT2}" = "tar" ; then
            TARFILE="tmp.tar.bz2~"
            cd "${MOUNT_DIR}"
            mm_conf_get "${URL_PATH}" "${TARFILE}"
            /bin/tar -jxf "${TARFILE}"
            /bin/rm -f "${TARFILE}"
        fi
    elif /usr/bin/test "${URL_PROTOCOL}" = "file" ; then
        if   /usr/bin/test -f "${URL_PATH}" ; then
            if   /usr/bin/test "${URL_EXT1}" = "sfs" ; then
                DIR="/initrd/rw/loopfs/`/bin/echo ${MOUNT_DIR} | /bin/sed 's%//*%~%g'`"
                FILE="image.sfs"
                /bin/mkdir -p "${DIR}"
                /bin/mkdir -p "${DIR}/ro"
                /bin/mkdir -p "${DIR}/rw"
                cd "${DIR}"
                /bin/cp "${URL_PATH}" "${FILE}"
                /bin/mount -t squashfs -o loop "${DIR}/${FILE}" "${DIR}/ro"
                /bin/mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none "${MOUNT_DIR}"
            elif /usr/bin/test "${URL_EXT1}" = "cmg" ; then
                DIR="/initrd/rw/loopfs/`/bin/echo ${MOUNT_DIR} | /bin/sed 's%//*%~%g'`"
                FILE="image.cmg"
                /bin/mkdir -p "${DIR}"
                /bin/mkdir -p "${DIR}/ro"
                /bin/mkdir -p "${DIR}/rw"
                cd "${DIR}"
                /bin/cp "${URL_PATH}" "${FILE}"
                /bin/mount -t cramfs -o loop "${DIR}/${FILE}" "${DIR}/ro"
                /bin/mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none "${MOUNT_DIR}"
            elif /usr/bin/test "${URL_EXT1}" = "bz2" && /usr/bin/test "${URL_EXT2}" = "tar" ; then
                TARFILE="tmp.tar.bz2~"
                cd "${MOUNT_DIR}"
                /bin/cp "${URL_PATH}" "${TARFILE}"
                /bin/tar -jxf "${TARFILE}"
                /bin/rm -f "${TARFILE}"
            fi
        elif /usr/bin/test -d "${URL_PATH}" ; then
            /bin/mount --rbind "${URL_PATH}" "${MOUNT_DIR}"
        fi
    fi

    if /usr/bin/test -n "${MOUNT_VFSTYPE}" ; then
        OPTIONS=""
        MOUNT_OPTIONS=`/bin/echo ${MOUNT_OPTIONS} | /bin/sed 's%^,%%'`
        /usr/bin/test -n "${EXTRA_OPTIONS}" && OPTIONS="${EXTRA_OPTIONS}"
        /usr/bin/test -n "${MOUNT_OPTIONS}" && OPTIONS="${OPTIONS} -o ${MOUNT_OPTIONS}"
        /bin/mount -n -t "${MOUNT_VFSTYPE}" ${OPTIONS} "${MOUNT_DEVICE}" "${MOUNT_DIR}"
    fi

    # Update fstab.
    case "${MOUNT_VFSTYPE}" in
        cifs)
            /bin/echo "${MOUNT_DEVICE} ${MOUNT_DIR} ${MOUNT_VFSTYPE} ${MOUNT_OPTIONS} 0 0" >> /etc/fstab
            ;;
        nfs)
            /bin/echo "${MOUNT_DEVICE} ${MOUNT_DIR} ${MOUNT_VFSTYPE} ${MOUNT_OPTIONS} 0 0" >> /etc/fstab
            ;;
    esac
}

mm_var_get() {
    VAR=$1

    /bin/echo `set | /bin/grep "^${VAR}=" | /bin/sed 's%^[^=]*=%%' | /bin/sed "s%^'%%" | /bin/sed "s%'$%%"`
}

#===============================================================================
# squashfs functions
#===============================================================================
mm_squashfs_codecs_make() {
    if /usr/bin/test -d /usr/lib/codecs && /usr/bin/test `ls -1 /usr/lib/codecs | /usr/bin/wc -l` -ne 0 ; then
        /bin/true
    else
        /bin/rm -rf /usr/lib/codecs
        /bin/mkdir -p /usr/lib/codecs
        cd /usr/lib/codecs
        /usr/bin/wget http://www4.mplayerhq.hu/MPlayer/releases/codecs/essential-20060611.tar.bz2
        /bin/tar -jxf essential-20060611.tar.bz2
        /bin/rm -f essential-20060611.tar.bz2
        /bin/mv essential-20060611/* .
        /bin/rm -rf essential-20060611
    fi

    FILE=/codecs.sfs
    /usr/bin/mksquashfs /usr/lib/codecs ${FILE} > /dev/null 2>&1
    if /usr/bin/test $? -ne 0 ; then
        /bin/rm -f ${FILE}
        /bin/echo "error: mksquashfs failed."
        return 1
    fi

    /bin/chmod 644 ${FILE}

    /bin/echo "created codecs squashfs image: \"${FILE}\"."
    return 0
}

mm_squashfs_extras_make() {
    if /usr/bin/test ! -d /usr/local ; then
        /bin/echo "error: the extras directory does not exist."
        return 1
    fi

    INITRD_FILE=`/bin/echo ${initrd} | /bin/sed 's%^.*/%%'`
    INITRD_FILE_PREFIX=`/bin/echo ${INITRD_FILE} | /bin/sed 's%-.*$%%'`
    if /usr/bin/test "${INITRD_FILE_PREFIX}" = "rootfs" ; then
        FILE=/`/bin/echo ${INITRD_FILE} | /bin/sed 's%^rootfs%extras%'`.sfs
    else
        FILE=/extras.sfs
    fi

    /usr/bin/mksquashfs /usr/local ${FILE} > /dev/null 2>&1
    if /usr/bin/test $? -ne 0 ; then
        /bin/rm -f ${FILE}
        /bin/echo "error: mksquashfs failed."
        return 1
    fi

    /bin/chmod 644 ${FILE}

    /bin/echo "created extras squashfs image: \"${FILE}\"."
    return 0
}

mm_squashfs_themecache_make() {
    if /usr/bin/test ! -d /root/.mythtv/themecache ; then
        /bin/echo "error: the MythTV themecache directory does not exist."
        return 1
    fi
    if /usr/bin/test ! "`cd /root/.mythtv/themecache ; ls -1 | /bin/grep -c *`" = "1" ; then
        /bin/echo "error: the MythTV themecache directory does not contain exactly one cached theme."
        return 1
    fi

    FILE=/`cd /root/.mythtv/themecache ; ls`.sfs
    /usr/bin/mksquashfs /root/.mythtv/themecache ${FILE} > /dev/null 2>&1
    if /usr/bin/test $? -ne 0 ; then
        /bin/rm -f ${FILE}
        /bin/echo "error: mksquashfs failed."
        return 1
    fi

    /bin/chmod 644 ${FILE}

    /bin/echo "created themecache squashfs image: \"${FILE}\"."
    return 0
}

#===============================================================================
# splash screen functions
#===============================================================================
mm_splash_progress_val=1
mm_splash_progress_max=1

mm_splash_running_test() {
    if /usr/bin/test -n "`/bin/pidof splash_util`" && /usr/bin/test -e /var/cache/splash/fifo ; then
        return 0
    else
        return 1
    fi
}

mm_splash_init() {
    # Initialize progress variables.
    mm_splash_progress_val=0
    mm_splash_progress_max=$1

    SPLASH_ENABLE=yes

    # Disable splash screen when more than kernel errors are logged to the console.
    # That is when the loglevel is greater than 4.
    if /usr/bin/test "${SPLASH_ENABLE}" = "yes" ; then
        LOGLEVEL=`/bin/cat /proc/sys/kernel/printk | /usr/bin/cut -f 1`
        /usr/bin/test -z "${LOGLEVEL}" && SPLASH_ENABLE='no'
        /usr/bin/test -n "${LOGLEVEL}" && /usr/bin/test ${LOGLEVEL} -gt 4 && SPLASH_ENABLE='no'
    fi

    # Disable splash screen when there is no framebuffer device.
    if /usr/bin/test "${SPLASH_ENABLE}" = "yes" ; then
        /usr/bin/test ! -e '/dev/fb0' && SPLASH_ENABLE='no'
    fi

    # Disable splash screen when the video resolution is not compatible.
    # That is when the resolution is not 800x600 or color depth is less than 16.
    if /usr/bin/test "${SPLASH_ENABLE}" = "yes" ; then
        GEOMETRY=`/usr/sbin/fbset | /bin/grep geometry`
        XRES=` /bin/echo ${GEOMETRY} | /usr/bin/cut -d ' ' -f 2`
        YRES=` /bin/echo ${GEOMETRY} | /usr/bin/cut -d ' ' -f 3`
        VXRES=`/bin/echo ${GEOMETRY} | /usr/bin/cut -d ' ' -f 4`
        VYRES=`/bin/echo ${GEOMETRY} | /usr/bin/cut -d ' ' -f 5`
        DEPTH=`/bin/echo ${GEOMETRY} | /usr/bin/cut -d ' ' -f 6`
        /usr/bin/test -z "${XRES}"  && SPLASH_ENABLE='no'
        /usr/bin/test -z "${YRES}"  && SPLASH_ENABLE='no'
        /usr/bin/test -z "${VXRES}" && SPLASH_ENABLE='no'
        /usr/bin/test -z "${VYRES}" && SPLASH_ENABLE='no'
        /usr/bin/test -z "${DEPTH}" && SPLASH_ENABLE='no'
        /usr/bin/test -n "${XRES}"  && /usr/bin/test ${XRES}  -ne 800 && SPLASH_ENABLE='no'
        /usr/bin/test -n "${YRES}"  && /usr/bin/test ${YRES}  -ne 600 && SPLASH_ENABLE='no'
        /usr/bin/test -n "${VXRES}" && /usr/bin/test ${VXRES} -ne 800 && SPLASH_ENABLE='no'
        /usr/bin/test -n "${VYRES}" && /usr/bin/test ${VYRES} -ne 600 && SPLASH_ENABLE='no'
        /usr/bin/test -n "${DEPTH}" && /usr/bin/test ${DEPTH} -lt 16  && SPLASH_ENABLE='no'
    fi

    if /usr/bin/test "${SPLASH_ENABLE}" = "yes" ; then
        /usr/bin/chvt 1
        /bin/mkdir -p "/var/cache/splash"
        /sbin/splash_util --daemon --theme="MythTV"
        mm_splash_command "set mode silent"
        mm_splash_command "progress 0"
        mm_splash_command "set message starting splash screen ..."
        mm_splash_command "repaint"
    fi

    return 0
}

mm_splash_halt() {
    /usr/bin/test -n "`/bin/pidof -s splash_util`" && /usr/bin/killall splash_util

    /usr/bin/test -e "/var/cache/splash" && /bin/rm -rf "/var/cache/spalsh"

    return 0
}

mm_splash_command()
{
    /usr/bin/test `mm_splash_running_test ; /bin/echo $?` -eq 0 && /bin/echo "$1" >> "/var/cache/splash/fifo"

    return 0
}

mm_splash_message_output() {
    mm_splash_command "set message ${MESSAGE}"
    mm_splash_command "repaint"

    return 0
}

mm_splash_progress_update() {
    mm_splash_progress_val=$((mm_splash_progress_val + 1))
    /usr/bin/test ${mm_splash_progress_val} -gt ${mm_splash_progress_max} && mm_splash_progress_val=${mm_splash_progress_max}
    mm_splash_command "progress $(( 65535 * ${mm_splash_progress_val} / ${mm_splash_progress_max} ))"
    mm_splash_command "repaint"

    return 0
}

#===============================================================================
# mythdb functions.
#===============================================================================
mm_mythdb_command_run() {
    COMMAND=$1

    RETURN=0
    /usr/bin/mysql \
        --host=${MM_MYTH_SERVER} \
        --user=${MM_MYTH_DBUSERNAME} \
        --password=${MM_MYTH_DBPASSWORD} \
        --database=${MM_MYTH_DBNAME} \
        --execute="${COMMAND} ;"
    RETURN=$?

    return ${RETURN}
}

mm_mythdb_jumppoint_delete() {
    DESTINATION=$1
    HOSTNAME=`/bin/hostname`

    if /usr/bin/test -n "${DESTINATION}" ; then
        mm_mythdb_command_run "DELETE FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\" AND destination=\"${DESTINATION}\""
    else
        mm_mythdb_command_run "DELETE FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_jumppoint_dump() {
    DESTINATION=$1
    HOSTNAME=`/bin/hostname`

    if /usr/bin/test -n "${DESTINATION}" ; then
        mm_mythdb_command_run "SELECT * FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\" AND destination=\"${DESTINATION}\""
    else
        mm_mythdb_command_run "SELECT * FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_jumppoint_update() {
    DESTINATION=$1
    KEYLIST=$2
    HOSTNAME=`/bin/hostname`

    mm_mythdb_command_run "UPDATE jumppoints SET keylist=\"${KEYLIST}\" \
        WHERE hostname=\"${HOSTNAME}\" AND destination=\"${DESTINATION}\""
}

mm_mythdb_keybinding_delete() {
    CONTEXT=$1
    ACTION=$2
    HOSTNAME=`/bin/hostname`

    if   /usr/bin/test -n "${CONTEXT}" && /usr/bin/test -n "${ACTION}" ; then
        mm_mythdb_command_run "DELETE FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
    elif /usr/bin/test -n "${CONTEXT}" ; then
        mm_mythdb_command_run "DELETE FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\""
    else
        mm_mythdb_command_run "DELETE FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_keybinding_dump() {
    CONTEXT=$1
    ACTION=$2
    HOSTNAME=`/bin/hostname`

    if   /usr/bin/test -n "${CONTEXT}" && /usr/bin/test -n "${ACTION}" ; then
        mm_mythdb_command_run "SELECT * FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
    elif /usr/bin/test -n "${CONTEXT}" ; then
        mm_mythdb_command_run "SELECT * FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\""
    else
        mm_mythdb_command_run "SELECT * FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_keybinding_update() {
    CONTEXT=$1
    ACTION=$2
    KEYLIST=$3
    HOSTNAME=`/bin/hostname`

    mm_mythdb_command_run "UPDATE keybindings SET keylist=\"${KEYLIST}\" \
        WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
}

mm_mythdb_musicplaylist_dump() {
    mm_mythdb_command_run "SELECT * FROM musicplaylist"
}

mm_mythdb_musicplaylist_scope() {
    MUSICPLAYLIST=$1
    SCOPE=$2
    HOSTNAME=`/bin/hostname`

    case "${SCOPE}" in
        local)
            mm_mythdb_command_run "UPDATE musicplaylist SET hostname=\"${HOSTNAME}\" WHERE name=\"${MUSICPLAYLIST}\""
            ;;
        global)
            mm_mythdb_command_run "UPDATE musicplaylist SET hostname=\"\"            WHERE name=\"${MUSICPLAYLIST}\""
            ;;
    esac
}

mm_mythdb_setting_delete() {
    VALUE=$1
    HOSTNAME=`/bin/hostname`

    if /usr/bin/test -n "${VALUE}" ; then
        mm_mythdb_command_run "DELETE FROM settings WHERE value=\"${VALUE}\" AND hostname=\"${HOSTNAME}\""
    else
        mm_mythdb_command_run "DELETE FROM settings WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_setting_dump() {
    VALUE=$1
    HOSTNAME=`/bin/hostname`

    if /usr/bin/test -n "${VALUE}" ; then
        mm_mythdb_command_run "SELECT * FROM settings WHERE value=\"${VALUE}\" AND hostname=\"${HOSTNAME}\""
    else
        mm_mythdb_command_run "SELECT * FROM settings WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_setting_update() {
    VALUE=$1
    DATA=$2
    HOSTNAME=`/bin/hostname`

    mm_mythdb_command_run "UPDATE settings SET data=\"${DATA}\" WHERE value=\"${VALUE}\" AND hostname=\"${HOSTNAME}\""
}


#===============================================================================
# Hardware processing functions.
#===============================================================================

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
mm_hardware_pci_process() {
    pci_process_function=$1

    /usr/sbin/lspci -mn | /bin/sed -e 's%"%%g' | 
    while read pci ; do
        index=1            ; bus=`      /bin/echo "${pci}" | /usr/bin/cut -d ' ' -f ${index}`
        index=$((index+1)) ; class=`    /bin/echo "${pci}" | /usr/bin/cut -d ' ' -f ${index}`
        index=$((index+1)) ; vendor=`   /bin/echo "${pci}" | /usr/bin/cut -d ' ' -f ${index}`
        index=$((index+1)) ; device=`   /bin/echo "${pci}" | /usr/bin/cut -d ' ' -f ${index}`
        index=$((index+1)) ; revision=` /bin/echo "${pci}" | /usr/bin/cut -d ' ' -f ${index}`
        if /usr/bin/test `/bin/echo "${revision}"   | /bin/grep -c -e '^-r'` = "1" ; then
            revision=`  /bin/echo "${revision}"   | /bin/sed -e 's%^-r%%'`
        else
            index=$((index-1)) ; revision='00'
        fi
        index=$((index+1)) ; class_prog=`/bin/echo "${pci}" | /usr/bin/cut -d ' ' -f ${index}`
        if /usr/bin/test `/bin/echo "${class_prog}" | /bin/grep -c -e '^-p'` = "1" ; then
            class_prog=`/bin/echo "${class_prog}" | /bin/sed -e 's%^-p%%'`
        else
            index=$((index-1)) ; class_prog='00'
        fi
        index=$((index+1)) ; subvendor=`/bin/echo "${pci}" | /usr/bin/cut -d ' ' -f ${index}`
        index=$((index+1)) ; subdevice=`/bin/echo "${pci}" | /usr/bin/cut -d ' ' -f ${index}`
        /bin/echo `${pci_process_function} ${class} ${vendor} ${device} ${revision} ${class_prog} ${subvendor} ${subdevice}`
    done |
    mm_uniq
}

mm_hardware_pci2x_map() {
    class=$1
    vendor=$2
    device=$3
    revision=$4
    class_prog=$5
    subvendor=$6
    subdevice=$7

    if /usr/bin/test -n "${class}" ; then
        /bin/cat /etc/hardware.d/pci2x.map | /bin/sed -e 's%#.*$%%g' | /bin/sed -e 's% *%%g' | /bin/grep -e "^${class}," |
        {
            found=
            while read map ; do
                if /usr/bin/test -n "${map}" ; then
                    map_class_prog=`/bin/echo ${map} | /usr/bin/cut -d ',' -f 2`
                    map_vendor=`    /bin/echo ${map} | /usr/bin/cut -d ',' -f 3`
                    map_device=`    /bin/echo ${map} | /usr/bin/cut -d ',' -f 4`
                    map_x_driver=`  /bin/echo ${map} | /usr/bin/cut -d ',' -f 5`
                    if ( /usr/bin/test -z "${map_class_prog}" || /usr/bin/test "${map_class_prog}" = "${class_prog}" ) &&
                       ( /usr/bin/test -z "${map_vendor}"     || /usr/bin/test "${map_vendor}"     = "${vendor}"     ) &&
                       ( /usr/bin/test -z "${map_device}"     || /usr/bin/test "${map_device}"     = "${device}"     ) ; then
                        if /usr/bin/test -z "${found}" ; then
                            found=1
                            /bin/echo ${map_x_driver}
                        fi
                    fi
                fi
            done
        }
    fi
}

mm_hardware_x2kernel_map() {
    x_driver=$1

    if /usr/bin/test -n "${x_driver}" ; then
        /bin/cat /etc/hardware.d/x2kernel.map | /bin/sed -e 's%#.*$%%g' | /bin/sed -e 's% *%%g' | /bin/grep -e "^${x_driver}," |
        {
            found=
            while read map ; do
                if /usr/bin/test -n "${map}" ; then
                    map_kernel_module=`/bin/echo ${map} | /usr/bin/cut -d ',' -f 2`
                fi
                if /usr/bin/test -z "${found}" ; then
                    found=1
                    /bin/echo ${map_kernel_module}
                fi
            done
        }
    fi
}

mm_hardware_usb_process() {
    usb_process_function=$1

    /usr/sbin/lsusb | /bin/sed -e 's%Bus \([^ ]*\) Device \([^:]*\): ID \([^:]*\):\([^ ]*\) .*$%\1 \2 \3\ \4%' | 
    while read usb ; do
        index=1            ; bus=`    /bin/echo ${usb} | /usr/bin/cut -d ' ' -f ${index}`
        index=$((index+1)) ; device=` /bin/echo ${usb} | /usr/bin/cut -d ' ' -f ${index}`
        index=$((index+1)) ; vendor=` /bin/echo ${usb} | /usr/bin/cut -d ' ' -f ${index}`
        index=$((index+1)) ; product=`/bin/echo ${usb} | /usr/bin/cut -d ' ' -f ${index}`
        /bin/echo `${usb_process_function} ${bus} ${device} ${vendor} ${product}`
    done |
    mm_uniq
}

mm_hardware_usb2lirc_driver_map() {
    bus=$1
    device=$2
    vendor=$3
    product=$4

    if /usr/bin/test -n "${vendor}" && /usr/bin/test -n "${product}" ; then
        /bin/cat /etc/hardware.d/usb2lirc.map | /bin/sed -e 's%#.*$%%g' | /bin/sed -e 's% *%%g' | /bin/grep -e "^${vendor},${product}," |
        {
            found=
            while read map ; do
                if /usr/bin/test -n "${map}" ; then
                    map_driver=`/bin/echo ${map} | /usr/bin/cut -d ',' -f 3`
                    if /usr/bin/test -z "${found}" ; then
                        found=1
                        /bin/echo ${map_driver}
                    fi
                fi
            done
        }
    fi
}

mm_hardware_usb2lirc_remote_map() {
    bus=$1
    device=$2
    vendor=$3
    product=$4

    if /usr/bin/test -n "${vendor}" && /usr/bin/test -n "${product}" ; then
        /bin/cat /etc/hardware.d/usb2lirc.map | /bin/sed -e 's%#.*$%%g' | /bin/sed -e 's% *%%g' | /bin/grep -e "^${vendor},${product}," |
        {
            found=
            while read map ; do
                if /usr/bin/test -n "${map}" ; then
                    map_remote=`/bin/echo ${map} | /usr/bin/cut -d ',' -f 4`
                    if /usr/bin/test -z "${found}" ; then
                        found=1
                        /bin/echo ${map_remote}
                    fi
                fi
            done
        }
    fi
}

mm_hardware_usb2lcdproc_map() {
    bus=$1
    device=$2
    vendor=$3
    product=$4

    if /usr/bin/test -n "${vendor}" && /usr/bin/test -n "${product}" ; then
        /bin/cat /etc/hardware.d/usb2lcdproc.map | /bin/sed -e 's%#.*$%%g' | /bin/sed -e 's% *%%g' | /bin/grep -e "^${vendor},${product}," |
        {
            found=
            while read map ; do
                if /usr/bin/test -n "${map}" ; then
                    map_driver=`/bin/echo ${map} | /usr/bin/cut -d ',' -f 3`
                    if /usr/bin/test -z "${found}" ; then
                        found=1
                        /bin/echo ${map_driver}
                    fi
                fi
            done
        }
    fi
}

mm_hardware_cpu_get() {
    case `/bin/cat /proc/cpuinfo | /bin/grep '^model name' | /usr/bin/cut -d ':' -f 2 | /bin/sed 's%^ *%%' | /bin/sed 's% *$$%%'` in
        AMD\ Athlon\(tm\)\ 64\ Processor\ *) /bin/echo 'athlon64' ;;
        VIA\ Nehemiah)                       /bin/echo 'c3-2'     ;;
        VIA\ Samuel\ 2)                      /bin/echo 'c3'       ;;
        *)                                   /bin/echo ''         ;;
    esac
}
