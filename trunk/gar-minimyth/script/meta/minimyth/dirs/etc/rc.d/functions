#!/bin/sh
################################################################################
# functions
################################################################################
[ -n "${MM_DEBUG}" ] && set -x

. /etc/conf

#===============================================================================
# general functions.
#===============================================================================
mm_command_run() {
    COMMAND=$1

    if [ "${MM_DEBUG}" = "yes" ] ; then
        LOG_DIR=/var/log
        LOG_FILE=/var/log/minimyth.log
    else
        LOG_DIR=/dev
        LOG_FILE=/dev/null
    fi

    RETURN=0
    if [ -w ${LOG_FILE} ] || [ -w ${LOG_DIR} ] ; then
        echo "--- execution start: ${COMMAND}"  >> ${LOG_FILE} 2>&1
        ${COMMAND}                              >> ${LOG_FILE} 2>&1
        RETURN=$?
        echo "--- execution end  : ${COMMAND}"  >> ${LOG_FILE} 2>&1
    else
        echo "--- execution start: ${COMMAND}"  2>&1
        ${COMMAND}                              2>&1
        RETURN=$?
        echo "--- execution end  : ${COMMAND}"  2>&1
    fi

    return ${RETURN}
}

mm_conf_get() {
    REMOTE_FILE=$1
    LOCAL_FILE=$2

    LOCAL_DIR=`echo ${LOCAL_FILE} | sed -e 's%[^/]*$%%' -e 's%/$%%'`
    [ -n "${LOCAL_DIR}" ] && mkdir -p ${LOCAL_DIR}

    TMP_FILE=${LOCAL_FILE}~

    rm -f ${TMP_FILE}
    FILE_GOT=0
    [ ${FILE_GOT} = 0 ] && 
        tftp -g -r ${MM_TFTP_ROOTDIR}/conf/`hostname`/${REMOTE_FILE} -l ${TMP_FILE} ${MM_TFTP_SERVER} && FILE_GOT=1
    [ ${FILE_GOT} = 0 ] && 
        tftp -g -r ${MM_TFTP_ROOTDIR}/conf/${REMOTE_FILE}            -l ${TMP_FILE} ${MM_TFTP_SERVER} && FILE_GOT=1
    [ ${FILE_GOT} = 1 ] && 
        mv -f ${TMP_FILE} ${LOCAL_FILE}
    rm -f ${TMP_FILE}
}

mm_message_output() {
    LEVEL=$1
    MESSAGE=$2

    if [ `mm_splash_running_test ; echo $?` -eq 0 ] ; then
        logger    -t minimyth -p local0.${LEVEL} "${MESSAGE}"
        mm_splash_message_output "${MESSAGE}"
    else
        logger -s -t minimyth -p local0.${LEVEL} "${MESSAGE}"
    fi
}

#-------------------------------------------------------------------------------
# mm_url_mount
#
# This function mounts a remote directory as a local directory.
#
# This function takes three arguments:
#     URL: required argument:
#         A URL that points to the remote directory. A URL must have the
#         following form:
#             <protocol>://<username>:<password>@<server>/<path>?<options>
#         where <options> are additional mount options (-o).
#         For example:
#             nfs://server.home/home/public/music
#             cifs://user:pass@server.home/home/public/music,domain=home
#             conf:themecache.tar.bz2
#         The valid protocol values are: nfs, cifs, tftp and conf. For nfs and
#         cifs, the URL points to a remote directory. For tftp, the URL points
#         to a tarfile (*.tar.bz2) or a cramfs image (*.cmg) on a TFTP server
#         that will be downloaded and expanded into (for files) or downloaded
#         and mounted at (for images) the mount point. For conf, the URL points
#         to a tarfile (*.tar.bz2) or a cramfs image (*.cmg) in the MiniMyth
#         conf directory on the TFTP server that will be downloaded and expanded
#         into (for files) or downloaded and mounted at (for images) the mount
#         point.
#     MOUNT_DIR: required argument:
#         The local directory (e.g. /mnt/music) where the URL will be mounted.
#-------------------------------------------------------------------------------
mm_url_mount() {
    URL="$1"
    MOUNT_DIR="$2"

    mkdir -p ${MOUNT_DIR}

    URL_PROTOCOL=`echo ${URL} | cut -d? -f1 | cut -d: -f1`
    URL_USERNAME=`echo ${URL} | cut -d? -f1 | sed 's%^[^:]*:%%' | sed 's%^//%%' | sed 's%[^@]*$%%'  | sed 's%@$%%' | cut -d: -f1`
    URL_PASSWORD=`echo ${URL} | cut -d? -f1 | sed 's%^[^:]*:%%' | sed 's%^//%%' | sed 's%[^@]*$%%'  | sed 's%@$%%' | cut -d: -f2`
    URL_SERVER=`  echo ${URL} | cut -d? -f1 | sed 's%^[^:]*:%%' | sed 's%^//%%' | sed 's%^[^@]*@%%' | sed 's%/[^/]*%%g'`
    URL_PATH=`    echo ${URL} | cut -d? -f1 | sed 's%^[^:]*:%%' | sed 's%^//[^/]*/%/%'`
    URL_OPTIONS=` echo ${URL}               | sed 's%^[^?]*%%'  | sed 's%^?%%'`

    URL_FILE=`    echo ${URL_PATH} | sed 's%^.*/%%'`
    URL_EXTMAX=`  echo ${URL_FILE} | sed 's%^.*/%%' |sed 's%[^.]*%%g' | wc -c` 
    URL_EXT1=
    [ ${URL_EXTMAX} -ge 1 ] && URL_EXT1=`echo ${URL_FILE} | sed 's%^.*/%%' | cut -s -d. -f$((${URL_EXTMAX}-0))`
    URL_EXT2=
    [ ${URL_EXTMAX} -ge 2 ] && URL_EXT2=`echo ${URL_FILE} | sed 's%^.*/%%' | cut -s -d. -f$((${URL_EXTMAX}-1))`

    MOUNT_OPTIONS="${URL_OPTIONS}"

    MOUNT_VFSTYPE=""
    EXTRA_OPTIONS=""
    if   [ "${URL_PROTOCOL}" = "nfs" ] ; then
        MOUNT_VFSTYPE=nfs
        MOUNT_DEVICE="${URL_SERVER}:${URL_PATH}"
        MOUNT_OPTIONS="${MOUNT_OPTIONS},rsize=8192,wsize=8192"
    elif [ "${URL_PROTOCOL}" = "cifs" ] ; then
        MOUNT_VFSTYPE=cifs
        EXTRA_OPTIONS="-n"
        MOUNT_DEVICE="//${URL_SERVER}${URL_PATH}"
        if [ ! "${URL_USERNAME}" = "" ] ; then
            MOUNT_OPTIONS="${MOUNT_OPTIONS},username=${URL_USERNAME}"
        fi
        if [ ! "${URL_PASSWORD}" = "" ] ; then
            MOUNT_OPTIONS="${MOUNT_OPTIONS},password=${URL_PASSWORD}"
        fi
    elif [ "${URL_PROTOCOL}" = "tftp" ] ; then
        if   [ "${URL_EXT1}" = "cmg" ] ; then
            DIR=/initrd/rw/loopfs/`echo ${MOUNT_DIR} | sed 's%//*%~%g'`
            FILE="image.cmg"
            mkdir -p ${DIR}
            mkdir -p ${DIR}/ro
            mkdir -p ${DIR}/rw
            cd ${DIR}
            tftp -g -r ${URL_PATH} -l ${FILE} ${URL_SERVER}
            mount -t cramfs -o loop ${DIR}/${FILE} ${DIR}/ro
            mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none ${MOUNT_DIR}
        elif [ "${URL_EXT1}" = "bz2" ] && [ "${URL_EXT2}" = "tar" ] ; then
            TARFILE="tmp.tar.bz2~"
            cd ${MOUNT_DIR}
            tftp -g -r ${URL_PATH} -l ${TARFILE} ${URL_SERVER}
            tar -jxf ${TARFILE}
            rm -f ${TARFILE}
        fi
    elif [ "${URL_PROTOCOL}" = "conf" ] ; then
        if   [ "${URL_EXT1}" = "cmg" ] ; then
            DIR=/initrd/rw/loopfs/`echo ${MOUNT_DIR} | sed 's%//*%~%g'`
            FILE="image.cmg"
            mkdir -p ${DIR}
            mkdir -p ${DIR}/ro
            mkdir -p ${DIR}/rw
            cd ${DIR}
            mm_conf_get ${URL_PATH} ${FILE}
            mount -t cramfs -o loop ${DIR}/${FILE} ${DIR}/ro
            mount -t unionfs -o dirs=${DIR}/rw=rw:${DIR}/ro=ro none ${MOUNT_DIR}
        elif [ "${URL_EXT1}" = "bz2" ] && [ "${URL_EXT2}" = "tar" ] ; then
            TARFILE="tmp.tar.bz2~"
            cd ${MOUNT_DIR}
            mm_conf_get ${URL_PATH} ${TARFILE}
            tar -jxf ${TARFILE}
            rm -f ${TARFILE}
        fi
    fi

    if [ -n "${MOUNT_VFSTYPE}" ] ; then
        MOUNT_OPTIONS=`echo ${MOUNT_OPTIONS} | sed 's%^,%%'`
        [ -n "${EXTRA_OPTIONS}" ] && OPTIONS="${EXTRA_OPTIONS}"
        [ -n "${MOUNT_OPTIONS}" ] && OPTIONS="${OPTIONS} -o ${MOUNT_OPTIONS}"
        mount -n -t ${MOUNT_VFSTYPE} ${OPTIONS} ${MOUNT_DEVICE} ${MOUNT_DIR}
    fi

    # Update fstab.
    case "${MOUNT_VFSTYPE}" in
        cifs)
            echo "${MOUNT_DEVICE} ${MOUNT_DIR} ${MOUNT_VFSTYPE} ${MOUNT_OPTIONS} 0 0" >> /etc/fstab
            ;;
        nfs)
            echo "${MOUNT_DEVICE} ${MOUNT_DIR} ${MOUNT_VFSTYPE} ${MOUNT_OPTIONS} 0 0" >> /etc/fstab
            ;;
    esac
}

mm_var_get() {
    VAR=$1

    echo `set | grep "^${VAR}=" | sed 's%^[^=]*=%%' | sed "s%^'%%" | sed "s%'$%%"`
}

#===============================================================================
# splash screen functions
#===============================================================================
mm_splash_progress_val=1
mm_splash_progress_max=1

mm_splash_running_test() {
    if [ -n "`pidof splash_util`" ] && [ -e /var/cache/splash/fifo ] ; then
        return 0
    else
        return 1
    fi
}

mm_splash_init() {
    # Initialize progress variables.
    mm_splash_progress_val=0
    mm_splash_progress_max=$1

    SPLASH_ENABLE=yes

    # Disable splash screen when more than kernel errors are logged to the console.
    # That is when the loglevel is greater than 4.
    LOGLEVEL=`cat /proc/sys/kernel/printk | cut -f 1`
    [ ${LOGLEVEL} -gt 4 ] && SPLASH_ENABLE=no

    # Disable splash screen when the video resolution is not compatible.
    # That is when the resolution is not 800x600 or color depth is less than 16.
    GEOMETRY=`fbset | grep geometry`
    XRES=` echo ${GEOMETRY} | cut -d' ' -f 2`
    YRES=` echo ${GEOMETRY} | cut -d' ' -f 3`
    VXRES=`echo ${GEOMETRY} | cut -d' ' -f 4`
    VYRES=`echo ${GEOMETRY} | cut -d' ' -f 5`
    DEPTH=`echo ${GEOMETRY} | cut -d' ' -f 6`
    [ ${XRES}  -ne 800 ] && SPLASH_ENABLE=no
    [ ${YRES}  -ne 600 ] && SPLASH_ENABLE=no
    [ ${VXRES} -ne 800 ] && SPLASH_ENABLE=no
    [ ${VYRES} -ne 600 ] && SPLASH_ENABLE=no
    [ ${DEPTH} -lt 16  ] && SPLASH_ENABLE=no

    if [ "${SPLASH_ENABLE}" = "yes" ] ; then
        chvt 1
        mkdir -p /var/cache/splash
        splash_util --daemon --theme="MythTV"
        mm_splash_command "set mode silent"
        mm_splash_command "progress 0"
        mm_splash_command "set message starting splash screen ..."
        mm_splash_command "repaint"
    fi

    return 0
}

mm_splash_halt() {
    [ -n "`pidof -s splash_util`" ] && killall splash_util

    [ -e "/var/cache/splash" ] && rm -rf /var/cache/spalsh

    return 0
}

mm_splash_command()
{
    [ `mm_splash_running_test ; echo $?` -eq 0 ] && echo "$1" >> /var/cache/splash/fifo

    return 0
}

mm_splash_message_output() {
    mm_splash_command "set message ${MESSAGE}"
    mm_splash_command "repaint"

    return 0
}

mm_splash_progress_update() {
    mm_splash_progress_val=$((mm_splash_progress_val + 1))
    [ ${mm_splash_progress_val} -gt ${mm_splash_progress_max} ] && mm_splash_progress_val=${mm_splash_progress_max}
    mm_splash_command "progress $(( 65535 * ${mm_splash_progress_val} / ${mm_splash_progress_max} ))"
    mm_splash_command "repaint"

    return 0
}

#===============================================================================
# mythdb functions.
#===============================================================================
mm_mythdb_command_run() {
    COMMAND=$1

    RETURN=0
    mysql \
        --host=${MM_MYTH_SERVER} \
        --user=${MM_MYTH_DBUSERNAME} \
        --password=${MM_MYTH_DBPASSWORD} \
        --exec="use ${MM_MYTH_DBNAME} ; ${COMMAND} ;"
    RETURN=$?

    return ${RETURN}
}

mm_mythdb_jumppoint_delete() {
    DESTINATION=$1
    HOSTNAME=`hostname`

    if [ -n "${DESTINATION}" ] ; then
        mm_mythdb_command_run "DELETE FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\" AND destination=\"${DESTINATION}\""
    else
        mm_mythdb_command_run "DELETE FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_jumppoint_dump() {
    DESTINATION=$1
    HOSTNAME=`hostname`

    if [ -n "${DESTINATION}" ] ; then
        mm_mythdb_command_run "SELECT * FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\" AND destination=\"${DESTINATION}\""
    else
        mm_mythdb_command_run "SELECT * FROM jumppoints \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_jumppoint_update() {
    DESTINATION=$1
    KEYLIST=$2
    HOSTNAME=`hostname`

    mm_mythdb_command_run "UPDATE jumppoints SET keylist=\"${KEYLIST}\" \
        WHERE hostname=\"${HOSTNAME}\" AND destination=\"${DESTINATION}\""
}

mm_mythdb_keybinding_delete() {
    CONTEXT=$1
    ACTION=$2
    HOSTNAME=`hostname`

    if   [ -n "${CONTEXT}" ] && [ -n "${ACTION}" ] ; then
        mm_mythdb_command_run "DELETE FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
    elif [ -n "${CONTEXT}" ] ; then
        mm_mythdb_command_run "DELETE FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\""
    else
        mm_mythdb_command_run "DELETE FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_keybinding_dump() {
    CONTEXT=$1
    ACTION=$2
    HOSTNAME=`hostname`

    if   [ -n "${CONTEXT}" ] && [ -n "${ACTION}" ] ; then
        mm_mythdb_command_run "SELECT * FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
    elif [ -n "${CONTEXT}" ] ; then
        mm_mythdb_command_run "SELECT * FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\""
    else
        mm_mythdb_command_run "SELECT * FROM keybindings \
            WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_keybinding_update() {
    CONTEXT=$1
    ACTION=$2
    KEYLIST=$3
    HOSTNAME=`hostname`

    mm_mythdb_command_run "UPDATE keybindings SET keylist=\"${KEYLIST}\" \
        WHERE hostname=\"${HOSTNAME}\" AND context=\"${CONTEXT}\" AND action=\"${ACTION}\""
}

mm_mythdb_musicplaylist_dump() {
    mm_mythdb_command_run "SELECT * FROM musicplaylist"
}

mm_mythdb_musicplaylist_scope() {
    MUSICPLAYLIST=$1
    SCOPE=$2
    HOSTNAME=`hostname`

    case "${SCOPE}" in
        local)
            mm_mythdb_command_run "UPDATE musicplaylist SET hostname=\"${HOSTNAME}\" WHERE name=\"${MUSICPLAYLIST}\""
            ;;
        global)
            mm_mythdb_command_run "UPDATE musicplaylist SET hostname=\"\"            WHERE name=\"${MUSICPLAYLIST}\""
            ;;
    esac
}

mm_mythdb_setting_delete() {
    VALUE=$1
    HOSTNAME=`hostname`

    if [ -n "${VALUE}" ] ; then
        mm_mythdb_command_run "DELETE FROM settings WHERE value=\"${VALUE}\" AND hostname=\"${HOSTNAME}\""
    else
        mm_mythdb_command_run "DELETE FROM settings WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_setting_dump() {
    VALUE=$1
    HOSTNAME=`hostname`

    if [ -n "${VALUE}" ] ; then
        mm_mythdb_command_run "SELECT * FROM settings WHERE value=\"${VALUE}\" AND hostname=\"${HOSTNAME}\""
    else
        mm_mythdb_command_run "SELECT * FROM settings WHERE hostname=\"${HOSTNAME}\""
    fi
}

mm_mythdb_setting_update() {
    VALUE=$1
    DATA=$2
    HOSTNAME=`hostname`

    mm_mythdb_command_run "UPDATE settings SET data=\"${DATA}\" WHERE value=\"${VALUE}\" AND hostname=\"${HOSTNAME}\""
}

