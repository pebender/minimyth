#!/bin/sh

# Only allow one running instance of mm_sleep.
pids=`/bin/pidof mm_sleep`
instances=`/bin/echo ${pids} | /usr/bin/wc -w`
if /usr/bin/test ${instances} -ne 1 ; then
    exit 1
fi

. /etc/rc.d/functions

# Create the state directory for mm_sleep.
/bin/rm -fr   /var/lib/mm_sleep.$$
/bin/mkdir -p /var/lib/mm_sleep.$$

# Turn off any external equipment.
/usr/bin/mm_external power_off

# If MPlayer is running, then exit it.
mm_x_xmacroplay 'xine' 'KeyStr Escape\n'
if /usr/bin/test -n "`/bin/pidof mplayer`" ; then
    /bin/kill `/bin/pidof mplayer`
fi
while /usr/bin/test -n "`/bin/pidof mplayer`" ; do
    /bin/sleep 1
done

# If Xine is running, then exit it.
mm_x_xmacroplay 'xine' 'KeyStr Q\n'
if /usr/bin/test -n "`/bin/pidof xine`" ; then
    /bin/kill `/bin/pidof xine`
fi
while /usr/bin/test -n "`/bin/pidof xine`" ; do
    /bin/sleep 1
done

# If any game emulators are running, then exit them.
/usr/bin/mm_game_exit

# If mythfrontend is running, then return it to the main menu using the 'Main Menu' JumpPoint.
# If the Network Interface interface is enabled, then use it.
# Else, if the JumpPoint key sequence is set, then use it.
if /usr/bin/test -n "`/bin/pidof mythfrontend`" ; then
    NetworkControlEnabled=`mm_mythdb_settings_get NetworkControlEnabled`
    NetworkControlPort=`mm_mythdb_settings_get NetworkControlPort`
    MainMenuJumpPoint=`mm_mythdb_jumppoints_get "Main Menu"`

    if /usr/bin/test ${NetworkControlEnabled} -eq 1 ; then
        /usr/bin/nc localhost ${NetworkControlPort} > /dev/null 2>&1 << EOF
jump mainmenu
EOF
    elif /usr/bin/test ! -z "${MainMenuJumpPoint}" && /usr/bin/test ! "x${MainMenuJumpPoint}" = "xNULL" ; then
        # Convert MythTV JumpPoint key sequence to an XMacroPlay command sequence.
        key_count=`/bin/echo ${MainMenuJumpPoint} | /bin/sed -e 's%[^+][^+]*%%g' | /usr/bin/wc -c`
        key_index=1
        key_press=""
        key_release=""
        while /usr/bin/test ${key_index} -le ${key_count} ; do
            key=`/bin/echo ${MainMenuJumpPoint} | /usr/bin/cut -d '+' -f ${key_index}`
            case  "${key}" in
                ALT|Alt)     key="Alt_L"     ;;
                CTRL|Ctrl)   key="Control_L" ;;
                META|Meta)   key="Meta_L"    ;;
                SHIFT|Shift) key="Shift_L"   ;;
            esac
            key_press="${key_press}KeyStrPress ${key}\n "
            key_release="KyeStrRelease ${key}\n ${key_release}"
            key_index=$((${key_index} + 1))
        done
        # Send command sequence to mythfrontend using XMacroPlay.
        mm_x_xmacroplay 'mythfrontend' "${key_press}${key_release}"
    fi
fi

# Stop LCDd because it can stop working as a result of suspend.
while /usr/bin/test -n "`/bin/pidof LCDd`" ; do
    /bin/touch /var/lib/mm_sleep.$$/LCDd
    /usr/bin/killall LCDd 2> /dev/null
done

# Stop irexec so that the remote button press used to wake up the frontend
# does not suspend the frontend.
while /usr/bin/test -n "`/bin/pidof irexec`" ; do
    /bin/touch /var/lib/mm_sleep.$$/irexec
    /usr/bin/killall irexec 2> /dev/null
done

# Stop X
if /usr/bin/test "x${MM_X_RESTART_ON_SLEEP_ENABLED}" = "xyes" ; then
    mm_x_stop
fi

/bin/echo mem > /sys/power/state

# Start X
if /usr/bin/test "x${MM_X_RESTART_ON_SLEEP_ENABLED}" = "xyes" ; then
    mm_x_start
fi

# If irexec was running before suspend, then restart it.
if /usr/bin/test -e /var/lib/mm_sleep.$$/irexec ; then
    /usr/bin/test -z `/bin/pidof irexec` && /usr/bin/irexec -d /etc/lircrc
    /bin/rm -f /var/lib/mm_sleep.$$/irexec
fi

# If LCDd was running before suspend, then restart it.
if /usr/bin/test -e /var/lib/mm_sleep.$$/LCDd ; then
    /usr/bin/test -z `/bin/pidof irexec` && /etc/LCDd -c /etc/LCDd.conf
    /bin/rm -f /var/lib/mm_sleep.$$/LCDd
fi

# Turn on any external equipment.
/usr/bin/mm_external power_on

# Remove the state directory for mm_sleep.
/bin/rm -fr   /var/lib/mm_sleep.$$
