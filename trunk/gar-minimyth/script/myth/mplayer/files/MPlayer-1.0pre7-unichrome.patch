diff -Naur MPlayer-1.0pre7-old/codec-cfg.c MPlayer-1.0pre7-new/codec-cfg.c
--- MPlayer-1.0pre7-old/codec-cfg.c	2004-12-17 05:27:34.000000000 -0800
+++ MPlayer-1.0pre7-new/codec-cfg.c	2005-06-01 06:59:17.275473084 -0700
@@ -170,6 +170,7 @@
 		{"ZRMJPEGIT", IMGFMT_ZRMJPEGIT},
 		{"ZRMJPEGIB", IMGFMT_ZRMJPEGIB},
 
+		{"VLD_MPEG2",IMGFMT_XVMC_VLD_MPEG2},
 		{"IDCT_MPEG2",IMGFMT_XVMC_IDCT_MPEG2},
 		{"MOCO_MPEG2",IMGFMT_XVMC_MOCO_MPEG2},
 
diff -Naur MPlayer-1.0pre7-old/configure MPlayer-1.0pre7-new/configure
--- MPlayer-1.0pre7-old/configure	2005-04-13 04:46:35.000000000 -0700
+++ MPlayer-1.0pre7-new/configure	2005-06-01 06:59:17.279472633 -0700
@@ -251,6 +251,7 @@
                          (check for X & /dev/mga_vid) [autodetect]
   --enable-xv            build with Xv render support for X 4.x [autodetect]
   --enable-xvmc          build with XvMC acceleration for X 4.x [disable]
+  --enable-xxmc          build with XvMC-VLD acceleration for X 4.x [autodetect]  
   --enable-vm            build with XF86VidMode support for X11 [autodetect]
   --enable-xinerama      build with Xinerama support for X11 [autodetect]
   --enable-x11           build with X11 render support [autodetect]
@@ -351,6 +352,7 @@
   --with-cdparanoiaincdir=DIR  cdparanoia headers in DIR (*)
   --with-cdparanoialibdir=DIR  cdparanoia libraries (libcdda_*) in DIR (*)
   --with-xvmclib=NAME      name of adapter-specific library (e.g. XvMCNVIDIA)
+  --with-xxmclib=NAME      name of adapter-specific library (e.g. viaXvMC)
   --with-termcaplib=NAME   name of library with termcap functionality
                            name should be given without leading "lib"
                            checks for "termcap" and "tinfo"
@@ -1273,6 +1275,7 @@
 
 _prefix="/usr/local"
 _xvmclib="XvMCNVIDIA"
+_xxmclib="viaXvMC"
 
 # GOTCHA: the variables below defines the default behavior for autodetection
 # and have - unless stated otherwise - at least 2 states : yes no
@@ -1290,6 +1293,7 @@
 _dga=auto	# 1 2 no auto
 _xv=auto
 _xvmc=no  #auto when complete
+_xxmc=no  #auto when complete
 _sdl=auto
 _directx=auto
 _win32waveout=auto
@@ -1442,6 +1446,8 @@
   --disable-xv)		_xv=no		;;
   --enable-xvmc)        _xvmc=yes       ;;
   --disable-xvmc)       _xvmc=no        ;;
+  --enable-xxmc)        _xxmc=yes       ;;
+  --disable-xxmc)       _xxmc=no        ;;
   --enable-sdl)		_sdl=yes	;;
   --disable-sdl)	_sdl=no		;;
   --enable-directx)     _directx=yes    ;;
@@ -1805,6 +1811,9 @@
   --with-xvmclib=*)
     _xvmclib=`echo $ac_option | cut -d '=' -f 2`
     ;;
+  --with-xxmclib=*)
+    _xxmclib=`echo $ac_option | cut -d '=' -f 2`
+    ;;
   --with-dvbincdir=*)
     _inc_dvb=-I`echo $ac_option | cut -d '=' -f 2 | sed 's,:, -I,g'`
     ;;
@@ -3528,6 +3537,31 @@
 echores "$_xv"
 
 
+#This will do for now.
+echocheck "XxMC (VIA VLD)"
+if test "$_x11" = yes && test "$_xv" = yes && test "$_xxmc" != no ; then
+  _xxmc=no
+  cat > $TMPC <<EOF
+#include <X11/Xlib.h>
+#include <X11/extensions/Xvlib.h>
+#include <X11/extensions/vldXvMC.h>
+int main(void) { 
+  (void) XvMCQueryExtension(0,0,0);
+  (void) XvMCCreateContext(0,0,0,0,0,0,0);
+  return 0; }
+EOF
+  cc_check $_inc_x11 -lXvMC -l$_xxmclib $_ld_xv $_ld_x11 && _xxmc=yes
+fi
+
+if test "$_xxmc" = yes ; then
+  _def_xxmc='#define HAVE_XVMC_VLD 1'
+  _ld_xxmc="-lXvMC -l$_xxmclib"
+  _vosrc="$_vosrc vo_xvmc.c"
+else
+  _def_xxmc='#undef HAVE_XVMC_VLD'
+fi
+echores "$_xxmc"
+
 echocheck "XvMC"
 if test "$_x11" = yes && test "$_xv" = yes && test "$_xvmc" != no ; then
   _xvmc=no
@@ -3546,13 +3580,19 @@
   _def_xvmc='#define HAVE_XVMC 1'
   _ld_xvmc="-lXvMC -l$_xvmclib"
   _vosrc="$_vosrc vo_xvmc.c"
-  _vomodules="xvmc $_vomodules"
 else
   _def_xvmc='#undef HAVE_XVMC'
-  _novomodules="xvmc $_novomodules"
 fi
 echores "$_xvmc"
 
+# xxmc and xvmc both provided by xvmc vo, but different include/link
+# required until XvMC wrapper is used. so share this.
+#
+if test "$_xvmc" = yes || test "$_xxmc" = yes ; then
+  _vomodules="xvmc $_vomodules"
+else
+  _novomodules="xvmc $_novomodules"
+fi
 
 echocheck "Xinerama"
 if test "$_x11" = yes && test "$_xinerama" != no ; then
@@ -6748,6 +6788,7 @@
 X11DIR = $_ld_x11
 
 HAVE_XVMC_ACCEL = $_xvmc
+HAVE_XXMC_ACCEL = $_xxmc
 
 # for libavcodec:
 SRC_PATH=..
@@ -6757,7 +6798,7 @@
 SLIBSUF=.so
 
 # video output
-X_LIB = $_ld_gl $_ld_dga $_ld_xv $_ld_xvmc $_ld_vm $_ld_xinerama $_ld_x11 $_ld_sock
+X_LIB = $_ld_gl $_ld_dga $_ld_xv $_ld_xvmc $_ld_xxmc $_ld_vm $_ld_xinerama $_ld_x11 $_ld_sock
 GGI_LIB = $_ld_ggi
 MLIB_LIB =  $_ld_mlib
 MLIB_INC = $_inc_mlib
@@ -7453,6 +7494,7 @@
 $_def_x11
 $_def_xv
 $_def_xvmc
+$_def_xxmc
 $_def_vm
 $_def_xf86keysym
 $_def_xinerama
diff -Naur MPlayer-1.0pre7-old/etc/codecs.conf MPlayer-1.0pre7-new/etc/codecs.conf
--- MPlayer-1.0pre7-old/etc/codecs.conf	2005-04-10 09:44:29.000000000 -0700
+++ MPlayer-1.0pre7-new/etc/codecs.conf	2005-06-01 06:59:17.281472407 -0700
@@ -76,6 +76,7 @@
   fourcc PIM1        ; Pinnacle hardware-MPEG-1
   driver ffmpeg
   dll "mpegvideo_xvmc"
+  out VLD_MPEG2
   out IDCT_MPEG2
   out MOCO_MPEG2
 
diff -Naur MPlayer-1.0pre7-old/libavcodec/allcodecs.c MPlayer-1.0pre7-new/libavcodec/allcodecs.c
--- MPlayer-1.0pre7-old/libavcodec/allcodecs.c	2005-04-16 13:41:13.000000000 -0700
+++ MPlayer-1.0pre7-new/libavcodec/allcodecs.c	2005-06-01 06:59:17.281472407 -0700
@@ -138,6 +138,9 @@
     register_avcodec(&mpeg1video_decoder);
     register_avcodec(&mpeg2video_decoder);
     register_avcodec(&mpegvideo_decoder);
+#ifdef HAVE_XVMC_VLD
+    register_avcodec(&mpeg_xxmc_decoder);
+#endif
 #ifdef HAVE_XVMC
     register_avcodec(&mpeg_xvmc_decoder);
 #endif
diff -Naur MPlayer-1.0pre7-old/libavcodec/avcodec.h MPlayer-1.0pre7-new/libavcodec/avcodec.h
--- MPlayer-1.0pre7-old/libavcodec/avcodec.h	2005-04-16 13:41:13.000000000 -0700
+++ MPlayer-1.0pre7-new/libavcodec/avcodec.h	2005-06-01 06:59:17.283472182 -0700
@@ -228,6 +228,7 @@
     PIX_FMT_UYVY422,   ///< Packed pixel, Cb Y0 Cr Y1 
     PIX_FMT_UYVY411,   ///< Packed pixel, Cb Y0 Y1 Cr Y2 Y3
     PIX_FMT_NB,
+    PIX_FMT_XVMC_MPEG2_VLD,
 };
 
 /* currently unused, may be used if 24/32 bits samples ever supported */
@@ -1938,6 +1939,7 @@
 extern AVCodec mpeg2video_decoder;
 extern AVCodec mpegvideo_decoder;
 extern AVCodec mpeg_xvmc_decoder;
+extern AVCodec mpeg_xxmc_decoder;
 extern AVCodec h263i_decoder;
 extern AVCodec flv_decoder;
 extern AVCodec rv10_decoder;
diff -Naur MPlayer-1.0pre7-old/libavcodec/error_resilience.c MPlayer-1.0pre7-new/libavcodec/error_resilience.c
--- MPlayer-1.0pre7-old/libavcodec/error_resilience.c	2005-04-16 13:41:13.000000000 -0700
+++ MPlayer-1.0pre7-new/libavcodec/error_resilience.c	2005-06-01 06:59:17.284472069 -0700
@@ -923,7 +923,7 @@
     }else
         guess_mv(s);
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)
     /* the filters below are not XvMC compatible, skip them */
     if(s->avctx->xvmc_acceleration) goto ec_clean;
 #endif
@@ -1012,7 +1012,7 @@
         v_block_filter(s, s->current_picture.data[2], s->mb_width  , s->mb_height  , s->uvlinesize, 0);
     }
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)
 ec_clean:
 #endif
     /* clean a few tables */
diff -Naur MPlayer-1.0pre7-old/libavcodec/Makefile MPlayer-1.0pre7-new/libavcodec/Makefile
--- MPlayer-1.0pre7-old/libavcodec/Makefile	2005-04-16 13:41:13.000000000 -0700
+++ MPlayer-1.0pre7-new/libavcodec/Makefile	2005-06-01 06:59:17.284472069 -0700
@@ -65,6 +65,13 @@
 ASM_OBJS=
 
 ifeq ($(HAVE_XVMC_ACCEL),yes)
+XVMC=yes
+endif
+ifeq ($(HAVE_XXMC_ACCEL),yes)
+XVMC=yes
+endif
+
+ifeq ($(XVMC),yes)
 OBJS+= xvmcvideo.o
 endif
 
diff -Naur MPlayer-1.0pre7-old/libavcodec/mpeg12.c MPlayer-1.0pre7-new/libavcodec/mpeg12.c
--- MPlayer-1.0pre7-old/libavcodec/mpeg12.c	2005-04-16 13:41:13.000000000 -0700
+++ MPlayer-1.0pre7-new/libavcodec/mpeg12.c	2005-06-01 06:59:17.287471731 -0700
@@ -75,17 +75,26 @@
 static int mpeg_decode_motion(MpegEncContext *s, int fcode, int pred);
 static void exchange_uv(MpegEncContext *s);
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)
 extern int XVMC_field_start(MpegEncContext *s, AVCodecContext *avctx);
 extern int XVMC_field_end(MpegEncContext *s);
 extern void XVMC_pack_pblocks(MpegEncContext *s,int cbp);
 extern void XVMC_init_block(MpegEncContext *s);//set s->block
 #endif
 
+
+#ifdef HAVE_XVMC_VLD
+extern int XVMC_decode_slice(MpegEncContext *s, int start_code,
+                                 uint8_t *buffer, int buf_size);
+#endif
+
 const enum PixelFormat pixfmt_yuv_420[]= {PIX_FMT_YUV420P,-1};
 const enum PixelFormat pixfmt_yuv_422[]= {PIX_FMT_YUV422P,-1};
 const enum PixelFormat pixfmt_yuv_444[]= {PIX_FMT_YUV444P,-1};
 const enum PixelFormat pixfmt_xvmc_mpg2_420[] = {
+#ifdef HAVE_XVMC_VLD
+                                           PIX_FMT_XVMC_MPEG2_VLD,
+#endif
                                            PIX_FMT_XVMC_MPEG2_IDCT,
                                            PIX_FMT_XVMC_MPEG2_MC,
 					   -1};
@@ -1162,9 +1171,9 @@
         }else
             memset(s->last_mv, 0, sizeof(s->last_mv)); /* reset mv prediction */
         s->mb_intra = 1;
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)
         //one 1 we memcpy blocks in xvmcvideo
-        if(s->avctx->xvmc_acceleration > 1){
+        if(s->avctx->xvmc_acceleration == 2){
             XVMC_pack_pblocks(s,-1);//inter are always full blocks
             if(s->swap_uv){
                 exchange_uv(s);
@@ -1362,9 +1371,9 @@
 		 cbp |= get_bits(&s->gb, mb_block_count-6);
             }
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)
             //on 1 we memcpy blocks in xvmcvideo
-            if(s->avctx->xvmc_acceleration > 1){
+            if(s->avctx->xvmc_acceleration == 2){
                 XVMC_pack_pblocks(s,cbp);
                 if(s->swap_uv){
                     exchange_uv(s);
@@ -2398,13 +2407,12 @@
                 } 
             }
     }
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)
 // MPV_frame_start will call this function too,
 // but we need to call it on every field
     if(s->avctx->xvmc_acceleration)
          XVMC_field_start(s,avctx);
 #endif
-
     return 0;
 }
 
@@ -2433,6 +2441,17 @@
         return -1;
     }
     
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4){
+        int used = XVMC_decode_slice(s, mb_y, *buf, buf_size);
+        if (used < 0)
+            return DECODE_SLICE_ERROR;
+        *buf += used - 1;
+        return DECODE_SLICE_OK;
+    }
+#endif
+
+ 
     init_get_bits(&s->gb, *buf, buf_size*8);
 
     ff_mpeg1_clean_buffers(s);
@@ -2488,7 +2507,7 @@
     for(;;) {
 #ifdef HAVE_XVMC
         //one 1 we memcpy blocks in xvmcvideo
-        if(s->avctx->xvmc_acceleration > 1)
+        if(s->avctx->xvmc_acceleration == 2)
             XVMC_init_block(s);//set s->block
 #endif
 
@@ -2640,10 +2659,11 @@
     if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr)
         return 0;
 
-#ifdef HAVE_XVMC
-    if(s->avctx->xvmc_acceleration)
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)
+    if(s->avctx->xvmc_acceleration) 
         XVMC_field_end(s);
 #endif
+
     /* end of slice reached */
     if (/*s->mb_y<<field_pic == s->mb_height &&*/ !s->first_field) {
         /* end of image */
@@ -3206,6 +3226,41 @@
 
 #endif
 
+#ifdef HAVE_XVMC_VLD
+static int mpeg_xxmc_decode_init(AVCodecContext *avctx){
+    Mpeg1Context *s;
+    if( avctx->thread_count > 1)
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_CODED_ORDER) )
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD) )
+        dprintf("mpeg12.c: XVMC_VLD decoder will work better if SLICE_FLAG_ALLOW_FIELD is set\n");
+
+    mpeg_decode_init(avctx);
+    s = avctx->priv_data;
+
+    avctx->pix_fmt = PIX_FMT_XVMC_MPEG2_VLD;
+    avctx->xvmc_acceleration = 4;
+
+    return 0;
+}
+
+AVCodec mpeg_xxmc_decoder = {
+    "mpegvideo_xvmc",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_MPEG2VIDEO_XVMC,
+    sizeof(Mpeg1Context),
+    mpeg_xxmc_decode_init,
+    NULL,
+    mpeg_decode_end,
+    mpeg_decode_frame,
+    CODEC_CAP_DRAW_HORIZ_BAND | CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED| CODEC_CAP_HWACCEL,
+    .flush= ff_mpeg_flush,
+};
+
+#endif
+
+
 /* this is ugly i know, but the alternative is too make 
    hundreds of vars global and prefix them with ff_mpeg1_
    which is far uglier. */
diff -Naur MPlayer-1.0pre7-old/libavcodec/mpegvideo.c MPlayer-1.0pre7-new/libavcodec/mpegvideo.c
--- MPlayer-1.0pre7-old/libavcodec/mpegvideo.c	2005-04-16 13:41:13.000000000 -0700
+++ MPlayer-1.0pre7-new/libavcodec/mpegvideo.c	2005-06-01 06:59:17.291471280 -0700
@@ -62,7 +62,7 @@
 static void  denoise_dct_c(MpegEncContext *s, DCTELEM *block);
 #endif //CONFIG_ENCODERS
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)
 extern int  XVMC_field_start(MpegEncContext*s, AVCodecContext *avctx);
 extern void XVMC_field_end(MpegEncContext *s);
 extern void XVMC_decode_mb(MpegEncContext *s);
@@ -1558,8 +1558,8 @@
 
         update_noise_reduction(s);
     }
-        
-#ifdef HAVE_XVMC
+
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)        
     if(s->avctx->xvmc_acceleration)
         return XVMC_field_start(s, avctx);
 #endif
@@ -1571,11 +1571,11 @@
 {
     int i;
     /* draw edge for correct motion prediction if outside */
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)
 //just to make sure that all data is rendered.
     if(s->avctx->xvmc_acceleration){
         XVMC_field_end(s);
-    }else
+    }
 #endif
     if(s->unrestricted_mv && s->current_picture.reference && !s->intra_only && !(s->flags&CODEC_FLAG_EMU_EDGE)) {
             draw_edges(s->current_picture.data[0], s->linesize  , s->h_edge_pos   , s->v_edge_pos   , EDGE_WIDTH  );
@@ -3649,7 +3649,7 @@
     int mb_x, mb_y;
     const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;
 #ifdef HAVE_XVMC
-    if(s->avctx->xvmc_acceleration){
+    if(s->avctx->xvmc_acceleration & 3){
         XVMC_decode_mb(s);//xvmc uses pblocks
         return;
     }
diff -Naur MPlayer-1.0pre7-old/libavcodec/xvmcvideo.c MPlayer-1.0pre7-new/libavcodec/xvmcvideo.c
--- MPlayer-1.0pre7-old/libavcodec/xvmcvideo.c	2005-04-16 13:41:13.000000000 -0700
+++ MPlayer-1.0pre7-new/libavcodec/xvmcvideo.c	2005-06-01 06:59:17.293471054 -0700
@@ -31,7 +31,7 @@
 #include "fastmemcpy.h"
 #endif
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)|defined(HAVE_XVMC_VLD)
 
 //X11 includes are in the xvmc_render.h
 //by replacing it with none-X one
@@ -70,11 +70,69 @@
     }
 }
 
+#ifdef HAVE_XVMC_VLD
+static XvMCSurface* findPastSurface(MpegEncContext *s,
+                                    xvmc_render_state_t *render)
+{
+    Picture *lastp = s->last_picture_ptr;
+    xvmc_render_state_t *last = NULL;
+
+    if (NULL!=lastp) {
+        last = (xvmc_render_state_t*)(lastp->data[2]);
+        if (B_TYPE==last->pict_type)
+            av_log(s->avctx,AV_LOG_DEBUG, "Past frame is a B frame in findPastSurface, this is bad.\n");
+        //assert(B_TYPE!=last->pict_type);
+    }
+
+    if (NULL==last)
+        if (!s->first_field)
+            last = render; // predict second field from the first
+        else
+            return 0;
+
+    if (last->magic != MP_XVMC_RENDER_MAGIC)
+        return 0;
+
+    return (last->state & MP_XVMC_STATE_PREDICTION) ? last->p_surface : 0;
+}
+
+static XvMCSurface* findFutureSurface(MpegEncContext *s)
+{
+    Picture *nextp = s->next_picture_ptr;
+    xvmc_render_state_t *next = NULL;
+
+    if (NULL!=nextp) {
+        next = (xvmc_render_state_t*)(nextp->data[2]);
+        if (B_TYPE==next->pict_type)
+            av_log(s->avctx,AV_LOG_DEBUG, "Next frame is a B frame in findFutureSurface, thisis bad.\n");
+        //assert(B_TYPE!=next->pict_type);
+    }
+
+    assert(NULL!=next);
+
+    if (next->magic != MP_XVMC_RENDER_MAGIC)
+        return 0;
+
+    return (next->state & MP_XVMC_STATE_PREDICTION) ? next->p_surface : 0;
+}
+#endif //HAVE_XVMC_VLD
+
 //these functions should be called on every new field or/and frame
 //They should be safe if they are called few times for same field!
+
 int XVMC_field_start(MpegEncContext*s, AVCodecContext *avctx){
-xvmc_render_state_t * render,* last, * next;
+    xvmc_render_state_t * render, * last, * next;
 
+#ifdef HAVE_XVMC_VLD
+    XvMCMpegControl     binfo;
+    XvMCQMatrix         qmatrix;
+    int                 i;
+    Status              status;
+
+    memset(&binfo, 0, sizeof(binfo));
+    memset(&qmatrix, 0, sizeof(qmatrix));
+#endif
+    
     assert(avctx != NULL);
 
     render = (xvmc_render_state_t*)s->current_picture.data[2];
@@ -85,12 +143,53 @@
     render->picture_structure = s->picture_structure;
     render->flags = (s->first_field)? 0: XVMC_SECOND_FIELD;
 
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        if (render->picture_structure == PICT_FRAME)
+            render->flags |= XVMC_FRAME_PICTURE;
+        else if (render->picture_structure == PICT_TOP_FIELD)
+            render->flags |= XVMC_TOP_FIELD;
+        else if (render->picture_structure == PICT_BOTTOM_FIELD)
+            render->flags |= XVMC_BOTTOM_FIELD;
+    }
+    else
+#endif
+    {
 //make sure that all data is drawn by XVMC_end_frame
     assert(render->filled_mv_blocks_num==0);
+    }
 
     render->p_future_surface = NULL;
     render->p_past_surface = NULL;
 
+    render->pict_type = s->pict_type; // for later frame dropping use
+
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+{
+    switch(s->pict_type){
+        case  I_TYPE:
+            break;
+        case  B_TYPE:
+            render->p_past_surface = findPastSurface(s, render);
+            render->p_future_surface = findFutureSurface(s);
+            if (!render->p_past_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding B frame and past frame is null!");
+            else if (!render->p_future_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding B frame and future frame is null!");
+            break;
+            
+        case  P_TYPE:
+            render->p_past_surface = findPastSurface(s, render);
+            render->p_future_surface = render->p_surface;
+            if (!render->p_past_surface)
+                av_log(avctx, AV_LOG_ERROR, "error: decoding P frame and past frame is null!");
+            break;
+    }
+} else
+#endif
+{
     switch(s->pict_type){
         case  I_TYPE:
             return 0;// no prediction from other frames
@@ -111,18 +210,119 @@
             render->p_past_surface = last->p_surface;
             return 0;
     }
+}
 
-return -1;
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        for (i = 0; i < 64; i++){
+        qmatrix.intra_quantiser_matrix[i] = s->intra_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.non_intra_quantiser_matrix[i] = s->inter_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.chroma_intra_quantiser_matrix[i] = s->chroma_intra_matrix[s->dsp.idct_permutation[i]];
+        qmatrix.chroma_non_intra_quantiser_matrix[i] = s->chroma_inter_matrix[s->dsp.idct_permutation[i]];
+        }
+
+    qmatrix.load_intra_quantiser_matrix = 1;
+    qmatrix.load_non_intra_quantiser_matrix = 1;
+    qmatrix.load_chroma_intra_quantiser_matrix = 1;
+    qmatrix.load_chroma_non_intra_quantiser_matrix = 1;
+
+
+    binfo.flags = 0;
+    if (s->alternate_scan)
+        binfo.flags |= XVMC_ALTERNATE_SCAN;
+    if (s->top_field_first)
+        binfo.flags |= XVMC_TOP_FIELD_FIRST;
+    if (s->frame_pred_frame_dct)
+        binfo.flags |= XVMC_PRED_DCT_FRAME;
+    else
+        binfo.flags |= XVMC_PRED_DCT_FIELD;
+
+    if (s->intra_vlc_format)
+        binfo.flags |= XVMC_INTRA_VLC_FORMAT;
+    if (!s->first_field && !s->progressive_sequence)
+        binfo.flags |= XVMC_SECOND_FIELD;
+    if (s->q_scale_type)
+        binfo.flags |= XVMC_Q_SCALE_TYPE;
+    if (s->concealment_motion_vectors)
+        binfo.flags |= XVMC_CONCEALMENT_MOTION_VECTORS;
+    if (s->progressive_sequence)
+        binfo.flags |= XVMC_PROGRESSIVE_SEQUENCE;
+
+    binfo.picture_structure = s->picture_structure;
+    switch (s->pict_type)
+    {
+    case I_TYPE:    binfo.picture_coding_type = XVMC_I_PICTURE;     break;
+    case P_TYPE:    binfo.picture_coding_type = XVMC_P_PICTURE;     break;
+    case B_TYPE:    binfo.picture_coding_type = XVMC_B_PICTURE;     break;
+    default:    av_log(avctx, AV_LOG_ERROR, "%s: Unknown picture coding type: %d\n", __FUNCTION__, s->pict_type);
+    }
+
+    binfo.intra_dc_precision = s->intra_dc_precision;;
+
+    if (s->codec_id == CODEC_ID_MPEG2VIDEO)
+        binfo.mpeg_coding = 2;
+    else
+        binfo.mpeg_coding = 1;
+
+    s->mb_width = (s->width + 15) / 16;
+    s->mb_height = (s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence) ?
+        2 * ((s->height + 31) / 32) : (s->height + 15) / 16;
+
+    if (s->codec_id == CODEC_ID_MPEG2VIDEO)
+{
+    binfo.FVMV_range = (s->mpeg_f_code[0][1] - 1);
+    binfo.FHMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.BVMV_range = (s->mpeg_f_code[1][1] - 1);
+    binfo.BHMV_range = (s->mpeg_f_code[1][0] - 1);
+}
+else
+{
+    binfo.FVMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.FHMV_range = (s->mpeg_f_code[0][0] - 1);
+    binfo.BVMV_range = (s->mpeg_f_code[1][1] - 1);
+    binfo.BHMV_range = (s->mpeg_f_code[1][1] - 1);
+}
+
+    status = XvMCLoadQMatrix(render->disp, render->ctx, &qmatrix);
+    if (status)
+        av_log(avctx,AV_LOG_ERROR, "XvMCLoadQMatrix: Error: %d\n", status);
+
+    status = XvMCBeginSurface(render->disp, render->ctx, render->p_surface,
+                              render->p_past_surface, render->p_future_surface,
+                              &binfo);
+    if (status)
+        av_log(avctx,AV_LOG_ERROR, "XvMCBeginSurface: Error: %d\n", status);
+
+    if (!status)
+        return 0;
+    }
+#endif
+
+    return -1;
 }
 
 void XVMC_field_end(MpegEncContext *s){
-xvmc_render_state_t * render;
+    xvmc_render_state_t * render;
+    
     render = (xvmc_render_state_t*)s->current_picture.data[2];
     assert(render != NULL);
 
-    if(render->filled_mv_blocks_num > 0){
-//        printf("xvmcvideo.c: rendering %d left blocks after last slice!!!\n",render->filled_mv_blocks_num );
-        ff_draw_horiz_band(s,0,0);
+#ifdef HAVE_XVMC_VLD
+    if (s->avctx->xvmc_acceleration == 4)
+    {
+        XvMCFlushSurface(render->disp, render->p_surface);
+        XvMCSyncSurface(render->disp, render->p_surface);
+
+    	s->error_count = 0;
+    }
+    else
+#endif
+    {
+        if(render->filled_mv_blocks_num > 0){
+//          printf("xvmcvideo.c: rendering %d left blocks after last slice!!!\n",render->filled_mv_blocks_num );
+            ff_draw_horiz_band(s,0,0);
+        }
     }
 }
 
@@ -313,4 +513,52 @@
 
 }
 
+#ifdef HAVE_XVMC_VLD
+static int length_to_next_start(uint8_t* pbuf_ptr, int buf_size)
+{
+    uint8_t*    buf_ptr;
+    unsigned int    state = 0xFFFFFFFF, v;
+
+    buf_ptr = pbuf_ptr;
+    while (buf_ptr < pbuf_ptr + buf_size)
+    {
+        v = *buf_ptr++;
+        if (state == 0x000001) {
+            return buf_ptr - pbuf_ptr - 4;
+        }
+        state = ((state << 8) | v) & 0xffffff;
+    }
+    return -1;
+}
+
+#define SLICE_MIN_START_CODE   0x00000101
+#define SLICE_MAX_START_CODE   0x000001af
+
+void XVMC_decode_slice(MpegEncContext *s, int mb_y, uint8_t* buffer, int buf_size)
+{
+    int slicelen = length_to_next_start(buffer, buf_size);
+    xvmc_render_state_t*    render;
+
+    if (slicelen < 0)
+    {
+        if ((mb_y == s->mb_height - 1) || 
+            (!s->progressive_sequence && mb_y == (s->mb_height >> 1) -1) ||
+	    (s->codec_id != CODEC_ID_MPEG2VIDEO))
+            slicelen = buf_size;
+        else
+            return -1;
+    }
+
+    render = (xvmc_render_state_t*)s->current_picture.data[2];
+    render->slice_code = SLICE_MIN_START_CODE + mb_y;
+    render->slice_data = buffer;
+    render->slice_datalen = slicelen;
+
+    ff_draw_horiz_band(s, 0, 0);
+
+    return slicelen;
+}
 #endif
+
+#endif
+
diff -Naur MPlayer-1.0pre7-old/libmpcodecs/img_format.c MPlayer-1.0pre7-new/libmpcodecs/img_format.c
--- MPlayer-1.0pre7-old/libmpcodecs/img_format.c	2004-08-10 18:41:43.000000000 -0700
+++ MPlayer-1.0pre7-new/libmpcodecs/img_format.c	2005-06-01 06:59:17.293471054 -0700
@@ -64,6 +64,7 @@
 	case IMGFMT_ZRMJPEGIB: return("Zoran MJPEG bottom field first");
 	case IMGFMT_XVMC_MOCO_MPEG2: return("MPEG1/2 Motion Compensation");
 	case IMGFMT_XVMC_IDCT_MPEG2: return("MPEG1/2 Motion Compensation and IDCT");
+	case IMGFMT_XVMC_VLD_MPEG2: return("MPEG1/2 Motion Compensation and VLD");
     }
     return("Unknown");
 }
diff -Naur MPlayer-1.0pre7-old/libmpcodecs/img_format.h MPlayer-1.0pre7-new/libmpcodecs/img_format.h
--- MPlayer-1.0pre7-old/libmpcodecs/img_format.h	2004-08-10 18:41:43.000000000 -0700
+++ MPlayer-1.0pre7-new/libmpcodecs/img_format.h	2005-06-01 06:59:17.294470941 -0700
@@ -106,6 +106,7 @@
 //these are chroma420
 #define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
 #define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
+#define IMGFMT_XVMC_VLD_MPEG2 (IMGFMT_XVMC|0x42)
 
 typedef struct {
     void* data;
diff -Naur MPlayer-1.0pre7-old/libmpcodecs/vd_ffmpeg.c MPlayer-1.0pre7-new/libmpcodecs/vd_ffmpeg.c
--- MPlayer-1.0pre7-old/libmpcodecs/vd_ffmpeg.c	2005-04-07 15:04:08.000000000 -0700
+++ MPlayer-1.0pre7-new/libmpcodecs/vd_ffmpeg.c	2005-06-01 06:59:17.295470828 -0700
@@ -51,7 +51,7 @@
 #undef HAVE_XVMC
 #endif
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)||defined(HAVE_XVMC_VLD)
 #include "xvmc_render.h"
 #endif
 
@@ -85,7 +85,7 @@
 static enum PixelFormat get_format(struct AVCodecContext * avctx, 
                                    const enum PixelFormat * pix_fmt);
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)||defined(HAVE_XVMC_VLD)
 static int mc_get_buffer(AVCodecContext *avctx, AVFrame *pic);
 static void mc_release_buffer(AVCodecContext *avctx, AVFrame *pic);
 static void mc_render_slice(struct AVCodecContext *s,
@@ -148,6 +148,10 @@
         case IMGFMT_XVMC_MOCO_MPEG2:
             if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_IDCT) return CONTROL_TRUE;
 #endif
+#ifdef HAVE_XVMC_VLD
+        case IMGFMT_XVMC_VLD_MPEG2:
+            if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_VLD) return CONTROL_TRUE;
+#endif
 	}
         return CONTROL_FALSE;
         }
@@ -207,12 +211,12 @@
         avctx->cr_available = 1;
 #endif
 
-#ifdef HAVE_XVMC
-
+#if defined(HAVE_XVMC)||defined(HAVE_XVMC_VLD)
 #ifdef CODEC_CAP_HWACCEL
     if(lavc_codec->capabilities & CODEC_CAP_HWACCEL){
 #else
-    if(lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC){
+    if((lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC)||
+	(lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC_VLD)){
 #endif
         printf("vd_ffmpeg: XVMC accelerated codec\n");
         assert(ctx->do_dr1);//these are must to!
@@ -506,6 +510,9 @@
         case PIX_FMT_XVMC_MPEG2_MC:ctx->best_csp=IMGFMT_XVMC_MOCO_MPEG2;break;
         case PIX_FMT_XVMC_MPEG2_IDCT:ctx->best_csp=IMGFMT_XVMC_IDCT_MPEG2;break;
 #endif
+#ifdef HAVE_XVMC_VLD
+        case PIX_FMT_XVMC_MPEG2_VLD:ctx->best_csp=IMGFMT_XVMC_VLD_MPEG2;break;
+#endif
 	default:
 	    ctx->best_csp=0;
 	}
@@ -718,7 +725,7 @@
 
 #if LIBAVCODEC_BUILD < 4707
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)||defined(HAVE_XVMC_VLD)
     if( !avctx->xvmc_acceleration )
 #endif
 
@@ -900,12 +907,17 @@
 vd_ffmpeg_ctx *ctx = sh->context;
 int i;
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)||defined(HAVE_XVMC_VLD)
     if(avctx->xvmc_acceleration){
         avctx->get_buffer= mc_get_buffer;
         avctx->release_buffer= mc_release_buffer;
         avctx->draw_horiz_band = mc_render_slice;
+#ifdef HAVE_XVMC
         printf("vd_ffmpeg: XVMC accelerated MPEG2\n");
+#endif
+#ifdef HAVE_XVMC_VLD
+        printf("vd_ffmpeg: XVMC-VLD accelerated MPEG2\n");
+#endif
         assert(ctx->do_dr1);//these are must to!
         assert(ctx->do_slices); //it is (vo_)ffmpeg bug if this fails
         avctx->flags|= CODEC_FLAG_EMU_EDGE;//do i need that??!!
@@ -920,7 +932,7 @@
     return fmt[0];
 }
 
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC)||defined(HAVE_XVMC_VLD)
 static int mc_get_buffer(AVCodecContext *avctx, AVFrame *pic){
     sh_video_t * sh = avctx->opaque;
     vd_ffmpeg_ctx *ctx = sh->context;
diff -Naur MPlayer-1.0pre7-old/libvo/video_out.c MPlayer-1.0pre7-new/libvo/video_out.c
--- MPlayer-1.0pre7-old/libvo/video_out.c	2004-12-21 12:33:51.000000000 -0800
+++ MPlayer-1.0pre7-new/libvo/video_out.c	2005-06-01 06:59:17.295470828 -0700
@@ -156,7 +156,7 @@
 #ifdef HAVE_TDFXFB
         &video_out_tdfxfb,
 #endif
-#ifdef HAVE_XVMC
+#if defined(HAVE_XVMC_VLD)||defined(XVMC)
         &video_out_xvmc,
 #endif
 #ifdef HAVE_XV
diff -Naur MPlayer-1.0pre7-old/libvo/vo_xvmc.c MPlayer-1.0pre7-new/libvo/vo_xvmc.c
--- MPlayer-1.0pre7-old/libvo/vo_xvmc.c	2005-04-13 12:38:44.000000000 -0700
+++ MPlayer-1.0pre7-new/libvo/vo_xvmc.c	2005-06-01 06:59:17.297470603 -0700
@@ -24,6 +24,10 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
+
 #include "x11_common.h"
 #include "xvmc_render.h"
 
@@ -54,6 +58,9 @@
 static int first_frame;//draw colorkey on first frame
 static int use_queue;
 static int xv_port_request = 0;
+static int use_deint_bob; /* non-zero if we're doing bob de-interlacing */
+static int use_deint_one; /* non-zero if we're doing one field de-interlacing */
+static int use_tv_clip;   /* non-zero if we're clipping the top couple of lines */
 
 static int image_width,image_height;
 static uint32_t  drwX,drwY;
@@ -116,7 +123,7 @@
   "XVideo Motion Compensation",
   "xvmc",
   "Ivan Kalvachev <iive@users.sf.net>",
-  ""
+  "Ivor Hewitt <ivor@ivor.org> - VIA VLD support"
 };
 
 LIBVO_EXTERN(xvmc);
@@ -189,7 +196,25 @@
 }
 //end of vo_xv shm/xvimage code
 
+int hasVLDAcceleration()
+{
+#ifdef HAVE_XVMC_VLD
+      return XVMC_VLD == (surface_info.mc_type & XVMC_VLD);
+#else
+    return 0;
+#endif
+}
+
 static int xvmc_check_surface_format(uint32_t format, XvMCSurfaceInfo * surf_info){
+#ifdef HAVE_XVMC_VLD
+   if (format == IMGFMT_XVMC_VLD_MPEG2 ){
+     //printf("VLD Check surf %08x - %08x\n", surf_info->mc_type, XVMC_VLD|XVMC_MPEG_2);
+     if( surf_info->mc_type != (XVMC_VLD|XVMC_MPEG_2) ) return -1;
+     if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
+     return 0;
+   }
+#endif
+
    if ( format == IMGFMT_XVMC_IDCT_MPEG2 ){ 
       if( surf_info->mc_type != (XVMC_IDCT|XVMC_MPEG_2) ) return -1;
       if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
@@ -360,6 +385,9 @@
   {  "benchmark", OPT_ARG_BOOL, &benchmark,       NULL },
   {  "sleep",     OPT_ARG_BOOL, &use_sleep,       NULL },
   {  "queue",     OPT_ARG_BOOL, &use_queue,       NULL },
+  {  "deint-bob", OPT_ARG_BOOL, &use_deint_bob,   NULL },
+  {  "deint-one", OPT_ARG_BOOL, &use_deint_one,   NULL },
+  {  "tv-clip",   OPT_ARG_BOOL, &use_tv_clip,   NULL },  
   {  NULL }
 };
 
@@ -397,6 +425,9 @@
    benchmark = 0; //disable PutImageto allow faster display than screen refresh
    use_sleep = 0;
    use_queue = 0;
+   use_deint_bob = 0;
+   use_deint_one = 0;
+   use_tv_clip = 0;
 
    /* parse suboptions */
    if ( subopt_parse( arg, subopts ) != 0 )
@@ -465,6 +496,8 @@
    if(surface_info.chroma_format == XVMC_CHROMA_FORMAT_444)
       blocks_per_macroblock = 12;
 
+if (!hasVLDAcceleration())
+{
    rez = XvMCCreateBlocks(mDisplay,&ctx,numblocks*blocks_per_macroblock,&data_blocks);
    if( rez != Success ){
       XvMCDestroyContext(mDisplay,&ctx);
@@ -480,6 +513,8 @@
    }
    printf("vo_xvmc: mv_blocks allocated\n");
 
+}
+
    if(surface_render==NULL)
       surface_render=malloc(MAX_SURFACES*sizeof(xvmc_render_state_t));//easy mem debug
    memset(surface_render,0,MAX_SURFACES*sizeof(xvmc_render_state_t));
@@ -498,6 +533,13 @@
       surface_render[i].chroma_format = surface_info.chroma_format;
       surface_render[i].unsigned_intra = (surface_info.flags & XVMC_INTRA_UNSIGNED) == XVMC_INTRA_UNSIGNED;
       surface_render[i].p_surface = &surface_array[i];
+
+        surface_render[i].state = 0;
+
+        surface_render[i].disp = mDisplay;
+        surface_render[i].ctx = &ctx;
+
+
       if( verbose > 3 )
           printf("vo_xvmc: surface[%d] = %p .rndr=%p\n",i,&surface_array[i], &surface_render[i]);
    }
@@ -999,8 +1041,9 @@
 }
 
 static void put_xvmc_image(xvmc_render_state_t * p_render_surface, int draw_ck){
-int rez;
+int rez,field;
 int clipX,clipY,clipW,clipH;
+int srcY=0,srcH=image_height;
 
    if(p_render_surface == NULL)
       return;
@@ -1016,11 +1059,51 @@
    if(benchmark)
       return;
 
+   if (use_tv_clip) {
+    /*
+     Clip top few lines off to get rid of annoying flicker
+     when using bob de-interlacing on TV sourced video.
+    */
+     srcY+=4;
+     srcH-=4;
+   }
+   
+   if (use_deint_bob || use_deint_one) {
+  /*
+   Passing  XVMC_TOP_FIELD then XVMC_BOTTOM_FIELD turns on
+   bob de-interlacing in the unichrome driver. Just passing
+   XVMC_TOP_FIELD through just does 1 field de-interlacing.
+  */
+     field=p_render_surface->flags ? XVMC_TOP_FIELD : XVMC_BOTTOM_FIELD;
+   }
+   else field=XVMC_FRAME_PICTURE; /* no de-interlacing */
+      
    rez = XvMCPutSurface(mDisplay, p_render_surface->p_surface, 
                         vo_window,
-                        0, 0, image_width, image_height,
+                        0, srcY, image_width, srcH,
                         clipX, clipY, clipW, clipH,
-                        3);//p_render_surface_to_show->display_flags);
+                        field);
+
+   if (use_deint_bob && rez == Success) {
+ /*
+   Pause before we do the next putsurface - I guess this is to
+   allow the hardware to complete whatever it needs to do before
+   we hit it with more data, and cause something to spin on a lock
+   Adding this reduces CPU usage from about 20% to 10% on a 1GHz CPU.
+   Xine actually does this:
+     unsigned  ms_per_field = 500 * frame->vo_frame.duration / 90000 - 2;
+   I can't see how to get frame duration in mplayer, so we use an
+   abitrary pause of 10ms - seems to work ok.
+ */
+     usleep(10*1000);
+     rez = XvMCPutSurface(mDisplay, p_render_surface->p_surface, 
+                          vo_window,
+                          0,srcY,image_width,srcH,
+                          clipX, clipY, clipW, clipH,
+                          (field & XVMC_TOP_FIELD) ? XVMC_BOTTOM_FIELD : XVMC_TOP_FIELD);
+   }
+   
+
    if(rez != Success){
       printf("vo_xvmc: PutSurface failer, critical error %d!\n",rez);
       assert(0);
@@ -1124,9 +1207,11 @@
 
    if( number_of_surfaces ){
 
-      XvMCDestroyMacroBlocks(mDisplay,&mv_blocks);
-      XvMCDestroyBlocks(mDisplay,&data_blocks);
-
+      if (!hasVLDAcceleration())
+      {
+         XvMCDestroyMacroBlocks(mDisplay,&mv_blocks);
+         XvMCDestroyBlocks(mDisplay,&data_blocks);
+      }
       for(i=0; i<number_of_surfaces; i++)
       {
          XvMCHideSurface(mDisplay,&surface_array[i]);//it doesn't hurt, I hope
@@ -1199,6 +1284,17 @@
    assert( rndr != NULL );
    assert( rndr->magic == MP_XVMC_RENDER_MAGIC );
 
+   if (hasVLDAcceleration())
+   {
+        rez = XvMCPutSlice2(mDisplay,&ctx,(char*)rndr->slice_data,
+                            rndr->slice_datalen,
+                            rndr->slice_code);
+        if (rez)
+           printf("vo_xxmc::slice Error %d\n",rez);
+
+   }
+   else
+   {
    rez = XvMCRenderSurface(mDisplay,&ctx,rndr->picture_structure,
              		   rndr->p_surface,
                            rndr->p_past_surface,
@@ -1210,7 +1306,7 @@
    if(rez != Success)
    {
    int i;
-      printf("vo_xvmc::slice: RenderSirface returned %d\n",rez);
+      printf("vo_xvmc::slice: RenderSurface returned %d\n",rez);
 
       printf("vo_xvmc::slice: pict=%d,flags=%x,start_blocks=%d,num_blocks=%d\n",
              rndr->picture_structure,rndr->flags,rndr->start_mv_blocks_num,
@@ -1238,6 +1334,7 @@
    rez = XvMCFlushSurface(mDisplay, rndr->p_surface);
    assert(rez==Success);
 
+}
 //   rndr->start_mv_blocks_num += rndr->filled_mv_blocks_num;
    rndr->start_mv_blocks_num = 0;
    rndr->filled_mv_blocks_num = 0;
@@ -1330,8 +1427,16 @@
 
 // these are shared!! so watch out
 // do call RenderSurface before overwriting
+if (!hasVLDAcceleration())
+{
    mpi->planes[0] = (char*)data_blocks.blocks;   
    mpi->planes[1] = (char*)mv_blocks.macro_blocks;
+}
+else
+{
+   mpi->planes[0] = 1;
+   mpi->planes[1] = 0;
+}
    mpi->priv =
    mpi->planes[2] = (char*)rndr;
 
diff -Naur MPlayer-1.0pre7-old/Makefile MPlayer-1.0pre7-new/Makefile
--- MPlayer-1.0pre7-old/Makefile	2005-04-16 13:18:12.000000000 -0700
+++ MPlayer-1.0pre7-new/Makefile	2005-06-01 06:59:17.298470490 -0700
@@ -80,7 +80,9 @@
 ifeq ($(TREMOR),yes)
 PARTS += tremor
 endif
-
+ifeq ($(HAVE_XXMC_ACCEL),yes)
+CODEC_LIBS += $(X_LIB)
+endif
 ALL_PRG = $(PRG)
 ifeq ($(MENCODER),yes)
 ALL_PRG += $(PRG_MENCODER)
diff -Naur MPlayer-1.0pre7-old/version.h MPlayer-1.0pre7-new/version.h
--- MPlayer-1.0pre7-old/version.h	1969-12-31 16:00:00.000000000 -0800
+++ MPlayer-1.0pre7-new/version.h	2005-06-01 06:59:17.298470490 -0700
@@ -0,0 +1 @@
+#define VERSION "1.0pre6-3.4.3"
diff -Naur MPlayer-1.0pre7-old/xvmc_render.h MPlayer-1.0pre7-new/xvmc_render.h
--- MPlayer-1.0pre7-old/xvmc_render.h	2003-08-25 14:40:35.000000000 -0700
+++ MPlayer-1.0pre7-new/xvmc_render.h	2005-06-01 06:59:17.298470490 -0700
@@ -5,6 +5,9 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
 
 //the surface should be shown, video driver manipulate this
 #define MP_XVMC_STATE_DISPLAY_PENDING 1
@@ -27,7 +30,20 @@
   int idct;//does we use IDCT acceleration?
   int chroma_format;//420,422,444
   int unsigned_intra;//+-128 for intra pictures after clip
+
+#ifdef HAVE_XVMC_VLD
+  int reserved1[3];
+  // These are for the XVMC VLD slice interface
+  int pict_type; //this is for skipping frames
+  int   slice_code; 
+  int   slice_datalen;
+  unsigned char *slice_data;
+  Display *disp;
+  XvMCContext *ctx;
+#else
   int reserved1[12];//future extenstions (e.g. gmc,qpel)
+#endif
+  
   void * p_osd_target_surface_render;//pointer to the surface where subpicture is rendered
   XvMCSurface* p_surface;//pointer to rendered surface, never changed
 
@@ -47,4 +63,6 @@
   
   int next_free_data_block_num;//used in add_mv_block, pointer to next free block
 
+
+
 } xvmc_render_state_t;
