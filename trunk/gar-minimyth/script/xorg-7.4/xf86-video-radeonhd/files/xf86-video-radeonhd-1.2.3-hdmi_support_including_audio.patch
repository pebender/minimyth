diff -Naur xf86-video-radeonhd-1.2.3-old/man/radeonhd.man xf86-video-radeonhd-1.2.3-new/man/radeonhd.man
--- xf86-video-radeonhd-1.2.3-old/man/radeonhd.man	2008-10-13 10:51:20.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/man/radeonhd.man	2008-10-17 12:16:13.000000000 -0700
@@ -393,6 +393,17 @@
 mailing list.
 .RE
 .TP
+.BI "Option \*qAudio\*q \*q" boolean \*q
+This option enables the audio hardware, wich is responsible for delivering audio data
+to the different HDMI capable conntectors and used to communicate with the audio
+driver of the operation system. The default is
+.BR off .
+.TP
+.BI "Option \*qHDMI\*q \*q" boolean \*q
+Possible values are "DVI-I 0", "DVI-I 1"..,"DVI-D 0","DVI-I 1",.., "all".
+This option enables HDMI-Audio and HDMI-Info packets on the specified connector.
+This is the only way enabling HDMI at the moment, since decoding E-EDID data to check if monitor supports HDMI is not implemented (yet).
+.TP
 .BI "Option \*qTVMode\*q \*q" tv-mode \*q
 The TV standard to use on the TV output.
 .RS
diff -Naur xf86-video-radeonhd-1.2.3-old/src/Makefile.am xf86-video-radeonhd-1.2.3-new/src/Makefile.am
--- xf86-video-radeonhd-1.2.3-old/src/Makefile.am	2008-10-13 10:54:08.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/Makefile.am	2008-10-17 12:16:13.000000000 -0700
@@ -42,6 +42,10 @@
 	rhd_atomcrtc.c \
 	rhd_biosscratch.c \
 	rhd_biosscratch.h \
+	rhd_audio.c \
+	rhd_audio.h \
+	rhd_hdmi.c \
+	rhd_hdmi.h \
 	rhd_atombios.h \
 	rhd_atomout.h \
 	rhd.h \
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_atomout.c xf86-video-radeonhd-1.2.3-new/src/rhd_atomout.c
--- xf86-video-radeonhd-1.2.3-old/src/rhd_atomout.c	2008-10-13 08:32:39.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_atomout.c	2008-10-17 12:16:13.000000000 -0700
@@ -45,6 +45,7 @@
 #include "rhd_atombios.h"
 #include "rhd_atomout.h"
 #include "rhd_biosscratch.h"
+#include "rhd_hdmi.h"
 
 #if defined (ATOM_BIOS) && defined (ATOM_BIOS_PARSER)
 struct rhdAtomOutputPrivate {
@@ -77,6 +78,7 @@
 
     Bool   Coherent;
     DisplayModePtr Mode;
+    struct rhdHdmi *Hdmi;
 
     int    BlLevel;
 };
@@ -330,6 +332,7 @@
     rhdAtomSelectCrtcSource(rhdPtr->atomBIOS, Output->Crtc->Id ? atomCrtc2 : atomCrtc1, &CrtcSourceConfig);
     data.Address = NULL;
     RHDAtomBiosFunc(Output->scrnIndex, rhdPtr->atomBIOS, ATOM_SET_REGISTER_LIST_LOCATION, &data);
+    RHDHdmiSetMode(Private->Hdmi, Mode);
 }
 
 /*
@@ -342,9 +345,39 @@
     struct rhdAtomOutputPrivate *Private = (struct rhdAtomOutputPrivate *) Output->Private;
     struct atomEncoderConfig *EncoderConfig = &Private->EncoderConfig;
     union AtomBiosArg data;
+    Bool enableHDMI = FALSE;
 
     RHDFUNC(Output);
 
+    if(Output->Connector != NULL) {
+	enableHDMI = RHDConnectorEnableHDMI(Output->Connector);
+	switch(Output->Id) {
+	    case RHD_OUTPUT_TMDSA:
+	    case RHD_OUTPUT_LVTMA:
+		if(enableHDMI && !Private->EncoderConfig.u.lvds2.Hdmi)
+		    Private->EncoderConfig.u.lvds2.Hdmi = TRUE;
+		else if(!enableHDMI && Private->EncoderConfig.u.lvds2.Hdmi)
+		    Private->EncoderConfig.u.lvds2.Hdmi = FALSE;
+		break;
+
+	    case RHD_OUTPUT_UNIPHYA:
+	    case RHD_OUTPUT_UNIPHYB:
+	    case RHD_OUTPUT_KLDSKP_LVTMA:
+		if(enableHDMI && Private->TransmitterConfig.Mode == atomDVI) {
+		    Private->TransmitterConfig.Mode = atomHDMI;
+		    Private->EncoderConfig.u.dig.EncoderMode = atomHDMI;
+
+		} else if(!enableHDMI && Private->TransmitterConfig.Mode == atomHDMI) {
+		    Private->TransmitterConfig.Mode = atomDVI;
+		    Private->EncoderConfig.u.dig.EncoderMode = atomDVI;
+		}
+		break;
+
+	    default:
+		break;
+	}
+    }
+
     data.Address = &Private->Save;
     RHDAtomBiosFunc(Output->scrnIndex, rhdPtr->atomBIOS, ATOM_SET_REGISTER_LIST_LOCATION, &data);
 
@@ -372,6 +405,7 @@
 			ERROR_MSG("rhdAtomOutputControl(atomOutputEnable)");
 		    break;
 	    }
+	    RHDHdmiEnable(Private->Hdmi, enableHDMI);
 	    break;
 	case RHD_POWER_RESET:
 	    RHDDebug(Output->scrnIndex, "RHD_POWER_RESET\n");
@@ -411,6 +445,7 @@
 	    }
 	    if (!rhdAtomEncoderControl(rhdPtr->atomBIOS, Private->EncoderId, atomEncoderOff, &Private->EncoderConfig))
 		ERROR_MSG("rhdAtomEncoderControl(atomEncoderOff)");
+	    RHDHdmiEnable(Private->Hdmi, FALSE);
 	    break;
     }
 
@@ -424,6 +459,8 @@
 static inline void
 rhdAtomOutputSave(struct rhdOutput *Output)
 {
+     struct rhdAtomOutputPrivate *Private = (struct rhdAtomOutputPrivate *) Output->Private;
+     RHDHdmiSave(Private->Hdmi);
 }
 
 /*
@@ -440,6 +477,7 @@
      RHDAtomBiosFunc(Output->scrnIndex, rhdPtr->atomBIOS, ATOM_RESTORE_REGISTERS, &data);
      if (Output->Connector && Output->Connector->Type == RHD_CONNECTOR_PANEL)
 	 atomSetBacklightFromBIOSScratch(Output);
+     RHDHdmiRestore(Private->Hdmi);
 }
 
 /*
@@ -448,6 +486,7 @@
 static ModeStatus
 rhdAtomOutputModeValid(struct rhdOutput *Output, DisplayModePtr Mode)
 {
+
     RHDFUNC(Output);
 
     if (Mode->Flags & V_INTERLACE)
@@ -456,7 +495,6 @@
     if (Mode->Clock < 25000)
 	return MODE_CLOCK_LOW;
 
-
     if (Output->Connector->Type == RHD_CONNECTOR_DVI_SINGLE
 #if 0
 		|| Output->Connector->Type == RHD_CONNECTOR_DP_DUAL
@@ -648,11 +686,14 @@
 static void
 rhdAtomOutputDestroy(struct rhdOutput *Output)
 {
+    struct rhdAtomOutputPrivate *Private = (struct rhdAtomOutputPrivate *) Output->Private;
     RHDFUNC(Output);
-    if (((struct rhdAtomOutputPrivate *)(Output->Private))->Save)
-	xfree(((struct rhdAtomOutputPrivate *)(Output->Private))->Save);
-    if (Output->Private)
-	xfree(Output->Private);
+    if (Private->Save)
+	xfree(Private->Save);
+    RHDHdmiDestroy(Private->Hdmi);
+
+    if (Private)
+	xfree(Private);
     Output->Private = NULL;
     xfree(Output->Name);
 }
@@ -725,11 +766,13 @@
 	    Output->Sense = RHDBIOSScratchDACSense;
 	    Private->EncoderId = atomEncoderDACA;
 	    Private->OutputControlId = atomDAC1Output;
+	    Private->Hdmi = NULL;
 	    break;
 	case RHD_OUTPUT_DACB:
 	    Output->Sense = RHDBIOSScratchDACSense;
 	    Private->EncoderId = atomEncoderDACB;
 	    Private->OutputControlId = atomDAC2Output;
+	    Private->Hdmi = NULL;
 	    break;
 	case RHD_OUTPUT_TMDSA:
 	case RHD_OUTPUT_LVTMA:
@@ -755,6 +798,7 @@
 	    else
 		Private->DualLink = FALSE;
 
+	    Private->Hdmi = RHDHdmiInit(rhdPtr, Output);
 
 	    Private->EncoderVersion = rhdAtomEncoderControlVersion(rhdPtr->atomBIOS, Private->EncoderId);
 	    switch (Private->EncoderVersion.cref) {
@@ -838,9 +882,11 @@
 	    if (ConnectorType == RHD_CONNECTOR_PANEL) {
 		TransmitterConfig->Mode = EncoderConfig->u.dig.EncoderMode = atomLVDS;
 		LVDSInfoRetrieve(rhdPtr, Private);
+		Private->Hdmi = NULL;
 	    } else {
 		TransmitterConfig->Mode = EncoderConfig->u.dig.EncoderMode = atomDVI;
 		TMDSInfoRetrieve(rhdPtr, Private);
+		Private->Hdmi = RHDHdmiInit(rhdPtr, Output);
 	    }
 	    break;
 
@@ -879,6 +925,7 @@
 		case RHD_CONNECTOR_DVI:
 		case RHD_CONNECTOR_DVI_SINGLE:
 		    TransmitterConfig->Mode = EncoderConfig->u.dig.EncoderMode = atomDVI;
+		    Private->Hdmi = RHDHdmiInit(rhdPtr, Output);
 		    break;
 #if 0
 		case RHD_CONNECTOR_DP:
@@ -927,6 +974,7 @@
 		case RHD_CONNECTOR_DVI:
 		case RHD_CONNECTOR_DVI_SINGLE:
 		    TransmitterConfig->Mode = EncoderConfig->u.dig.EncoderMode = atomDVI;
+		    Private->Hdmi = RHDHdmiInit(rhdPtr, Output);
 		    break;
 #if 0
 		case RHD_CONNECTOR_DP:
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_audio.c xf86-video-radeonhd-1.2.3-new/src/rhd_audio.c
--- xf86-video-radeonhd-1.2.3-old/src/rhd_audio.c	1969-12-31 16:00:00.000000000 -0800
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_audio.c	2008-10-17 12:16:13.000000000 -0700
@@ -0,0 +1,396 @@
+/*
+ * Copyright 2008  Christian KÃ¶nig <deathsimple@vodafone.de>
+ * Copyright 2007  Luc Verhaegen <lverhaegen@novell.com>
+ * Copyright 2007  Matthias Hopf <mhopf@novell.com>
+ * Copyright 2007  Egbert Eich   <eich@novell.com>
+ * Copyright 2007  Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "xf86.h"
+
+#include "rhd.h"
+#include "rhd_connector.h"
+#include "rhd_output.h"
+#include "rhd_audio.h"
+#include "rhd_hdmi.h"
+#include "rhd_regs.h"
+
+#define AUDIO_TIMER_INTERVALL 100 /* 1/10 sekund should be enough */
+
+/*
+ * current number of channels
+ */
+static int
+AudioChannels(struct rhdAudio* Audio)
+{
+    return (RHDRegRead(Audio, AUDIO_RATE_BPS_CHANNEL) & 0x7) + 1;
+}
+
+/*
+ * current bits per sample
+ */
+static int
+AudioBitsPerSample(struct rhdAudio* Audio)
+{
+    CARD32 value = (RHDRegRead(Audio, AUDIO_RATE_BPS_CHANNEL) & 0xF0) >> 4;
+    switch(value)
+    {
+	case 0x0: return  8;
+	case 0x1: return 16;
+	case 0x2: return 20;
+	case 0x3: return 24;
+	case 0x4: return 32;
+    }
+
+    xf86DrvMsg(Audio->scrnIndex, X_WARNING, "%s: unknown bits per sample 0x%x "
+               "using 16 instead.\n", __func__, (int) value);
+
+    return 16;
+}
+
+/*
+ * current sampling rate in HZ
+ */
+static int
+AudioRate(struct rhdAudio* Audio)
+{
+    CARD32 value = RHDRegRead(Audio, AUDIO_RATE_BPS_CHANNEL);
+    CARD32 result;
+
+    if(value & 0x4000)
+	result = 44100;
+    else
+	result = 48000;
+
+    result *= ((value >> 11) & 0x7) + 1;
+    result /= ((value >> 8) & 0x7) + 1;
+
+    return result;
+}
+
+/*
+ * something playing ?
+ */
+static Bool
+AudioPlaying(struct rhdAudio* Audio)
+{
+    return (RHDRegRead(Audio, AUDIO_PLAYING) >> 4) & 1;
+}
+
+/*
+ * iec 60958 status bits
+ */
+static CARD8
+AudioStatusBits(struct rhdAudio* Audio)
+{
+    return RHDRegRead(Audio, AUDIO_STATUS_BITS) & 0xff;
+}
+
+/*
+ * iec 60958 category code
+ */
+static CARD8
+AudioCategoryCode(struct rhdAudio* Audio)
+{
+    return (RHDRegRead(Audio, AUDIO_STATUS_BITS) >> 8) & 0xff;
+}
+
+/*
+ * update all registered hdmi interfaces with current audio parameters
+ */
+static CARD32
+AudioUpdateHdmi(OsTimerPtr timer, CARD32 time, pointer ptr)
+{
+    struct rhdAudio *Audio = (struct rhdAudio*)ptr;
+    Bool playing = AudioPlaying(Audio);
+    int channels = AudioChannels(Audio);
+    int rate = AudioRate(Audio);
+    int bps = AudioBitsPerSample(Audio);
+    CARD8 status_bits = AudioStatusBits(Audio);
+    CARD8 category_code = AudioCategoryCode(Audio);
+
+    struct rhdHdmi* hdmi;
+
+    if(playing != Audio->SavedPlaying ||
+	channels != Audio->SavedChannels ||
+	rate != Audio->SavedRate ||
+	bps != Audio->SavedBitsPerSample ||
+	status_bits != Audio->SavedStatusBits ||
+	category_code != Audio->SavedCategoryCode) {
+
+	Audio->SavedPlaying = playing;
+	Audio->SavedChannels = channels;
+	Audio->SavedRate = rate;
+	Audio->SavedBitsPerSample = bps;
+	Audio->SavedStatusBits = status_bits;
+	Audio->SavedCategoryCode = category_code;
+
+	for(hdmi=Audio->Registered; hdmi != NULL; hdmi=hdmi->Next)
+	    RHDHdmiUpdateAudioSettings(
+		hdmi, playing, channels,
+		rate, bps, status_bits,
+		category_code);
+    }
+
+    return AUDIO_TIMER_INTERVALL;
+}
+
+/*
+ * allocate and init the audio structure
+ */
+void
+RHDAudioInit(RHDPtr rhdPtr)
+{
+    RHDFUNC(rhdPtr);
+
+    if (rhdPtr->ChipSet >= RHD_R600) {
+	struct rhdAudio *Audio = (struct rhdAudio *) xnfcalloc(sizeof(struct rhdAudio), 1);
+
+	Audio->scrnIndex = rhdPtr->scrnIndex;
+	Audio->Registered = NULL;
+
+	Audio->SavedChannels = -1;
+	Audio->SavedRate = -1;
+	Audio->SavedBitsPerSample = -1;
+        Audio->SavedStatusBits = 0;
+        Audio->SavedCategoryCode = 0;
+	Audio->Stored = FALSE;
+
+	rhdPtr->Audio = Audio;
+    } else
+	rhdPtr->Audio = NULL;
+}
+
+/*
+ * enable or disable the complete audio engine
+ */
+void
+RHDAudioSetEnable(RHDPtr rhdPtr, Bool Enable)
+{
+    struct rhdAudio *Audio = rhdPtr->Audio;
+
+    if (!Audio)	return;
+    RHDFUNC(Audio);
+
+    RHDRegMask(Audio, AUDIO_ENABLE, Enable ? 0x80000000 : 0x0, 0x80000000);
+    if(Enable) {
+	/* the hardware generates an interrupt if audio starts/stops playing,
+	 * but since drm doesn't support this interrupt, we check
+	 * every AUDIO_TIMER_INTERVALL ms if something has changed
+	 */
+	Audio->Timer = TimerSet(NULL, 0, AUDIO_TIMER_INTERVALL, AudioUpdateHdmi, Audio);
+	RHDAudioSetSupported(
+		rhdPtr,
+		AUDIO_RATE_32000_HZ|AUDIO_RATE_44100_HZ|AUDIO_RATE_48000_HZ|
+		AUDIO_BPS_16|AUDIO_BPS_20|AUDIO_BPS_24,
+		AUDIO_CODEC_PCM
+	);
+    } else {
+	TimerFree(Audio->Timer);
+	Audio->Timer = NULL;
+    }
+}
+
+/*
+ * programm the audio clock and timing registers
+ */
+void
+RHDAudioSetClock(RHDPtr rhdPtr, struct rhdOutput* Output, CARD32 Clock)
+{
+    struct rhdAudio *Audio = rhdPtr->Audio;
+    int Rate = 48000;
+
+    if (!Audio)	return;
+    RHDFUNC(Audio);
+
+    xf86DrvMsg(Audio->scrnIndex, X_INFO, "%s: using %s as clock source with %d khz\n",
+	__func__, Output->Name, (int)Clock);
+
+    switch(Output->Id) {
+	case RHD_OUTPUT_TMDSA:
+	    RHDRegWrite(Audio, AUDIO_PLL1_MUL, Rate*50);
+	    RHDRegWrite(Audio, AUDIO_PLL1_DIV, Clock*100);
+	    RHDRegWrite(Audio, AUDIO_CLK_SRCSEL, 0);
+	    RHDRegMask(Audio, AUDIO_TIMING, 0, 0x301);
+	    break;
+
+	case RHD_OUTPUT_LVTMA:
+	    RHDRegWrite(Audio, AUDIO_PLL2_MUL, Rate*50);
+	    RHDRegWrite(Audio, AUDIO_PLL2_DIV, Clock*100);
+	    RHDRegWrite(Audio, AUDIO_CLK_SRCSEL, 1);
+	    RHDRegMask(Audio, AUDIO_TIMING, 0, 0x301);
+	    break;
+
+	case RHD_OUTPUT_UNIPHYA:
+	/*case RHD_OUTPUT_UNIPHYB: */
+	case RHD_OUTPUT_KLDSKP_LVTMA:
+	    RHDRegWrite(Audio, AUDIO_PLL1_MUL, Rate*50);
+	    RHDRegWrite(Audio, AUDIO_PLL1_DIV, Clock*100);
+	    RHDRegWrite(Audio, AUDIO_PLL2_MUL, 0x18);
+	    RHDRegWrite(Audio, AUDIO_PLL2_DIV, 0x1B);
+	    RHDRegWrite(Audio, AUDIO_CLK_SRCSEL, 0);
+	    RHDRegMask(Audio, AUDIO_TIMING, 0x100, 0x301);
+	    break;
+
+	default:
+	    xf86DrvMsg(Audio->scrnIndex, X_ERROR, "%s: unsupported output type\n", __func__);
+	    break;
+    }
+}
+
+/*
+ * set the supported audio rates, bits per sample and codecs
+ */
+void
+RHDAudioSetSupported(RHDPtr rhdPtr, CARD32 config, CARD32 codec)
+{
+    struct rhdAudio *Audio = rhdPtr->Audio;
+    if (!Audio)	return;
+
+    RHDFUNC(Audio);
+
+    if(config & 0xFFE0F000)
+	xf86DrvMsg(Audio->scrnIndex, X_WARNING, "%s: reserved config bits set 0x%x\n",
+		   __func__, (int) config);
+
+    if(codec & 0xFFFFFFF8)
+	xf86DrvMsg(Audio->scrnIndex, X_WARNING, "%s: reserved codec bits set 0x%x\n",
+		   __func__, (int) codec);
+
+    RHDRegWrite(Audio, AUDIO_SUPPORTED_SIZE_RATE, config);
+    RHDRegWrite(Audio, AUDIO_SUPPORTED_CODEC, codec);
+}
+
+/*
+ * register and hdmi interface for getting updates when audio parameters change
+ */
+void
+RHDAudioRegisterHdmi(RHDPtr rhdPtr, struct rhdHdmi* rhdHdmi)
+{
+    struct rhdAudio *Audio = rhdPtr->Audio;
+    if (!Audio)	return;
+    RHDFUNC(Audio);
+
+    if(!rhdHdmi)
+	return;
+
+    rhdHdmi->Next = Audio->Registered;
+    Audio->Registered = rhdHdmi;
+}
+
+
+/*
+ * unregister the hdmi interface
+ */
+void RHDAudioUnregisterHdmi(RHDPtr rhdPtr, struct rhdHdmi* rhdHdmi)
+{
+    struct rhdAudio *Audio = rhdPtr->Audio;
+    struct rhdHdmi** hdmiPtr;
+    if (!Audio)	return;
+    RHDFUNC(Audio);
+
+    for(hdmiPtr=&Audio->Registered; hdmiPtr!=NULL;hdmiPtr=&(*hdmiPtr)->Next)
+	if(*hdmiPtr == rhdHdmi) {
+	    *hdmiPtr = rhdHdmi->Next;
+	    rhdHdmi->Next = NULL;
+	    return;
+	}
+}
+
+/*
+ * save the current config of audio engine
+ */
+void
+RHDAudioSave(RHDPtr rhdPtr)
+{
+    struct rhdAudio *Audio = rhdPtr->Audio;
+    if (!Audio)	return;
+
+    RHDFUNC(Audio);
+
+    Audio->StoreEnabled = RHDRegRead(Audio, AUDIO_ENABLE) & 0x80000000 ? TRUE : FALSE;
+
+    Audio->StoreTiming = RHDRegRead(Audio, AUDIO_TIMING);
+
+    Audio->StoreSupportedSizeRate = RHDRegRead(Audio, AUDIO_SUPPORTED_SIZE_RATE);
+    Audio->StoreSupportedCodec = RHDRegRead(Audio, AUDIO_SUPPORTED_CODEC);
+
+    Audio->StorePll1Mul     = RHDRegRead(Audio, AUDIO_PLL1_MUL);
+    Audio->StorePll1Div     = RHDRegRead(Audio, AUDIO_PLL1_DIV);
+    Audio->StorePll2Mul     = RHDRegRead(Audio, AUDIO_PLL2_MUL);
+    Audio->StorePll2Div     = RHDRegRead(Audio, AUDIO_PLL2_DIV);
+    Audio->StoreClockSrcSel = RHDRegRead(Audio, AUDIO_CLK_SRCSEL);
+
+    Audio->Stored = TRUE;
+}
+
+/*
+ * restore the saved config of audio engine
+ */
+void
+RHDAudioRestore(RHDPtr rhdPtr)
+{
+    struct rhdAudio *Audio = rhdPtr->Audio;
+    if (!Audio)	return;
+
+    RHDFUNC(Audio);
+
+    if (!Audio->Stored) {
+        xf86DrvMsg(Audio->scrnIndex, X_ERROR, "%s: trying to restore "
+                   "uninitialized values.\n", __func__);
+        return;
+    }
+
+    /* shoutdown the audio engine before doing anything else */
+    RHDAudioSetEnable(rhdPtr, FALSE);
+
+    RHDRegWrite(Audio, AUDIO_TIMING, Audio->StoreTiming);
+    RHDRegWrite(Audio, AUDIO_SUPPORTED_SIZE_RATE, Audio->StoreSupportedSizeRate);
+    RHDRegWrite(Audio, AUDIO_SUPPORTED_CODEC, Audio->StoreSupportedCodec);
+
+    RHDRegWrite(Audio, AUDIO_PLL1_MUL, Audio->StorePll1Mul);
+    RHDRegWrite(Audio, AUDIO_PLL1_DIV, Audio->StorePll1Div);
+    RHDRegWrite(Audio, AUDIO_PLL2_MUL, Audio->StorePll2Mul);
+    RHDRegWrite(Audio, AUDIO_PLL2_DIV, Audio->StorePll2Div);
+    RHDRegWrite(Audio, AUDIO_CLK_SRCSEL, Audio->StoreClockSrcSel);
+
+    RHDAudioSetEnable(rhdPtr, Audio->StoreEnabled);
+}
+
+/*
+ * release the allocated memory
+ */
+void
+RHDAudioDestroy(RHDPtr rhdPtr)
+{
+    RHDFUNC(rhdPtr);
+
+    if (!rhdPtr->Audio)	return;
+
+    if(rhdPtr->Audio->Timer)
+	TimerFree(rhdPtr->Audio->Timer);
+
+    xfree(rhdPtr->Audio);
+}
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_audio.h xf86-video-radeonhd-1.2.3-new/src/rhd_audio.h
--- xf86-video-radeonhd-1.2.3-old/src/rhd_audio.h	1969-12-31 16:00:00.000000000 -0800
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_audio.h	2008-10-17 12:16:13.000000000 -0700
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2008  Christian KÃ¶nig <deathsimple@vodafone.de>
+ * Copyright 2007  Luc Verhaegen <lverhaegen@novell.com>
+ * Copyright 2007  Matthias Hopf <mhopf@novell.com>
+ * Copyright 2007  Egbert Eich   <eich@novell.com>
+ * Copyright 2007  Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _RHD_AUDIO_H
+#define _RHD_AUDIO_H
+
+struct rhdAudio {
+
+	int scrnIndex;
+
+	struct rhdHdmi* Registered;
+	OsTimerPtr 	Timer;
+
+	Bool	SavedPlaying;
+	int	SavedChannels;
+	int	SavedRate;
+	int	SavedBitsPerSample;
+	CARD8	SavedStatusBits;
+	CARD8	SavedCategoryCode;
+
+	Bool Stored;
+	Bool StoreEnabled;
+
+	CARD32 StoreTiming;
+	CARD32 StoreSupportedSizeRate;
+	CARD32 StoreSupportedCodec;
+
+	CARD32 StorePll1Mul;
+	CARD32 StorePll1Div;
+	CARD32 StorePll2Mul;
+	CARD32 StorePll2Div;
+	CARD32 StoreClockSrcSel;
+};
+
+/*
+ * used for config value of RHDAudioSetSupported
+ */
+enum {
+	AUDIO_RATE_8000_HZ   = 0x00000001,
+	AUDIO_RATE_11025_HZ  = 0x00000002,
+	AUDIO_RATE_16000_HZ  = 0x00000004,
+	AUDIO_RATE_22050_HZ  = 0x00000008,
+	AUDIO_RATE_32000_HZ  = 0x00000010,
+	AUDIO_RATE_44100_HZ  = 0x00000020,
+	AUDIO_RATE_48000_HZ  = 0x00000040,
+	AUDIO_RATE_88200_HZ  = 0x00000080,
+	AUDIO_RATE_96000_HZ  = 0x00000100,
+	AUDIO_RATE_176400_HZ = 0x00000200,
+	AUDIO_RATE_192000_HZ = 0x00000400,
+	AUDIO_RATE_384000_HZ = 0x00000800,
+
+	AUDIO_BPS_8  = 0x00010000,
+	AUDIO_BPS_16 = 0x00020000,
+	AUDIO_BPS_20 = 0x00040000,
+	AUDIO_BPS_24 = 0x00080000,
+	AUDIO_BPS_32 = 0x00100000
+};
+
+/*
+ * used for codec value of RHDAudioSetSupported
+ */
+enum {
+	AUDIO_CODEC_PCM      = 0x00000001,
+	AUDIO_CODEC_FLOAT32  = 0x00000002,
+	AUDIO_CODEC_AC3      = 0x00000004
+};
+
+/*
+ * used for status bist value in RHDAudioUpdateHdmi
+ */
+enum {
+	AUDIO_STATUS_DIG_ENABLE   = 0x01,
+	AUDIO_STATUS_V            = 0x02,
+	AUDIO_STATUS_VCFG         = 0x04,
+	AUDIO_STATUS_EMPHASIS     = 0x08,
+	AUDIO_STATUS_COPYRIGHT    = 0x10,
+	AUDIO_STATUS_NONAUDIO     = 0x20,
+	AUDIO_STATUS_PROFESSIONAL = 0x40,
+	AUDIO_STATUS_LEVEL        = 0x80
+};
+
+void RHDAudioInit(RHDPtr rhdPtr);
+
+void RHDAudioSetSupported(RHDPtr rhdPtr, CARD32 config, CARD32 codec);
+void RHDAudioSetEnable(RHDPtr rhdPtr, Bool Enable);
+void RHDAudioSetClock(RHDPtr rhdPtr, struct rhdOutput* Output, CARD32 Clock);
+
+void RHDAudioRegisterHdmi(RHDPtr rhdPtr, struct rhdHdmi* rhdHdmi);
+void RHDAudioUnregisterHdmi(RHDPtr rhdPtr, struct rhdHdmi* rhdHdmi);
+
+void RHDAudioSave(RHDPtr rhdPtr);
+void RHDAudioRestore(RHDPtr rhdPtr);
+
+void RHDAudioDestroy(RHDPtr rhdPtr);
+
+#endif /* _RHD_AUDIO_H */
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_connector.c xf86-video-radeonhd-1.2.3-new/src/rhd_connector.c
--- xf86-video-radeonhd-1.2.3-old/src/rhd_connector.c	2008-10-13 08:32:39.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_connector.c	2008-10-17 12:16:13.000000000 -0700
@@ -484,3 +484,25 @@
 		   output_name[cp[n].Output[1]]);
     }
 }
+
+/*
+ * Should we enable HDMI on this connector?
+ */
+Bool RHDConnectorEnableHDMI(struct rhdConnector *Connector)
+{
+    RHDPtr rhdPtr = RHDPTRI(Connector);
+    RHDFUNC(rhdPtr);
+
+    /* ask connected monitor if it supports HDMI */
+    /* TODO: Not implemented yet! */
+
+    /* check if user forced HDMI on this connector */
+    if(rhdPtr->hdmi.set && (
+	strcasecmp(rhdPtr->hdmi.val.string, Connector->Name) == 0 ||
+	strcasecmp(rhdPtr->hdmi.val.string, "all") == 0))
+    {
+	return TRUE;
+    }
+
+    return FALSE;
+}
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_connector.h xf86-video-radeonhd-1.2.3-new/src/rhd_connector.h
--- xf86-video-radeonhd-1.2.3-old/src/rhd_connector.h	2008-07-22 09:20:48.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_connector.h	2008-10-17 12:16:13.000000000 -0700
@@ -85,5 +85,6 @@
 void RHDHPDSave(RHDPtr rhdPtr);
 void RHDHPDRestore(RHDPtr rhdPtr);
 void RHDConnectorsDestroy(RHDPtr rhdPtr);
+Bool RHDConnectorEnableHDMI(struct rhdConnector *Connector);
 
 #endif /* _RHD_CONNECTOR_H */
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_dig.c xf86-video-radeonhd-1.2.3-new/src/rhd_dig.c
--- xf86-video-radeonhd-1.2.3-old/src/rhd_dig.c	2008-10-13 08:32:39.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_dig.c	2008-10-17 12:16:13.000000000 -0700
@@ -41,6 +41,7 @@
 #include "rhd_connector.h"
 #include "rhd_output.h"
 #include "rhd_regs.h"
+#include "rhd_hdmi.h"
 #ifdef ATOM_BIOS
 #include "rhd_atombios.h"
 #include "rhd_atomout.h"
@@ -106,6 +107,7 @@
     Bool Coherent;
     Bool RunDualLink;
     DisplayModePtr Mode;
+    struct rhdHdmi *Hdmi;
 
     /* LVDS */
     Bool FPDI;
@@ -1249,14 +1251,25 @@
     struct DIGPrivate *Private = (struct DIGPrivate *)Output->Private;
     struct transmitter *Transmitter = &Private->Transmitter;
     struct encoder *Encoder = &Private->Encoder;
+    Bool enableHDMI;
 
     RHDDebug(Output->scrnIndex, "%s(%s,%s)\n",__func__,Output->Name,
 	     rhdPowerString[Power]);
 
+    if(Output->Connector != NULL) {
+	/* check if attached monitor supports HDMI */
+	enableHDMI = RHDConnectorEnableHDMI(Output->Connector);
+	if (enableHDMI && Private->EncoderMode == TMDS_DVI)
+	    Private->EncoderMode = TMDS_HDMI;
+	else if (!enableHDMI && Private->EncoderMode == TMDS_HDMI)
+	    Private->EncoderMode = TMDS_DVI;
+    }
+
     switch (Power) {
 	case RHD_POWER_ON:
 	    Encoder->Power(Output, Power);
 	    Transmitter->Power(Output, Power);
+	    RHDHdmiEnable(Private->Hdmi, Private->EncoderMode == TMDS_HDMI);
 	    return;
 	case RHD_POWER_RESET:
 	    Transmitter->Power(Output, Power);
@@ -1266,6 +1279,7 @@
 	default:
 	    Transmitter->Power(Output, Power);
 	    Encoder->Power(Output, Power);
+	    RHDHdmiEnable(Private->Hdmi, FALSE);
 	    return;
     }
 }
@@ -1319,6 +1333,7 @@
 
     Encoder->Mode(Output, Crtc, Mode);
     Transmitter->Mode(Output, Crtc, Mode);
+    RHDHdmiSetMode(Private->Hdmi, Mode);
 }
 
 /*
@@ -1335,6 +1350,7 @@
 
     Encoder->Save(Output);
     Transmitter->Save(Output);
+    RHDHdmiSave(Private->Hdmi);
 }
 
 /*
@@ -1351,6 +1367,7 @@
 
     Encoder->Restore(Output);
     Transmitter->Restore(Output);
+    RHDHdmiRestore(Private->Hdmi);
 }
 
 /*
@@ -1367,6 +1384,7 @@
 
     Encoder->Destroy(Output);
     Transmitter->Destroy(Output);
+    RHDHdmiDestroy(Private->Hdmi);
 
     xfree(Private);
     Output->Private = NULL;
@@ -1545,14 +1563,17 @@
 	    if (Private->BlLevel < 0)
 		Private->BlLevel = RhdAtomSetupBacklightControlProperty(Output, &Private->Transmitter.Property);
 #endif
+	    Private->Hdmi = NULL;
 	    break;
 	case RHD_CONNECTOR_DVI:
 	    Private->RunDualLink = FALSE; /* will be set later acc to pxclk */
 	    Private->EncoderMode = TMDS_DVI;
+	    Private->Hdmi = RHDHdmiInit(rhdPtr, Output);
 	    break;
 	case RHD_CONNECTOR_DVI_SINGLE:
 	    Private->RunDualLink = FALSE;
-	    Private->EncoderMode = TMDS_DVI;  /* currently also HDMI */
+	    Private->EncoderMode = TMDS_DVI; /* changed later to HDMI if aplicateable */
+	    Private->Hdmi = RHDHdmiInit(rhdPtr, Output);
 	    break;
     }
 
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_driver.c xf86-video-radeonhd-1.2.3-new/src/rhd_driver.c
--- xf86-video-radeonhd-1.2.3-old/src/rhd_driver.c	2008-10-13 10:54:08.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_driver.c	2008-10-17 12:16:13.000000000 -0700
@@ -116,6 +116,7 @@
 #include "rhd_card.h"
 #include "rhd_randr.h"
 #include "rhd_cs.h"
+#include "rhd_audio.h"
 #include "r5xx_accel.h"
 #include "rhd_video.h"
 
@@ -247,7 +248,9 @@
     OPTION_USE_ATOMBIOS,
     OPTION_ATOMBIOS,     /* only for testing, don't document in man page! */
 #endif
-    OPTION_UNVERIFIED_FEAT
+    OPTION_UNVERIFIED_FEAT,
+    OPTION_AUDIO,
+    OPTION_HDMI
 } RHDOpts;
 
 static const OptionInfoRec RHDOptions[] = {
@@ -274,6 +277,8 @@
     { OPTION_ATOMBIOS,	           "AtomBIOS",             OPTV_ANYSTR,  {0}, FALSE },
 #endif
     { OPTION_UNVERIFIED_FEAT,	   "UnverifiedFeatures",   OPTV_BOOLEAN, {0}, FALSE },
+    { OPTION_AUDIO,		   "Audio",	           OPTV_BOOLEAN, {0}, FALSE },
+    { OPTION_HDMI,		   "HDMI",	           OPTV_ANYSTR,  {0}, FALSE },
     { -1, NULL, OPTV_NONE,	{0}, FALSE }
 };
 
@@ -345,6 +350,7 @@
     RHDMCDestroy(rhdPtr);
     RHDVGADestroy(rhdPtr);
     RHDPLLsDestroy(rhdPtr);
+    RHDAudioDestroy(rhdPtr);
     RHDLUTsDestroy(rhdPtr);
     RHDOutputsDestroy(rhdPtr);
     RHDConnectorsDestroy(rhdPtr);
@@ -785,6 +791,7 @@
 	RHDAtomCrtcsInit(rhdPtr);
     if (!RHDPLLsInit(rhdPtr))
 	RHDAtomPLLsInit(rhdPtr);
+    RHDAudioInit(rhdPtr);
     RHDLUTsInit(rhdPtr);
     RHDCursorsInit(rhdPtr); /* do this irrespective of hw/sw cursor setting */
 
@@ -1168,6 +1175,9 @@
     /* fix viewport */
     RHDAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
 
+    /* enable/disable audio */
+    RHDAudioSetEnable(rhdPtr, rhdPtr->audio.val.bool);
+
     /* Initialise cursor functions */
     miDCInitialize (pScreen, xf86GetPointerScreenFuncs());
 
@@ -2344,6 +2354,7 @@
     rhdPtr->BIOSScratch = RHDSaveBiosScratchRegisters(rhdPtr);
 #endif
     RHDPLLsSave(rhdPtr);
+    RHDAudioSave(rhdPtr);
     RHDLUTsSave(rhdPtr);
 
     RHDCrtcSave(rhdPtr->Crtc[0]);
@@ -2367,6 +2378,7 @@
 	rhdRestoreCursor(pScrn);
 
     RHDPLLsRestore(rhdPtr);
+    RHDAudioRestore(rhdPtr);
     RHDLUTsRestore(rhdPtr);
 
     RHDVGARestore(rhdPtr);
@@ -2742,6 +2754,10 @@
 			&rhdPtr->unverifiedFeatures, FALSE);
     RhdGetOptValBool   (rhdPtr->Options, OPTION_USE_ATOMBIOS,
 			&rhdPtr->UseAtomBIOS, FALSE);
+    RhdGetOptValBool   (rhdPtr->Options, OPTION_AUDIO,
+			&rhdPtr->audio, FALSE);
+    RhdGetOptValString (rhdPtr->Options, OPTION_HDMI,
+			&rhdPtr->hdmi, "none");
 
 #ifdef ATOM_BIOS
     rhdParseAtomBIOSUsage(pScrn);
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd.h xf86-video-radeonhd-1.2.3-new/src/rhd.h
--- xf86-video-radeonhd-1.2.3-old/src/rhd.h	2008-10-13 10:54:09.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/rhd.h	2008-10-17 12:16:13.000000000 -0700
@@ -222,6 +222,8 @@
     RHDOpt		tvModeName;
     RHDOpt		scaleTypeOpt;
     RHDOpt		unverifiedFeatures;
+    RHDOpt		audio;
+    RHDOpt		hdmi;
     enum RHD_HPD_USAGE	hpdUsage;
     unsigned int        FbMapSize;
     pointer             FbBase;   /* map base of fb   */
@@ -270,6 +272,7 @@
     struct rhdVGA      *VGA; /* VGA compatibility HW */
     struct rhdCrtc     *Crtc[2];
     struct rhdPLL      *PLLs[2]; /* Pixelclock PLLs */
+    struct rhdAudio    *Audio;
 
     struct rhdLUTStore  *LUTStore;
     struct rhdLUT       *LUT[2];
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_hdmi.c xf86-video-radeonhd-1.2.3-new/src/rhd_hdmi.c
--- xf86-video-radeonhd-1.2.3-old/src/rhd_hdmi.c	1969-12-31 16:00:00.000000000 -0800
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_hdmi.c	2008-10-17 12:16:13.000000000 -0700
@@ -0,0 +1,529 @@
+/*
+ * Copyright 2008  Christian KÃ¶nig <deathsimple@vodafone.de>
+ * Copyright 2007  Luc Verhaegen <lverhaegen@novell.com>
+ * Copyright 2007  Matthias Hopf <mhopf@novell.com>
+ * Copyright 2007  Egbert Eich   <eich@novell.com>
+ * Copyright 2007  Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "xf86.h"
+
+#include "rhd.h"
+#include "rhd_audio.h"
+#include "rhd_connector.h"
+#include "rhd_output.h"
+#include "rhd_hdmi.h"
+#include "rhd_regs.h"
+
+enum HdmiColorFormat {
+    RGB = 0,
+    YCC_422 = 1,
+    YCC_444 = 2
+};
+
+struct {
+    CARD32 Clock;
+
+    int N_32kHz;
+    int CTS_32kHz;
+
+    int N_44_1kHz;
+    int CTS_44_1kHz;
+
+    int N_48kHz;
+    int CTS_48kHz;
+
+} AudioClockRegeneration[] = {
+    /*             32kHz          44.1kHz        48kHz    */
+    /* Clock      N     CTS      N     CTS      N     CTS */
+    {  25174,  4576,  28125,  7007,  31250,  6864,  28125 }, /*  25,20/1.001 MHz */
+    {  25200,  4096,  25200,  6272,  28000,  6144,  25200 }, /*  25.20       MHz */
+    {  27000,  4096,  27000,  6272,  30000,  6144,  27000 }, /*  27.00       MHz */
+    {  27027,  4096,  27027,  6272,  30030,  6144,  27027 }, /*  27.00*1.001 MHz */
+    {  54000,  4096,  54000,  6272,  60000,  6144,  54000 }, /*  54.00       MHz */
+    {  54054,  4096,  54054,  6272,  60060,  6144,  54054 }, /*  54.00*1.001 MHz */
+    {  74175, 11648, 210937, 17836, 234375, 11648, 140625 }, /*  74.25/1.001 MHz */
+    {  74250,  4096,  74250,  6272,  82500,  6144,  74250 }, /*  74.25       MHz */
+    { 148351, 11648, 421875,  8918, 234375,  5824, 140625 }, /* 148.50/1.001 MHz */
+    { 148500,  4096, 148500,  6272, 165000,  6144, 148500 }, /* 148.50       MHz */
+    {      0,  4096,      0,  6272,      0,  6144,      0 }  /* Other */
+};
+
+/*
+ * calculate CTS value if it's not found in the table
+ */
+static void
+HdmiCalcCTS(struct rhdHdmi *hdmi, CARD32 Clock, int* CTS, int N, int freq)
+{
+    if(*CTS == 0) *CTS = (long long)Clock*1000*N/(128*freq);
+    xf86DrvMsg(hdmi->scrnIndex, X_INFO, "Using ACR timing N=%d CTS=%d for frequency %d\n",N,*CTS,freq);
+}
+
+/*
+ * update the N and CTS parameters for a given clock rate
+ */
+static void
+HdmiAudioClockRegeneration(struct rhdHdmi *hdmi, CARD32 Clock)
+{
+    int CTS;
+    int N;
+    int i;
+    for(i=0; AudioClockRegeneration[i].Clock != Clock && AudioClockRegeneration[i].Clock != 0; i++);
+
+    CTS = AudioClockRegeneration[i].CTS_32kHz;
+    N = AudioClockRegeneration[i].N_32kHz;
+    HdmiCalcCTS(hdmi, Clock, &CTS, N, 32000);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_32kHz_CTS, CTS << 12);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_32kHz_N, N);
+
+    CTS = AudioClockRegeneration[i].CTS_44_1kHz;
+    N = AudioClockRegeneration[i].N_44_1kHz;
+    HdmiCalcCTS(hdmi, Clock, &CTS, N, 44100);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_44_1kHz_CTS, CTS << 12);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_44_1kHz_N, N);
+
+    CTS = AudioClockRegeneration[i].CTS_48kHz;
+    N = AudioClockRegeneration[i].N_48kHz;
+    HdmiCalcCTS(hdmi, Clock, &CTS, N, 48000);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_48kHz_CTS, CTS << 12);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_48kHz_N, N);
+}
+
+/*
+ * calculate the crc for a given info frame
+ */
+static void
+HdmiInfoFrameChecksum(CARD8 packetType, CARD8 versionNumber, CARD8 length, CARD8* frame)
+{
+    int i;
+    frame[0] = packetType + versionNumber + length;
+    for(i=1;i<=length;i++)
+	frame[0] += frame[i];
+    frame[0] = 0x100 - frame[0];
+}
+
+/*
+ * build a HDMI Video Info Frame
+ */
+static void
+HdmiVideoInfoFrame(
+    struct rhdHdmi *hdmi,
+    enum HdmiColorFormat ColorFormat,
+    Bool ActiveInformationPresent,
+    CARD8 ActiveFormatAspectRatio,
+    CARD8 ScanInformation,
+    CARD8 Colorimetry,
+    CARD8 ExColorimetry,
+    CARD8 Quantization,
+    Bool ITC,
+    CARD8 PictureAspectRatio,
+    CARD8 VideoFormatIdentification,
+    CARD8 PixelRepetition,
+    CARD8 NonUniformPictureScaling,
+    CARD8 BarInfoDataValid,
+    CARD16 TopBar,
+    CARD16 BottomBar,
+    CARD16 LeftBar,
+    CARD16 RightBar
+)
+{
+    CARD8 frame[14];
+
+    frame[0x0] = 0;
+    frame[0x1] =
+	(ScanInformation & 0x3) |
+	((BarInfoDataValid & 0x3) << 2) |
+	((ActiveInformationPresent & 0x1) << 4) |
+	((ColorFormat & 0x3) << 5);
+    frame[0x2] =
+	(ActiveFormatAspectRatio & 0xF) |
+	((PictureAspectRatio & 0x3) << 4) |
+	((Colorimetry & 0x3) << 6);
+    frame[0x3] =
+	(NonUniformPictureScaling & 0x3) |
+	((Quantization & 0x3) << 2) |
+	((ExColorimetry & 0x7) << 4) |
+	((ITC & 0x1) << 7);
+    frame[0x4] = (VideoFormatIdentification & 0x7F);
+    frame[0x5] = (PixelRepetition & 0xF);
+    frame[0x6] = (TopBar & 0xFF);
+    frame[0x7] = (TopBar >> 8);
+    frame[0x8] = (BottomBar & 0xFF);
+    frame[0x9] = (BottomBar >> 8);
+    frame[0xA] = (LeftBar & 0xFF);
+    frame[0xB] = (LeftBar >> 8);
+    frame[0xC] = (RightBar & 0xFF);
+    frame[0xD] = (RightBar >> 8);
+
+    HdmiInfoFrameChecksum(0x82, 0x02, 0x0D, frame);
+
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_0,
+	frame[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_1,
+	frame[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x7] << 24));
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_2,
+	frame[0x8] | (frame[0x9] << 8) | (frame[0xA] << 16) | (frame[0xB] << 24));
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_3,
+	frame[0xC] | (frame[0xD] << 8));
+}
+
+/*
+ * build a Audio Info Frame
+ */
+static void
+HdmiAudioInfoFrame(
+    struct rhdHdmi *hdmi,
+    CARD8 ChannelCount,
+    CARD8 CodingType,
+    CARD8 SampleSize,
+    CARD8 SampleFrequency,
+    CARD8 Format,
+    CARD8 ChannelAllocation,
+    CARD8 LevelShift,
+    Bool DownmixInhibit
+)
+{
+    CARD8 frame[11];
+
+    frame[0x0] = 0;
+    frame[0x1] = (ChannelCount & 0x7) | ((CodingType & 0xF) << 4);
+    frame[0x2] = (SampleSize & 0x3) | ((SampleFrequency & 0x7) << 2);
+    frame[0x3] = Format;
+    frame[0x4] = ChannelAllocation;
+    frame[0x5] = ((LevelShift & 0xF) << 3) | ((DownmixInhibit & 0x1) << 7);
+    frame[0x6] = 0;
+    frame[0x7] = 0;
+    frame[0x8] = 0;
+    frame[0x9] = 0;
+    frame[0xA] = 0;
+
+    HdmiInfoFrameChecksum(0x84, 0x01, 0x0A, frame);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_AUDIOINFOFRAME_0,
+	frame[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_AUDIOINFOFRAME_1,
+	frame[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x8] << 24));
+}
+
+/*
+ * it's unknown what these bits do excatly, but it's indeed quite usefull for debugging
+ */
+static void
+HdmiAudioDebugWorkaround(struct rhdHdmi* hdmi, Bool Enable)
+{
+    if(Enable) {
+	RHDRegMask(hdmi, hdmi->Offset+HDMI_CNTL, 0x1000, 0x1000);
+	RHDRegWrite(hdmi, hdmi->Offset+HDMI_AUDIO_DEBUG, 0xffffff);
+    } else {
+	RHDRegMask(hdmi, hdmi->Offset+HDMI_CNTL, 0, 0x1000);
+    }
+}
+
+/*
+ * allocate/initialize the HDMI structure
+ * and register with audio engine
+ * output selects which engine is used
+ */
+struct rhdHdmi*
+RHDHdmiInit(RHDPtr rhdPtr, struct rhdOutput* Output)
+{
+    struct rhdHdmi *hdmi;
+    RHDFUNC(rhdPtr);
+
+    if(rhdPtr->ChipSet >= RHD_R600) {
+	hdmi = (struct rhdHdmi *) xnfcalloc(sizeof(struct rhdHdmi), 1);
+	hdmi->scrnIndex = rhdPtr->scrnIndex;
+	hdmi->Output = Output;
+	switch(Output->Id) {
+	    case RHD_OUTPUT_TMDSA:
+		hdmi->Offset = HDMI_TMDS;
+		break;
+
+	    case RHD_OUTPUT_LVTMA:
+		hdmi->Offset = HDMI_LVTMA;
+		break;
+
+	    case RHD_OUTPUT_UNIPHYA:
+		hdmi->Offset = HDMI_TMDS;
+		break;
+
+	    case RHD_OUTPUT_KLDSKP_LVTMA:
+		hdmi->Offset = HDMI_DIG;
+		break;
+
+	    /*case RHD_OUTPUT_UNIPHYB: */
+
+	    default:
+		xf86DrvMsg(hdmi->scrnIndex, X_ERROR, "%s: unknown HDMI output type\n", __func__);
+		xfree(hdmi);
+		return NULL;
+		break;
+	}
+	hdmi->Stored = FALSE;
+	RHDAudioRegisterHdmi(rhdPtr, hdmi);
+	return hdmi;
+    } else
+	return NULL;
+}
+
+/*
+ * update the info frames with the data from the current display mode
+ */
+void
+RHDHdmiSetMode(struct rhdHdmi *hdmi, DisplayModePtr Mode)
+{
+    if(!hdmi) return;
+    RHDFUNC(hdmi);
+
+    RHDAudioSetClock(RHDPTRI(hdmi), hdmi->Output, Mode->Clock);
+
+    HdmiAudioDebugWorkaround(hdmi, FALSE);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_UNKNOWN_0, 0x1000);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_UNKNOWN_1, 0x0);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_UNKNOWN_2, 0x1000);
+
+    HdmiAudioClockRegeneration(hdmi, Mode->Clock);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VIDEOCNTL, 0x13);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VERSION, 0x202);
+
+    HdmiVideoInfoFrame(hdmi, RGB, FALSE, 0, 0, 0, 
+	0, 0, FALSE, 0, 0, 0, 0, 0, 0, 0, 0, 0);
+
+    /* audio packets per line, does anyone know how to calc this ? */
+    RHDRegMask(hdmi, hdmi->Offset+HDMI_CNTL, 0x020000, 0x1F0000);
+
+    /* update? reset? don't realy know */
+    RHDRegMask(hdmi, hdmi->Offset+HDMI_CNTL, 0x14000000, 0x14000000);
+}
+
+/*
+ * update settings whith current parameters from audio engine
+ */
+void
+RHDHdmiUpdateAudioSettings(
+    struct rhdHdmi* hdmi,
+    Bool playing,
+    int channels,
+    int rate,
+    int bps,
+    CARD8 status_bits,
+    CARD8 category_code
+)
+{
+    CARD32 iec;
+
+    if(!hdmi) return;
+    RHDFUNC(hdmi);
+
+    xf86DrvMsg(hdmi->scrnIndex, X_INFO, "%s: %s with "
+	"%d channels, %d Hz sampling rate, %d bits per sample,\n",
+	 __func__, playing ? "playing" : "stoped", channels, rate, bps);
+    xf86DrvMsg(hdmi->scrnIndex, X_INFO, "%s: "
+	"0x%02x IEC60958 status bits and 0x%02x category code\n",
+	 __func__, (int)status_bits, (int)category_code);
+
+    /* start delivering audio frames */
+    RHDRegMask(hdmi, hdmi->Offset+HDMI_CNTL, playing ? 1 : 0, 0x1);
+
+    iec = 0;
+    if(status_bits & AUDIO_STATUS_PROFESSIONAL)	iec |= 1 << 0;
+    if(status_bits & AUDIO_STATUS_NONAUDIO)	iec |= 1 << 1;
+    if(status_bits & AUDIO_STATUS_COPYRIGHT)	iec |= 1 << 2;
+    if(status_bits & AUDIO_STATUS_EMPHASIS)	iec |= 1 << 3;
+
+    iec |= category_code << 8;
+
+    switch(rate)
+    {
+        case  32000: iec |= 0x3 << 24; break;
+        case  44100: iec |= 0x0 << 24; break;
+        case  88200: iec |= 0x8 << 24; break;
+        case 176400: iec |= 0xc << 24; break;
+        case  48000: iec |= 0x2 << 24; break;
+        case  96000: iec |= 0xa << 24; break;
+        case 192000: iec |= 0xe << 24; break;
+    }
+ 
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_IEC60958_1, iec);
+
+    iec = 0;
+    switch(bps)
+    {
+    	case 16: iec |= 0x2; break;
+    	case 20: iec |= 0x3; break;
+    	case 24: iec |= 0xb; break;
+    }
+    if(status_bits & AUDIO_STATUS_V) iec |= 0x5 << 16;
+
+    RHDRegMask(hdmi, hdmi->Offset+HDMI_IEC60958_2, iec, 0x5000f);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_AUDIOCNTL, 0x31);
+    HdmiAudioInfoFrame(hdmi, channels-1, 0, 0, 0, 0, 0, 0, FALSE);
+
+    RHDRegMask(hdmi, hdmi->Offset+HDMI_CNTL, 0x400000, 0x400000);
+}
+
+/*
+ * enable/disable the HDMI engine
+ */
+void
+RHDHdmiEnable(struct rhdHdmi *hdmi, Bool Enable)
+{
+    if(!hdmi) return;
+    RHDFUNC(hdmi);
+
+    /* some version of atombios ignore the enable HDMI flag
+     * so enabling/disabling HDMI was moved here for TMDSA and LVTMA */
+    switch(hdmi->Output->Id) {
+	case RHD_OUTPUT_TMDSA:
+	     RHDRegMask(hdmi, TMDSA_CNTL, Enable ? 0x4 : 0x0, 0x4);
+	     RHDRegWrite(hdmi, hdmi->Offset+HDMI_ENABLE, Enable ? 0x101 : 0x0);
+	     break;
+
+	case RHD_OUTPUT_LVTMA:
+	     RHDRegMask(hdmi, LVTMA_CNTL, Enable ? 0x4 : 0x0, 0x4);
+	     RHDRegWrite(hdmi, hdmi->Offset+HDMI_ENABLE, Enable ? 0x105 : 0x0);
+	     break;
+
+	case RHD_OUTPUT_UNIPHYA:
+	case RHD_OUTPUT_UNIPHYB:
+	case RHD_OUTPUT_KLDSKP_LVTMA:
+	    RHDRegWrite(hdmi, hdmi->Offset+HDMI_ENABLE, Enable ? 0x110 : 0x0);
+	    break;
+
+	default:
+	    xf86DrvMsg(hdmi->scrnIndex, X_ERROR, "%s: unknown HDMI output type\n", __func__);
+	    break;
+    }
+}
+
+/*
+ * save the current config of HDMI engine
+ */
+void
+RHDHdmiSave(struct rhdHdmi *hdmi)
+{
+    if(!hdmi) return;
+    RHDFUNC(hdmi);
+
+    hdmi->StoreEnable = RHDRegRead(hdmi, hdmi->Offset+HDMI_ENABLE);
+    hdmi->StoreControl = RHDRegRead(hdmi, hdmi->Offset+HDMI_CNTL);
+    hdmi->StoredAudioDebugWorkaround = RHDRegRead(hdmi, hdmi->Offset+HDMI_AUDIO_DEBUG);
+
+    hdmi->StoredFrameVersion = RHDRegRead(hdmi, hdmi->Offset+HDMI_VERSION);
+
+    hdmi->StoredVideoControl = RHDRegRead(hdmi, hdmi->Offset+HDMI_VIDEOCNTL);
+    hdmi->StoreVideoInfoFrame[0x0] = RHDRegRead(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_0);
+    hdmi->StoreVideoInfoFrame[0x1] = RHDRegRead(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_1);
+    hdmi->StoreVideoInfoFrame[0x2] = RHDRegRead(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_2);
+    hdmi->StoreVideoInfoFrame[0x3] = RHDRegRead(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_3);
+
+    hdmi->StoredAudioControl = RHDRegRead(hdmi, hdmi->Offset+HDMI_AUDIOCNTL);
+    hdmi->StoreAudioInfoFrame[0x0] = RHDRegRead(hdmi, hdmi->Offset+HDMI_AUDIOINFOFRAME_0);
+    hdmi->StoreAudioInfoFrame[0x1] = RHDRegRead(hdmi, hdmi->Offset+HDMI_AUDIOINFOFRAME_1);
+
+    hdmi->Store_32kHz_N = RHDRegRead(hdmi, hdmi->Offset+HDMI_32kHz_N);
+    hdmi->Store_32kHz_CTS = RHDRegRead(hdmi, hdmi->Offset+HDMI_32kHz_CTS);
+
+    hdmi->Store_44_1kHz_N = RHDRegRead(hdmi, hdmi->Offset+HDMI_44_1kHz_N);
+    hdmi->Store_44_1kHz_CTS = RHDRegRead(hdmi, hdmi->Offset+HDMI_44_1kHz_CTS);
+
+    hdmi->Store_48kHz_N = RHDRegRead(hdmi, hdmi->Offset+HDMI_48kHz_N);
+    hdmi->Store_48kHz_CTS = RHDRegRead(hdmi, hdmi->Offset+HDMI_48kHz_CTS);
+
+    hdmi->StoreIEC60958[0] = RHDRegRead(hdmi, hdmi->Offset+HDMI_IEC60958_1);
+    hdmi->StoreIEC60958[1] = RHDRegRead(hdmi, hdmi->Offset+HDMI_IEC60958_2);
+
+    hdmi->StoreUnknown[0x0] = RHDRegRead(hdmi, hdmi->Offset+HDMI_UNKNOWN_0);
+    hdmi->StoreUnknown[0x1] = RHDRegRead(hdmi, hdmi->Offset+HDMI_UNKNOWN_1);
+    hdmi->StoreUnknown[0x2] = RHDRegRead(hdmi, hdmi->Offset+HDMI_UNKNOWN_2);
+
+    hdmi->Stored = TRUE;
+}
+
+/*
+ * restore the saved config of HDMI engine
+ */
+void
+RHDHdmiRestore(struct rhdHdmi *hdmi)
+{
+    if(!hdmi) return;
+    RHDFUNC(hdmi);
+
+    if (!hdmi->Stored) {
+        xf86DrvMsg(hdmi->scrnIndex, X_ERROR, "%s: trying to restore "
+                   "uninitialized values.\n", __func__);
+        return;
+    }
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_ENABLE, hdmi->StoreEnable);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_CNTL, hdmi->StoreControl);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_AUDIO_DEBUG, hdmi->StoredAudioDebugWorkaround);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VERSION, hdmi->StoredFrameVersion);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VIDEOCNTL, hdmi->StoredVideoControl);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_0, hdmi->StoreVideoInfoFrame[0x0]);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_1, hdmi->StoreVideoInfoFrame[0x1]);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_2, hdmi->StoreVideoInfoFrame[0x2]);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_VIDEOINFOFRAME_3, hdmi->StoreVideoInfoFrame[0x3]);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_AUDIOCNTL, hdmi->StoredAudioControl);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_AUDIOINFOFRAME_0, hdmi->StoreAudioInfoFrame[0x0]);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_AUDIOINFOFRAME_1, hdmi->StoreAudioInfoFrame[0x1]);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_32kHz_N, hdmi->Store_32kHz_N);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_32kHz_CTS, hdmi->Store_32kHz_CTS);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_44_1kHz_N, hdmi->Store_44_1kHz_N);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_44_1kHz_CTS, hdmi->Store_44_1kHz_CTS);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_48kHz_N, hdmi->Store_48kHz_N);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_48kHz_CTS, hdmi->Store_48kHz_CTS);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_IEC60958_1, hdmi->StoreIEC60958[0]);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_IEC60958_2, hdmi->StoreIEC60958[1]);
+
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_UNKNOWN_0, hdmi->StoreUnknown[0x0]);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_UNKNOWN_1, hdmi->StoreUnknown[0x1]);
+    RHDRegWrite(hdmi, hdmi->Offset+HDMI_UNKNOWN_2, hdmi->StoreUnknown[0x2]);
+}
+
+/*
+ * unregister with audio engine and release memory
+ */
+void
+RHDHdmiDestroy(struct rhdHdmi *hdmi)
+{
+    if(!hdmi) return;
+    RHDFUNC(hdmi);
+
+    RHDAudioUnregisterHdmi(RHDPTRI(hdmi), hdmi);
+
+    xfree(hdmi);
+}
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_hdmi.h xf86-video-radeonhd-1.2.3-new/src/rhd_hdmi.h
--- xf86-video-radeonhd-1.2.3-old/src/rhd_hdmi.h	1969-12-31 16:00:00.000000000 -0800
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_hdmi.h	2008-10-17 12:16:13.000000000 -0700
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2008  Christian KÃ¶nig <deathsimple@vodafone.de>
+ * Copyright 2007  Luc Verhaegen <lverhaegen@novell.com>
+ * Copyright 2007  Matthias Hopf <mhopf@novell.com>
+ * Copyright 2007  Egbert Eich   <eich@novell.com>
+ * Copyright 2007  Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _RHD_HDMI_H
+#define _RHD_HDMI_H
+
+struct rhdHdmi {
+	struct rhdHdmi* Next;
+
+	int scrnIndex;
+
+	struct rhdOutput* Output;
+	CARD16 Offset;
+
+	Bool Stored;
+	CARD32 StoreEnable;
+	CARD32 StoreControl;
+	CARD32 StoreUnknown[0x3];
+	CARD32 StoredAudioDebugWorkaround;
+
+	CARD32 StoredFrameVersion;
+	CARD32 StoredVideoControl;
+	CARD32 StoreVideoInfoFrame[0x4];
+	CARD32 StoredAudioControl;
+	CARD32 StoreAudioInfoFrame[0x2];
+
+	CARD32 Store_32kHz_N;
+	CARD32 Store_32kHz_CTS;
+
+	CARD32 Store_44_1kHz_N;
+	CARD32 Store_44_1kHz_CTS;
+
+	CARD32 Store_48kHz_N;
+	CARD32 Store_48kHz_CTS;
+
+	CARD32 StoreIEC60958[2];
+};
+
+struct rhdHdmi* RHDHdmiInit(RHDPtr rhdPtr, struct rhdOutput* Output);
+
+void RHDHdmiSetMode(struct rhdHdmi* rhdHdmi, DisplayModePtr Mode);
+void RHDHdmiEnable(struct rhdHdmi* rhdHdmi, Bool Enable);
+void RHDHdmiUpdateAudioSettings(
+	struct rhdHdmi* rhdHdmi,
+	Bool playing,
+	int channels,
+	int rate,
+	int bps,
+	CARD8 status_bits,
+	CARD8 catgory_code
+);
+
+void RHDHdmiSave(struct rhdHdmi* rhdHdmi);
+void RHDHdmiRestore(struct rhdHdmi* rhdHdmi);
+
+void RHDHdmiDestroy(struct rhdHdmi* rhdHdmi);
+
+#endif /* _RHD_HDMI_H */
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_lvtma.c xf86-video-radeonhd-1.2.3-new/src/rhd_lvtma.c
--- xf86-video-radeonhd-1.2.3-old/src/rhd_lvtma.c	2008-10-13 10:51:21.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_lvtma.c	2008-10-17 12:16:13.000000000 -0700
@@ -47,6 +47,7 @@
 #include "rhd_connector.h"
 #include "rhd_output.h"
 #include "rhd_regs.h"
+#include "rhd_hdmi.h"
 #ifdef ATOM_BIOS
 #include "rhd_atombios.h"
 #include "rhd_atomout.h"
@@ -693,6 +694,21 @@
 
 /*
  *
+ */
+static void
+LVDSDestroy(struct rhdOutput *Output)
+{
+    RHDFUNC(Output);
+
+    if (!Output->Private)
+	return;
+
+    xfree(Output->Private);
+    Output->Private = NULL;
+}
+
+/*
+ *
  * Handling for LVTMA block as TMDS.
  *
  */
@@ -701,6 +717,8 @@
     Bool Coherent;
     DisplayModePtr Mode;
 
+    struct rhdHdmi *Hdmi;
+
     Bool Stored;
 
     CARD32 StoreControl;
@@ -1116,6 +1134,8 @@
     RHDRegMask(Output, LVTMA_DATA_SYNCHRONIZATION, 0x00000100, 0x00000100);
     usleep(2);
     RHDRegMask(Output, LVTMA_DATA_SYNCHRONIZATION, 0, 0x00000001);
+
+    RHDHdmiSetMode(Private->Hdmi, Mode);
 }
 
 /*
@@ -1134,7 +1154,7 @@
 
     switch (Power) {
     case RHD_POWER_ON:
-	RHDRegMask(Output, LVTMA_CNTL, 0x00000001, 0x00000001);
+	RHDRegMask(Output, LVTMA_CNTL, 0x1, 0x00000001);
 
 	if (Private->RunsDualLink)
 	    RHDRegMask(Output, LVTMA_TRANSMITTER_ENABLE, 0x00003E3E,0x00003E3E);
@@ -1144,6 +1164,10 @@
 	RHDRegMask(Output, LVTMA_TRANSMITTER_CONTROL, 0x00000001, 0x00000001);
 	usleep(2);
 	RHDRegMask(Output, LVTMA_TRANSMITTER_CONTROL, 0, 0x00000002);
+	if(Output->Connector != NULL && RHDConnectorEnableHDMI(Output->Connector))
+	    RHDHdmiEnable(Private->Hdmi, TRUE);
+	else
+	    RHDHdmiEnable(Private->Hdmi, FALSE);
 	return;
     case RHD_POWER_RESET:
 	RHDRegMask(Output, LVTMA_TRANSMITTER_ENABLE, 0, 0x00003E3E);
@@ -1155,6 +1179,7 @@
 	RHDRegMask(Output, LVTMA_TRANSMITTER_CONTROL, 0, 0x00000001);
 	RHDRegMask(Output, LVTMA_TRANSMITTER_ENABLE, 0, 0x00003E3E);
 	RHDRegMask(Output, LVTMA_CNTL, 0, 0x00000001);
+	RHDHdmiEnable(Private->Hdmi, FALSE);
 	return;
     }
 }
@@ -1189,6 +1214,8 @@
        Private->StoreRv600PreEmphasis = RHDRegRead(Output, LVTMA_PREEMPHASIS_CONTROL);
     }
 
+    RHDHdmiSave(Private->Hdmi);
+
     Private->Stored = TRUE;
 }
 
@@ -1227,6 +1254,8 @@
 	RHDRegWrite(Output, LVTMA_TRANSMITTER_ADJUST, Private->StoreRv600TXAdjust);
 	RHDRegWrite(Output, LVTMA_PREEMPHASIS_CONTROL, Private->StoreRv600PreEmphasis);
     }
+
+    RHDHdmiRestore(Private->Hdmi);
 }
 
 
@@ -1234,14 +1263,17 @@
  *
  */
 static void
-LVTMADestroy(struct rhdOutput *Output)
+TMDSBDestroy(struct rhdOutput *Output)
 {
+    struct rhdTMDSBPrivate *Private = (struct rhdTMDSBPrivate *) Output->Private;
     RHDFUNC(Output);
 
-    if (!Output->Private)
+    if (!Private)
 	return;
 
-    xfree(Output->Private);
+    RHDHdmiDestroy(Private->Hdmi);
+
+    xfree(Private);
     Output->Private = NULL;
 }
 
@@ -1270,7 +1302,6 @@
     Output->Id = RHD_OUTPUT_LVTMA;
 
     Output->Sense = NULL; /* not implemented in hw */
-    Output->Destroy = LVTMADestroy;
 
     if (Type == RHD_CONNECTOR_PANEL) {
 	struct LVDSPrivate *Private;
@@ -1283,6 +1314,7 @@
 	Output->Save = LVDSSave;
 	Output->Restore = LVDSRestore;
 	Output->Property = LVDSPropertyControl;
+	Output->Destroy = LVDSDestroy;
 	Output->Private = Private =  LVDSInfoRetrieve(rhdPtr);
 #if 0
 	if (Private->BlLevel < 0)
@@ -1304,7 +1336,9 @@
 	Output->Save = TMDSBSave;
 	Output->Restore = TMDSBRestore;
 	Output->Property = TMDSBPropertyControl;
+	Output->Destroy = TMDSBDestroy;
 
+	Private->Hdmi = RHDHdmiInit(rhdPtr, Output);
 	Output->Private = Private;
 
 	Private->RunsDualLink = FALSE;
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_randr.c xf86-video-radeonhd-1.2.3-new/src/rhd_randr.c
--- xf86-video-radeonhd-1.2.3-old/src/rhd_randr.c	2008-10-13 10:51:21.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_randr.c	2008-10-17 12:16:13.000000000 -0700
@@ -72,6 +72,8 @@
 # include "rhd_mc.h"
 # include "rhd_card.h"
 # include "rhd_i2c.h"
+# include "rhd_audio.h"
+
 /*
  * Driver internal
  */
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_regs.h xf86-video-radeonhd-1.2.3-new/src/rhd_regs.h
--- xf86-video-radeonhd-1.2.3-old/src/rhd_regs.h	2008-09-22 10:15:23.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_regs.h	2008-10-17 12:16:13.000000000 -0700
@@ -96,6 +96,15 @@
     PCLK_CRTC1_CNTL                = 0x0480,
     PCLK_CRTC2_CNTL                = 0x0484,
 
+    /* these regs were reverse enginered, 
+     * so the chance is high that the naming is wrong 
+     * R6xx+ ??? */
+    AUDIO_PLL1_MUL		   = 0x0514,
+    AUDIO_PLL1_DIV		   = 0x0518,
+    AUDIO_PLL2_MUL		   = 0x0524,
+    AUDIO_PLL2_DIV		   = 0x0528,
+    AUDIO_CLK_SRCSEL		   = 0x0534,
+
     DCCG_DISP_CLK_SRCSEL           = 0x0538, /* rv620+ */
 
     SRBM_STATUS                    = 0x0E50,
@@ -261,6 +270,38 @@
     D2SCL_DITHER                   = 0x6DD4, /* guess */
     D2SCL_FLIP_CONTROL             = 0x6DD8, /* guess */
 
+    /* Audio, reverse enginered */
+    AUDIO_ENABLE		   = 0x7300, /* RW */
+    AUDIO_TIMING		   = 0x7344, /* RW */
+    /* Audio params */
+    AUDIO_VENDOR_ID                = 0x7380, /* RW */
+    AUDIO_REVISION_ID              = 0x7384, /* RW */
+    AUDIO_ROOT_NODE_COUNT          = 0x7388, /* RW */
+    AUDIO_NID1_NODE_COUNT          = 0x738c, /* RW */
+    AUDIO_NID1_TYPE                = 0x7390, /* RW */
+    AUDIO_SUPPORTED_SIZE_RATE      = 0x7394, /* RW */
+    AUDIO_SUPPORTED_CODEC          = 0x7398, /* RW */
+    AUDIO_SUPPORTED_POWER_STATES   = 0x739c, /* RW */
+    AUDIO_NID2_CAPS                = 0x73a0, /* RW */
+    AUDIO_NID3_CAPS                = 0x73a4, /* RW */
+    AUDIO_NID3_PIN_CAPS            = 0x73a8, /* RW */
+    /* Audio conn list */
+    AUDIO_CONN_LIST_LEN            = 0x73ac, /* RW */
+    AUDIO_CONN_LIST                = 0x73b0, /* RW */
+    /* Audio verbs */
+    AUDIO_RATE_BPS_CHANNEL         = 0x73c0, /* RO */
+    AUDIO_PLAYING                  = 0x73c4, /* RO */
+    AUDIO_IMPLEMENTATION_ID        = 0x73c8, /* RW */
+    AUDIO_CONFIG_DEFAULT           = 0x73cc, /* RW */
+    AUDIO_PIN_SENSE                = 0x73d0, /* RW */
+    AUDIO_PIN_WIDGET_CNTL          = 0x73d4, /* RO */
+    AUDIO_STATUS_BITS              = 0x73d8, /* RO */
+
+    /* HDMI */
+    HDMI_TMDS			   = 0x7400,
+    HDMI_LVTMA			   = 0x7700,
+    HDMI_DIG			   = 0x7800,
+
     /* R500 DAC A */
     DACA_ENABLE                    = 0x7800,
     DACA_SOURCE_SELECT             = 0x7804,
@@ -1044,5 +1085,31 @@
     AGPv3_8X_MODE        = 0x02
 };
 
+enum {
+    /* HDMI registers */
+    HDMI_ENABLE           = 0x00,
+    HDMI_CNTL             = 0x08,
+    HDMI_UNKNOWN_0        = 0x0C,
+    HDMI_AUDIOCNTL        = 0x10,
+    HDMI_VIDEOCNTL        = 0x14,
+    HDMI_VERSION          = 0x18,
+    HDMI_UNKNOWN_1        = 0x28,
+    HDMI_VIDEOINFOFRAME_0 = 0x54,
+    HDMI_VIDEOINFOFRAME_1 = 0x58,
+    HDMI_VIDEOINFOFRAME_2 = 0x5c,
+    HDMI_VIDEOINFOFRAME_3 = 0x60,
+    HDMI_32kHz_CTS        = 0xac,
+    HDMI_32kHz_N          = 0xb0,
+    HDMI_44_1kHz_CTS      = 0xb4,
+    HDMI_44_1kHz_N        = 0xb8,
+    HDMI_48kHz_CTS        = 0xbc,
+    HDMI_48kHz_N          = 0xc0,
+    HDMI_AUDIOINFOFRAME_0 = 0xcc,
+    HDMI_AUDIOINFOFRAME_1 = 0xd0,
+    HDMI_IEC60958_1       = 0xd4,
+    HDMI_IEC60958_2       = 0xd8,
+    HDMI_UNKNOWN_2        = 0xdc,
+    HDMI_AUDIO_DEBUG      = 0xe0
+};
 
 #endif /* _RHD_REGS_H */
diff -Naur xf86-video-radeonhd-1.2.3-old/src/rhd_tmds.c xf86-video-radeonhd-1.2.3-new/src/rhd_tmds.c
--- xf86-video-radeonhd-1.2.3-old/src/rhd_tmds.c	2008-09-22 10:15:23.000000000 -0700
+++ xf86-video-radeonhd-1.2.3-new/src/rhd_tmds.c	2008-10-17 12:16:13.000000000 -0700
@@ -46,6 +46,7 @@
 #include "rhd_connector.h"
 #include "rhd_output.h"
 #include "rhd_regs.h"
+#include "rhd_hdmi.h"
 
 #ifdef ATOM_BIOS
 #include "rhd_atombios.h"
@@ -57,6 +58,8 @@
     Bool Coherent;
     int PowerState;
 
+    struct rhdHdmi *Hdmi;
+
     Bool Stored;
 
     CARD32 StoreControl;
@@ -335,6 +338,8 @@
 	RHDRegMask(Output, TMDSA_TRANSMITTER_CONTROL, 0x00000000, 0x10000000);
     else
 	RHDRegMask(Output, TMDSA_TRANSMITTER_CONTROL, 0x10000000, 0x10000000);
+
+    RHDHdmiSetMode(Private->Hdmi, Mode);
 }
 
 /*
@@ -353,7 +358,7 @@
     case RHD_POWER_ON:
 	if (Private->PowerState == RHD_POWER_SHUTDOWN
 	    || Private->PowerState == RHD_POWER_UNKNOWN) {
-	    RHDRegMask(Output, TMDSA_CNTL, 0x00000001, 0x00000001);
+	    RHDRegMask(Output, TMDSA_CNTL, 0x1, 0x00000001);
 
 	    RHDRegMask(Output, TMDSA_TRANSMITTER_CONTROL, 0x00000001, 0x00000001);
 	    usleep(20);
@@ -385,6 +390,11 @@
 	    RHDRegMask(Output, TMDSA_TRANSMITTER_ENABLE, 0x00001F1F, 0x00001F1F);
 	} else
 	    RHDRegMask(Output, TMDSA_TRANSMITTER_ENABLE, 0x0000001F, 0x00001F1F);
+
+	if(Output->Connector != NULL && RHDConnectorEnableHDMI(Output->Connector))
+	    RHDHdmiEnable(Private->Hdmi, TRUE);
+	else
+	    RHDHdmiEnable(Private->Hdmi, FALSE);
 	Private->PowerState = RHD_POWER_ON;
 	return;
 
@@ -403,6 +413,7 @@
 	RHDRegMask(Output, TMDSA_TRANSMITTER_CONTROL, 0, 0x00000001);
 	RHDRegMask(Output, TMDSA_TRANSMITTER_ENABLE, 0, 0x00001F1F);
 	RHDRegMask(Output, TMDSA_CNTL, 0, 0x00000001);
+	RHDHdmiEnable(Private->Hdmi, FALSE);
 	Private->PowerState = RHD_POWER_SHUTDOWN;
 	return;
     }
@@ -438,6 +449,8 @@
     if (ChipSet >= RHD_RV610)
 	Private->StoreTXAdjust = RHDRegRead(Output, TMDSA_TRANSMITTER_ADJUST);
 
+    RHDHdmiSave(Private->Hdmi);
+
     Private->Stored = TRUE;
 }
 
@@ -476,6 +489,8 @@
 
     if (ChipSet >= RHD_RV610)
 	RHDRegWrite(Output, TMDSA_TRANSMITTER_ADJUST, Private->StoreTXAdjust);
+
+    RHDHdmiRestore(Private->Hdmi);
 }
 
 /*
@@ -484,12 +499,15 @@
 static void
 TMDSADestroy(struct rhdOutput *Output)
 {
+    struct rhdTMDSPrivate *Private = (struct rhdTMDSPrivate *) Output->Private;
     RHDFUNC(Output);
 
-    if (!Output->Private)
+    if (!Private)
 	return;
 
-    xfree(Output->Private);
+    RHDHdmiDestroy(Private->Hdmi);
+
+    xfree(Private);
     Output->Private = NULL;
 }
 
@@ -523,6 +541,7 @@
     Private->RunsDualLink = FALSE;
     Private->Coherent = FALSE;
     Private->PowerState = RHD_POWER_UNKNOWN;
+    Private->Hdmi = RHDHdmiInit(rhdPtr, Output);
 
     Output->Private = Private;
 
