diff -Naur bluez-4.58-old/input/device.c bluez-4.58-new/input/device.c
--- bluez-4.58-old/input/device.c	2009-05-09 02:31:01.000000000 -0700
+++ bluez-4.58-new/input/device.c	2009-11-15 04:42:56.000000000 -0800
@@ -83,18 +83,6 @@
 	struct input_device	*idev;
 };
 
-struct input_device {
-	DBusConnection		*conn;
-	char			*path;
-	bdaddr_t		src;
-	bdaddr_t		dst;
-	uint32_t		handle;
-	guint			dc_id;
-	char			*name;
-	struct btd_device	*device;
-	GSList			*connections;
-};
-
 GSList *devices = NULL;
 
 static struct input_device *find_device_by_path(GSList *list, const char *path)
@@ -640,6 +628,7 @@
 		fake->connect = fake_hid_connect;
 		fake->disconnect = fake_hid_disconnect;
 		fake->priv = fake_hid;
+		fake->idev = idev;
 		err = fake_hid_connadd(fake, iconn->intr_io, fake_hid);
 		goto cleanup;
 	}
@@ -1103,15 +1092,16 @@
 
 static struct input_conn *input_conn_new(struct input_device *idev,
 					const char *uuid, const char *alias,
-					int timeout)
+					struct input_dev_conf *conf)
 {
 	struct input_conn *iconn;
 
 	iconn = g_new0(struct input_conn, 1);
-	iconn->timeout = timeout;
+	iconn->timeout = conf->timeout;
 	iconn->uuid = g_strdup(uuid);
 	iconn->alias = g_strdup(alias);
 	iconn->idev = idev;
+	idev->conf = conf;
 
 	return iconn;
 }
@@ -1119,7 +1109,7 @@
 int input_device_register(DBusConnection *conn, struct btd_device *device,
 			const char *path, const bdaddr_t *src,
 			const bdaddr_t *dst, const char *uuid,
-			uint32_t handle, int timeout)
+			uint32_t handle, struct input_dev_conf *conf)
 {
 	struct input_device *idev;
 	struct input_conn *iconn;
@@ -1132,7 +1122,7 @@
 		devices = g_slist_append(devices, idev);
 	}
 
-	iconn = input_conn_new(idev, uuid, "hid", timeout);
+	iconn = input_conn_new(idev, uuid, "hid", conf);
 	if (!iconn)
 		return -EINVAL;
 
diff -Naur bluez-4.58-old/input/device.h bluez-4.58-new/input/device.h
--- bluez-4.58-old/input/device.h	2009-04-22 18:40:04.000000000 -0700
+++ bluez-4.58-new/input/device.h	2009-11-15 04:42:56.000000000 -0800
@@ -27,7 +27,22 @@
 #define L2CAP_PSM_HIDP_CTRL	0x11
 #define L2CAP_PSM_HIDP_INTR	0x13
 
-struct input_device;
+struct input_dev_conf {
+	int timeout;
+	int ps3remote_compat;
+};
+struct input_device {
+	DBusConnection		*conn;
+	char			*path;
+	bdaddr_t		src;
+	bdaddr_t		dst;
+	uint32_t		handle;
+	guint			dc_id;
+	char			*name;
+	struct btd_device	*device;
+	struct input_dev_conf	*conf;
+	GSList			*connections;
+};
 struct input_conn;
 
 struct fake_input {
@@ -39,6 +54,10 @@
 	gboolean	(*connect) (struct input_conn *iconn, GError **err);
 	int		(*disconnect) (struct input_conn *iconn);
 	void		*priv;
+	void		*data;
+	const struct input_device * idev;
+	guint		sid_in;
+	guint		sid_out;
 };
 
 int fake_input_register(DBusConnection *conn, struct btd_device *device,
@@ -47,7 +66,7 @@
 int input_device_register(DBusConnection *conn, struct btd_device *device,
 			const char *path, const bdaddr_t *src,
 			const bdaddr_t *dst, const char *uuid,
-			uint32_t handle, int timeout);
+			uint32_t handle, struct input_dev_conf *conf);
 int input_device_unregister(const char *path, const char *uuid);
 
 int input_device_set_channel(const bdaddr_t *src, const bdaddr_t *dst, int psm,
diff -Naur bluez-4.58-old/input/fakehid.c bluez-4.58-new/input/fakehid.c
--- bluez-4.58-old/input/fakehid.c	2009-04-22 18:40:04.000000000 -0700
+++ bluez-4.58-new/input/fakehid.c	2009-11-15 04:42:56.000000000 -0800
@@ -31,11 +31,13 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 
 #include <bluetooth/bluetooth.h>
 #include <bluetooth/l2cap.h>
 #include <bluetooth/hidp.h>
 #include <bluetooth/sdp.h>
+#include <bluetooth/hci.h>
 
 #include <glib.h>
 #include <dbus/dbus.h>
@@ -92,7 +94,7 @@
 	[PS3R_BIT_SELECT] = 0x50,
 };
 
-static unsigned int ps3remote_keymap[] = {
+static unsigned int ps3keymap_def[] = {
 	[0x16] = KEY_EJECTCD,
 	[0x64] = KEY_AUDIO,
 	[0x65] = KEY_ANGLE,
@@ -145,12 +147,64 @@
 	[0x39] = KEY_PAUSE,
 	[0x61] = KEY_FRAMEFORWARD,	/* slow/step forward */
 	[0xff] = KEY_MAX,
+}, ps3keymap_alt[] = {
+	[0x16] = KEY_EJECTCD,
+	[0x64] = KEY_A,			/* audio */
+	[0x65] = KEY_Z,			/* angle */
+	[0x63] = KEY_T,			/* subtitle */
+	[0x0f] = KEY_DELETE,		/* clear */
+	[0x28] = KEY_END,		/* timer */
+	[0x00] = KEY_1,
+	[0x01] = KEY_2,
+	[0x02] = KEY_3,
+	[0x03] = KEY_4,
+	[0x04] = KEY_5,
+	[0x05] = KEY_6,
+	[0x06] = KEY_7,
+	[0x07] = KEY_8,
+	[0x08] = KEY_9,
+	[0x09] = KEY_0,
+	[0x81] = KEY_F7,		/* red */
+	[0x82] = KEY_F8,		/* green */
+	[0x83] = KEY_F9,		/* yellow */
+	[0x80] = KEY_F10,		/* blue */
+	[0x70] = KEY_D,			/* display */
+	[0x1a] = KEY_MENU,		/* top menu */
+	[0x40] = KEY_F11,		/* pop up/menu */
+	[0x0e] = KEY_ESC,		/* return */
+	[0x5c] = KEY_F12,		/* options/triangle */
+	[0x5d] = KEY_BACK,		/* back/circle */
+	[0x5f] = KEY_V,			/* view/square */
+	[0x5e] = KEY_X,			/* cross */
+	[0x54] = KEY_UP,
+	[0x56] = KEY_DOWN,
+	[0x57] = KEY_LEFT,
+	[0x55] = KEY_RIGHT,
+	[0x0b] = KEY_ENTER,
+	[0x5a] = KEY_F1,		/* L1 */
+	[0x58] = KEY_F2,		/* L2 */
+	[0x51] = KEY_F3,		/* L3 */
+	[0x5b] = KEY_F4,		/* R1 */
+	[0x59] = KEY_F5,		/* R2 */
+	[0x52] = KEY_F6,		/* R3 */
+	[0x43] = KEY_HOMEPAGE,		/* PS button */
+	[0x50] = KEY_INSERT,		/* select */
+	[0x53] = KEY_HOME,		/* start */
+	[0x33] = KEY_R,			/* scan back */
+	[0x32] = KEY_PLAY,
+	[0x34] = KEY_F,			/* scan forward */
+	[0x30] = KEY_PAGEDOWN,		/* prev */
+	[0x38] = KEY_STOP,
+	[0x31] = KEY_PAGEUP,		/* next */
+	[0x60] = KEY_COMMA,		/* slow/step back */
+	[0x39] = KEY_PAUSE,
+	[0x61] = KEY_DOT,		/* slow/step forward */
+	[0xff] = KEY_MAX,
 };
 
-static int ps3remote_decode(char *buff, int size, unsigned int *value)
+static int ps3remote_decode(char *buff, int size, unsigned int *value,
+						struct ps3remote_data *ps3)
 {
-	static unsigned int lastkey = 0;
-	static unsigned int lastmask = 0;
 	unsigned int i, mask;
 	int retval;
 	guint8 key;
@@ -165,11 +219,11 @@
 
 	/* first, check flags */
 	for (i = 0; i < 24; i++) {
-		if ((lastmask & (1 << i)) == (mask & (1 << i)))
+		if ((ps3->lastmask & (1 << i)) == (mask & (1 << i)))
 			continue;
 		if (ps3remote_bits[i] == 0)
 			goto error;
-		retval = ps3remote_keymap[ps3remote_bits[i]];
+		retval = ps3->keymap[ps3remote_bits[i]];
 		if (mask & (1 << i))
 			/* key pressed */
 			*value = 1;
@@ -182,21 +236,21 @@
 
 	*value = buff[11];
 	if (buff[11] == 1) {
-		retval = ps3remote_keymap[key];
+		retval = ps3->keymap[key];
 	} else
-		retval = lastkey;
+		retval = ps3->lastkey;
 
 	if (retval == KEY_RESERVED)
 		goto error;
 	if (retval == KEY_MAX)
 		return retval;
 
-	lastkey = retval;
+	ps3->lastkey = retval;
 
 out:
 	fflush(stdout);
 
-	lastmask = mask;
+	ps3->lastmask = mask;
 
 	return retval;
 
@@ -204,22 +258,69 @@
 	error("ps3remote: unrecognized sequence [%#x][%#x][%#x][%#x] [%#x],"
 			"last: [%#x][%#x][%#x][%#x]",
 			buff[2], buff[3], buff[4], buff[5], buff[11],
-				lastmask >> 16, lastmask >> 8 & 0xff,
-						lastmask & 0xff, lastkey);
+				ps3->lastmask >> 16, ps3->lastmask >> 8 & 0xff,
+					ps3->lastmask & 0xff, ps3->lastkey);
 	return -1;
 }
+static gboolean ps3remote_sendkey(int uinput, unsigned int key, 
+				  unsigned int value)
+{
+	struct uinput_event event;
+
+	memset(&event, 0, sizeof(event));
+	gettimeofday(&event.time, NULL);
+	event.type = EV_KEY;
+	event.code = key;
+	event.value = value;
+	if (write(uinput, &event, sizeof(event)) != sizeof(event)) {
+		error("Error writing to uinput device");
+		return FALSE;
+	}
 
+	memset(&event, 0, sizeof(event));
+	gettimeofday(&event.time, NULL);
+	event.type = EV_SYN;
+	event.code = SYN_REPORT;
+	if (write(uinput, &event, sizeof(event)) != sizeof(event)) {
+		error("Error writing to uinput device");
+		return FALSE;
+	}
+	return TRUE;
+}
+static gboolean ps3remote_out(GIOChannel *chan, GIOCondition cond,
+                                gpointer data)
+{
+	struct ps3remote_data *ps3 = ((struct fake_input *)data)->data;
+	const struct input_device *idev = ((struct fake_input *)data)->idev;
+	uint16_t to = (ps3->timeout < 5) ? 15 : ps3->timeout;
+	gulong ms;
+
+	if(g_timer_elapsed(ps3->timer,&ms) > to) {
+		DBG("idle timeout, disconnecting BT channel");
+		device_request_disconnect(idev->device, NULL);
+		return FALSE;
+	} else
+		usleep(750);
+	return TRUE;
+}
 static gboolean ps3remote_event(GIOChannel *chan, GIOCondition cond,
 				gpointer data)
 {
 	struct fake_input *fake = data;
-	struct uinput_event event;
+	struct ps3remote_data *ps3 = (struct ps3remote_data *)fake->data;
 	unsigned int key, value = 0;
 	gsize size;
 	char buff[50];
 
-	if (cond & G_IO_NVAL)
-		return FALSE;
+	g_timer_start(ps3->timer);
+	if (cond & G_IO_NVAL) {
+		if(ps3->lastkey == KEY_HOMEPAGE && ps3->lastval == 1)
+			DBG("Remote turned off");
+		else
+			DBG("Remote disconnected [%u:%u]", ps3->lastkey, 
+								ps3->lastval);
+		goto failed;
+	}
 
 	if (cond & (G_IO_HUP | G_IO_ERR)) {
 		error("Hangup or error on rfcomm server socket");
@@ -234,40 +335,36 @@
 		goto failed;
 	}
 
-	key = ps3remote_decode(buff, size, &value);
+	key = ps3remote_decode(buff, size, &value, ps3);
 	if (key == KEY_RESERVED) {
 		error("Got invalid key from decode");
 		goto failed;
 	} else if (key == KEY_MAX)
 		return TRUE;
 
-	memset(&event, 0, sizeof(event));
-	gettimeofday(&event.time, NULL);
-	event.type = EV_KEY;
-	event.code = key;
-	event.value = value;
-	if (write(fake->uinput, &event, sizeof(event)) != sizeof(event)) {
-		error("Error writing to uinput device");
+	/* Delaying key till release, assuming possible turn-off */
+	if(key == KEY_HOMEPAGE) {
+		if(value == 0 && ps3->lastkey == KEY_HOMEPAGE 
+							&& ps3->lastval == 1) {
+			ps3remote_sendkey(fake->uinput, key, 1);
+			ps3remote_sendkey(fake->uinput, key, 0);
+		} else
+			DBG("Delayed: %u:%u (%u:%u)", key, value, 
+						ps3->lastkey, ps3->lastval);
+	} else if(!ps3remote_sendkey(fake->uinput, key, value))
 		goto failed;
-	}
-
-	memset(&event, 0, sizeof(event));
-	gettimeofday(&event.time, NULL);
-	event.type = EV_SYN;
-	event.code = SYN_REPORT;
-	if (write(fake->uinput, &event, sizeof(event)) != sizeof(event)) {
-		error("Error writing to uinput device");
-		goto failed;
-	}
 
+	ps3->lastkey = key;
+	ps3->lastval = value;
+	DBG("Passed key %u:%u", key, value);
 	return TRUE;
 
 failed:
-	ioctl(fake->uinput, UI_DEV_DESTROY);
-	close(fake->uinput);
-	fake->uinput = -1;
+	g_timer_stop(ps3->timer);
+	g_source_remove(fake->sid_in);
+	g_source_remove(fake->sid_out);
 	g_io_channel_unref(fake->io);
-
+	DBG("Event failed");
 	return FALSE;
 }
 
@@ -275,8 +372,20 @@
 				  struct fake_hid *fake_hid)
 {
 	struct uinput_dev dev;
+	struct ps3remote_data *ps3 = (struct ps3remote_data *)fake->data;
+	struct stat sbuf;
 	int i;
 
+	/* check if uinput already open */
+	if(fake->uinput > 0) {
+		if(!(i=fstat(fake->uinput, &sbuf))) {
+			DBG("input %d is opened", fake->uinput);
+			return 0;
+		} else
+			DBG("fstat(%d): error[%d]: %s", fake->uinput, i, 
+							strerror(errno));
+	}
+	/* create uinput device */
 	fake->uinput = open("/dev/input/uinput", O_RDWR);
 	if (fake->uinput < 0) {
 		fake->uinput = open("/dev/uinput", O_RDWR);
@@ -308,11 +417,11 @@
 
 	/* enabling keys */
 	for (i = 0; i < 256; i++)
-		if (ps3remote_keymap[i] != KEY_RESERVED)
+		if (ps3->keymap[i] != KEY_RESERVED)
 			if (ioctl(fake->uinput, UI_SET_KEYBIT,
-						ps3remote_keymap[i]) < 0) {
+						ps3->keymap[i]) < 0) {
 				error("Error enabling uinput key %i",
-							ps3remote_keymap[i]);
+							ps3->keymap[i]);
 				goto err;
 			}
 
@@ -328,6 +437,19 @@
 	close(fake->uinput);
 	return 1;
 }
+static gboolean ps3remote_connect(struct fake_input *fake, GError **err)
+{
+	if(!fake->data) {
+		struct ps3remote_data *ps3 = g_new0(struct ps3remote_data, 1);
+		ps3->timer = g_timer_new();
+		ps3->timeout = fake->idev->conf->timeout;
+		ps3->keymap = (fake->idev->conf
+					&& fake->idev->conf->ps3remote_compat)?
+						ps3keymap_alt : ps3keymap_def;
+		fake->data = ps3;
+	}
+	return TRUE;
+}
 
 static gboolean fake_hid_common_connect(struct fake_input *fake, GError **err)
 {
@@ -344,10 +466,12 @@
 	{
 		.vendor		= 0x054c,
 		.product	= 0x0306,
-		.connect	= fake_hid_common_connect,
+		.connect	= ps3remote_connect,
 		.disconnect	= fake_hid_common_disconnect,
 		.event		= ps3remote_event,
+		.oevent		= ps3remote_out,
 		.setup_uinput	= ps3remote_setup_uinput,
+		.fakes		= NULL,
 	},
 
 	{ },
@@ -369,10 +493,34 @@
 
 	return NULL;
 }
+struct fake_input * fake_find_input(GSList *list, 
+					const struct input_device *idev)
+{
+        GSList *l;
+
+	if(!list)
+		return NULL;
+        for (l = list; l; l = l->next) {
+                struct fake_input *fake = l->data;
+
+                if (fake->idev == idev)
+                        return fake;
+        }
+        return NULL;
+}
 
 int fake_hid_connadd(struct fake_input *fake, GIOChannel *intr_io,
 						struct fake_hid *fake_hid)
 {
+	struct fake_input *finput;
+
+	if((finput = fake_find_input(fake_hid->fakes, fake->idev))) {
+		g_free(fake);
+		fake = finput;
+	} else {
+		fake_hid->fakes = g_slist_append(fake_hid->fakes, fake);
+	}
+	fake_hid->connect(fake,NULL);
 	if (fake_hid->setup_uinput(fake, fake_hid)) {
 		error("Error setting up uinput");
 		return ENOMEM;
@@ -380,8 +528,10 @@
 
 	fake->io = g_io_channel_ref(intr_io);
 	g_io_channel_set_close_on_unref(fake->io, TRUE);
-	g_io_add_watch(fake->io, G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,
-					(GIOFunc) fake_hid->event, fake);
-
+	fake->sid_in = g_io_add_watch(fake->io, 
+				G_IO_IN | G_IO_ERR | G_IO_HUP | G_IO_NVAL,
+				(GIOFunc) fake_hid->event, fake);
+	fake->sid_out = g_io_add_watch(fake->io, G_IO_OUT,
+				(GIOFunc) fake_hid->oevent, fake);
 	return 0;
 }
diff -Naur bluez-4.58-old/input/fakehid.h bluez-4.58-new/input/fakehid.h
--- bluez-4.58-old/input/fakehid.h	2009-02-25 12:14:11.000000000 -0800
+++ bluez-4.58-new/input/fakehid.h	2009-11-15 04:42:56.000000000 -0800
@@ -30,7 +30,18 @@
 	gboolean (*connect) (struct fake_input *fake_input, GError **err);
 	int (*disconnect) (struct fake_input *fake_input);
 	gboolean (*event) (GIOChannel *chan, GIOCondition cond, gpointer data);
+	gboolean (*oevent) (GIOChannel *chan, GIOCondition cond, gpointer data);
 	int (*setup_uinput) (struct fake_input *fake, struct fake_hid *fake_hid);
+	GSList *fakes;
+};
+
+struct ps3remote_data {
+	unsigned int	lastkey;
+	unsigned int	lastval;
+	unsigned int	lastmask;
+	GTimer *	timer;
+	uint16_t 	timeout;
+	unsigned int *	keymap;
 };
 
 struct fake_hid *get_fake_hid(uint16_t vendor, uint16_t product);
diff -Naur bluez-4.58-old/input/input.conf bluez-4.58-new/input/input.conf
--- bluez-4.58-old/input/input.conf	2008-08-05 14:14:56.000000000 -0700
+++ bluez-4.58-new/input/input.conf	2009-11-15 04:42:56.000000000 -0800
@@ -4,6 +4,14 @@
 # particular interface
 [General]
 
-# Set idle timeout (in minutes) before the connection will
+# Set idle timeout (in seconds) before the connection will
 # be disconnect (defaults to 0 for no timeout)
 #IdleTimeout=30
+
+##
+# Section for options, specific to Sony PS3 BD Remote driver
+[PS3 Remote]
+
+# Set keymap to generic keycodes/scancodes, in order
+# to be compatible with old XInput driver.
+#Compat=1
diff -Naur bluez-4.58-old/input/manager.c bluez-4.58-new/input/manager.c
--- bluez-4.58-old/input/manager.c	2009-08-16 11:43:34.000000000 -0700
+++ bluez-4.58-new/input/manager.c	2009-11-15 04:42:56.000000000 -0800
@@ -42,7 +42,7 @@
 #include "server.h"
 #include "manager.h"
 
-static int idle_timeout = 0;
+static struct input_dev_conf idev_conf;
 
 static DBusConnection *connection = NULL;
 static GSList *adapters = NULL;
@@ -72,7 +72,7 @@
 	device_get_address(device, &dst);
 
 	return input_device_register(connection, device, path, &src, &dst,
-				HID_UUID, rec->handle, idle_timeout * 60);
+				HID_UUID, rec->handle, &idev_conf);
 }
 
 static void hid_device_remove(struct btd_device *device)
@@ -175,9 +175,17 @@
 {
 	GError *err = NULL;
 
+	memset(&idev_conf,0,sizeof(struct input_dev_conf));
 	if (config) {
-		idle_timeout = g_key_file_get_integer(config, "General",
-						"IdleTimeout", &err);
+		idev_conf.timeout = g_key_file_get_integer(config, 
+				     "General", "IdleTimeout", &err);
+		if (err) {
+			debug("input.conf: %s", err->message);
+			g_error_free(err);
+		}
+		idev_conf.ps3remote_compat = 
+				g_key_file_get_integer(config, 
+				"PS3 Remote", "Compat", &err);
 		if (err) {
 			debug("input.conf: %s", err->message);
 			g_error_free(err);
