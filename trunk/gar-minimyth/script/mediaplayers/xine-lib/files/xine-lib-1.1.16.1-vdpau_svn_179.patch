diff -Naur xine-lib-1.1.16.1-old/configure.ac xine-lib-1.1.16.1-new/configure.ac
--- xine-lib-1.1.16.1-old/configure.ac	2009-01-11 15:58:58.000000000 -0800
+++ xine-lib-1.1.16.1-new/configure.ac	2009-01-19 18:50:51.000000000 -0800
@@ -865,6 +865,20 @@
 
 
 dnl ---------------------------------------------
+dnl Check for VDPAU
+dnl ---------------------------------------------
+AC_ARG_WITH([vdpau], AS_HELP_STRING([--without-vdpau], [Doesn't build VDPAU plugins]))
+if test "x$with_vdpau" != "xno"; then
+  AC_CHECK_HEADERS([vdpau/vdpau_x11.h], [have_vdpau=yes], [have_vdpau=no])
+  if test "x$have_vdpau" = "xyes"; then
+    AC_CHECK_LIB(vdpau, vdp_device_create_x11, have_vdpau="yes", [have_vdpau="no"], [$X_LIBS $X_PRE_LIBS -lXext $X_EXTRA_LIBS])
+  fi
+fi
+
+AM_CONDITIONAL(HAVE_VDPAU, test "x$have_vdpau" = "xyes" )
+
+
+dnl ---------------------------------------------
 dnl Check for xcb
 dnl ---------------------------------------------
 AC_ARG_WITH([xcb], AS_HELP_STRING([--without-xcb], [Doesn't build XCB video out plugins]))
@@ -2733,6 +2747,7 @@
 src/libmpeg2/Makefile
 src/libmusepack/Makefile
 src/libmusepack/musepack/Makefile
+src/libvdpau/Makefile
 src/libspudec/Makefile
 src/libspucc/Makefile
 src/libspucmml/Makefile
@@ -3069,6 +3084,9 @@
     echo "   - xcb-xv (XVideo using XCB)"
   fi
 fi
+if test "x$have_vdpau" = "xyes"; then
+  echo "   - vdpau (X11 VDPAU)"
+fi
 if test "x$no_aalib" != "xyes"; then
   echo "   - aa (Ascii ART)"
 fi
diff -Naur xine-lib-1.1.16.1-old/configure.ac.orig xine-lib-1.1.16.1-new/configure.ac.orig
--- xine-lib-1.1.16.1-old/configure.ac.orig	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/configure.ac.orig	2009-01-19 18:50:39.000000000 -0800
@@ -0,0 +1,3239 @@
+dnl
+dnl Configure.ac for xine
+dnl
+
+AC_INIT
+AC_CONFIG_SRCDIR([src/xine-engine/xine.c])
+AC_CONFIG_MACRO_DIR([m4])
+AC_CONFIG_LIBOBJ_DIR([lib])
+
+dnl
+dnl Require autoconf version 2.60
+dnl
+AC_PREREQ(2.59)
+
+dnl Making releases:
+dnl   XINE_SUB += 1; XINE_PATCH = ''; continue with XINE_LT_* values below
+dnl
+XINE_MAJOR=1
+XINE_MINOR=1
+XINE_SUB=16
+dnl XINE_PATCH should be left empty or set to ".1" or ".2" or something similar
+XINE_PATCH=.1
+dnl Release series number (usually $XINE_MAJOR.$XINE_MINOR)
+XINE_SERIES=1.1
+
+dnl if test $XINE_SUB -eq 0 ; then
+dnl  XINE_SUBPART="";
+dnl else
+  XINE_SUBPART=".$XINE_SUB$XINE_PATCH"
+dnl fi
+
+dnl The libtool version numbers (XINE_LT_*); Don't even think about faking this!
+dnl 
+dnl immediately before every release do:
+dnl ===================================
+dnl if (the interface is totally unchanged from previous release)
+dnl    XINE_LT_REVISION ++;
+dnl else { /* interfaces have been added, removed or changed */
+dnl    XINE_LT_REVISION = 0;
+dnl    XINE_LT_CURRENT ++;
+dnl    if (any interfaces have been _added_ since last release)
+dnl       XINE_LT_AGE ++;
+dnl    if (any interfaces have been _removed_ or _incompatibly changed_)
+dnl       XINE_LT_AGE = 0;
+dnl }
+dnl 
+dnl If you want to know more about what you are doing, here are some details:
+dnl  * XINE_LT_CURRENT is the current API version
+dnl  * XINE_LT_REVISION is an internal revision number which is increased when the API
+dnl    itself did not change
+dnl  * XINE_LT_AGE is the number of previous API versions still supported by this library
+dnl  * libtool has its own numbering scheme, because local library numbering schemes
+dnl    are platform dependent
+dnl  * in Linux, the library will be named
+dnl    libname.so.(XINE_LT_CURRENT - XINE_LT_AGE).XINE_LT_AGE.XINE_LT_REVISION
+
+XINE_LT_CURRENT=26
+XINE_LT_REVISION=0
+XINE_LT_AGE=25
+
+dnl for a release tarball do "rm .cvsversion" before "make dist"
+if test -f "${srcdir-.}/.cvsversion"; then
+  XINE_PRE="hg"
+else
+  XINE_PRE=""
+fi
+
+AC_SUBST(XINE_MAJOR)
+AC_SUBST(XINE_MINOR)
+AC_SUBST(XINE_SUB)
+AC_SUBST(XINE_PATCH)
+AC_SUBST(XINE_SERIES)
+AC_SUBST(XINE_IFACE_AGE)
+AC_SUBST(XINE_BIN_AGE)
+
+AC_DEFINE_UNQUOTED(XINE_MAJOR, $XINE_MAJOR,[xine major version number])
+AC_DEFINE_UNQUOTED(XINE_MINOR, $XINE_MINOR,[xine minor version number])
+AC_DEFINE_UNQUOTED(XINE_SUB, $XINE_SUB, [xine sub version number])
+AC_DEFINE_UNQUOTED(XINE_PATCH, $XINE_PATCH, [xine patch version number])
+
+AC_SUBST(XINE_LT_CURRENT)
+AC_SUBST(XINE_LT_REVISION)
+AC_SUBST(XINE_LT_AGE)
+
+AC_DEFINE_UNQUOTED(XINE_LT_CURRENT, $XINE_LT_CURRENT, [xine interface version number])
+AC_DEFINE_UNQUOTED(XINE_LT_AGE, $XINE_LT_AGE, [xine interface version age])
+
+SPEC_VERSION=$XINE_MAJOR.$XINE_MINOR${XINE_SUBPART}$XINE_PRE
+TAR_NAME="xine-lib-"$SPEC_VERSION
+dnl TAR_NAME="xine-lib-"$XINE_MAJOR-$XINE_PRE
+dnl SPEC_VERSION=${XINE_MAJOR}_$XINE_PRE
+
+AC_SUBST(TAR_NAME)
+AC_SUBST(SPEC_VERSION)
+
+LIBNAME=libxine$XINE_MAJOR
+AC_SUBST(LIBNAME)
+
+AC_DEFINE_UNQUOTED(XINE_TEXTDOMAIN, "$LIBNAME", [catalog message text domain])
+
+dnl
+AM_INIT_AUTOMAKE("xine-lib", $SPEC_VERSION)
+dnl AM_INIT_AUTOMAKE("xine-lib", $XINE_MAJOR-$XINE_PRE)
+
+dnl ---------------------------------------------
+dnl Made possible to build for another arch.
+dnl ---------------------------------------------
+
+AC_CANONICAL_HOST
+AC_CANONICAL_BUILD
+
+test "$host" == "$build" && check_athlon=yes
+
+AC_CONFIG_HEADERS([include/configure.h])
+
+
+dnl ---------------------------------------------
+dnl Check for programs.
+dnl ---------------------------------------------
+
+AC_PROG_CC
+AM_PROG_AS
+
+case "$host_os" in
+  *darwin*)
+     m4_ifdef([AC_PROG_OBJC],
+       [AC_PROG_OBJC],
+       [AC_CHECK_TOOL([OBJC], [gcc])
+        AC_SUBST([OBJC])
+	AC_SUBST([OBJCFLAGS])
+       ])
+     CPPFLAGS="$CPPFLAGS -DCONFIG_DARWIN"
+     ;;
+esac
+
+AC_GNU_SOURCE
+dnl Save CFLAGS, AC_ISC_POSIX set some unwanted default CFLAGS
+saved_CFLAGS="$CFLAGS"
+AC_ISC_POSIX
+AC_PATH_MAGIC
+CFLAGS="$saved_CFLAGS"
+AC_HEADER_STDC
+
+AC_PROG_MAKE_SET
+AC_PROG_EGREP
+AC_PROG_INSTALL
+AC_PROG_LN_S
+AC_PROG_AWK
+AC_C_INLINE
+
+AC_CHECK_TOOL([STRINGS], [strings], [false])
+
+dnl ---------------------------------------------
+dnl Libtool
+dnl ---------------------------------------------
+
+AC_LIBTOOL_DLOPEN
+AC_DISABLE_STATIC
+AC_LIBTOOL_WIN32_DLL
+AC_PROG_LIBTOOL
+AC_PROG_LIBTOOL_SANITYCHECK
+AC_SUBST(LIBTOOL_DEPS)
+if ${CONFIG_SHELL} ./libtool --features | grep "enable static" >/dev/null; then
+  STATIC="-static"
+else
+  STATIC=
+fi
+AC_SUBST(STATIC)
+
+
+dnl ---------------------------------------------
+dnl Requirements for macros whose first invocations are conditional
+dnl ---------------------------------------------
+
+PKG_PROG_PKG_CONFIG
+CC_CHECK_WERROR
+
+dnl ---------------------------------------------
+dnl NLS Support
+dnl ---------------------------------------------
+
+dnl ALL_LINGUAS="cs da de el en@quot en@boldquot es et fr gl id it ja ko nl nn no pl pt pt_BR ru sl sv tr zh"
+AM_ICONV
+AC_ARG_ENABLE([iconvtest],
+	AS_HELP_STRING([--disable-iconvtest], [don't require iconv library]))
+if test "x$enable_iconvtest" != xno; then
+  if test "x$am_cv_func_iconv" != xyes; then
+    AC_MSG_ERROR([
+****************************************************************
+* iconv library not found. It's necessary for proper           *
+* manipulation with texts so xine requires it as default.      *
+*                                                              *
+* You need to install iconv library or to specify prefix       *
+* by option --with-libiconv-prefix.                            *
+*                                                              *
+* If you don't want iconv support use the option               *
+* --disable-iconvtest.                                          *
+****************************************************************
+  ])
+  fi
+fi
+
+AM_GNU_GETTEXT([external])
+AM_GNU_GETTEXT_VERSION([0.16.1])
+AC_PROG_GMSGFMT_PLURAL
+
+AC_CHECK_FUNCS([nl_langinfo])
+
+dnl ---------------------------------------------
+dnl Checks for typedefs, structures, and compiler characteristics.
+dnl ---------------------------------------------
+
+AC_C_BIGENDIAN
+AC_C_CONST
+dnl AC_C_ALWAYS_INLINE removal allows ffmpeg to be more widely buildable
+AC_TYPE_OFF_T
+AC_TYPE_SIZE_T
+AC_CHECK_SIZEOF(long)
+dnl AC_CHECK_TYPES([ptrdiff_t])
+dnl For systems without inttypes.h would be needed extend generated replacement.
+AC_CHECK_GENERATE_INTTYPES([include])
+AM_CONDITIONAL(GENERATED_INTTYPES_H, test "x$ac_cv_header_inttypes_h" != x"yes")
+AC_CHECK_TYPE(ssize_t, :, AC_DEFINE(ssize_t, __int64, [define ssize_t to __int64 if it's missing in default includes]))
+
+dnl ---------------------------------------------
+dnl threads and OS specific stuff
+dnl ---------------------------------------------
+
+CC_PTHREAD_FLAGS(, [AC_MSG_ERROR([Pthread support is needed])])
+CC_PTHREAD_RECURSIVE_MUTEX(, [AC_MSG_ERROR([recursive mutex support is needed - please report])])
+dnl <pthread.h> is implicitly included by xine-internals.h, so the include dir is needed everywhere
+CPPFLAGS="$CPPFLAGS $PTHREAD_CFLAGS"
+
+AC_CHECK_DECL(sysi86,[
+	AC_DEFINE(HAVE_SYSI86,1,[Define this if the 'sysi86' function is declared in sys/sysi86.h])
+      ],,[
+#include <sys/sysi86.h>
+])
+
+AC_GETOPT_LONG
+
+dnl ---------------------------------------------
+dnl Windows ports checks
+dnl ---------------------------------------------
+case "$host" in
+  *-*-mingw* | *-*-cygwin*)
+    dnl check if we are using the cygwin, mingw or cygwin with mno-cygwin mode
+    dnl in which case we are actually dealing with a mingw32 compiler
+    case "$host" in
+      *-*-mingw32*)
+        SYS=mingw32
+        ;;
+      *-*-cygwin*)
+        AC_EGREP_CPP(pattern, 
+                     [#ifdef WIN32
+                      yes
+                      #endif],
+                     SYS=mingw32, SYS=cygwin)
+        ;;
+    esac
+
+    if test "$SYS" = "mingw32"; then
+      WIN32_CPPFLAGS='-I$(top_srcdir)/win32/include'
+      LIBS="-lwinmm -lwsock32 $LIBS"
+      GOOM_LIBS="-liberty"
+      LDFLAGS="-Wl,--enable-stdcall-fixup $LDFLAGS"
+    fi
+    LDFLAGS="-no-undefined $LDFLAGS"
+    ;;
+esac
+AC_SUBST(GOOM_LIBS)
+AC_SUBST(WIN32_CPPFLAGS)
+AM_CONDITIONAL(WIN32, test "x$SYS" = "xmingw32")
+
+
+dnl ---------------------------------------------
+dnl dynamic linker
+dnl ---------------------------------------------
+AM_DL()
+
+
+dnl ---------------------------------------------
+dnl determine libdir name
+dnl ---------------------------------------------
+
+AC_MSG_CHECKING([libdir name])
+case $host in
+*-*-linux*)
+ # Test if the compiler is 64bit
+ echo 'int i;' > conftest.$ac_ext
+ xine_cv_cc_64bit_output=no
+ if AC_TRY_EVAL(ac_compile); then
+ case `"$MAGIC_CMD" conftest.$ac_objext` in
+ *"ELF 64"*)
+   xine_cv_cc_64bit_output=yes
+   ;;
+ esac
+ fi
+ rm -rf conftest*
+ ;;
+esac
+
+case $host_cpu:$xine_cv_cc_64bit_output in
+powerpc64:yes | s390x:yes | sparc64:yes | x86_64:yes)
+ XINE_LIBNAME="lib64"
+ ;;
+*:*)
+ XINE_LIBNAME="lib"
+ ;;
+esac
+AC_MSG_RESULT([$XINE_LIBNAME])
+
+
+dnl ---------------------------------------------
+dnl mpeg2lib and ffmpeg stuff
+dnl ---------------------------------------------
+
+AC_SUBST(LIBMPEG2_CFLAGS)
+
+AC_ARG_WITH([external-ffmpeg], AS_HELP_STRING([--with-external-ffmpeg], [use external ffmpeg library]))
+
+case "x$with_external_ffmpeg" in
+   xno)
+      ;;
+   xyes)
+      PKG_CHECK_MODULES([FFMPEG], [libavcodec >= 51.20.0])
+      ;;
+   *)
+      with_external_ffmpeg=yes
+      PKG_CHECK_MODULES([FFMPEG], [libavcodec >= 51.20.0], [],
+			[AC_MSG_RESULT(no); with_external_ffmpeg=no])
+      ;;
+esac
+if test "x$with_external_ffmpeg" != "xno"; then
+   PKG_CHECK_MODULES([FFMPEG_UTIL], [libavutil])
+   PKG_CHECK_MODULES([FFMPEG_POSTPROC], [libpostproc])
+   AC_SUBST([FFMPEG_CFLAGS])
+   AC_SUBST([FFMPEG_LIBS])
+   AC_SUBST([FFMPEG_POSTPROC_CFLAGS])
+   AC_SUBST([FFMPEG_POSTPROC_LIBS])
+   AC_DEFINE([HAVE_FFMPEG], [1], [Define this if you have ffmpeg library])
+
+   dnl Check presence of ffmpeg/avutil.h to see if it's old or new
+   dnl style for headers. The new style would be preferred actually...
+   AC_CHECK_HEADERS([ffmpeg/avutil.h])
+   
+   AC_MSG_RESULT([using external ffmpeg])
+else
+  AC_MSG_NOTICE([
+*********************************************************************
+xine-lib is configured to use internal ffmpeg.
+
+This copy of ffmpeg is old. You are strongly advised to install a
+newer version (including development files) and to reconfigure
+xine-lib to use it.
+*********************************************************************])
+  LIBFFMPEG_CPPFLAGS="-DHAVE_AV_CONFIG_H -DRUNTIME_CPUDETECT -DXINE_MPEG_ENCODER -D_ISOC9X_SOURCE -DCONFIG_DECODERS"
+  AC_CHECK_TYPES(int_fast8_t, [], [LIBFFMPEG_CPPFLAGS="$LIBFFMPEG_CPPFLAGS -DEMULATE_FAST_INT"])
+  AC_SUBST([LIBFFMPEG_CPPFLAGS])
+fi
+AM_CONDITIONAL(HAVE_FFMPEG, test "x$with_external_ffmpeg" = "xyes")
+
+
+AC_ARG_ENABLE([ffmpeg_uncommon_codecs],
+	AS_HELP_STRING([--disable-ffmpeg-uncommon-codecs], [don't build uncommon ffmpeg codecs]))
+
+AC_ARG_ENABLE([ffmpeg_popular_codecs],
+	AS_HELP_STRING([--disable-ffmpeg-popular-codecs], [don't build popular ffmpeg codecs]))
+
+AS_MKDIR_P(src/libffmpeg)
+ffmpeg_config_h=src/libffmpeg/ffmpeg_config.h
+echo "/* Automatically generated */" > $ffmpeg_config_h
+
+dnl uncommon ffmpeg codecs
+ffmpeg_uncommon_codecs="AASC ASV1 ASV2 AVS CSCD CYUV DVVIDEO EIGHTBPS FLIC FLV FOURXM FRAPS HUFFYUV IDCIN INTERPLAY_VIDEO KMVC LOCO MMVIDEO NUV QDRAW QPEG ROQ RPZA SMACKER SMC SNOW TRUEMOTION1 TRUEMOTION2 TSCC ULTI VCR1 VMDVIDEO WNV1 XAN_WC3 XL ZMBV ALAC AMR_NB AMR_WB LIBGSM MACE3 MACE6 SHORTEN SMACKAUD TRUESPEECH TTA VMDAUDIO PCM_ALAW PCM_MULAW PCM_S8 PCM_S16BE PCM_S16LE PCM_S24BE PCM_S24DAUD PCM_S24LE PCM_S32BE PCM_S32LE PCM_U8 PCM_U16BE PCM_U16LE PCM_U24BE PCM_U24LE PCM_U32BE PCM_U32LE INTERPLAY_DPCM ROQ_DPCM SOL_DPCM VQA XAN_DPCM ADPCM_4XM ADPCM_CT ADPCM_EA ADPCM_IMA_DK3 ADPCM_IMA_DK4 ADPCM_IMA_QT ADPCM_IMA_SMJPEG ADPCM_IMA_WAV ADPCM_IMA_WS ADPCM_MS ADPCM_SBPRO_2 ADPCM_SBPRO_3 ADPCM_SBPRO_4 ADPCM_XA ADPCM_YAMAHA"
+for ucname in $ffmpeg_uncommon_codecs; do
+  config_name="CONFIG_${ucname}_DECODER"
+  enabled_name="ENABLE_${ucname}_DECODER"
+  
+  if test "x$enable_ffmpeg_uncommon_codecs" != xno; then
+    echo "#define $config_name 1" >> $ffmpeg_config_h
+    echo "#define $enabled_name 1" >> $ffmpeg_config_h
+  else
+    echo "#define $enabled_name 0" >> $ffmpeg_config_h
+  fi
+done
+
+dnl popular ffmpeg codecs
+ffmpeg_popular_codecs="CINEPAK FLASHSV H261 H263 H263I H264 INDEO2 INDEO3 MJPEG MJPEGB MPEG1VIDEO MPEG2VIDEO MPEG4 MPEGVIDEO MSMPEG4V1 MSMPEG4V2 MSMPEG4V3 MSRLE MSVIDEO1 QTRLE RV10 RV20 SVQ1 SVQ3 VC1 VP3 VP5 VP6 VP6F WMV1 WMV2 WMV3 COOK DTS FLAC MP2 MP3 QDM2 RA_144 RA_288 WAVPACK WMAV1 WMAV2 ADPCM_SWF"
+
+for ucname in $ffmpeg_popular_codecs; do
+  config_name="CONFIG_${ucname}_DECODER"
+  enabled_name="ENABLE_${ucname}_DECODER"
+  
+  if test "x$enable_ffmpeg_popular_codecs" != xno; then
+    echo "#define $config_name 1" >> $ffmpeg_config_h
+    echo "#define $enabled_name 1" >> $ffmpeg_config_h
+  else
+    echo "#define $enabled_name 0" >> $ffmpeg_config_h
+  fi
+done
+
+dnl disabled ffmpeg codecs
+ffmpeg_disabled_codecs="BMP CAVS CLJR DSICINVIDEO FFV1 FFVHUFF GIF MDEC MPEG_XVMC MSZH PNG RAWVIDEO SP5X TARGA TIERTEXSEQVIDEO TIFF VMNC ZLIB DSICINAUDIO IMC MP3ADU MP3ON4 MPC7 SONIC WS_SND1 ADPCM_ADX ADPCM_G726 DVBSUB DVDSUB THEORA AAC MPEG4AAC AC3 VORBIS"
+for ucname in $ffmpeg_disabled_codecs; do
+  config_name="CONFIG_${ucname}_DECODER"
+  enabled_name="ENABLE_${ucname}_DECODER"
+  
+  echo "#define $enabled_name 0" >> $ffmpeg_config_h
+done
+
+dnl disabled ffmpeg encoders
+ffmpeg_extra_encoders="H263P JPEGLS LJPEG PAM PBM PGM PGMYUV PPM SONIC_LS"
+for ucname in $ffmpeg_uncommon_codecs $ffmpeg_popular_codecs $ffmpeg_disabled_codecs $ffmpeg_extra_encoders; do
+  config_name="CONFIG_${ucname}_ENCODER"
+  enabled_name="ENABLE_${ucname}_ENCODER"
+  
+  echo "#define $enabled_name 0" >> $ffmpeg_config_h
+done
+
+dnl disabled parsers
+ffmpeg_parsers="AAC AC3 CAVSVIDEO DVBSUB DVDSUB H261 H263 H264 MJPEG MPEG4VIDEO MPEGAUDIO MPEGVIDEO PNM"
+for ucname in $ffmpeg_parsers; do
+  config_name="CONFIG_${ucname}_PARSER"
+  enabled_name="ENABLE_${ucname}_PARSER"
+  
+  echo "#define $enabled_name 0" >> $ffmpeg_config_h
+done
+
+LIBMPEG2_CFLAGS=""
+
+AC_CHECK_DECL(lrintf,[
+	AC_DEFINE(HAVE_LRINTF,1,[Define this if the 'lrintf' function is declared in math.h])
+	AC_DEFINE(_ISOC9X_SOURCE,1,[Define this if you are ISO C9X compliant])
+      ],,[
+#define _ISOC9X_SOURCE
+#include <math.h>
+])
+AC_CHECK_DECL(rintf,[
+	AC_DEFINE(HAVE_RINTF,1,[Define this if the 'rintf' function is declared in math.h])
+      ],,[
+#include <math.h>
+])
+
+AC_CHECK_FUNCS(memalign)
+
+AC_ARG_ENABLE([altivec],
+	AS_HELP_STRING([--disable-altivec], [do not use assembly codes for Motorola 74xx CPUs]))
+
+AC_ARG_ENABLE([vis],
+	AS_HELP_STRING([--disable-vis], [do not use assembly codes for Sun UltraSPARC CPUs]))
+
+AC_ARG_ENABLE([mlib],
+	AS_HELP_STRING([--enable-mlib], [build Sun mediaLib support]))
+
+AC_ARG_ENABLE([mlib-lazyload],
+	AS_HELP_STRING([--enable-mlib-lazyload], [check for Sun mediaLib at runtime]))
+
+if test "x$enable_mlib" = xyes; then
+    if test "x$MLIBHOME" = x; then
+	mlibhome=/opt/SUNWmlib
+    else
+	mlibhome="$MLIBHOME"
+    fi
+
+    AC_CHECK_LIB(mlib, mlib_VideoAddBlock_U8_S16,
+	[ saved_CPPFLAGS="$CPPFLAGS"
+	  CPPFLAGS="$CPPFLAGS -I$mlibhome/include"
+	  AC_CHECK_HEADER(mlib_video.h,
+	       [ if test "x$enable_mlib_lazyload" = xyes; then
+		     if test "$GCC" = yes; then
+			 MLIB_LIBS="-L$mlibhome/lib -Wl,-z,lazyload,-lmlib,-z,nolazyload"
+		     else
+			 MLIB_LIBS="-L$mlibhome/lib -z lazyload -lmlib -z nolazyload"
+		     fi
+		     AC_DEFINE(MLIB_LAZYLOAD,1,[Define this if you want to load mlib lazily])
+		 else
+		     MLIB_LIBS="-L$mlibhome/lib -lmlib"
+		 fi
+		 MLIB_CFLAGS="-I$mlibhome/include"
+		 LIBMPEG2_CFLAGS="$LIBMPEG2_CFLAGS $MLIB_CFLAGS" 
+		 LIBFFMPEG_CFLAGS="$LIBFFMPEG_CFLAGS $MLIB_CFLAGS"
+		 AC_DEFINE(HAVE_MLIB,1,[Define this if you have mlib installed])
+		 AC_DEFINE(LIBMPEG2_MLIB,1,[Define this if you have mlib installed])
+		 ac_have_mlib=yes
+	       ],)
+	  CPPFLAGS="$saved_CPPFLAGS"
+	], , -L$mlibhome/lib)
+fi
+AM_CONDITIONAL(HAVE_MLIB, test "x$ac_have_mlib" = "xyes")
+AC_SUBST(MLIB_LIBS)
+AC_SUBST(MLIB_CFLAGS)
+
+dnl ---------------------------------------------
+dnl Checks for X11
+dnl ---------------------------------------------
+
+if test "x$with_x" != "xno"; then
+   PKG_CHECK_MODULES([X], [x11 xext], , [
+     AC_PATH_XTRA
+   
+     dnl Set xv_path if its not done already
+     dnl we do it here before rewriting X_LIBS
+     if test x$xv_path = x; then
+     	xv_path=`echo $X_LIBS | sed -e 's/\-L\(.*\)/\1/'`
+     fi
+     
+     dnl ----------------------------------------------
+     dnl Check for XShm support (required with X)
+     dnl ----------------------------------------------
+
+     if test "x$no_x" != "xyes"; then
+        ac_save_CPPFLAGS="$CPPFLAGS"
+        CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+        AC_CHECK_HEADERS([X11/extensions/XShm.h], [true],
+  		   [AC_MSG_ERROR([XShm extension is required])])
+	AC_CHECK_LIB([Xext], [main], [true],
+	           [AC_MSG_ERROR([libXext is required])], [$X_LIBS])
+        CPPFLAGS="$ac_save_CPPFLAGS"
+	X_LIBS="$X_LIBS $X_PRE_LIBS -lX11 -lXext"
+     fi
+   ])
+else
+   no_x="yes"
+fi
+
+if test "x$no_x" != "xyes"; then
+    AC_DEFINE(HAVE_X11,1,[Define this if you have X11R6 installed])
+fi
+AM_CONDITIONAL(HAVE_X11, [test "x$no_x" != "xyes"])
+
+
+dnl ---------------------------------------------
+dnl Locate libraries needed for X health check
+dnl ---------------------------------------------
+
+soname_script="/[[0-9]]$/! d; s%^.*/%%
+t q
+b
+:q
+q"
+x_lib_location="`ls -1 "${x_libraries:-/usr/local/lib}/libX11.so"* "${x_libraries:-/usr/lib}/libX11.so"* 2>/dev/null | sed -e \"${soname_script}\"`"
+AC_DEFINE_UNQUOTED([LIBX11_SO], "${x_lib_location:-libX11.so}", [The soname of libX11, needed for dlopen()])
+x_lib_location="`ls -1 "${x_libraries:-/usr/local/lib}/libXv.so"*  "${x_libraries:-/usr/lib}/libXv.so"*  2>/dev/null | sed -e \"${soname_script}\"`"
+AC_DEFINE_UNQUOTED([LIBXV_SO],  "${x_lib_location:-libXv.so}",  [The soname of libXv, needed for dlopen()])
+
+
+dnl ---------------------------------------------
+dnl socket library
+dnl ---------------------------------------------
+
+dnl Test for socket and network support library
+NET_LIBS=""
+AC_CHECK_LIB(socket, socket, NET_LIBS="-lsocket $NET_LIBS",)
+AC_CHECK_LIB(nsl, gethostbyname, NET_LIBS="-lnsl $NET_LIBS",)
+AC_SUBST(NET_LIBS)
+
+
+dnl ---------------------------------------------
+dnl socklen_t
+dnl ---------------------------------------------
+AC_CHECK_SOCKLEN_T
+
+
+dnl ---------------------------------------------
+dnl IPv6
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([ipv6],
+	AS_HELP_STRING([--enable-ipv6], [enable use of IPv6]))
+
+if test "x$enable_ipv6" = "xyes"; then
+   AC_DEFINE([ENABLE_IPV6], [1], [Enable this when IPv6 is requested])
+fi
+
+dnl ---------------------------------------------
+dnl zlib
+dnl ---------------------------------------------
+
+AC_ARG_WITH(zlib-prefix, 
+  AS_HELP_STRING(
+    [--with-zlib-prefix=PREFIX],
+    [path to zlib compression library]),
+  [zlib_prefix="$withval"],
+  [zlib_prefix="no"])
+
+if test "x$zlib_prefix" = "xno"; then
+  ZLIB_LIBS="-lz"
+else
+  ZLIB_CPPFLAGS="-I$zlib_prefix/include"
+  ZLIB_LIBS="-L$zlib_prefix/lib -lz"
+fi
+
+ac_save_CPPFLAGS="$CPPFLAGS"
+ac_save_LIBS="$LIBS"
+CPPFLAGS="$CPPFLAGS $ZLIB_CPPFLAGS"
+LIBS="$LIBS $ZLIB_LIBS"
+
+AC_CHECK_LIB(z, gzsetparams,
+  [AC_CHECK_HEADER(zlib.h,
+     have_zlib=yes)])
+
+CPPFLAGS="$ac_save_CPPFLAGS"
+LIBS="$ac_save_LIBS"
+
+if test "x$have_zlib" != "xyes"; then
+  AC_MSG_ERROR(zlib needed)
+fi
+AC_SUBST(ZLIB_CPPFLAGS)
+AC_SUBST(ZLIB_LIBS)
+
+
+dnl ---------------------------------------------
+dnl check posix timers
+dnl ---------------------------------------------
+
+AC_CHECK_LIB(rt, clock_getres,
+             [RT_LIBS="-lrt"
+              AC_DEFINE(HAVE_POSIX_TIMERS,1,
+                        [Define this if you have POSIX timers.])], 
+             AC_MSG_RESULT([*** no POSIX timers available.]))
+AC_SUBST(RT_LIBS)
+
+dnl ---------------------------------------------
+dnl Check for OpenGL & [GLut | GLU]
+dnl ---------------------------------------------
+
+AM_PATH_OPENGL()
+
+
+dnl ---------------------------------------------
+dnl Check for platform which supports syncfb
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([syncfb],
+	AS_HELP_STRING([--disable-syncfb], [do not build syncfb plugin]))
+
+case "$host_os" in
+  *linux*) ;;
+  *)
+    if test "x$enable_syncfb" = "xyes"; then
+       AC_MSG_ERROR([You cannot build SyncFB support on non-Linux systems.])
+    fi
+    enable_syncfb=no ;;
+esac
+
+AM_CONDITIONAL(HAVE_SYNCFB, test "x$enable_syncfb" != "xno")
+
+
+dnl ----------------------------------------------
+dnl Check for usable video-for-linux (v4l) support
+dnl ----------------------------------------------
+AC_ARG_ENABLE([v4l],
+	AS_HELP_STRING([--disable-v4l], [do not build Video4Linux input plugin]))
+
+if test "x$enable_v4l" != "xno"; then
+  AC_CHECK_HEADERS([linux/videodev.h], [have_v4l=yes], [have_v4l=no])
+  AC_CHECK_HEADERS([asm/types.h])
+  if test "x$enable_v4l" = "xyes" && test "x$have_v4l" = "xno"; then
+     AC_MSG_ERROR([Video4Linux support requested, but prerequisite headers not found.])
+  fi
+fi
+
+AM_CONDITIONAL(HAVE_V4L, [test "x$have_v4l" = "xyes"])
+
+dnl ----------------------------------------------
+dnl Check for Xv and XvMC support
+dnl ----------------------------------------------
+
+dnl With recent XFree86 or Xorg, dynamic linking is preferred!
+dnl Only dynamic linking is possible when using libtool < 1.4.0
+
+AC_ARG_WITH(xv-path, AS_HELP_STRING([--with-xv-path=path], [where libXv is installed]),
+            xv_path="$withval",)
+
+AC_ARG_ENABLE([static-xv],
+        AS_HELP_STRING([--enable-static-xv],[Enable this to force linking against libXv.a]))
+
+if test "x$enable_static_xv" = "xyes"; then
+  xv_prefer_shared="no"
+else
+  xv_prefer_shared="yes"
+fi
+
+if test "x$no_x" != "xyes"; then
+   PKG_CHECK_MODULES([XV], [xv], [
+     ac_have_xv="yes"
+     AC_DEFINE([HAVE_XV], [1], [Define this if you have libXv installed])
+   ], [AC_FIND_LIBXV])
+fi
+AM_CONDITIONAL(HAVE_XV, test "x$ac_have_xv" = "xyes")
+
+
+host_or_hostalias="$host"
+if test "$host_or_hostalias" = ""; then
+    dnl user has called ./configure with a host parameter unknown to
+    dnl config.sub; the canonical "$host" is empty
+    dnl
+    dnl Try the following switch with user's original host_alias 
+    dnl input instead.
+    dnl
+    host_or_hostalias="$host_alias"
+fi
+
+case "$host_or_hostalias" in
+  hppa*)
+	if test "x$ac_have_xv_static" = "xyes"; then
+	  echo "warning: hppa linker - disabling static libXv"
+	  XV_LIBS="libXv.so"
+	fi
+	;;
+
+  ppc-*-linux* | powerpc-*)
+        ppc_arch="yes"
+        ;;
+
+  *)
+        ;;
+esac
+AM_CONDITIONAL(PPC_ARCH, test "x$ppc_arch" = "xyes")
+
+dnl
+dnl Check if we can enable the xxmc plugin.
+dnl
+
+AC_ARG_ENABLE([xvmc],
+  AS_HELP_STRING([--disable-xvmc], [Disable XxMC and XvMC outplut plugins]) )
+
+if test "x$no_x" = "x" && test "x$enable_xvmc" != "xno"; then
+
+AC_ARG_WITH(xxmc-path, AS_HELP_STRING([--with-xxmc-path=path], [where libXvMC libraries for the
+	xxmc plugin are  installed. Defalts to the default X library path.]),
+	xxmc_path="$withval", xxmc_path="${x_libraries:-/usr/lib}")
+AC_ARG_WITH(xxmc-lib, AS_HELP_STRING([--with-xxmc-lib=XXXX], [The name of the XvMC library 
+	libXXXX.so for the xxmc plugin.]),xxmc_stub="$withval", 
+	xxmc_stub="XvMCW")
+
+saved_libs="$LIBS"
+saved_CPPFLAGS="$CPPFLAGS"
+if test "x$x_includes" != "x"; then
+	CPPFLAGS="$CPPFLAGS -I$x_includes"
+fi
+
+XXMC_LIBS="-L$xxmc_path -l$xxmc_stub"
+AC_MSG_CHECKING(whether to enable the xxmc plugin with vld extensions)
+AC_MSG_RESULT()
+dnl Check if vld "extended" XvMC is available
+if test "x$xxmc_stub" == "xXvMCW" && test "x$ac_have_xv" == "xyes"; then
+	AC_CHECK_LIB($xxmc_stub, XvMCPutSlice,
+             	     ac_have_xxmc="yes",
+	             [ac_have_xxmc="no"
+              	        AC_MSG_RESULT([*** Could not link with -l$xxmc_stub for vld extensions.])],
+                     [-L$xxmc_path $X_LIBS $X_PRE_LIBS $XV_LIBS -lXext $X_EXTRA_LIBS])
+else
+    if test "x$ac_have_xv" = "xyes"; then 
+      AC_CHECK_LIB($xxmc_stub, XvMCPutSlice,
+	           [ac_have_xxmc="yes"
+	             XXMC_LIBS="$XXMC_LIBS -lXvMC"],
+                   [ac_have_xxmc="no"
+		     AC_MSG_RESULT([*** Could not link with -l$xxmc_stub -lXvMC for vld extensions.])],
+                   [-L$xxmc_path -lXvMC $X_LIBS $X_PRE_LIBS $XV_LIBS -lXext $X_EXTRA_LIBS])
+    else 
+      ac_have_xxmc="no",
+    fi  
+fi
+
+if test "x$ac_have_xxmc" = "xyes"; then
+  AC_CHECK_HEADERS(X11/extensions/vldXvMC.h,
+     [ac_have_vldxvmc_h="yes"],
+     ac_have_vldxvmc="no",)
+  if test "x$ac_have_vldxvmc_h" = "xyes"; then
+     AC_DEFINE([HAVE_VLDXVMC], [1], 
+               [Define 1 if you have vldXvMC.h])
+  fi
+fi
+dnl Try fallback to standard XvMC if vld failed
+if test "x$ac_have_xxmc" = "xno"; then
+  if test "x$xxmc_stub" == "xXvMCW"; then
+	  AC_CHECK_LIB($xxmc_stub, XvMCCreateContext,
+               ac_have_xxmc="yes",
+	       [ac_have_xxmc="no"
+                AC_MSG_RESULT([*** Could not link with -l$xxmc_stub for standard XvMC.])],
+               [-L$xxmc_path $X_LIBS $X_PRE_LIBS $XV_LIBS -lXext $X_EXTRA_LIBS])
+  else
+      if test "x$ac_have_xv" = "xyes"; then 
+        AC_CHECK_LIB($xxmc_stub, XvMCCreateContext,
+	             [ac_have_xxmc="yes"
+		      XXMC_LIBS="$XXMC_LIBS -lXvMC"],
+                     [ac_have_xxmc="no"
+		      AC_MSG_RESULT([*** Could not link with -lXvMC for standard XvMC.])],
+                     [-L$xxmc_path -lXvMC $X_LIBS $X_PRE_LIBS $XV_LIBS -lXext $X_EXTRA_LIBS])
+      else 
+        ac_have_xxmc="no",
+      fi  
+  fi
+fi
+if test "x$ac_have_xxmc" = "xyes"; then
+  AC_CHECK_HEADERS(X11/extensions/XvMC.h,,
+     ac_have_xxmc="no",)
+fi
+if test "x$ac_have_xxmc" = "xyes"; then
+  AC_DEFINE(HAVE_XXMC,1,[Define this to compile the xxmc plugin.])
+  if test "x$ac_have_vldxvmc_h" = "xyes"; then
+    AC_MSG_RESULT([*** Enabling xxmc plugin with vld extensions.])
+  else
+    AC_MSG_RESULT([*** Enabling xxmc plugin for standard XvMC *only*.])
+  fi
+else
+  AC_MSG_RESULT([*** Disabling xxmc plugin due to above errors.])
+fi
+LIBS="$saved_libs"
+fi
+AM_CONDITIONAL(HAVE_VLDXVMC, test "x$ac_have_vldxvmc_h" = "xyes")
+AM_CONDITIONAL(HAVE_XXMC, test "x$ac_have_xxmc" = "xyes")
+AC_SUBST(XXMC_LIBS)
+	   
+dnl
+dnl Check if we can enable the xvmc plugin.
+dnl
+if test "x$no_x" = "x" && test "x$enable_xvmc" != "xno"; then
+
+AC_ARG_WITH(xvmc-path, AS_HELP_STRING([--with-xvmc-path=path], [where libXvMC libraries for the
+	xvmc plugin are  installed. Defalts to the default X library path.]),
+	xvmc_path="$withval", xvmc_path="${x_libraries:-/usr/lib}")
+AC_ARG_WITH(xvmc-lib, AS_HELP_STRING([--with-xvmc-lib=XXXX], [The name of the XvMC library 
+	libXXXX.so for the xvmc plugin.]),xvmc_stub="$withval", 
+	xvmc_stub="XvMCW")
+saved_libs="$LIBS"
+XVMC_LIBS="-L$xvmc_path -l$xvmc_stub"
+AC_MSG_CHECKING(whether to enable the xvmc plugin)
+AC_MSG_RESULT()
+if test "x$xvmc_stub" == "xXvMCW"; then
+	AC_CHECK_LIB($xvmc_stub, XvMCCreateContext,
+             ac_have_xvmc="yes",
+	     [ac_have_xvmc="no"
+              AC_MSG_RESULT([*** Could not link with -l$xvmc_stub.])],
+             [-L$xvmc_path $X_LIBS $X_PRE_LIBS $XV_LIBS -lXext $X_EXTRA_LIBS])
+else
+    if test "x$ac_have_xv" = "xyes"; then 
+      AC_CHECK_LIB($xvmc_stub, XvMCCreateContext,
+	           [ac_have_xvmc="yes"
+		    XVMC_LIBS="$XVMC_LIBS -lXvMC"],
+                   [ac_have_xvmc="no"
+		    AC_MSG_RESULT([*** Could not link with -lXvMC.])],
+                   [-L$xvmc_path -lXvMC $X_LIBS $X_PRE_LIBS $XV_LIBS -lXext $X_EXTRA_LIBS])
+    else 
+      ac_have_xvmc="no",
+    fi  
+fi
+if test "x$ac_have_xvmc" = "xyes"; then
+  AC_CHECK_HEADERS(X11/extensions/XvMC.h,,
+     ac_have_xvmc="no",)
+fi
+if test "x$ac_have_xvmc" = "xyes"; then
+  AC_DEFINE(HAVE_XVMC,1,[Define this if you have an XvMC library and XvMC.h installed.])
+  AC_MSG_RESULT([*** Enabling old xvmc plugin.])
+else
+  AC_MSG_RESULT([*** Disabling old xvmc plugin due to above errors.])
+fi
+CPPFLAGS="$saved_CPPFLAGS"
+LIBS="$saved_libs"
+fi
+AM_CONDITIONAL(HAVE_XVMC, test "x$ac_have_xvmc" = "xyes")
+AC_SUBST(XVMC_LIBS)
+
+
+dnl ---------------------------------------------
+dnl Check for xcb
+dnl ---------------------------------------------
+AC_ARG_WITH([xcb], AS_HELP_STRING([--without-xcb], [Doesn't build XCB video out plugins]))
+
+if test "x$with_xcb" != "xno"; then
+  PKG_CHECK_MODULES([XCB], [xcb-shape >= 1.0], [have_xcb="yes"], [have_xcb="no"])
+fi
+
+AC_SUBST(XCB_CFLAGS)
+AC_SUBST(XCB_LIBS)
+AM_CONDITIONAL(HAVE_XCB, test "x$have_xcb" = "xyes" )
+
+
+dnl ---------------------------------------------
+dnl Check for xcb-shm
+dnl ---------------------------------------------
+
+if test "x$have_xcb" = "xyes"; then
+  PKG_CHECK_MODULES([XCBSHM], [xcb-shm], [have_xcbshm="yes"], [have_xcbshm="no"])
+fi
+
+AC_SUBST(XCBSHM_CFLAGS)
+AC_SUBST(XCBSHM_LIBS)
+AM_CONDITIONAL(HAVE_XCBSHM, test "x$have_xcbshm" = "xyes" )
+
+
+dnl ---------------------------------------------
+dnl Check for xcb-xv
+dnl ---------------------------------------------
+
+if test "x$have_xcb" = "xyes"; then
+  PKG_CHECK_MODULES([XCBXV], [xcb-xv], [have_xcbxv="yes"], [have_xcbxv="no"])
+fi
+
+AC_SUBST(XCBXV_CFLAGS)
+AC_SUBST(XCBXV_LIBS)
+AM_CONDITIONAL(HAVE_XCBXV, test "x$have_xcbxv" = "xyes" )
+
+
+dnl ---------------------------------------------
+dnl Checks for Xinerama extension
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([xinerama],
+  AS_HELP_STRING([--disable-xinerama], [do not build Xinerama support]))
+
+if test "x$enable_xinerama" != "xno"; then
+   PKG_CHECK_MODULES([XINERAMA], [xinerama], [ac_have_xinerama=yes], [
+      AC_CHECK_LIB(Xinerama, XineramaQueryExtension, 
+                  [XINERAMA_LIBS="-lXinerama"
+                   ac_have_xinerama="yes"],,
+                  [$X_LIBS $X_PRE_LIBS -lXext $X_EXTRA_LIBS])
+   ])
+   if test "x$ac_have_xinerama" = "xyes"; then
+      AC_DEFINE(HAVE_XINERAMA,1,[Define this if you have libXinerama installed])
+      X_LIBS="${X_LIBS} ${XINERAMA_LIBS}"
+   fi
+else
+  ac_have_xinerama=no
+fi
+dnl AM_CONDITIONAL(HAVE_XINERAMA, test "x$ac_have_xinerama" = "xyes")
+
+ 
+dnl ---------------------------------------------
+dnl Checks for Ascii-Art library
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([aalib],
+  AS_HELP_STRING([--disable-aalib], [do not build AALIB support]),
+  [with_aalib=$enableval], [with_aalib=yes])
+
+if test "x$with_aalib" = "xyes"; then
+  AM_PATH_AALIB(1.4,, AC_MSG_RESULT([*** All of AALIB dependent parts will be disabled ***]))
+else
+  no_aalib=yes
+fi
+
+AM_CONDITIONAL(HAVE_AA, test "x$no_aalib" != "xyes")
+
+dnl ---------------------------------------------
+dnl Checks for Color AsCii Art library
+dnl ---------------------------------------------
+
+AC_ARG_WITH([caca],
+  AS_HELP_STRING([--without-caca], [Do not build CACA support]))
+
+if test "x$with_caca" != "xno"; then
+   have_caca=yes
+   PKG_CHECK_MODULES([CACA], [caca >= 0.99beta14 cucul >= 0.99beta14 ],
+		     [], [AC_MSG_RESULT(no); have_caca="no"])
+   if test "x$with_caca" = "xyes" && test "x$have_caca" = "xno"; then
+      AC_MSG_ERROR([CACA support requested, but libcaca 0.99 not found])
+   fi
+fi
+
+AM_CONDITIONAL([HAVE_CACA], [test "x$have_caca" = "xyes"])
+
+dnl ---------------------------------------------
+dnl Check solaris framebuffer device support
+dnl ---------------------------------------------
+
+AC_CHECK_HEADER(sys/fbio.h, ac_have_sunfb=yes,)
+AM_CONDITIONAL(HAVE_SUNFB, [test "x$ac_have_sunfb" = "xyes"])
+
+
+dnl ---------------------------------------------
+dnl Check for Sun DGA
+dnl ---------------------------------------------
+
+saved_LDFLAGS="$LDFLAGS"
+LDFLAGS="$LDFLAGS -L/usr/openwin/lib"
+saved_CPPFLAGS="$CPPFLAGS"
+CPPFLAGS="$CPPFLAGS -I/usr/openwin/include"
+AC_CHECK_LIB(dga, XDgaGrabDrawable, [
+	AC_CHECK_HEADER(dga/dga.h, [
+	        SUNDGA_CFLAGS="-I/usr/openwin/include"
+		SUNDGA_LIBS="-L/usr/openwin/lib -R/usr/openwin/lib -ldga"
+		ac_have_sundga=yes
+	])
+])
+LDFLAGS="$saved_LDFLAGS"
+CPPFLAGS="$saved_CPPFLAGS"
+AM_CONDITIONAL(HAVE_SUNDGA, [test "x$ac_have_sundga" = "xyes"])
+AC_SUBST(SUNDGA_CFLAGS)
+AC_SUBST(SUNDGA_LIBS)
+
+
+dnl ---------------------------------------------
+dnl Check linux framebuffer device support
+dnl ---------------------------------------------
+
+AC_CHECK_HEADER(linux/fb.h,
+                [AC_DEFINE(HAVE_FB,1,[Define this if you have linux framebuffer support])
+                 have_fb=yes],)
+AC_ARG_ENABLE(fb, AS_HELP_STRING([--disable-fb], [do not build linux framebuffer support]),
+	      have_fb=$enableval)
+AM_CONDITIONAL(HAVE_FB, [test "x$have_fb" = "xyes"])
+
+
+dnl ---------------------------------------------
+dnl Check whether to build Mac OS X video output driver
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE(macosx_video, AS_HELP_STRING([--enable-macosx-video], [enable support for Mac OS X OpenGL video output]),
+              have_macosx_video=$enableval)
+AM_CONDITIONAL(HAVE_MACOSX_VIDEO, [test "x$have_macosx_video" = "xyes"])
+
+
+dnl ---------------------------------------------
+dnl Check whether to build Mac OS X audio output driver
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE(coreaudio, AS_HELP_STRING([--enable-coreaudio], [enable support for Mac OS X Coreaudio output]),
+              have_coreaudio=$enableval)
+AM_CONDITIONAL(HAVE_COREAUDIO, [test "x$have_coreaudio" = "xyes"])
+
+
+dnl ---------------------------------------------
+dnl Check for DirectFB
+dnl ---------------------------------------------
+AC_ARG_ENABLE(directfb,
+	AS_HELP_STRING([--enable-directfb], [enable use of DirectFB]),
+		enable_directfb=$enableval,
+		enable_directfb=no)
+
+if test "x$enable_directfb" = "xyes"; then
+  PKG_CHECK_MODULES([DIRECTFB], [directfb >= 0.9.22], [have_directfb="yes"], [have_directfb="no"])
+fi
+
+AC_SUBST(DIRECTFB_CFLAGS)
+AC_SUBST(DIRECTFB_LIBS)
+AM_CONDITIONAL(HAVE_DIRECTFB, test "x$have_directfb" = "xyes" )
+
+
+dnl ---------------------------------------------
+dnl check for SDL
+dnl ---------------------------------------------
+
+AC_ARG_WITH([sdl],
+	AS_HELP_STRING([--without-sdl], [Build without SDL video output]))
+
+if test "x$with_sdl" != "xno"; then
+   PKG_CHECK_MODULES([SDL], [sdl], [have_sdl=yes], [have_sdl=no])
+   if test "x$with_sdl" = "xyes" && test "x$have_sdl" = "xno"; then
+      AC_MSG_ERROR([SDL support requested, but SDL not found])
+   elif test "x$have_sdl" = "xyes"; then
+      AC_DEFINE([HAVE_SDL], [1], [Define this if you have SDL installed])
+   fi
+fi
+
+AM_CONDITIONAL([HAVE_SDL], [test "x$have_sdl" = "xyes"])
+
+AC_SUBST([SDL_CFLAGS])
+AC_SUBST([SDL_LIBS])
+
+dnl ---------------------------------------------
+dnl check for Libstk
+dnl ---------------------------------------------
+
+AC_ARG_WITH([libstk],
+	AS_HELP_STRING([--with-libstk], [Build with STK surface video driver]))
+
+if test "x$with_libstk" = "xyes"; then
+   PKG_CHECK_MODULES([LIBSTK], [libstk >= 0.2.0], [have_libstk=yes], [have_libstk=no])
+   if test "x$with_libstk" = "xyes" && test "x$have_libstk" = "xno"; then
+      AC_MSG_ERROR([libstk support requested, but libstk not found])
+   fi
+fi
+
+AM_CONDITIONAL([HAVE_STK], [test "x$have_libstk" = "xyes"])
+
+dnl ---------------------------------------------
+dnl check for pulseaudio
+dnl ---------------------------------------------
+
+AC_ARG_WITH([pulseaudio],
+   AS_HELP_STRING([--without-pulseaudio], [Do not build Pulseaudio support]))
+
+if test "x$with_pulseaudio" != "xno"; then
+   PKG_CHECK_MODULES([PULSEAUDIO], [libpulse], [have_pulseaudio="yes"], [have_pulseaudio="no"])
+fi
+
+AM_CONDITIONAL(HAVE_PULSEAUDIO, [test "x$have_pulseaudio" = x"yes"])
+AC_SUBST([PULSEAUDIO_CFLAGS])
+AC_SUBST([PULSEAUDIO_LIBS])
+
+dnl ---------------------------------------------
+dnl check for DirectX
+dnl ---------------------------------------------
+
+AM_PATH_DIRECTX()
+
+
+dnl ---------------------------------------------
+dnl dxr3 / hollywood plus card
+dnl ---------------------------------------------
+
+case "$host_or_hostalias" in
+  *-linux*)
+    AC_CHECK_DXR3()
+    if test "x$have_libfame" = "xyes" ; then
+      AC_DEFINE_UNQUOTED(HAVE_LIBFAME,1,[Define this if you have libfame mpeg encoder installed (fame.sf.net)])
+      AM_PATH_LIBFAME(0.8.10, 
+        AC_DEFINE(HAVE_NEW_LIBFAME,1,[Define this if you have libfame 0.8.10 or above]))
+    fi
+    if test "x$have_librte" = "xyes" ; then
+      AC_DEFINE_UNQUOTED(HAVE_LIBRTE,1,[Define this if you have librte mpeg encoder installed (zapping.sf.net)])
+    fi
+    ;;
+  *)
+    have_dxr3="no"
+    have_libfame="no"
+    have_librte="no"
+    have_encoder="no"
+    ;;
+esac
+AM_CONDITIONAL(HAVE_DXR3, test "x$have_dxr3" = "xyes")
+AM_CONDITIONAL(HAVE_LIBFAME, test "x$have_libfame" = "xyes")
+AM_CONDITIONAL(HAVE_LIBRTE, test "x$have_librte" = "xyes")
+
+
+dnl ---------------------------------------------
+dnl Vidix/libdha
+dnl ---------------------------------------------
+
+AC_LINUX_PATH(/usr/src/linux)
+AC_SUBST([LINUX_INCLUDE])
+
+AC_ARG_ENABLE(vidix, AS_HELP_STRING([--disable-vidix], [do not build vidix support]),
+	      check_vidix=$enableval, check_vidix=yes)
+AC_ARG_ENABLE(dha-kmod, AS_HELP_STRING([--enable-dha-kmod], [build DHA kernel module]),
+	      enable_dha_kmod=$enableval,enable_dha_kmod=no)
+
+enable_vidix="no"
+
+AC_MSG_CHECKING(for vidix support)
+if test "x$check_vidix" = "xyes" -a "x$ac_cv_prog_AWK" != "xno"; then
+  if test "x$no_x" != "xyes" -o "x$have_fb" = "xyes"; then
+    case "$host_or_hostalias" in
+      i?86-*-linux* | k?-*-linux* | athlon-*-linux*)
+        enable_vidix="yes"
+        enable_linux="yes"
+        ;;
+      i?86-*-freebsd* | k?-*-freebsd* | athlon-*-freebsd* | i?86-*-kfreebsd*)
+        enable_vidix="yes"
+        enable_dha_kmod="no"
+        ;;
+      *)
+        enable_dha_kmod="no"
+        enable_vidix="no"
+        ;;
+    esac
+  fi
+fi
+AC_MSG_RESULT($enable_vidix)
+
+AC_MSG_CHECKING(for DHA linux kernel module build)
+if test "x$enable_dha_kmod" = "xyes"; then
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+
+AM_CONDITIONAL(HAVE_VIDIX, test "x$enable_vidix" = "xyes")
+AM_CONDITIONAL(HAVE_LINUX, test "x$enable_linux" = "xyes")
+AM_CONDITIONAL(BUILD_DHA_KMOD, test "x$enable_dha_kmod" = "xyes")
+AC_CHECK_PROG(MKNOD, mknod, mknod, no)
+AC_CHECK_PROG(DEPMOD, depmod, depmod, no, "$PATH:/sbin")
+
+
+dnl ---------------------------------------------
+dnl Ogg/Vorbis libs.
+dnl ---------------------------------------------
+
+AC_ARG_WITH([vorbis],
+	AS_HELP_STRING([--without-vorbis], [Build without Vorbis audio decoder]))
+
+if test "x$with_vorbis" != "xno"; then
+   PKG_CHECK_MODULES([VORBIS], [ogg vorbis], [have_vorbis=yes], [have_vorbis=no])
+   if test "x$with_vorbis" = "xyes" && test "x$have_vorbis" = "xno"; then
+      AC_MSG_ERROR([Vorbis support requested, but libvorbis not found])
+   fi
+fi
+AM_CONDITIONAL([HAVE_VORBIS], [test "x$have_vorbis" = "xyes"])
+
+AC_SUBST([VORBIS_CFLAGS])
+AC_SUBST([VORBIS_LIBS])
+
+dnl ---------------------------------------------
+dnl Ogg/Theora libs.
+dnl ---------------------------------------------
+
+AC_ARG_WITH([theora],
+	AS_HELP_STRING([--without-theora], [Build without Theora video decoder]))
+
+if test "x$with_theora" != "xno"; then
+   PKG_CHECK_MODULES([THEORA], [ogg theora], [have_theora=yes], [have_theora=no])
+   if test "x$with_theora" = "xyes" && test "x$have_theora" = "xno"; then
+      AC_MSG_ERROR([Theora support requested, but libtheora not found])
+   elif test "x$have_theora" = "xyes"; then
+      AC_DEFINE([HAVE_THEORA], [1], [Define this if you have theora])
+   fi
+fi
+AM_CONDITIONAL([HAVE_THEORA], [test "x$have_theora" = "xyes"])
+
+AC_SUBST([THEORA_CFLAGS])
+AC_SUBST([THEORA_LIBS])
+
+dnl ---------------------------------------------
+dnl Ogg/Speex libs.
+dnl ---------------------------------------------
+AC_ARG_WITH([speex],
+	AS_HELP_STRING([--without-speex], [Build without Speex audio decoder]))
+
+if test "x$with_speex" != "xno"; then
+   PKG_CHECK_MODULES([SPEEX], [ogg speex], [have_speex=yes], [have_speex=no])
+   if test "x$with_speex" = "xyes" && test "x$have_speex" = "xno"; then
+      AC_MSG_ERROR([Speex support requested, but libspeex not found])
+   elif test "x$have_speex" = "xyes"; then
+      AC_DEFINE([HAVE_SPEEX], [1], [Define this if you have speex])
+   fi
+fi
+AM_CONDITIONAL([HAVE_SPEEX], [test "x$have_speex" = "xyes"])
+
+AC_SUBST([SPEEX_CFLAGS])
+AC_SUBST([SPEEX_LIBS])
+
+dnl ---------------------------------------------
+dnl check for libFLAC
+dnl ---------------------------------------------
+
+AC_ARG_WITH([libflac],
+  AS_HELP_STRING([--with-libflac], [build libFLAC-based decoder and demuxer]))
+
+have_libflac="no"
+if test "x$with_libflac" = "xyes"; then
+  AM_PATH_LIBFLAC([have_libflac="yes"])
+fi
+
+AM_CONDITIONAL([HAVE_LIBFLAC], [test "x$have_libflac" = "xyes"])
+
+dnl ---------------------------------------------
+dnl External version of a52dec
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE(a52dec, AS_HELP_STRING([--disable-a52dec], [Disable support for a52dec decoding library (default: enabled)]),
+              [enable_a52dec="$enableval"], [enable_a52dec="yes"])
+AC_ARG_WITH(external-a52dec, AS_HELP_STRING([--with-external-a52dec], [use external a52dec library (not recommended)]),
+            [external_a52dec="$withval"], [external_a52dec="no"])
+
+have_a52="no"
+
+if test "x$enable_a52dec" = "xno"; then
+  AC_MSG_RESULT([a52dec support disabled])
+elif test "x$external_a52dec" = "xyes"; then
+  have_a52="yes"
+  AC_CHECK_HEADERS([a52dec/a52.h a52dec/a52_internal.h],, have_a52="no",
+[
+  #ifdef HAVE_SYS_TYPES_H
+  # include <sys/types.h>
+  #endif
+  #ifdef HAVE_INTTYPES_H
+  # include <inttypes.h>
+  #endif
+  #ifdef HAVE_STDINT_H
+  # include <stdint.h>
+  #endif
+
+  #include <a52dec/a52.h>
+])
+  SAVE_LIBS="$LIBS"
+  AC_CHECK_LIB([a52], [a52_init],, have_a52="no", [-lm])
+  LIBS="$SAVE_LIBS"
+
+  if test "x$have_a52" = "xno"; then
+    AC_MSG_RESULT([*** no usable version of a52dec found, using internal copy ***])
+  fi
+else
+  AC_MSG_RESULT([Use included a52dec support])
+fi
+
+AM_CONDITIONAL(A52, test "x$enable_a52dec" = "xyes")
+AM_CONDITIONAL(EXTERNAL_A52DEC, test "x$have_a52" = "xyes")
+
+dnl ---------------------------------------------
+dnl External version of libmad
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE(mad, AS_HELP_STRING([--disable-mad], [Disable support for MAD decoding library (default: enabled)]),
+              [enable_libmad="$enableval"], [enable_libmad="yes"])
+AC_ARG_WITH(external-libmad, AS_HELP_STRING([--with-external-libmad], [use external libmad library (not recommended)]),
+            [external_libmad="$withval"], [external_libmad="no"])
+
+have_mad="no"
+
+if test "x$enable_libmad" = "xno"; then
+  AC_MSG_RESULT([libmad support disabled])
+elif test "x$external_libmad" = "xyes"; then
+  PKG_CHECK_MODULES(LIBMAD, [mad], have_mad=yes, have_mad=no)
+  AC_CHECK_HEADERS([mad.h])
+  AC_SUBST(LIBMAD_LIBS)
+  AC_SUBST(LIBMAD_CFLAGS)
+  if test "x$have_mad" = "xno"; then
+    AC_MSG_RESULT([*** no usable version of libmad found, using internal copy ***])
+  fi
+else
+  AC_MSG_RESULT([Use included libmad support])
+fi
+
+AM_CONDITIONAL(MAD, test "x$enable_libmad" = "xyes")
+AM_CONDITIONAL(EXTERNAL_LIBMAD, test "x$have_mad" = "xyes")
+
+dnl ---------------------------------------------
+dnl External libmpcdec support
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([musepack], AS_HELP_STRING([--disable-musepack], [Disable support for MusePack decoding (default: enabled)]))
+AC_ARG_WITH([external-libmpcdec], AS_HELP_STRING([--with-external-libmpcdec], [Use external libmpc library]))
+
+if test "x$enable_musepack" = "xno"; then
+   AC_MSG_RESULT([musepack support disabled])
+elif test "x$with_external_libmpcdec" = "xyes"; then
+   AC_CHECK_LIB([mpcdec], [mpc_decoder_decode], [have_mpcdec=yes])
+   AC_CHECK_HEADERS([mpcdec/mpcdec.h], , [have_mpcdec=no])
+   if test "x$have_mpcdec" != "xyes"; then
+      AC_MSG_ERROR([Unable to find mpcdec])
+   fi
+   AC_DEFINE([HAVE_LIBMPC], [1], [Define if external libmpc is used])
+else
+   AC_MSG_RESULT([Use included libmusepack])
+fi
+
+AM_CONDITIONAL([MUSEPACK], [test "x$enable_musepack" != "xno"])
+AM_CONDITIONAL([EXTERNAL_MPCDEC], [test "x$have_mpcdec" = "xyes"])
+
+dnl ---------------------------------------------
+dnl MNG libs.
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([mng],
+  AS_HELP_STRING([--disable-mng], [do not build mng support]),
+  [with_mng=$enableval], [with_mng=yes])
+
+if test "x$with_mng" = "xyes"; then
+  AC_CHECK_LIB(mng, mng_initialize,
+	[ AC_CHECK_HEADER(libmng.h,
+		[ have_libmng=yes
+		  MNG_LIBS="-lmng" ], 
+		AC_MSG_RESULT([*** All libmng dependent parts will be disabled ***]))],
+	AC_MSG_RESULT([*** All libmng dependent parts will be disabled ***]))
+  AC_SUBST(MNG_LIBS)
+else
+  have_libmng=no
+fi
+AM_CONDITIONAL(HAVE_LIBMNG, test "x$have_libmng" = "xyes")
+
+dnl ---------------------------------------------
+dnl MagickWand API of Imagemagick.
+dnl ---------------------------------------------
+
+AC_ARG_WITH([imagemagick],
+	AS_HELP_STRING([--without-imagemagick], [Build without ImageMagick image decoder]))
+
+if test "x$with_imagemagick" != "xno"; then
+   PKG_CHECK_MODULES([WAND], [Wand], [have_imagemagick=yes], [have_imagemagick=no])
+   if test "x$with_imagemagick" = "xyes" && test "x$have_imagemagick" = "xno"; then
+      AC_MSG_ERROR([ImageMagick support requested, but Wand not found])
+   elif test "x$have_imagemagick" = "xyes"; then
+      AC_DEFINE([HAVE_WAND], [1], [Define this if you have ImageMagick installed])
+   fi
+fi
+
+AM_CONDITIONAL([HAVE_WAND], [test "x$have_imagemagick" = "xyes"])
+AC_SUBST(WAND_CFLAGS)
+AC_SUBST(WAND_LIBS)
+
+dnl ---------------------------------------------
+dnl freetype2 lib.
+dnl ---------------------------------------------
+AC_ARG_WITH([freetype],
+	AS_HELP_STRING([--with-freetype], [Build with FreeType2 library]))
+
+if test "x$with_freetype" = "xyes"; then
+   PKG_CHECK_MODULES([FT2], [freetype2], [have_freetype=yes], [have_freetype=no])
+   if test "x$have_freetype" = "xno"; then
+      AC_MSG_ERROR([FreeType2 support requested but FreeType2 library not found])
+   elif test "x$have_freetype" = "xyes"; then
+      AC_DEFINE([HAVE_FT2], [1], [Define this if you have freetype2 library])
+   fi
+fi
+AC_SUBST([FT2_CFLAGS])
+AC_SUBST([FT2_LIBS])
+
+dnl ---------------------------------------------
+dnl fontconfig
+dnl ---------------------------------------------
+AC_ARG_WITH([fontconfig],
+	AS_HELP_STRING([--with-fontconfig], [Build with fontconfig library]))
+
+if test "x$with_fontconfig" = "xyes"; then
+   if test "x$have_freetype" != "xyes"; then
+      AC_MSG_ERROR([fontconfig support requested, but FreeType2 not enabled.])
+   fi
+
+   PKG_CHECK_MODULES([FONTCONFIG], [fontconfig], [have_fontconfig=yes], [have_fontconfig=no])
+   if test "x$have_fontconfig" = "xno"; then
+      AC_MSG_ERROR([fontconfig support requested but fontconfig library not found])
+   elif test "x$have_fontconfig" = "xyes"; then
+      AC_DEFINE([HAVE_FONTCONFIG], [1], [Define this if you have fontconfig library])
+   fi
+fi
+AC_SUBST([FONTCONFIG_CFLAGS])
+AC_SUBST([FONTCONFIG_LIBS])
+
+
+dnl ---------------------------------------------
+dnl OSS style audio interface
+dnl ---------------------------------------------
+AC_ARG_ENABLE([oss],
+	AS_HELP_STRING([--disable-oss], [Do not build OSS audio output support]))
+
+if test "x$enable_oss" != "xno"; then
+   AC_CHECK_HEADERS([sys/soundcard.h machine/soundcard.h soundcard.h], [break])
+   AC_CHECK_DECL([SNDCTL_DSP_SETFRAGMENT], [have_ossaudio=yes], [], [
+     #ifdef HAVE_SYS_SOUNDCARD_H
+     # include <sys/soundcard.h>
+     #endif
+     #ifdef HAVE_MACHINE_SOUNDCARD_H
+     # include <sys/soundcard.h>
+     #endif
+     #ifdef HAVE_SOUNDCARD_H
+     # include <soundcard.h>
+     #endif
+   ])
+
+   if test "x$have_ossaudio" = "xyes"; then
+      AC_IOCTL_REQUEST
+   fi
+fi
+
+AM_CONDITIONAL(HAVE_OSS, test "x$have_ossaudio" = "xyes")
+
+
+dnl ---------------------------------------------
+dnl Alsa support
+dnl ---------------------------------------------
+
+AC_ARG_WITH([alsa],
+   AS_HELP_STRING([--without-alsa], [Build without ALSA audio output]))
+
+if test "x$with_alsa" != "xno"; then
+   PKG_CHECK_MODULES([ALSA], [alsa >= 0.9.0], [have_alsa=yes], [have_alsa=no])
+   AC_SUBST([ALSA_LIBS])
+   AC_SUBST([ALSA_CFLAGS])
+   if test "x$have_alsa" = "xyes"; then
+      AC_DEFINE([HAVE_ALSA], [1], [Define this if you have ALSA installed])
+   elif test "x$with_alsa" = "xyes"; then
+      AC_MSG_ERROR([ALSA support requested but not found.])
+   fi
+fi
+
+AM_CONDITIONAL([HAVE_ALSA], [test "x$have_alsa" = "xyes"])
+
+dnl ---------------------------------------------
+dnl ESD support
+dnl ---------------------------------------------
+
+AC_ARG_WITH([esound],
+	AS_HELP_STRING([--without-esound], [Build without ESounD audio output]))
+
+if test "x$with_esound" != "xno"; then
+   PKG_CHECK_MODULES([ESD], [esound], [have_esound=yes], [have_esound=no])
+   if test "x$with_esound" = "xyes" && test "x$have_esound" = "xno"; then
+      AC_MSG_ERROR([ESounD support requested, but libesd not found])
+   elif test "x$have_esound" = "xyes"; then
+      AC_DEFINE([HAVE_ESD], [1], [Define this if you have ESounD installed])
+   fi
+fi
+
+AM_CONDITIONAL([HAVE_ESD], [test "x$have_esound" = "xyes"])
+
+AC_SUBST([ESD_CFLAGS])
+AC_SUBST([ESD_LIBS])
+
+
+dnl ---------------------------------------------
+dnl ARTS support
+dnl ---------------------------------------------
+
+AC_ARG_WITH([arts],
+  AS_HELP_STRING([--with-arts], [Build with ARTS audio output]),
+  [with_arts=$withval], [with_arts=no])
+
+if test "x$with_arts" = "xyes"; then
+  AM_PATH_ARTS(0.9.5,
+        AC_DEFINE(HAVE_ARTS,1,[Define this if you have ARTS (libartsc) installed]),
+        AC_MSG_RESULT(*** All of ARTS dependent parts will be disabled ***))
+else
+  no_arts=yes
+fi
+AM_CONDITIONAL(HAVE_ARTS, test "x$no_arts" != "xyes")
+
+
+dnl ---------------------------------------------
+dnl FusionSound support
+dnl ---------------------------------------------
+
+AC_ARG_WITH([fusionsound],
+  AS_HELP_STRING([--with-fusionsound], [Build with FunsionSound audio output]),
+  [with_fusionsound=$withval], [with_fusionsound=no])
+
+if test "x$with_fusionsound" = "xyes"; then
+  PKG_CHECK_MODULES(FUSIONSOUND, fusionsound >= 0.9.23,
+      AC_DEFINE(HAVE_FUSIONSOUND,1,[Define to 1 if you have FusionSound.]),
+      AC_MSG_RESULT(*** All of FusionSound dependent parts will be disabled ***))
+  AC_SUBST(FUSIONSOUND_CFLAGS)
+  AC_SUBST(FUSIONSOUND_LIBS)
+else
+  no_fusionsound=yes
+fi
+AM_CONDITIONAL(HAVE_FUSIONSOUND, test "x$no_fusionsound" != "xyes")
+
+
+dnl ---------------------------------------------
+dnl JACK support
+dnl ---------------------------------------------
+
+AC_ARG_WITH([jack],
+	AS_HELP_STRING([--without-jack], [Build without Jack support]))
+
+if test "x$with_jack" != "xno"; then
+   PKG_CHECK_MODULES([JACK], [jack >= 0.100], [have_jack=yes], [have_jack=no])
+   
+   if test "x$with_jack" = "xyes" && test "x$have_jack" = "xno"; then
+      AC_MSG_ERROR([Jack support requested, but Jack not found])
+   fi
+fi
+
+AM_CONDITIONAL([HAVE_JACK], [test "x$have_jack" = "xyes"])
+
+
+dnl ---------------------------------------------
+dnl gnome-vfs support
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([gnomevfs],
+  AS_HELP_STRING([--disable-gnomevfs], [do not build gnome-vfs support]),
+  [with_gnome_vfs=$enableval], [with_gnome_vfs=yes])
+
+if test "x$with_gnome_vfs" = "xyes"; then
+  PKG_CHECK_MODULES(GNOME_VFS, gnome-vfs-2.0,
+                no_gnome_vfs=no,
+		no_gnome_vfs=yes)
+  AC_SUBST(GNOME_VFS_CFLAGS)
+  AC_SUBST(GNOME_VFS_LIBS)
+  if test "x$no_gnome_vfs" != "xyes"; then
+    AC_DEFINE(HAVE_GNOME_VFS,1,[Define this if you have gnome-vfs installed])
+  else
+    AC_MSG_RESULT(*** All of the gnome-vfs dependent parts will be disabled ***)
+  fi
+else
+  no_gnome_vfs=yes
+fi
+AM_CONDITIONAL(HAVE_GNOME_VFS, test "x$no_gnome_vfs" != "xyes")
+
+dnl ---------------------------------------------
+dnl gdk-pixbuf support
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([gdkpixbuf],
+   AS_HELP_STRING([--disable-gdkpixbuf], [do not build gdk-pixbuf support]))
+
+if test "x$enable_gdkpixbuf" != "xno"; then
+  PKG_CHECK_MODULES(GDK_PIXBUF, gdk-pixbuf-2.0,
+                no_gdkpixbuf=no,
+		no_gdkpixbuf=yes)
+  AC_SUBST(GDK_PIXBUF_CFLAGS)
+  AC_SUBST(GDK_PIXBUF_LIBS)
+  if test "x$no_gdkpixbuf" != "xyes"; then
+    AC_DEFINE(HAVE_GDK_PIXBUF,1,[Define this if you have gdk-pixbuf installed])
+  else
+    AC_MSG_RESULT(*** All of the gdk-pixbuf dependent parts will be disabled ***)
+  fi
+else
+  no_gdkpixbuf=yes
+fi
+AM_CONDITIONAL(HAVE_GDK_PIXBUF, test "x$no_gdkpixbuf" != "xyes")
+
+dnl ---------------------------------------------
+dnl libsmbclient support
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([samba],
+  AS_HELP_STRING([--disable-samba], [do not build Samba support]),
+  [with_samba=$enableval], [with_samba=yes])
+
+if test "x$with_samba" = "xyes"; then
+  AC_CHECK_LIB(smbclient, smbc_init,
+	[ AC_CHECK_HEADER(libsmbclient.h,
+		[ have_libsmbclient=yes
+		  LIBSMBCLIENT_LIBS="-lsmbclient" ], 
+		AC_MSG_RESULT([*** All libsmbclient dependent parts will be disabled ***]))],
+	AC_MSG_RESULT([*** All libsmbclient dependent parts will be disabled ***]))
+  AC_SUBST(LIBSMBCLIENT_LIBS)
+fi
+AM_CONDITIONAL(HAVE_LIBSMBCLIENT, test "x$have_libsmbclient" = "xyes")
+
+
+dnl ---------------------------------------------
+dnl SUN style audio interface
+dnl ---------------------------------------------
+
+AC_MSG_CHECKING(for Sun audio support)
+have_sunaudio=no
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+	    #include <sys/types.h>
+	    #include <sys/audioio.h>
+	]], [[
+	    audio_info_t audio_info;
+	    AUDIO_INITINFO(&audio_info);
+	]])],[
+	    have_sunaudio=yes
+	],[])
+AC_MSG_RESULT($have_sunaudio)
+AM_CONDITIONAL(HAVE_SUNAUDIO, test "x$have_sunaudio" = "xyes")
+
+if test "x$have_sunaudio" = "xyes"; then
+   dnl NetBSD and OpenBSD don't have this, but check for it
+   dnl rather than assuming that it doesn't happen elsewhere.
+   AC_CHECK_MEMBERS([audio_info_t.output_muted])
+fi
+
+
+dnl ---------------------------------------------
+dnl IRIX style audio interface
+dnl ---------------------------------------------
+
+AM_CHECK_IRIXAL([AC_DEFINE(HAVE_IRIXAL,1,
+			[Define this if you have a usable IRIX al interface available])],
+	[AC_MSG_RESULT([*** All of IRIX AL dependent parts will be disabled ***])])
+AM_CONDITIONAL(HAVE_IRIXAL, [test "x$am_cv_have_irixal" = xyes])
+
+
+dnl ---------------------------------------------
+dnl Solaris kstat kernel statistics
+dnl ---------------------------------------------
+
+AC_CHECK_LIB(kstat, kstat_open,
+	[KSTAT_LIBS=-lkstat
+	 AC_DEFINE(HAVE_KSTAT,1,[Define this if you have kernel statistics available via kstat interface])])
+AC_SUBST(KSTAT_LIBS)
+
+
+dnl ---------------------------------------------
+dnl cdrom ioctls
+dnl ---------------------------------------------
+
+AC_CHECK_HEADERS([linux/cdrom.h sys/dvdio.h], [break])
+AC_CHECK_HEADERS([sys/cdio.h sys/scsiio.h])
+AM_CHECK_CDROM_IOCTLS(
+	[AC_DEFINE(HAVE_CDROM_IOCTLS,1,[Define this if you have CDROM ioctls])],
+	[AC_MSG_RESULT([*** (S)VCD support will be disabled ***])])
+AM_CONDITIONAL(HAVE_CDROM_IOCTLS, [test "x$have_cdrom_ioctls" = "xyes"])
+
+
+dnl ---------------------------------------------
+dnl check for a usable version of libdvdnav
+dnl ---------------------------------------------
+
+AC_ARG_WITH(external-dvdnav, AS_HELP_STRING([--with-external-dvdnav], [use external dvdnav library (not recommended)]),
+            [external_dvdnav="$withval"], [no_dvdnav="yes"; external_dvdnav="no"])
+
+if test "x$external_dvdnav" = "xyes"; then
+  AM_PATH_DVDNAV(0.1.9,
+	  AC_DEFINE(HAVE_DVDNAV,1,[Define this if you have a suitable version of libdvdnav]),
+	  [AC_MSG_RESULT([*** no usable version of libdvdnav found, using internal copy ***])])
+else
+  AC_MSG_RESULT([Use included DVDNAV support])
+fi
+
+AM_CONDITIONAL(HAVE_DVDNAV, [test "x$no_dvdnav" != "xyes"])
+
+
+dnl ---------------------------------------------
+dnl Video CD
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE(vcd, AS_HELP_STRING([--disable-vcd], [do not compile VCD plugin]),
+              enable_vcd=$enableval, enable_vcd=yes)
+
+dnl Force build of both vcd plugins, for now.
+dnl AC_ARG_ENABLE(vcdo, AS_HELP_STRING([--disable-vcdo], [do not compile old VCD plugin]),
+dnl               enable_vcdo=$enableval, enable_vcdo=yes)
+dnl
+enable_vcdo="yes"
+
+AC_ARG_WITH(internal-vcdlibs, AS_HELP_STRING([--with-internal-vcdlibs], [force using internal libcdio/libvcd/libvcdinfo]),
+            [internal_vcdnav="$withval"], [internal_vcdnav="no"])
+
+if test "x$enable_vcd" = "xyes"; then
+  dnl empty_array_size
+  AC_MSG_CHECKING([how to create empty arrays])
+
+  empty_array_size="xxx"
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[struct { int foo; int bar[]; } doo;]])],[empty_array_size=""],[])
+
+  if test "x$empty_array_size" = "xxxx";then
+   AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[struct { int foo; int bar[0]; } doo;]])],[empty_array_size="0"],[])
+  fi
+
+  if test "x$empty_array_size" = "xxxx"
+  then
+    AC_MSG_ERROR([compiler is unable to creaty empty arrays])
+  else
+    AC_DEFINE_UNQUOTED(EMPTY_ARRAY_SIZE, $empty_array_size, 
+	   [what to put between the brackets for empty arrays])
+    changequote(`,')
+    msg="[${empty_array_size}]"
+    changequote([,])
+  AC_MSG_RESULT($msg)
+  fi
+  dnl empty_array_size
+
+  if test "x$internal_vcdnav" = "xno" ; then
+    PKG_CHECK_MODULES([LIBCDIO], [libcdio >= 0.71], [], [internal_vcdnav=yes])
+    PKG_CHECK_MODULES([LIBVCDINFO], [libvcdinfo >= 0.7.23], [], [internal_vcdnav=yes])
+    if test "x$internal_vcdnav" = "xyes"; then
+       AC_MSG_RESULT([Use included libcdio/libvcdinfo support])
+    fi
+  fi
+
+  dnl check twice, fallback is internal copy
+  if test "x$internal_vcdnav" = "xno"; then
+     AC_DEFINE([HAVE_VCDNAV], [1], [Define this if you use external libcdio/libvcdinfo])
+  else
+    AC_DEFINE_UNQUOTED(HOST_ARCH, "$host_os/$host_cpu", [host os/cpu identifier])
+
+    AC_DEFINE(_DEVELOPMENT_, [], enable warnings about being development release)
+    AC_HEADER_STDC
+    AC_CHECK_HEADERS(sys/stat.h stdint.h glob.h inttypes.h stdbool.h)
+
+    if test "x$ac_cv_header_stdint_h" != "xyes" 
+     then
+       AC_CHECK_SIZEOF(int, 4)
+       AC_CHECK_SIZEOF(long, 4)
+       AC_CHECK_SIZEOF(long long, 8)
+    fi
+
+    dnl ISOC99_PRAGMA
+    AC_MSG_CHECKING([whether $CC supports ISOC99 _Pragma()])
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[_Pragma("pack(1)")]])],[
+      ISOC99_PRAGMA=yes 
+      AC_DEFINE(HAVE_ISOC99_PRAGMA, [], [Supports ISO _Pragma() macro])
+    ],[ISOC99_PRAGMA=no])
+    AC_MSG_RESULT($ISOC99_PRAGMA)
+
+    dnl
+    dnl bitfield order
+    dnl
+    AC_MSG_CHECKING([bitfield ordering in structs])
+
+    dnl basic compile test for all platforms
+    AC_COMPILE_IFELSE([
+int main() {
+  struct { char bit_0:1, bit_12:2, bit_345:3, bit_67:2; }
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+  __attribute__((packed))
+#endif
+  bf = { 1,1,1,1 };
+  switch (0) case 0: case sizeof(bf) == 1:;
+  return 0;
+}
+], [], AC_MSG_ERROR([compiler doesn't support bitfield structs]))
+
+
+    dnl run test
+    AC_RUN_IFELSE([
+int main() {
+  struct { char bit_0:1, bit_12:2, bit_345:3, bit_67:2; }
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+  __attribute__((packed))
+#endif
+  bf = { 1,1,1,1 };
+  if (sizeof (bf) != 1) return 1;
+  return *((unsigned char*) &bf) != 0x4b; }
+], bf_lsbf=1, [
+  AC_RUN_IFELSE([
+int main() {
+  struct { char bit_0:1, bit_12:2, bit_345:3, bit_67:2; }
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
+  __attribute__((packed))
+#endif
+ bf = { 1,1,1,1 };
+ if (sizeof (bf) != 1) return 1;
+ return *((unsigned char*) &bf) != 0xa5; }
+], bf_lsbf=0, AC_MSG_ERROR([unsupported bitfield ordering]))
+  ],
+  [case "$host" in
+     *-*-mingw32* | *-*-cygwin*)
+       bf_lsbf=1
+     ;;
+     *)
+       AC_MSG_RESULT([unknown])
+       AC_MSG_ERROR([value of bitfield test isn't known for $host
+*********************************************************************
+Value of bitfield test can't be found out for cross-compiling and we
+don't know its value for host "$host".
+
+Because it's needed for VCD plugin, disable VCD by configure option
+--disable-vcd or use external VCD library.
+*********************************************************************])
+  esac]
+)
+
+    if test "x$cross_compiling" = "xyes"; then
+      TEXT=" (guessed)"
+    else
+      TEXT=""
+    fi
+    if test "x$bf_lsbf" = "x1"; then
+     AC_MSG_RESULT(LSBF${TEXT})
+     AC_DEFINE(BITFIELD_LSBF, [], [compiler does lsbf in struct bitfields])
+    else
+     AC_MSG_RESULT(MSBF${TEXT})
+    fi
+
+    AC_CHECK_HEADERS([errno.h fcntl.h \
+		     stdbool.h  stdlib.h stdint.h stdio.h string.h \
+		     strings.h linux/version.h sys/cdio.h sys/stat.h \
+		     sys/types.h ])
+
+    LIBCDIO_CFLAGS='-I$(top_srcdir)/src/input/vcd/libcdio'
+    LIBCDIO_LIBS='$(top_builddir)/src/input/vcd/libcdio/libcdio.la'
+    LIBISO9660_LIBS='$(top_builddir)/src/input/vcd/libcdio/libiso9660.la'
+    LIBVCD_CFLAGS='-I$(top_srcdir)/src/input/vcd/libvcd'
+    LIBVCD_LIBS='$(top_builddir)/src/input/vcd/libvcd/libvcd.la'
+    LIBVCDINFO_LIBS='$(top_builddir)/src/input/vcd/libvcd/libvcdinfo.la'
+
+    case $host_os in
+         darwin*)
+           AC_CHECK_HEADERS(IOKit/IOKitLib.h CoreFoundation/CFBase.h, 
+                            [have_iokit_h="yes"])
+           if test "x$have_iokit_h" = "xyes" ; then 
+             AC_DEFINE([HAVE_DARWIN_CDROM], [1],
+	          [Define 1 if you have Darwin OS X-type CD-ROM support])
+           fi
+         ;;
+         linux*)
+            AC_CHECK_HEADERS(linux/version.h)
+            AC_CHECK_HEADERS(linux/cdrom.h, [have_linux_cdrom_h="yes"])
+	    if test "x$have_linux_cdrom_h" = "xyes" ; then
+	       AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[
+#include <linux/cdrom.h>
+struct cdrom_generic_command test;
+int has_timeout=sizeof(test.timeout);]])],
+                [AC_DEFINE([HAVE_LINUX_CDROM_TIMEOUT], [1], 
+                       [Define 1 if timeout is in cdrom_generic_command struct])],[])
+	       AC_DEFINE([HAVE_LINUX_CDROM], [1], 
+                       [Define 1 if you have Linux-type CD-ROM support])
+	    fi
+	 ;;
+         bsdi*)
+            AC_CHECK_HEADERS(dvd.h, [have_bsdi_dvd_h="yes"])
+	    if test "x$have_bsdi_dvd_h" = "xyes" ; then
+     	      AC_DEFINE([HAVE_BSDI_CDROM], [1], 
+                        [Define 1 if you have BSDI-type CD-ROM support])
+	    fi
+	 ;;
+         sunos*|sun*|solaris*)
+            AC_CHECK_HEADERS(sys/cdio.h)
+     	    AC_DEFINE([HAVE_SOLARIS_CDROM], [1], 
+                      [Define 1 if you have Solaris CD-ROM support])
+	 ;;
+         cygwin*)
+	    AC_DEFINE([CYGWIN], [1], 
+                      [Define 1 if you are compiling using cygwin])
+     	    AC_DEFINE([HAVE_WIN32_CDROM], [1], 
+                      [Define 1 if you have MinGW CD-ROM support])
+	    LIBCDIO_LIBS="$LIBCDIO_LIBS -lwinmm"
+	    LIBVCD_LIBS="$LIBVCD_LIBS -lwinmm"
+	 ;;
+         mingw*)
+	    AC_DEFINE([MINGW32], [1], 
+                      [Define 1 if you are compiling using MinGW])
+     	    AC_DEFINE([HAVE_WIN32_CDROM], [1], 
+                      [Define 1 if you have MinGW CD-ROM support])
+	 ;;
+         freebsd4.*|kfreebsd*-gnu)
+     	    AC_DEFINE([HAVE_FREEBSD_CDROM], [1], 
+                      [Define 1 if you have FreeBSD CD-ROM support])
+	 ;;
+         *)
+	    AC_MSG_WARN(Don't have OS CD-reading support for ${host_os}...)
+	    AC_MSG_WARN(Will use generic support.)
+	 ;;
+    esac
+    AC_SUBST(LINUX_CDROM_TIMEOUT)
+    AC_SUBST(HAVE_BSDI_CDROM)
+    AC_SUBST(HAVE_DARWIN_CDROM)
+    AC_SUBST(HAVE_FREEBSD_CDROM)
+    AC_SUBST(HAVE_LINUX_CDROM)
+    AC_SUBST(HAVE_SOLARIS_CDROM)
+    AC_SUBST(HAVE_WIN32_CDROM)
+    AC_SUBST(LINUX_CDROM_TIMEOUT)
+    AC_SUBST(LIBVCD_SYSDEP)
+
+    AC_CHECK_FUNCS( bzero memcpy )
+
+    AC_CHECK_MEMBER([struct tm.tm_gmtoff],
+                    [AC_DEFINE(HAVE_TM_GMTOFF, 1,
+                           [Define if struct tm has the tm_gmtoff member.])],
+                     ,
+                     [#include <time.h>])
+  fi
+fi
+
+AC_DEFINE([LIBCDIO_CONFIG_H], 1, [Get of rid system libcdio build configuration])
+AC_DEFINE([EXTERNAL_LIBCDIO_CONFIG_H], 1, [Get of rid system libcdio build configuration])
+AC_SUBST(LIBCDIO_CFLAGS)
+AC_SUBST(LIBCDIO_LIBS)
+AC_SUBST(LIBISO9660_LIBS)
+AC_SUBST(LIBVCD_CFLAGS)
+AC_SUBST(LIBVCD_LIBS)
+AC_SUBST(LIBVCDINFO_LIBS)
+AM_CONDITIONAL(HAVE_VCDNAV, [test "x$internal_vcdnav" = "xno"])
+AM_CONDITIONAL(ENABLE_VCD, [test "x$enable_vcd" = "xyes"])
+
+
+dnl ---------------------------------------------
+dnl ASF build can be optional
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([asf], AS_HELP_STRING([--disable-asf], [do not build ASF demuxer]))
+AM_CONDITIONAL(BUILD_ASF, test "x$enable_asf" != "xno")
+
+
+dnl ---------------------------------------------
+dnl Nosefart build can be optional
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([nosefart], AS_HELP_STRING([--disable-nosefart], [do not build nosefart player]))
+if test "x$enable_nosefart" != "xno"; then
+   AC_DEFINE([HAVE_NOSEFART], 1, [Define this if Nosefart is being built.])
+fi
+AM_CONDITIONAL(BUILD_NOSEFART, test "x$enable_nosefart" != "xno")
+
+dnl ---------------------------------------------
+dnl FAAD build can be optional
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([faad], AS_HELP_STRING([--disable-faad], [do not build FAAD decoder]))
+AC_ARG_WITH(external-libfaad, AS_HELP_STRING([--with-external-libfaad], [use external libfaad (recommended)]),
+            [external_libfaad="$withval"], [external_libfaad="yes"])
+
+have_faad=no
+if test "x$enable_faad" = "xno"; then
+  AC_MSG_RESULT([faad support disabled])
+elif test "x$with_external_libfaad" != "xno"; then
+  AC_CHECK_LIB([faad], [NeAACDecInit], [have_faad=yes])
+  if test "x$have_faad" = xyes; then 
+    AC_CHECK_HEADERS([faad.h], , [have_faad=no])
+    if test "x$have_faad" != "xyes"; then
+      AC_MSG_ERROR([Unable to find libfaad])
+    fi
+    AC_DEFINE([EXTERNAL_LIBFAAD], [1], [Define if external libfaad is used])
+  fi
+else
+  AC_MSG_RESULT([Use included libfaad])
+fi
+
+AM_CONDITIONAL(BUILD_FAAD, test "x$enable_faad" != "xno")
+AM_CONDITIONAL(EXTERNAL_LIBFAAD, test "x$have_faad" = "xyes")
+
+dnl ---------------------------------------------
+dnl Optional and external libdts
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE(dts, AS_HELP_STRING([--disable-dts], [Disable support for DTS decoding library (default: enabled)]),
+              [enable_libdts="$enableval"], [enable_libdts="yes"])
+AC_ARG_WITH(external-libdts, AS_HELP_STRING([--with-external-libdts], [use external libdts library (not recommended)]),
+            [external_libdts="$withval"], [external_libdts="no"])
+
+have_dts="no"
+
+if test "x$enable_libdts" = "xno"; then
+  AC_MSG_RESULT([libdts support disabled])
+elif test "x$external_libdts" = "xyes"; then
+  PKG_CHECK_MODULES(LIBDTS, [libdts], have_dts=yes, have_dts=no)
+  AC_CHECK_HEADERS([dts.h])
+  AC_SUBST(LIBDTS_LIBS)
+  AC_SUBST(LIBDTS_CFLAGS)
+  if test "x$have_dts" = "xno"; then
+    AC_MSG_RESULT([*** no usable version of libdts found, using internal copy ***])
+  fi
+else
+  AC_MSG_RESULT([Use included libdts support])
+fi
+
+AM_CONDITIONAL(DTS, test "x$enable_libdts" = "xyes")
+AM_CONDITIONAL(EXTERNAL_LIBDTS, test "x$have_dts" = "xyes")
+
+dnl ---------------------------------------------
+dnl libmodplug support 
+dnl ---------------------------------------------
+AC_ARG_ENABLE([modplug],
+  AS_HELP_STRING([--enable-modplug], [Enable modplug support]) )
+
+if test "x$enable_modplug" != "xno"; then
+  PKG_CHECK_MODULES([LIBMODPLUG], [libmodplug >= 0.7],
+    AC_DEFINE([HAVE_MODPLUG], 1, [define this if you have libmodplug installed]),
+    [enable_modplug=no])
+fi
+
+AC_SUBST(LIBMODPLUG_CFLAGS)
+AC_SUBST(LIBMODPLUG_LIBS)
+dnl AM_CONDITIONAL(HAVE_MODPLUG, [test "x$have_modplug" = x"yes"])
+
+dnl ---------------------------------------------
+dnl Wavpack library
+dnl ---------------------------------------------
+AC_ARG_WITH([wavpack],
+   AS_HELP_STRING([--with-wavpack], [Enable Wavpack decoder (requires libwavpack)]) )
+
+if test "x$with_wavpack" = "xyes"; then
+   PKG_CHECK_MODULES([WAVPACK], [wavpack], [have_wavpack=yes])
+fi
+
+AM_CONDITIONAL([HAVE_WAVPACK], [test "x$have_wavpack" = "xyes"])
+
+
+dnl --------------------------------------------
+dnl Real binary codecs support
+dnl --------------------------------------------
+
+AC_ARG_ENABLE([real-codecs],
+	AS_HELP_STRING([--disable-real-codecs], [Disable Real binary codecs support]))
+AC_ARG_WITH([real-codecs-path],
+	AS_HELP_STRING([--with-real-codecs-path=dir], [Specify directory for Real binary codecs]), [
+		AC_DEFINE_UNQUOTED([REAL_CODEC_PATH], ["$withval"], [Specified path for Real binary codecs])
+	])
+
+dnl On some systems, we cannot enable Real codecs support to begin with.
+dnl This includes Darwin, that uses Mach-O rather than ELF.
+case $host in
+     *-darwin*) enable_real_codecs="no" ;;
+esac
+
+if test "x$enable_real_codecs" != "xno"; then
+   dnl For those that have a replacement, break at the first one found
+   AC_CHECK_SYMBOLS([__environ _environ environ], [break], [need_weak_aliases=yes])
+   AC_CHECK_SYMBOLS([stderr __stderrp], [break], [need_weak_aliases=yes])
+
+   dnl For these there are no replacements
+   AC_CHECK_SYMBOLS([___brk_addr __ctype_b])
+
+   if test "x$need_weak_aliases" = "xyes"; then
+      CC_ATTRIBUTE_ALIAS(, [AC_MSG_ERROR([You need weak aliases support for Real codecs on your platform])])
+   fi
+fi
+
+AM_CONDITIONAL([ENABLE_REAL], [test "x$enable_real_codecs" != "xno"])
+
+dnl --------------------------------------------
+dnl mmap() support
+dnl --------------------------------------------
+
+AC_ARG_ENABLE([mmap],
+	AS_HELP_STRING([--enable-mmap], [Enable mmap() file loading (default: no)]))
+
+if test "x$enable_mmap" = "xyes"; then
+   AC_CHECK_FUNCS([mmap])
+fi
+
+dnl ---------------------------------------------
+dnl antialising support
+dnl ---------------------------------------------
+
+AC_ARG_ENABLE([antialiasing],
+     AS_HELP_STRING([--enable-antialiasing], [enable font antialiasing]))
+
+if test "x$enable_antialiasing" = "xyes"; then
+   AC_DEFINE(ENABLE_ANTIALIASING,1,[Define this to 1 to enable font antialising.])    
+fi
+
+dnl ---------------------------------------------
+dnl ip_mreqn
+dnl ---------------------------------------------
+
+AC_CHECK_IP_MREQN
+if test "x$have_ip_mreqn" = "xyes"; then
+  AC_DEFINE(HAVE_IP_MREQN,1,[Define this if you have ip_mreqn in netinet/in.h])
+fi
+
+dnl ---------------------------------------------
+dnl restrict keyword finding (from gstreamer)
+dnl ---------------------------------------------
+restrict=""
+for restrict_keyword in restrict __restrict__ __restrict; do
+  AC_MSG_CHECKING(for restrict keyword $restrict_keyword)
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[ void foo(char * $restrict_keyword p); ]])],[
+                 KEYWORD_FOUND=yes && AC_MSG_RESULT(yes) ],[
+                 KEYWORD_FOUND=no && AC_MSG_RESULT(no) ])
+  if test "x$KEYWORD_FOUND" = xyes; then
+    restrict="$restrict_keyword"
+    break
+  fi
+done
+if test "x$restrict" = x; then
+  AC_MSG_ERROR(No restrict keyword found)
+fi
+AC_DEFINE_UNQUOTED(restrict, $restrict, [restrict keyword])
+
+dnl ---------------------------------------------
+dnl ASM ALIGN is power of two ?
+dnl Used by internal FFmpeg and Planar postprocess
+dnl ---------------------------------------------
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[ asm (".align 3"); ]])],
+  AC_DEFINE([ASMALIGN_1SLN], [1], [define if '.align n' means alignment to (1<<n)-byte boundaries]),
+  :)
+AH_BOTTOM([#ifdef ASMALIGN_1SLN
+# define ASMALIGN(ZEROBITS) ".align " #ZEROBITS "\n\t"
+#else
+# define ASMALIGN(ZEROBITS) ".align 1<<" #ZEROBITS "\n\t"
+#endif
+])
+
+dnl ---------------------------------------------
+dnl Some extra checks.
+dnl ---------------------------------------------
+
+AC_SYS_LARGEFILE
+AC_CHECK_LIB(posix4, sched_get_priority_min)
+AC_CHECK_FUNCS([vsscanf sigaction sigset getpwuid_r nanosleep lstat memset readlink strchr tzset va_copy])
+AC_CHECK_FUNCS([snprintf _snprintf], [some_snprintf="yes"; break])
+AC_CHECK_FUNCS([vsnprintf _vsnprintf], [some_vsnprintf="yes"; break])
+AC_CHECK_FUNCS([strcasecmp _stricmp], [some_strcasecmp="yes"; break])
+AC_CHECK_FUNCS([strncasecmp _strnicmp], [some_strncasecmp="yes"; break])
+if test "x$some_snprintf" != "xyes" -o \
+        "x$some_vsnprintf" != "xyes" -o \
+        "x$some_strcasecmp" != "xyes" -o \
+        "x$some_strncasecmp" != "xyes"; then
+  AC_MSG_ERROR([required function not found])
+fi
+AC_FUNC_FSEEKO
+AC_CHECK_HEADERS(assert.h byteswap.h malloc.h execinfo.h ucontext.h sys/mman.h sys/mixer.h libgen.h netdb.h dirent.h sys/times.h sys/ioctl.h sys/param.h alloca.h)
+AC_REPLACE_FUNCS(asprintf basename gettimeofday setenv strcasestr strndup strpbrk strsep strtok_r timegm unsetenv memmem)
+
+AC_LIBSOURCE(hstrerror.c)
+AC_LINK_IFELSE([#include <netdb.h>
+int main(void) {
+  hstrerror(0);
+}], ac_cv_function_system_hstrerror="yes")
+AC_CHECK_LIB([resolv], [hstrerror], [
+  ac_cv_function_system_hstrerror="yes"
+  NET_LIBS="-lresolv $NET_LIBS"
+])
+AC_SUBST(NET_LIBS)
+if test "x$ac_cv_function_system_hstrerror" = "xyes"; then
+  AC_DEFINE(HAVE_HSTRERROR, 1, [Define to 1 if you have 'hstrerror' in <netdb.h>])
+
+else
+  AC_LIBOBJ(hstrerror)
+fi
+
+AC_LIBSOURCE(dirent_msvc.c)
+AC_CHECK_FUNC(opendir,
+  [AC_DEFINE(HAVE_OPENDIR, 1, [Define to 1 if you have 'opendir' function])],
+  [if test "x$SYS" = "xmingw32"; then
+    AC_LIBOBJ(dirent_msvc)
+  else
+    AC_MSG_ERROR([dirent is needed (opendir, readdir, ...)])
+  fi])
+
+XINE_CHECK_MINMAX([
+    AC_DEFINE(HAVE_MAX_MACRO, 1, [Define to 1 if you have 'MAX' macro in sys/param.h])
+    AC_DEFINE(HAVE_MIN_MACRO, 1, [Define to 1 if you have 'MIN' macro in sys/param.h])
+  ],[])
+
+dnl ---------------------------------------------
+dnl cflags and debug cflags
+dnl ---------------------------------------------
+ 
+AC_SUBST(DEBUG_CFLAGS)
+DEBUG_CFLAGS="-g -DDEBUG $CFLAGS"
+
+dnl dummy
+ASFLAGS="$ASFLAGS"
+AC_SUBST(ASFLAGS)
+
+dnl ---------------------------------------------
+dnl Check for some __attribute__ support needed
+dnl ---------------------------------------------
+
+CC_ATTRIBUTE_ALIGNED
+
+CC_ATTRIBUTE_VISIBILITY([protected], [visibility_export="protected"],
+  [CC_ATTRIBUTE_VISIBILITY([default], [visibility_export="default"])]
+)
+
+if test "x$visibility_export" != "x"; then
+  CC_FLAG_VISIBILITY([
+    AC_DEFINE([EXPORTED], [__attribute__((visibility("default")))],
+      [Mark a symbol as being exported if visibility is changed])
+    VISIBILITY_FLAG="-fvisibility=hidden"
+    ], [AC_DEFINE([EXPORTED], [], [Dummy mark as being exported])
+  ])
+else
+  AC_DEFINE([EXPORTED], [], [Dummy mark as being exported])
+fi
+
+AC_SUBST([VISIBILITY_FLAG])
+
+CC_ATTRIBUTE_SENTINEL
+CC_ATTRIBUTE_FORMAT
+CC_ATTRIBUTE_FORMAT_ARG
+CC_ATTRIBUTE_DEPRECATED
+CC_ATTRIBUTE_UNUSED
+CC_ATTRIBUTE_MALLOC
+CC_ATTRIBUTE_PACKED
+CC_ATTRIBUTE_CONST
+
+AC_OPTIMIZATIONS
+
+arch_x86="no"
+enable_armv4l="no"
+
+case "$host_or_hostalias" in
+  i?86-* | k?-* | athlon-* | pentium*-)
+    dnl enable x86 specific parts of the code
+    dnl
+    dnl all of this stuff needs gcc/gas; it uses gnu c compiler extensions
+    dnl like the extended asm() or __attribute(__cdecl__), or other direct
+    dnl mmx/sse/3dnow assembler instructions. 
+    dnl
+    AC_DEFINE_UNQUOTED(ARCH_X86_32,,[Define this if you're running x86 architecture 32 bits])
+    AC_DEFINE(FPM_INTEL,1,[Define to select libmad fixed point arithmetic implementation])
+    arch_x86="32"
+    enable_impure_text="yes"
+
+    case "$host_or_hostalias" in
+      *-*-cygwin) 
+        LIBS="$LIBS @INTLLIBS@ -lkernel32"
+        ;;
+    esac
+    ;;
+  x86_64-*)
+    AC_DEFINE_UNQUOTED(ARCH_X86_64,,[Define this if you're running x86 architecture 64 bits])
+    AC_DEFINE(FPM_64BIT,1,[Define to select libmad fixed point arithmetic implementation])
+    arch_x86="64"
+    ;;
+  powerpc-*-darwin*)
+    dnl avoid ppc compilation crash
+    AS="$CC"
+    AC_DEFINE_UNQUOTED(FPM_PPC,,[Define to select libmad fixed point arithmetic implementation])
+    AC_DEFINE_UNQUOTED(ARCH_PPC,,[Define this if you're running PowerPC architecture])
+
+    AC_CHECK_HEADER([altivec.h], , enable_altivec=no)
+    
+    if test "x$enable_altivec" != xno; then
+        AC_DEFINE_UNQUOTED(ENABLE_ALTIVEC,,[Define this if you want to use altivec on PowerPC CPUs])
+        CFLAGS="$CFLAGS -faltivec -maltivec"
+        LIBMPEG2_CFLAGS="$LIBMPEG2_CFLAGS -force_cpusubtype_ALL -faltivec -maltivec"
+    fi
+    ;;
+  ppc-*-linux* | powerpc-*) 
+    dnl avoid ppc compilation crash
+    AS="$CC"
+    AC_DEFINE_UNQUOTED(FPM_PPC,,[Define to select libmad fixed point arithmetic implementation])
+    AC_DEFINE_UNQUOTED(ARCH_PPC,,[Define this if you're running PowerPC architecture])
+
+    AC_CHECK_HEADER([altivec.h], , enable_altivec=no)
+    
+    if test "x$enable_altivec" != xno; then
+        AC_DEFINE_UNQUOTED(ENABLE_ALTIVEC,,[Define this if you have a Motorola 74xx CPU])
+        CFLAGS="$CFLAGS -maltivec"
+        LIBMPEG2_CFLAGS="$LIBMPEG2_CFLAGS -maltivec"
+    fi
+    ;;
+  sparc*-*-linux*)
+    if test "x$enable_vis" != xno; then
+      has_vis=yes
+    fi
+
+    AC_DEFINE_UNQUOTED(FPM_SPARC,,[Define to select libmad fixed point arithmetic implementation])
+    AC_DEFINE_UNQUOTED(ARCH_SPARC,,[Define this if you're running SPARC architecture])
+    ;;
+  sparc-*-solaris*)
+    if test "$GCC" = yes; then
+      case `$CC --version 2>/dev/null` in
+	1.*|2.*) ;;
+        *)
+          if test "x$enable_vis" != xno; then
+	     has_vis=yes
+          fi
+	  ;;
+      esac
+  
+      AC_DEFINE_UNQUOTED(FPM_SPARC,,[Define to select libmad fixed point arithmetic implementation])
+    else
+      AC_DEFINE_UNQUOTED(FPM_64BIT,,[Define to select libmad fixed point arithmetic implementation])
+    fi
+    AC_DEFINE_UNQUOTED(ARCH_SPARC,,[Define this if you're running SPARC architecture])
+    ;;
+  mips-*)
+    AC_DEFINE_UNQUOTED(FPM_MIPS,,[Define to select libmad fixed point arithmetic implementation])
+    ;;
+  alphaev56-* | alpha* | ia64-* | hppa*-linux-*)
+    AC_DEFINE_UNQUOTED(FPM_64BIT,,[Define to select libmad fixed point arithmetic implementation])
+    AC_DEFINE_UNQUOTED(ARCH_ALPHA,,[Define this if you're running Alpha architecture])
+    ;;
+  armv4l-*-linux*)
+    AC_DEFINE_UNQUOTED(FPM_ARM,,[Define to select libmad fixed point arithmetic implementation])
+    AC_DEFINE_UNQUOTED(ARCH_ARM,,[Define this if you're running ARM architecture])
+    enable_armv4l="yes"
+    ;;
+  *)
+    AC_DEFINE_UNQUOTED(FPM_DEFAULT,,[Define to select libmad fixed point arithmetic implementation])
+    ;;
+esac
+
+if test "x$has_vis" = "xyes"; then
+   AC_DEFINE_UNQUOTED(ENABLE_VIS,,[Define this if you have Sun UltraSPARC CPU])
+   case "$CFLAGS" in
+     *-mcpu=*) ;;
+     *) CFLAGS="$CFLAGS -mcpu=v9" ;;
+   esac
+fi
+AM_CONDITIONAL(ENABLE_VIS, test "x$has_vis" = "xyes")
+
+if test "x$arch_x86" != "xno"; then
+   AC_DEFINE_UNQUOTED(ARCH_X86,,[Define this if you're running x86 architecture])
+   AC_DEFINE_UNQUOTED(HAVE_MMX,,[Define this if you can compile MMX asm instructions])
+fi
+AM_CONDITIONAL(ARCH_X86, test "x$arch_x86" != "xno")
+AM_CONDITIONAL(ARCH_X86_32, test "x$arch_x86" = "x32")
+AM_CONDITIONAL(ARCH_X86_64, test "x$arch_x86" = "x64")
+AM_CONDITIONAL(HAVE_MMX, test "x$arch_x86" != "xno")
+
+case $host_os in
+  darwin*)
+      HOST_OS_DARWIN=1
+      AC_DEFINE_UNQUOTED(HOST_OS_DARWIN, 1, [Define this if built on Mac OS X/Darwin])
+      OBJCFLAGS="-D_INTL_REDIRECT_MACROS $OBJCFLAGS"
+        ;;
+esac
+AM_CONDITIONAL(HOST_OS_DARWIN, test "x$HOST_OS_DARWIN" = "x1")
+
+dnl ---------------------------------------------
+dnl Set IMPURE_TEXT_LDFLAGS
+dnl ---------------------------------------------
+
+IMPURE_TEXT_LDFLAGS=""
+if test "x$enable_impure_text" = xyes; then
+  case "$host_or_hostalias" in
+    *solaris*)
+      if test "$GCC" = yes; then
+        IMPURE_TEXT_LDFLAGS="-mimpure-text"
+      else
+        IMPURE_TEXT_LDFLAGS="-z textoff"
+      fi
+    ;;
+    *-darwin*)
+      IMPURE_TEXT_LDFLAGS="-Wl,-read_only_relocs,warning"
+      ;;
+  esac
+fi
+AC_SUBST(IMPURE_TEXT_LDFLAGS)
+
+dnl ---------------------------------------------
+dnl HAVE_ARMV4L is currently used in libavcodec makefile.am
+dnl ---------------------------------------------
+
+AM_CONDITIONAL(HAVE_ARMV4L, test "x$enable_armv4l" = "xyes")
+
+
+dnl ---------------------------------------------
+dnl Use features of autoconf 2.61, but stay compatible
+dnl with older versions.
+dnl ---------------------------------------------
+
+if test "x$datarootdir" = "x"; then
+   datarootdir='${datadir}'
+   AC_SUBST(datarootdir)
+fi
+
+if test "x$docdir" = "x"; then
+   docdir='${datarootdir}/doc/${PACKAGE}'
+   AC_SUBST(docdir)
+fi
+
+if test "x$htmldir" = "x"; then
+   htmldir='${docdir}'
+   AC_SUBST(htmldir)
+fi
+
+dnl ---------------------------------------------
+dnl XINE_ROOTDIR does not work if architecture independent files are 
+dnl installed to another place than architecture dependent files !!!
+dnl ---------------------------------------------
+
+if test "x$prefix" = xNONE; then
+   prefix="${ac_default_prefix}"
+fi
+if test "x$exec_prefix" = xNONE; then
+   exec_prefix='${prefix}'
+fi
+
+dnl
+dnl installation directories and directories relative to prefix
+dnl
+dnl Note:
+dnl   use AC_DEFINE for runtime
+dnl   use AC_SUBST for installation
+dnl
+
+makeexpand () {
+  local i
+  local j
+  i="$1"
+  while test "$i" != "$j"; do j="$i"; eval i="$j"; done
+  echo "$i"
+}
+
+xinelibdir='${libdir}/xine'
+xinedatadir='${datadir}/xine'
+pkgconfigdir='${libdir}/pkgconfig'
+AC_SUBST(xinelibdir)
+AC_SUBST(xinedatadir)
+AC_SUBST(pkgconfigdir)
+
+XINE_PLUGINROOT="\${xinelibdir}/plugins/$(($XINE_LT_CURRENT-$XINE_LT_AGE))"
+XINE_PLUGINDIR="$XINE_PLUGINROOT.$XINE_LT_AGE"
+XINE_FONTDIR="\${xinedatadir}/libxine$XINE_MAJOR/fonts"
+XINE_LOCALEDIR='${datadir}/locale'
+XINE_REL_PLUGINROOT="`makeexpand "$XINE_PLUGINROOT"`"
+XINE_REL_PLUGINROOT="`makeexpand "$XINE_REL_PLUGINROOT" | sed -e "s,^${prefix}/,,"`"
+XINE_REL_PLUGINDIR="$XINE_REL_PLUGINROOT.$XINE_LT_AGE"
+XINE_REL_FONTDIR="`makeexpand "$XINE_FONTDIR" | sed -e "s,^${prefix}/,,"`"
+XINE_REL_LOCALEDIR="`makeexpand "$XINE_LOCALEDIR" | sed -e "s,^${prefix}/,,"`"
+XINE_PKGCONFIG_DIR="`makeexpand "$pkgconfigdir"`"
+if test "x$SYS" = "xmingw32" -o "x$SYS" = "xcygwin"; then
+  dnl prefix in xine-config
+  XINE_CONFIG_PREFIX="\$(cd \$(dirname \$0)/..; pwd)"
+  dnl installation directories (in xine-config)
+  XINE_PLUGINROOTPATH="$XINE_CONFIG_PREFIX/$XINE_REL_PLUGINROOT"
+  XINE_PLUGINPATH="$XINE_PLUGINROOTPATH.$XINE_LT_AGE"
+  XINE_FONTPATH="$XINE_CONFIG_PREFIX/$XINE_REL_FONTDIR"
+  XINE_LOCALEPATH="$XINE_CONFIG_PREFIX/$XINE_REL_LOCALEDIR"
+  dnl runtime directories
+  AC_DEFINE(XINE_PLUGINROOT,[xine_get_pluginroot()],[Define this to general plugins directory location])
+  AC_DEFINE(XINE_PLUGINDIR,[xine_get_plugindir()],[Define this to specific plugins directory location])
+  AC_DEFINE(XINE_FONTDIR,[xine_get_fontdir()],[Define this to osd fonts dir location])
+  AC_DEFINE(XINE_LOCALEDIR,[xine_get_localedir()],[Path where catalog files will be.])
+else
+  dnl prefix in xine-config
+  XINE_CONFIG_PREFIX="`makeexpand "${prefix}"`"
+  dnl directories from xine-config and runtime directories
+  XINE_PLUGINROOTPATH="`makeexpand "$XINE_PLUGINROOT"`"
+  XINE_PLUGINPATH="$XINE_PLUGINROOTPATH.$XINE_LT_AGE"
+  XINE_FONTPATH="`makeexpand "$XINE_FONTDIR"`"
+  XINE_LOCALEPATH="`makeexpand "$XINE_LOCALEDIR"`"
+  dnl defining runtime directories
+  AC_DEFINE_UNQUOTED(XINE_PLUGINROOT,"$XINE_PLUGINROOTPATH",[Define this to general plugins directory location])
+  AC_DEFINE_UNQUOTED(XINE_PLUGINDIR,"$XINE_PLUGINPATH",[Define this to specific plugins directory location])
+  AC_DEFINE_UNQUOTED(XINE_FONTDIR,"$XINE_FONTPATH",[Define this to osd fonts dir location])
+  AC_DEFINE_UNQUOTED(XINE_LOCALEDIR, "$XINE_LOCALEPATH",[Path where catalog files will be.])
+fi
+AC_DEFINE_UNQUOTED(XINE_REL_PLUGINDIR,"$XINE_REL_PLUGINDIR",[Define this to specific plugin directory relative to execution prefix])
+AC_DEFINE_UNQUOTED(XINE_REL_PLUGINROOT,"$XINE_REL_PLUGINROOT",[Define this to general plugin directory relative to execution prefix])
+AC_DEFINE_UNQUOTED(XINE_REL_FONTDIR,"$XINE_REL_FONTDIR",[Define this to font directory relative to prefix])
+AC_DEFINE_UNQUOTED(XINE_REL_LOCALEDIR,"$XINE_REL_LOCALEDIR",[Define this to font directory relative to prefix])
+AC_SUBST(XINE_CONFIG_PREFIX)
+AC_SUBST(XINE_PLUGINPATH)
+AC_SUBST(XINE_FONTPATH)
+AC_SUBST(XINE_LOCALEPATH)
+AC_SUBST(XINE_PLUGINDIR)
+AC_SUBST(XINE_FONTDIR)
+AC_SUBST(XINE_LOCALEDIR)
+AC_SUBST(XINE_PKGCONFIG_DIR)
+
+dnl Where aclocal m4 files should be installed
+XINE_ACFLAGS="-I ${datarootdir}/aclocal"
+AC_DEFINE_UNQUOTED(XINE_ACFLAGS, "$XINE_ACFLAGS", [Path where aclocal m4 files will be.])
+AC_SUBST(XINE_ACFLAGS)
+
+dnl Where architecture independent data (e.g. logo) will/should be installed
+XINE_DATADIR="\${xinedatadir}"
+AC_SUBST(XINE_DATADIR)
+
+dnl Where scripts will/should be installed.
+XINE_SCRIPTPATH="\${xinedatadir}/scripts"
+AC_SUBST(XINE_SCRIPTPATH)
+
+
+dnl ---------------------------------------------
+dnl Some informations about xine-lib compilation
+dnl ---------------------------------------------
+
+XINE_BUILD_CC="`$CC -v 2>&1 | tail -1 2>/dev/null`"
+XINE_BUILD_OS="`uname -s -r -m`"
+XINE_BUILD_DATE="`date \"+%a %d %b %Y %T\"`"
+AC_SUBST(XINE_BUILD_CC)
+AC_SUBST(XINE_BUILD_OS)
+AC_SUBST(XINE_BUILD_DATE)
+
+
+dnl ---------------------------------------------
+dnl For win32 libraries location, needed by libw32dll.
+dnl ---------------------------------------------
+
+AC_ARG_WITH([w32-path],
+  AS_HELP_STRING([--with-w32-path=path], [location of Win32 binary codecs]),
+  [w32_path="$withval"], [w32_path="/usr/lib/codecs"])
+AC_SUBST(w32_path)
+
+AC_ARG_ENABLE([w32dll],
+  AS_HELP_STRING([--disable-w32dll], [Disable Win32 DLL support]),
+  , [enable_w32dll=$with_gnu_as])
+
+case $host in
+   *-mingw* | *-cygwin)
+     enable_w32dll="no" ;;
+   i?86-* | k?-* | athlon-* | pentium*-)
+     if test "x$enable_w32dll" != "xno"; then
+	CC_PROG_AS
+     fi
+     test "x$enable_w32dll" = "x" && \
+       enable_w32dll="$with_gnu_as"
+     ;;
+   *)
+     enable_w32dll="no" ;;
+esac
+
+if test "x$enable_w32dll" = "xyes" && \
+   test "x$with_gnu_as" = "xno"; then
+
+   AC_MSG_ERROR([You need GNU as to enable Win32 codecs support])
+fi
+
+AM_CONDITIONAL(HAVE_W32DLL, test "x$enable_w32dll" != "xno")
+
+
+dnl ---------------------------------------------
+dnl some include paths ( !!! DO NOT REMOVE !!! )
+dnl ---------------------------------------------
+
+INCLUDES='-I$(top_srcdir) -I$(top_builddir)/include -I$(top_srcdir)/include -I$(top_srcdir)/src -I$(top_builddir)/src/xine-engine -I$(top_srcdir)/src/xine-engine -I$(top_srcdir)/src/xine-utils $(INTLDIR) -I$(top_builddir)/src/input -I$(top_srcdir)/src/input $(WIN32_CPPFLAGS) -I$(top_builddir)/lib -I$(top_srcdir)/lib'
+AC_SUBST(INCLUDES)
+
+
+dnl ---------------------------------------------
+dnl Get where .m4 should be installed.
+dnl ---------------------------------------------
+
+dnl if test "x${ACLOCAL_DIR+set}" != xset; then
+dnl   case "`id`" in
+dnl     uid=0\(* )
+dnl       AC_MSG_CHECKING(for aclocal directory)
+dnl       if (aclocal --version) < /dev/null > /dev/null 2>&1; then
+dnl         ACLOCAL_DIR="`eval $ACLOCAL --print-ac-dir`"
+dnl         AC_MSG_RESULT($ACLOCAL_DIR)
+dnl       else
+dnl         ACLOCAL_DIR="${prefix}/share/aclocal"
+dnl         AC_MSG_RESULT(none - will be installed in $ACLOCAL_DIR)
+dnl       fi
+dnl       escapedprefix="`echo $prefix | sed -e 's/\\//\\\\\//g'`"
+dnl       ACLOCAL_DIR="`echo $ACLOCAL_DIR|sed -e 's/^'$escapedprefix/'\${prefix}'/`"
+dnl       ;;
+dnl   esac
+dnl fi
+AC_SUBST(ACLOCAL_DIR)
+AM_CONDITIONAL([INSTALL_M4],[test "x$ACLOCAL_DIR" != "x"])
+
+
+dnl ---------------------------------------------
+dnl It seems automake 1.5 don't take care about this script
+dnl ---------------------------------------------
+
+if test ! -z "$am_depcomp"; then
+	DEPCOMP="depcomp"
+fi
+AC_SUBST(DEPCOMP)
+
+
+dnl ---------------------------------------------
+dnl Check for documentation formatting tool
+dnl ---------------------------------------------
+
+AC_CHECK_PROG(SGMLTOOLS, sgmltools, sgmltools, no)
+AM_CONDITIONAL([HAVE_SGMLTOOLS], [test "$SGMLTOOLS" != "no"])
+
+AC_CHECK_PROG(FIG2DEV, fig2dev, fig2dev, no)
+AM_CONDITIONAL([HAVE_FIG2DEV], [test "$FIG2DEV" != "no"])
+
+dnl ---------------------------------------------
+dnl Newest automake workaround
+dnl ---------------------------------------------
+
+AC_SUBST(mkdir_p)
+if test -n "$ac_aux_dir"; then
+  case "$ac_aux_dir" in
+    /*) MKINSTALLDIRS="$ac_aux_dir/install-sh -d" ;;
+    *) MKINSTALLDIRS="\$(top_builddir)/$ac_aux_dir/install-sh -d" ;;
+  esac
+else
+  MKINSTALLDIRS="\$(top_srcdir)/install-sh -d"
+fi
+AC_SUBST(MKINSTALLDIRS)
+
+dnl this is an internal function we should not use, but
+dnl as long as neither autoconf nor automake offer an A[CM]_PROG_OBJC
+dnl check we will have to call it
+_AM_DEPENDENCIES([OBJC])
+
+AM_CONDITIONAL([BUILD_DMX_IMAGE], [test "x$have_imagemagick" = "xyes" -o "x$no_gdkpixbuf" != "xyes"])
+
+dnl We check for warnings here rather than with optimisations since we
+dnl want them to be _always_ enabled, to make sure the code is sane
+dnl enough.
+
+CC_CHECK_CFLAGS_APPEND([-Wall -Wchar-subscripts dnl
+			-Wnested-externs -Wcast-align dnl
+			-Wmissing-declarations -Wmissing-prototypes dnl
+			-Wmissing-format-attribute -Wno-pointer-sign])
+
+CC_CHECK_CFLAGS_APPEND([-Wformat=2 -Wformat],
+  [CC_CHECK_CFLAGS_APPEND([-Wno-format-zero-length])
+   break;
+  ])
+
+dnl check for strict aliasing problem, get the highest between =2 and
+dnl normal.
+CC_CHECK_CFLAGS_APPEND([-Wstrict-aliasing=2 -Wstrict-aliasing], [break;])
+
+dnl This *has* to stay at the end as it can break some autoconf tests.
+CC_CHECK_CFLAGS_APPEND([-Werror=implicit-function-declaration dnl
+                        -Werror-implicit-function-declaration], [break;])
+
+CC_NOUNDEFINED
+
+dnl signal FreeBSD have also FreeBSD based kernel.
+dnl 
+
+AH_BOTTOM([
+#if defined (__FreeBSD__) && !defined (__FreeBSD_kernel__)
+#define __FreeBSD_kernel__ __FreeBSD__
+#endif
+
+#if defined (__FreeBSD_kernel__)
+#include <sys/param.h>
+# if defined (__FreeBSD_version) && !defined (__FreeBSD_kernel_version)
+# define __FreeBSD_kernel_version __FreeBSD_version
+# endif
+#endif
+])
+
+
+dnl Common cflags for all platforms
+CFLAGS="-D_REENTRANT -D_FILE_OFFSET_BITS=64 -DXINE_COMPILE \$(MULTIPASS_CFLAGS) $CFLAGS"
+DEBUG_CFLAGS="-D_REENTRANT -D_FILE_OFFSET_BITS=64 -DXINE_COMPILE $DEBUG_CFLAGS"
+
+if test "x$enable_debug" = "xyes"; then
+   CFLAGS="$CFLAGS -DDEBUG"
+else
+   CFLAGS="$CFLAGS -DNDEBUG"
+fi
+
+dnl ---------------------------------------------
+dnl Output configuration files
+dnl ---------------------------------------------
+
+AC_CONFIG_FILES([
+Makefile
+doc/Makefile
+doc/man/Makefile
+doc/man/en/Makefile
+doc/hackersguide/Makefile
+doc/faq/Makefile
+include/Makefile
+include/xine.h
+lib/Makefile
+m4/Makefile
+misc/Makefile
+misc/SlackBuild
+misc/build_rpms.sh
+misc/fonts/Makefile
+misc/libxine.pc
+misc/relchk.sh
+misc/xine-config
+misc/xine-lib.spec
+po/Makevars.extra
+po/Makefile.in
+src/Makefile
+src/audio_out/Makefile
+src/combined/Makefile
+src/combined/ffmpeg/Makefile
+src/demuxers/Makefile
+src/dxr3/Makefile
+src/input/Makefile
+src/input/libdvdnav/Makefile
+src/input/dvb/Makefile
+src/input/librtsp/Makefile
+src/input/libreal/Makefile
+src/input/vcd/Makefile
+src/input/vcd/libcdio/Makefile
+src/input/vcd/libcdio/cdio/Makefile
+src/input/vcd/libcdio/MSWindows/Makefile
+src/input/vcd/libcdio/image/Makefile
+src/input/vcd/libvcd/Makefile
+src/input/vcd/libvcd/libvcd/Makefile
+src/liba52/Makefile
+src/libdts/Makefile
+src/libfaad/Makefile
+src/libfaad/codebook/Makefile
+src/libffmpeg/Makefile
+src/libffmpeg/libavcodec/Makefile
+src/libffmpeg/libavcodec/armv4l/Makefile
+src/libffmpeg/libavcodec/i386/Makefile
+src/libffmpeg/libavcodec/mlib/Makefile
+src/libffmpeg/libavcodec/alpha/Makefile
+src/libffmpeg/libavcodec/ppc/Makefile
+src/libffmpeg/libavcodec/sparc/Makefile
+src/libffmpeg/libavcodec/libpostproc/Makefile
+src/libffmpeg/libavutil/Makefile
+src/libmad/Makefile
+src/libmpeg2/Makefile
+src/libmusepack/Makefile
+src/libmusepack/musepack/Makefile
+src/libspudec/Makefile
+src/libspucc/Makefile
+src/libspucmml/Makefile
+src/libspudvb/Makefile
+src/libsputext/Makefile
+src/libw32dll/Makefile
+src/libw32dll/wine/Makefile
+src/libw32dll/DirectShow/Makefile
+src/libw32dll/dmo/Makefile
+src/libw32dll/qtx/Makefile
+src/libw32dll/qtx/qtxsdk/Makefile
+src/libxinevdec/Makefile
+src/libxineadec/Makefile
+src/libxineadec/gsm610/Makefile
+src/libxineadec/nosefart/Makefile
+src/libreal/Makefile
+src/post/Makefile
+src/post/planar/Makefile
+src/post/goom/Makefile
+src/post/mosaico/Makefile
+src/post/visualizations/Makefile
+src/post/audio/Makefile
+src/post/deinterlace/Makefile
+src/post/deinterlace/plugins/Makefile
+src/video_out/Makefile
+src/video_out/libdha/Makefile
+src/video_out/libdha/bin/Makefile
+src/video_out/libdha/kernelhelper/Makefile
+src/video_out/libdha/oth/Makefile
+src/video_out/libdha/sysdep/Makefile
+src/video_out/macosx/Makefile
+src/video_out/vidix/Makefile
+src/video_out/vidix/drivers/Makefile
+src/xine-utils/Makefile
+src/xine-engine/Makefile
+win32/Makefile
+win32/include/Makefile])
+AC_CONFIG_COMMANDS([default],[[chmod +x ./misc/SlackBuild ./misc/build_rpms.sh ./misc/relchk.sh]],[[]])
+AC_OUTPUT
+
+dnl Guard against multiple inclusion
+AH_TOP([#ifndef _XINE_CONFIGURE_H_
+#define _XINE_CONFIGURE_H_
+])
+AH_BOTTOM([#endif
+])
+
+dnl ---------------------------------------------
+dnl Work around a suspected bug in libtool:
+dnl
+dnl Remove excessive trailing slash from search dir names in the libtool script.
+dnl It occurs in dir names obtained by 'gcc -print-search-dirs' in the created
+dnl configure script and causes a test on dir names in libtool to fail,
+dnl leading to confusing (but harmless) 'warning: <lib> seems to be moved'.
+dnl
+dnl This should be fixed in the libtool package itself as all other dir names
+dnl there have no trailing slash.
+dnl ---------------------------------------------
+
+dnl Note: Brackets [] must be doubled as they are treated as m4 macro quotes.
+cat libtool | sed -e '/sys_lib_search_path_spec=/s/\/\([[ "]]\)/\1/g' > libtool.tmp
+mv -f libtool.tmp libtool
+chmod +x libtool
+
+dnl ---------------------------------------------
+dnl Some infos:
+dnl ---------------------------------------------
+
+echo "xine-lib summary:"
+echo "----------------"
+
+dnl Input
+echo " * input plugins:"
+echo "   - file          - net"
+echo "   - stdin_fifo    - rtp"
+echo "   - http          - mms"
+echo "   - pnm           - rtsp"
+echo "   - dvb"
+if test "x$external_dvdnav" = "xyes"; then
+  echo "   - dvd (external libs)"
+else
+  echo "   - dvd (internal libs)"
+fi
+if test "x$have_cdrom_ioctls" = "xyes"; then
+  if test "x$enable_vcd" = "xyes"; then
+    if test "x$internal_vcdnav" = "xno"; then
+      echo "   - vcd (external libs)"
+    else
+      echo "   - vcd (internal libs)"
+    fi
+  fi
+  echo "   - vcdo"
+  echo "   - cdda"
+fi
+if test "x$no_gnome_vfs" = "xno"; then
+  echo "   - gnome-vfs"
+fi
+if test "x$have_v4l" = "xyes"; then
+  echo "   - v4l"
+fi
+if test "x$have_libsmbclient" = "xyes"; then
+  echo "   - smbclient"
+fi
+echo ""
+
+dnl Demuxers
+echo " * demultiplexer plugins:"
+echo "   - avi           - mpeg"
+echo "   - mpeg_block    - mpeg_audio"
+echo "   - mpeg_elem     - mpeg_pes"
+echo "   - mpeg_ts       - qt/mpeg-4"
+echo "   - film          - roq"
+echo "   - fli           - smjpeg"
+echo "   - idcin         - wav"
+echo "   - wc3 mve       - voc"
+echo "   - vqa           - aiff"
+echo "   - cdda          - snd/au"
+echo "   - yuv4mpeg2     - real/realaudio"
+echo "   - ea wve        - raw dv"
+echo "   - interplay mve - psx str"
+echo "   - ws aud        - pva"
+echo "   - vox"
+echo "   - nsv           - 4xm"
+echo "   - FLAC          - aac"
+echo "   - iff           - matroska"
+echo "   - vmd           - flv"
+if test "x$enable_asf" = "xyes"; then
+  echo "   - asf"
+fi
+if test "x$enable_nosefart" != "xno"; then
+  echo "   - nsf"
+fi
+if test "x$have_vorbis" = "xyes"; then
+  echo "   - ogg"
+fi
+if test "x$have_libmng" = "xyes"; then
+  echo "   - mng"
+fi
+if test "x$enable_modplug" != x"no"; then
+  echo "   - mod"
+fi
+if test "x$have_libflac" = "xyes"; then
+  echo "   - FLAC (with libFLAC)"
+fi
+if test "x$have_wavpack" = "xyes"; then
+  echo "   - WavPack"
+fi
+if test "x$enable_a52dec" = "xyes"; then
+  if test "x$have_a52" = "xyes"; then
+    echo "   - ac3 (external library)"
+  else
+    echo "   - ac3 (internal library)"
+  fi
+fi
+echo ""
+
+dnl video decoders
+echo " * video decoder plugins:"
+echo "   - MPEG 1,2         - Amiga Bitplane"
+echo "   - Raw RGB          - Raw YUV"
+if test "x$with_external_ffmpeg" = "xyes"; then
+  echo "   - ffmpeg (external library):"
+else
+  echo "   - ffmpeg (internal library):"
+fi
+echo "     - MPEG-4 (ISO, Microsoft, DivX*, XviD)"
+echo "     - Creative YUV    - Motion JPEG"
+echo "     - Cinepak         - MS Video-1"
+echo "     - FLI/FLC         - MS RLE"
+echo "     - Id RoQ          - Id Cin"
+echo "     - Apple Graphics  - Apple Video"
+echo "     - Apple Animation - Interplay Video"
+echo "     - Westwood VQA    - Origin Xan"
+echo "     - H.263           - Intel Indeo 3"
+echo "     - SVQ1            - SVQ3"
+echo "     - Real Video 1.0  - Real Video 2.0"
+echo "     - 4X Video        - Sierra Video"
+echo "     - Asus v1/v2      - HuffYUV"
+echo "     - On2 VP3         - DV"
+echo "     - 8BPS            - Duck TrueMotion v1"
+echo "     - ATI VCR1        - Flash Video"
+echo "     - ZLIB            - MSZH"
+if test "x$have_dxr3" = "xyes"; then
+  echo "   - dxr3_video"
+fi
+if test "x$enable_w32dll" = "xyes"; then
+  echo "   - w32dll"
+fi
+if test "x$have_imagemagick" = "xyes"; then
+  echo "   - image"
+fi
+if test x"no_gdkpixbuf" != "xyes"; then
+  echo "   - gdk-pixbuf"
+fi
+if test "x$have_theora" = "xyes"; then
+  echo "   - theora"
+fi
+echo ""
+
+dnl audio decoders
+echo " * audio decoder plugins:"
+echo "   - GSM 06.10       - linear PCM"
+if test "x$with_external_ffmpeg" = "xyes"; then
+  echo "   - ffmpeg (external library):"
+else
+  echo "   - ffmpeg (internal library):"
+fi
+echo "     - Windows Media Audio v1/v2"
+echo "     - DV            - logarithmic PCM"
+echo "     - 14k4          - 28k8"
+echo "     - MS ADPCM      - IMA ADPCM"
+echo "     - XA ADPCM      - Game DPCM/ADPCM"
+echo "     - Mace 3:13     - Mace 6:1"
+echo "     - FLAC"
+if test "x$enable_nosefart" != "xno"; then
+  echo "   - Nosefart (NSF)"
+fi
+if test "x$have_libflac" = "xyes"; then
+  echo "   - FLAC (with libFLAC)"
+fi
+if test "x$have_vorbis" = "xyes"; then
+  echo "   - vorbis"
+fi
+if test "x$have_speex" = "xyes"; then
+  echo "   - speex"
+fi
+if test "x$enable_w32dll" = "xyes"; then
+  echo "   - w32dll"
+fi
+if test "x$enable_faad" = "xyes"; then
+  echo "   - faad"
+fi
+if test "x$enable_libmad" = "xyes"; then
+  if test "x$have_mad" = "xyes"; then
+    echo "   - MAD (MPG 1/2/3) (external library)"
+  else
+    echo "   - MAD (MPG 1/2/3) (internal library)"
+  fi
+fi
+if test "x$enable_libdts" = "xyes"; then
+  if test "x$have_dts" = "xyes"; then
+    echo "   - DTS (external library)"
+  else
+    echo "   - DTS (internal library)"
+  fi
+fi
+if test "x$enable_a52dec" = "xyes"; then
+  if test "x$have_a52" = "xyes"; then
+    echo "   - A52/ra-dnet (external library)"
+  else
+    echo "   - A52/ra-dnet (internal library)"
+  fi
+fi
+if test "x$enable_musepack" != "xno"; then
+  if test "x$have_mpcdec" = "xyes"; then
+    echo "   - MusePack (external library)"
+  else
+    echo "   - MusePack (internal library)"
+  fi
+fi
+if test "x$have_wavpack" = "xyes"; then
+  echo "   - WavPack"
+fi
+echo ""
+
+dnl spu decoders
+echo " * subtitle decoder plugins:"
+echo "   - spu             - spucc"
+echo "   - spucmml         - sputext"
+echo "   - spudvb"
+if test "x$have_dxr3" = "xyes"; then
+  echo "   - dxr3_spu"
+fi
+echo ""
+
+dnl post plugins
+echo " * post effect plugins:"
+echo "  * planar video effects:"
+echo "   - invert          - expand"
+echo "   - eq              - eq2"
+echo "   - boxblur         - denoise3d"
+echo "   - unsharp         - tvtime"
+echo "  * SFX:"
+echo "   - goom            - oscope"
+echo "   - fftscope        - mosaico"
+echo ""
+
+dnl Video plugins
+echo " * video driver plugins:"
+if test "x$no_x" != "xyes"; then
+  echo "   - XShm (X11 shared memory)"
+  dnl synfb
+  if test "x$enable_syncfb" != "xno"; then
+    echo "   - SyncFB (for Matrox G200/G400 cards)"
+  fi
+  dnl Xv
+  if test "x$ac_have_xv" = "xyes"; then
+    if test "x$ac_have_xv_static" = "xyes"; then
+      echo "   - Xv (XVideo *static*)"
+    else
+      echo "   - Xv (XVideo *shared*)"
+    fi
+  fi
+  dnl XxMC
+  if test "x$ac_have_xxmc" = "xyes"; then
+    if test "x$ac_have_vldxvmc_h" = "xyes"; then
+      echo "   - XxMC (XVideo extended motion compensation)"
+    else
+      echo "   - XxMC (XVideo motion compensation - vld extensions DISABLED)"
+    fi
+  fi
+  dnl XvMC
+  if test "x$ac_have_xvmc" = "xyes"; then
+    echo "   - XvMC (XVideo motion compensation)"
+  fi
+  if test "x$ac_have_opengl" = "xyes" -a "x$ac_have_glut" = "xyes" -o \
+	  "x$ac_have_opengl" = "xyes" -a "x$ac_have_glu" = "xyes"; then	
+    echo "   - OpenGL"
+  fi
+  if test "x$ac_have_sunfb" = "xyes"; then
+    if test "x$ac_have_sundga" = "xyes"; then
+      echo "   - PGX64 (for Sun XVR100/PGX64/PGX24 cards)"
+      echo "   - PGX32 (for Sun PGX32 cards)"
+    fi
+  fi
+fi
+if test "x$have_xcb" = "xyes"; then
+  dnl xcb-shm
+  if test "x$have_xcbshm" = "xyes"; then
+    echo "   - xcb-shm (X shared memory using XCB)"
+  fi
+  dnl xcb-xv
+  if test "x$have_xcbxv" = "xyes"; then
+    echo "   - xcb-xv (XVideo using XCB)"
+  fi
+fi
+if test "x$no_aalib" != "xyes"; then
+  echo "   - aa (Ascii ART)"
+fi
+if test "x$have_caca" = "xyes"; then
+  echo "   - caca (Color AsCii Art)"
+fi
+if test "x$have_fb" = "xyes"; then
+  echo "   - fb (Linux framebuffer device)"
+fi
+if test "x$have_sdl" = "xyes"; then
+  echo "   - sdl (Simple DirectMedia Layer)"
+fi
+if test "x$have_libstk" = "xyes"; then
+  echo "   - stk (Libstk Set-top Toolkit)"
+fi
+if test "x$have_directfb" = "xyes"; then
+  echo "   - directfb (DirectFB driver)"
+fi
+if test "x$have_dxr3" = "xyes"; then
+  if test "x$have_encoder" = "xyes"; then
+    echo "   - dxr3 (Hollywood+ and Creative dxr3, both mpeg and non-mpeg video)"
+  else
+    echo "   - dxr3 (Hollywood+ and Creative dxr3, mpeg video only)"
+  fi
+fi
+if test "x$enable_vidix" = "xyes"; then
+  echo $ECHO_N "   - vidix ("
+  
+  if test "x$no_x" != "xyes"; then
+    echo $ECHO_N "X11"
+    if test "x$have_fb" = "xyes"; then
+      echo $ECHO_N " and "
+    fi
+  fi
+    
+  if test "x$have_fb" = "xyes"; then
+      echo $ECHO_N "framebuffer"
+  fi
+  
+  echo $ECHO_N " support"
+
+  if test "x$enable_dha_kmod" = "xyes"; then
+    echo " with dhahelper)"
+  else
+    echo ")"
+  fi
+fi
+if test "x$have_directx" = "xyes"; then
+  echo "   - directx (DirectX video driver)"
+fi
+if test "x$have_macosx_video" = "xyes"; then
+  echo "   - Mac OS X OpenGL"
+fi
+
+echo ""
+
+dnl Audio plugins
+echo " * audio driver plugins:"
+if test "x$have_ossaudio" = "xyes"; then
+  echo "   - oss (Open Sound System)"
+fi
+if test "x$have_alsa" = "xyes"; then
+  echo "   - alsa"
+fi
+if test "x$have_esound" = "xyes"; then
+  echo "   - esd (Enlightened Sound Daemon)"
+fi
+if test "x$no_arts" != "xyes"; then
+  echo "   - arts (aRts - KDE soundserver)"
+fi
+if test "x$no_fusionsound" != "xyes"; then
+  echo "   - fusionsound (FusionSound driver)"
+fi
+if test "x$have_sunaudio" = "xyes"; then
+  echo "   - sun ()"
+fi
+if test "x$am_cv_have_irixal" = xyes; then
+  echo "   - irixal (Irix audio library)"
+fi
+if test "x$have_directx" = "xyes"; then
+  echo "   - directx (DirectX audio driver)"
+fi
+if test "x$have_coreaudio" = "xyes"; then
+  echo "   - CoreAudio (Mac OS X audio driver)"
+fi  
+if test "x$have_pulseaudio" = "xyes"; then
+  echo "   - pulseaudio sound server"
+fi
+if test "x$have_jack" = "xyes"; then
+  echo "   - Jack"
+fi
+echo "---"
+
+
+dnl ---------------------------------------------
+dnl some user warnings
+dnl ---------------------------------------------
+
+dnl some levels of variable expansion to get final install paths
+final_libdir="`eval eval eval eval echo $libdir`"
+final_bindir="`eval eval eval eval echo $bindir`"
+
+if test -r /etc/ld.so.conf && ! grep -x "$final_libdir" /etc/ld.so.conf >/dev/null ; then
+  if test "$final_libdir" != "/lib" -a "$final_libdir" != "/usr/lib" ; then
+    if ! echo "$LD_LIBRARY_PATH" | egrep "(:|^)$final_libdir(/?:|/?$)" >/dev/null ; then
+      echo
+      echo "****************************************************************"
+      echo "xine-lib will be installed to $final_libdir"
+      echo
+      echo "This path is not mentioned among the linker search paths in your"
+      echo "/etc/ld.so.conf. This means it is possible that xine-lib will"
+      echo "not be found when you try to compile or run a program using it."
+      echo "If this happens, you should add $final_libdir to"
+      echo "the environment variable LD_LIBRARY_PATH like that:"
+      echo
+      echo "export LD_LIBRARY_PATH=$final_libdir:\$LD_LIBRARY_PATH"
+      echo
+      echo "Alternatively you can add a line \"$final_libdir\""
+      echo "to your /etc/ld.so.conf."
+      echo "****************************************************************"
+      echo
+    fi
+  fi
+fi
+
+if ! echo "$PATH" | egrep "(:|^)$final_bindir(/?:|/?$)" >/dev/null ; then
+  echo
+  echo "****************************************************************"
+  echo "xine-config will be installed to $final_bindir"
+  echo
+  echo "This path is not in your search path. This means it is possible"
+  echo "that xine-config will not be found when you try to compile a"
+  echo "program using xine-lib. This will result in build failures."
+  echo "If this happens, you should add $final_bindir to"
+  echo "the environment variable PATH like that:"
+  echo
+  echo "export PATH=$final_bindir:\$PATH"
+  echo
+  echo "Note that this is only needed for compilation. It is not needed"
+  echo "to have xine-config in your search path at runtime. (Although"
+  echo "it will not cause any harm either.)"
+  echo "****************************************************************"
+  echo
+fi
+
+dnl warn if no X11 plugins will be built
+if test "x$no_x" = "xyes"; then
+  case $host in
+    *mingw*|*-cygwin) ;;
+    *-darwin*) ;;
+    *)
+      echo
+      echo "****************************************************************"
+      echo "WARNING! No X11 output plugins will be built."
+      echo
+      echo "For some reason, the requirements for building the X11 video"
+      echo "output plugins are not met. That means, that you will NOT be"
+      echo "able to use the resulting xine-lib to watch videos in a window"
+      echo "on any X11-based display (e.g. your desktop)."
+      echo
+      echo "If this is not what you want, provide the necessary X11 build"
+      echo "dependencies (usually done by installing a package called"
+      echo "XFree86-devel or similar) and run configure again."
+      echo "****************************************************************"
+      echo
+      ;;
+  esac
+fi
diff -Naur xine-lib-1.1.16.1-old/include/xine.h.in xine-lib-1.1.16.1-new/include/xine.h.in
--- xine-lib-1.1.16.1-old/include/xine.h.in	2009-01-11 12:54:19.000000000 -0800
+++ xine-lib-1.1.16.1-new/include/xine.h.in	2009-01-19 18:50:51.000000000 -0800
@@ -375,6 +375,8 @@
 #define XINE_PARAM_VO_TVMODE               0x0100000a /* ???                */
 #define XINE_PARAM_VO_WINDOW_WIDTH         0x0100000f /* readonly           */
 #define XINE_PARAM_VO_WINDOW_HEIGHT        0x01000010 /* readonly           */
+#define XINE_PARAM_VO_SHARPNESS            0x01000018 /* 0..65535           */
+#define XINE_PARAM_VO_NOISE_REDUCTION      0x01000019 /* 0..65535           */
 #define XINE_PARAM_VO_CROP_LEFT            0x01000020 /* crop frame pixels  */
 #define XINE_PARAM_VO_CROP_RIGHT           0x01000021 /* crop frame pixels  */
 #define XINE_PARAM_VO_CROP_TOP             0x01000022 /* crop frame pixels  */
@@ -482,6 +484,7 @@
 #define XINE_IMGFMT_YUY2 (('2'<<24)|('Y'<<16)|('U'<<8)|'Y')
 #define XINE_IMGFMT_XVMC (('C'<<24)|('M'<<16)|('v'<<8)|'X')
 #define XINE_IMGFMT_XXMC (('C'<<24)|('M'<<16)|('x'<<8)|'X')
+#define XINE_IMGFMT_VDPAU (('A'<<24)|('P'<<16)|('D'<<8)|'V')
 
 /* get current xine's virtual presentation timestamp (1/90000 sec)
  * note: this is mostly internal data.
@@ -2136,6 +2139,8 @@
 
 #define XINE_OSD_CAP_FREETYPE2 0x0001 /* freetype2 support compiled in     */
 #define XINE_OSD_CAP_UNSCALED  0x0002 /* unscaled overlays supp. by vo drv */
+#define XINE_OSD_CAP_CUSTOM_EXTENT 0x0004 /* hardware scaled to match video output window */ 
+#define XINE_OSD_CAP_ARGB_LAYER    0x0008 /* supports separate true color layer */
 
 typedef struct xine_osd_s xine_osd_t;
 
@@ -2200,6 +2205,28 @@
 void        xine_osd_set_palette   (xine_osd_t *self,
 				    const uint32_t *const color,
 				    const uint8_t *const trans ) XINE_PROTECTED;
+				    
+/*
+ * set an argb buffer to be blended into video
+ * the buffer must exactly match the osd dimensions
+ * and stay valid while the osd is on screen. pass
+ * a NULL pointer to safely remove the buffer from
+ * the osd layer. only the dirty area  will be
+ * updated on screen. for convinience the whole
+ * osd object will be considered dirty when setting
+ * a different buffer pointer.
+ * see also XINE_OSD_CAP_ARGB_LAYER
+ */
+void xine_osd_set_argb_buffer(xine_osd_t *self, uint32_t *argb_buffer,
+                              int dirty_x, int dirty_y, int dirty_width, int dirty_height) XINE_PROTECTED;
+
+/*
+ * define extent of reference coordinate system
+ * for video resolution independent osds.
+ * see also XINE_OSD_CAP_CUSTOM_EXTENT
+ */
+void xine_osd_set_extent(xine_osd_t *self, int extent_width, int extent_height) XINE_PROTECTED;
+
 /*
  * close osd rendering engine
  * loaded fonts are unloaded
diff -Naur xine-lib-1.1.16.1-old/include/xine.h.in.orig xine-lib-1.1.16.1-new/include/xine.h.in.orig
--- xine-lib-1.1.16.1-old/include/xine.h.in.orig	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/include/xine.h.in.orig	2009-01-19 18:50:39.000000000 -0800
@@ -0,0 +1,2258 @@
+/*
+ * Copyright (C) 2000-2006 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * public xine-lib (libxine) interface and documentation
+ *
+ *
+ * some programming guidelines about this api:
+ * -------------------------------------------
+ *
+ * (1) libxine has (per stream instance) a fairly static memory
+ *     model
+ * (2) as a rule of thumb, never free() or realloc() any pointers
+ *     returned by the xine engine (unless stated otherwise)
+ *     or, in other words:
+ *     do not free() stuff you have not malloc()ed
+ * (3) xine is multi-threaded, make sure your programming environment
+ *     can handle this.
+ *     for x11-related stuff this means that you either have to properly
+ *     use xlockdisplay() or use two seperate connections to the x-server
+ *
+ */
+/*_x_ Lines formatted like this one are xine-lib developer comments.  */
+/*_x_ They will be removed from the installed version of this header. */
+
+#ifndef HAVE_XINE_H
+#define HAVE_XINE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+#include <stdarg.h>
+
+#ifdef WIN32
+#include <windows.h>
+#include <windowsx.h>
+#endif
+
+#ifdef XINE_COMPILE
+#include <inttypes.h>
+#include "attributes.h"
+#else
+#include <xine/os_types.h>
+#include <xine/attributes.h>
+#endif
+
+/* This enables some experimental features. These are not part of the
+ * official libxine API, so use them only, if you absolutely need them.
+ * Although we make efforts to keep even this part of the API as stable
+ * as possible, this is not guaranteed. Incompatible changes can occur.
+ */
+/* #define XINE_ENABLE_EXPERIMENTAL_FEATURES */
+
+/* This disables some deprecated features. These are still part of the
+ * official libxine API and you may still use them. During the current
+ * major release series, these will always be available and will stay
+ * compatible. However, removal is likely to occur as soon as possible.
+ */
+/* #define XINE_DISABLE_DEPRECATED_FEATURES */
+
+
+/*********************************************************************
+ * xine opaque data types                                            *
+ *********************************************************************/
+
+typedef struct xine_s xine_t;
+typedef struct xine_stream_s xine_stream_t;
+typedef struct xine_audio_port_s xine_audio_port_t;
+typedef struct xine_video_port_s xine_video_port_t;
+
+#ifndef XINE_DISABLE_DEPRECATED_FEATURES
+/* convenience types: simple player UIs might want to call ports drivers */
+typedef xine_audio_port_t xine_ao_driver_t XINE_DEPRECATED;
+typedef xine_video_port_t xine_vo_driver_t XINE_DEPRECATED;
+#endif
+
+
+/*********************************************************************
+ * global engine handling                                            *
+ *********************************************************************/
+
+/*
+ * version information
+ */
+
+/* dynamic info from actually linked libxine */
+const char *xine_get_version_string (void) XINE_PROTECTED;
+void xine_get_version (int *major, int *minor, int *sub) XINE_PROTECTED;
+
+/* compare given version to libxine version,
+   return 1 if compatible, 0 otherwise */
+int  xine_check_version (int major, int minor, int sub) XINE_PROTECTED;
+
+/* static info - which libxine release this header came from */
+#define XINE_MAJOR_VERSION @XINE_MAJOR@
+#define XINE_MINOR_VERSION @XINE_MINOR@
+#define XINE_SUB_VERSION   @XINE_SUB@
+#define XINE_VERSION       "@VERSION@"
+
+/*
+ * pre-init the xine engine
+ *
+ * will first malloc and init a xine_t, create an empty config
+ * system, then scan through all installed plugins and add them
+ * to an internal list for later use.
+ *
+ * to fully init the xine engine, you have to load config values
+ * (either using your own storage method and calling
+ * xine_config_register_entry, or by using the xine_load_config
+ * utility function - see below) and then call xine_init
+ *
+ * the only proper way to shut down the xine engine is to
+ * call xine_exit() - do not try to free() the xine pointer
+ * yourself and do not try to access any internal data structures
+ */
+xine_t *xine_new (void) XINE_PROTECTED;
+
+/*
+ * post_init the xine engine
+ */
+void xine_init (xine_t *self) XINE_PROTECTED;
+
+/*
+ * helper functions to find and init audio/video drivers
+ * from xine's plugin collection
+ *
+ * id    : identifier of the driver, may be NULL for auto-detection
+ * data  : special data struct for ui/driver communications, depends
+ *         on driver
+ * visual: video driver flavor selector, constants see below
+ *
+ * both functions may return NULL if driver failed to load, was not
+ * found ...
+ *
+ * use xine_close_audio/video_driver() to close loaded drivers
+ * and free resources allocated by them
+ */
+xine_audio_port_t *xine_open_audio_driver (xine_t *self, const char *id,
+					   void *data) XINE_PROTECTED;
+xine_video_port_t *xine_open_video_driver (xine_t *self, const char *id,
+					   int visual, void *data) XINE_PROTECTED;
+
+void xine_close_audio_driver (xine_t *self, xine_audio_port_t  *driver) XINE_PROTECTED;
+void xine_close_video_driver (xine_t *self, xine_video_port_t  *driver) XINE_PROTECTED;
+
+/* valid visual types */
+#define XINE_VISUAL_TYPE_NONE              0
+#define XINE_VISUAL_TYPE_X11               1
+#define XINE_VISUAL_TYPE_X11_2            10
+#define XINE_VISUAL_TYPE_AA                2
+#define XINE_VISUAL_TYPE_FB                3
+#define XINE_VISUAL_TYPE_GTK               4
+#define XINE_VISUAL_TYPE_DFB               5
+#define XINE_VISUAL_TYPE_PM                6 /* used by the OS/2 port */
+#define XINE_VISUAL_TYPE_DIRECTX           7 /* used by the win32/msvc port */
+#define XINE_VISUAL_TYPE_CACA              8
+#define XINE_VISUAL_TYPE_MACOSX            9
+#define XINE_VISUAL_TYPE_XCB              11
+#define XINE_VISUAL_TYPE_RAW              12
+
+/*
+ * free all resources, close all plugins, close engine.
+ * self pointer is no longer valid after this call.
+ */
+void xine_exit (xine_t *self) XINE_PROTECTED;
+
+
+/*********************************************************************
+ * stream handling                                                   *
+ *********************************************************************/
+
+/*
+ * create a new stream for media playback/access
+ *
+ * returns xine_stream_t* if OK,
+ *         NULL on error (use xine_get_error for details)
+ *
+ * the only proper way to free the stream pointer returned by this
+ * function is to call xine_dispose() on it. do not try to access any
+ * fields in xine_stream_t, they're all private and subject to change
+ * without further notice.
+ */
+xine_stream_t *xine_stream_new (xine_t *self,
+				xine_audio_port_t *ao, xine_video_port_t *vo) XINE_PROTECTED;
+
+/*
+ * Make one stream the slave of another.
+ * This establishes a binary master slave relation on streams, where
+ * certain operations (specified by parameter "affection") on the master
+ * stream are also applied to the slave stream.
+ * If you want more than one stream to react to one master, you have to
+ * apply the calls in a top down way:
+ *  xine_stream_master_slave(stream1, stream2, 3);
+ *  xine_stream_master_slave(stream2, stream3, 3);
+ * This will make stream1 affect stream2 and stream2 affect stream3, so
+ * effectively, operations on stream1 propagate to stream2 and 3.
+ *
+ * Please note that subsequent master_slave calls on the same streams
+ * will overwrite their previous master/slave setting.
+ * Be sure to not mess around.
+ *
+ * returns 1 on success, 0 on failure
+ */
+int xine_stream_master_slave(xine_stream_t *master, xine_stream_t *slave,
+                             int affection) XINE_PROTECTED;
+
+/* affection is some of the following ORed together: */
+/* playing the master plays the slave */
+#define XINE_MASTER_SLAVE_PLAY     (1<<0)
+/* slave stops on master stop */
+#define XINE_MASTER_SLAVE_STOP     (1<<1)
+/* slave is synced to master's speed */
+#define XINE_MASTER_SLAVE_SPEED    (1<<2)
+
+/*
+ * open a stream
+ *
+ * look for input / demux / decoder plugins, find out about the format
+ * see if it is supported, set up internal buffers and threads
+ *
+ * returns 1 if OK, 0 on error (use xine_get_error for details)
+ */
+int xine_open (xine_stream_t *stream, const char *mrl) XINE_PROTECTED;
+
+/*
+ * play a stream from a given position
+ *
+ * start_pos:  0..65535
+ * start_time: milliseconds
+ * if both start position parameters are != 0 start_pos will be used
+ * for non-seekable streams both values will be ignored
+ *
+ * returns 1 if OK, 0 on error (use xine_get_error for details)
+ */
+int  xine_play (xine_stream_t *stream, int start_pos, int start_time) XINE_PROTECTED;
+
+/*
+ * set xine to a trick mode for fast forward, backwards playback,
+ * low latency seeking. Please note that this works only with some
+ * input plugins. mode constants see below.
+ *
+ * returns 1 if OK, 0 on error (use xine_get_error for details)
+ */
+int  xine_trick_mode (xine_stream_t *stream, int mode, int value) XINE_PROTECTED XINE_DEPRECATED;
+
+/* trick modes */
+#define XINE_TRICK_MODE_OFF                0
+#define XINE_TRICK_MODE_SEEK_TO_POSITION   1
+#define XINE_TRICK_MODE_SEEK_TO_TIME       2
+#define XINE_TRICK_MODE_FAST_FORWARD       3
+#define XINE_TRICK_MODE_FAST_REWIND        4
+
+/*
+ * stop stream playback
+ * xine_stream_t stays valid for new xine_open or xine_play
+ */
+void xine_stop (xine_stream_t *stream) XINE_PROTECTED;
+
+/*
+ * stop stream playback, free all stream-related resources
+ * xine_stream_t stays valid for new xine_open
+ */
+void xine_close (xine_stream_t *stream) XINE_PROTECTED;
+
+/*
+ * ask current/recent input plugin to eject media - may or may not work,
+ * depending on input plugin capabilities
+ */
+int  xine_eject (xine_stream_t *stream) XINE_PROTECTED;
+
+/*
+ * stop playback, dispose all stream-related resources
+ * xine_stream_t no longer valid when after this
+ */
+void xine_dispose (xine_stream_t *stream) XINE_PROTECTED;
+
+/*
+ * set/get engine parameters.
+ */
+void xine_engine_set_param(xine_t *self, int param, int value) XINE_PROTECTED;
+int xine_engine_get_param(xine_t *self, int param) XINE_PROTECTED;
+  
+#define XINE_ENGINE_PARAM_VERBOSITY        1
+
+/*
+ * set/get xine stream parameters
+ * e.g. playback speed, constants see below
+ */
+void xine_set_param (xine_stream_t *stream, int param, int value) XINE_PROTECTED;
+int  xine_get_param (xine_stream_t *stream, int param) XINE_PROTECTED;
+
+/*
+ * xine stream parameters
+ */
+#define XINE_PARAM_SPEED                   1 /* see below                   */
+#define XINE_PARAM_AV_OFFSET               2 /* unit: 1/90000 sec           */
+#define XINE_PARAM_AUDIO_CHANNEL_LOGICAL   3 /* -1 => auto, -2 => off       */
+#define XINE_PARAM_SPU_CHANNEL             4
+#define XINE_PARAM_VIDEO_CHANNEL           5
+#define XINE_PARAM_AUDIO_VOLUME            6 /* 0..100                      */
+#define XINE_PARAM_AUDIO_MUTE              7 /* 1=>mute, 0=>unmute          */
+#define XINE_PARAM_AUDIO_COMPR_LEVEL       8 /* <100=>off, % compress otherw*/
+#define XINE_PARAM_AUDIO_AMP_LEVEL         9 /* 0..200, 100=>100% (default) */
+#define XINE_PARAM_AUDIO_REPORT_LEVEL     10 /* 1=>send events, 0=> don't   */
+#define XINE_PARAM_VERBOSITY              11 /* control console output      */
+#define XINE_PARAM_SPU_OFFSET             12 /* unit: 1/90000 sec           */
+#define XINE_PARAM_IGNORE_VIDEO           13 /* disable video decoding      */
+#define XINE_PARAM_IGNORE_AUDIO           14 /* disable audio decoding      */
+#define XINE_PARAM_IGNORE_SPU             15 /* disable spu decoding        */
+#define XINE_PARAM_BROADCASTER_PORT       16 /* 0: disable, x: server port  */
+#define XINE_PARAM_METRONOM_PREBUFFER     17 /* unit: 1/90000 sec           */
+#define XINE_PARAM_EQ_30HZ                18 /* equalizer gains -100..100   */
+#define XINE_PARAM_EQ_60HZ                19 /* equalizer gains -100..100   */
+#define XINE_PARAM_EQ_125HZ               20 /* equalizer gains -100..100   */
+#define XINE_PARAM_EQ_250HZ               21 /* equalizer gains -100..100   */
+#define XINE_PARAM_EQ_500HZ               22 /* equalizer gains -100..100   */
+#define XINE_PARAM_EQ_1000HZ              23 /* equalizer gains -100..100   */
+#define XINE_PARAM_EQ_2000HZ              24 /* equalizer gains -100..100   */
+#define XINE_PARAM_EQ_4000HZ              25 /* equalizer gains -100..100   */
+#define XINE_PARAM_EQ_8000HZ              26 /* equalizer gains -100..100   */
+#define XINE_PARAM_EQ_16000HZ             27 /* equalizer gains -100..100   */
+#define XINE_PARAM_AUDIO_CLOSE_DEVICE     28 /* force closing audio device  */
+#define XINE_PARAM_AUDIO_AMP_MUTE         29 /* 1=>mute, 0=>unmute */
+#define XINE_PARAM_FINE_SPEED             30 /* 1.000.000 => normal speed   */ 
+#define XINE_PARAM_EARLY_FINISHED_EVENT   31 /* send event when demux finish*/
+#define XINE_PARAM_GAPLESS_SWITCH         32 /* next stream only gapless swi*/
+#define XINE_PARAM_DELAY_FINISHED_EVENT   33 /* 1/10sec,0=>disable,-1=>forev*/
+
+/*
+ * speed values for XINE_PARAM_SPEED parameter.
+ *
+ * alternatively, one may use XINE_PARAM_FINE_SPEED for greater
+ * control of the speed value, where:
+ * XINE_PARAM_SPEED / 4 <-> XINE_PARAM_FINE_SPEED / 1000000
+ */
+#define XINE_SPEED_PAUSE                   0
+#define XINE_SPEED_SLOW_4                  1
+#define XINE_SPEED_SLOW_2                  2
+#define XINE_SPEED_NORMAL                  4
+#define XINE_SPEED_FAST_2                  8
+#define XINE_SPEED_FAST_4                  16
+ 
+/* normal speed value for XINE_PARAM_FINE_SPEED parameter */
+#define XINE_FINE_SPEED_NORMAL             1000000
+
+/* video parameters */
+#define XINE_PARAM_VO_DEINTERLACE          0x01000000 /* bool               */
+#define XINE_PARAM_VO_ASPECT_RATIO         0x01000001 /* see below          */
+#define XINE_PARAM_VO_HUE                  0x01000002 /* 0..65535           */
+#define XINE_PARAM_VO_SATURATION           0x01000003 /* 0..65535           */
+#define XINE_PARAM_VO_CONTRAST             0x01000004 /* 0..65535           */
+#define XINE_PARAM_VO_BRIGHTNESS           0x01000005 /* 0..65535           */
+#define XINE_PARAM_VO_ZOOM_X               0x01000008 /* percent            */
+#define XINE_PARAM_VO_ZOOM_Y               0x0100000d /* percent            */
+#define XINE_PARAM_VO_PAN_SCAN             0x01000009 /* bool               */
+#define XINE_PARAM_VO_TVMODE               0x0100000a /* ???                */
+#define XINE_PARAM_VO_WINDOW_WIDTH         0x0100000f /* readonly           */
+#define XINE_PARAM_VO_WINDOW_HEIGHT        0x01000010 /* readonly           */
+#define XINE_PARAM_VO_CROP_LEFT            0x01000020 /* crop frame pixels  */
+#define XINE_PARAM_VO_CROP_RIGHT           0x01000021 /* crop frame pixels  */
+#define XINE_PARAM_VO_CROP_TOP             0x01000022 /* crop frame pixels  */
+#define XINE_PARAM_VO_CROP_BOTTOM          0x01000023 /* crop frame pixels  */
+
+
+#define XINE_VO_ZOOM_STEP                  100
+#define XINE_VO_ZOOM_MAX                   400
+#define XINE_VO_ZOOM_MIN                   -85
+
+/* possible ratios for XINE_PARAM_VO_ASPECT_RATIO */
+#define XINE_VO_ASPECT_AUTO                0
+#define XINE_VO_ASPECT_SQUARE              1 /* 1:1    */
+#define XINE_VO_ASPECT_4_3                 2 /* 4:3    */
+#define XINE_VO_ASPECT_ANAMORPHIC          3 /* 16:9   */
+#define XINE_VO_ASPECT_DVB                 4 /* 2.11:1 */
+#define XINE_VO_ASPECT_NUM_RATIOS          5
+#ifndef XINE_DISABLE_DEPRECATED_FEATURES
+#define XINE_VO_ASPECT_PAN_SCAN            41
+#define XINE_VO_ASPECT_DONT_TOUCH          42
+#endif
+
+/* stream format detection strategies */
+
+/* recognize stream type first by content then by extension. */
+#define XINE_DEMUX_DEFAULT_STRATEGY        0
+/* recognize stream type first by extension then by content. */
+#define XINE_DEMUX_REVERT_STRATEGY         1
+/* recognize stream type by content only.                    */
+#define XINE_DEMUX_CONTENT_STRATEGY        2
+/* recognize stream type by extension only.                  */
+#define XINE_DEMUX_EXTENSION_STRATEGY      3
+
+/* verbosity settings */
+#define XINE_VERBOSITY_NONE                0
+#define XINE_VERBOSITY_LOG                 1
+#define XINE_VERBOSITY_DEBUG               2
+
+/*
+ * snapshot function
+ *
+ * image format can be YUV 4:2:0 or 4:2:2
+ * will copy the image data into memory that <img> points to
+ * (interleaved for yuv 4:2:2 or planary for 4:2:0)
+ * 
+ * xine_get_current_frame() requires that <img> must be able
+ * to hold the image data. Use a NULL pointer to retrieve the
+ * necessary parameters for calculating the buffer size. Be
+ * aware that the image can change between two successive calls
+ * so you better pause the stream.
+ *
+ * xine_get_current_frame_s() requires to specify the buffer
+ * size and it returns the needed / used size. It won't copy
+ * image data into a too small buffer.
+ *
+ * xine_get_current_frame_alloc() takes care of allocating
+ * a buffer on its own, so image data can be retrieved by
+ * a single call without the need to pause the stream.
+ * 
+ * xine_get_current_frame_data() passes the parameters of the
+ * previously mentioned functions plus further information in
+ * a structure and can work like the _s or _alloc function
+ * respectively depending on the passed flags.
+ *
+ * all functions return 1 on success, 0 failure.
+ */
+int  xine_get_current_frame (xine_stream_t *stream,
+			     int *width, int *height,
+			     int *ratio_code, int *format,
+			     uint8_t *img) XINE_PROTECTED;
+
+int  xine_get_current_frame_s (xine_stream_t *stream,
+			     int *width, int *height,
+			     int *ratio_code, int *format,
+			     uint8_t *img, int *img_size) XINE_PROTECTED;
+
+int  xine_get_current_frame_alloc (xine_stream_t *stream,
+			     int *width, int *height,
+			     int *ratio_code, int *format,
+			     uint8_t **img, int *img_size) XINE_PROTECTED;
+
+typedef struct {
+
+  int      width;
+  int      height;
+  int      crop_left;
+  int      crop_right;
+  int      crop_top;
+  int      crop_bottom;
+  int      ratio_code;
+  int      interlaced;
+  int      format;
+  int      img_size;
+  uint8_t *img;
+} xine_current_frame_data_t;
+
+#define XINE_FRAME_DATA_ALLOCATE_IMG (1<<0)
+
+int  xine_get_current_frame_data (xine_stream_t *stream,
+			     xine_current_frame_data_t *data,
+			     int flags) XINE_PROTECTED;
+
+/* xine image formats */
+#define XINE_IMGFMT_YV12 (('2'<<24)|('1'<<16)|('V'<<8)|'Y')
+#define XINE_IMGFMT_YUY2 (('2'<<24)|('Y'<<16)|('U'<<8)|'Y')
+#define XINE_IMGFMT_XVMC (('C'<<24)|('M'<<16)|('v'<<8)|'X')
+#define XINE_IMGFMT_XXMC (('C'<<24)|('M'<<16)|('x'<<8)|'X')
+
+/* get current xine's virtual presentation timestamp (1/90000 sec)
+ * note: this is mostly internal data.
+ * one can use vpts with xine_osd_show() and xine_osd_hide().
+ */
+int64_t xine_get_current_vpts(xine_stream_t *stream) XINE_PROTECTED;
+
+
+/*********************************************************************
+ * media processing                                                  *
+ *********************************************************************/
+
+#ifdef XINE_ENABLE_EXPERIMENTAL_FEATURES
+
+/*
+ * access to decoded audio and video frames from a stream
+ * these functions are intended to provide the basis for
+ * re-encoding and other video processing applications
+ *
+ * note that the xine playback engine will block when
+ * rendering to a framegrab port: to unblock the stream,
+ * you must fetch the frames manually with the
+ * xine_get_next_* functions.  this ensures that a
+ * framegrab port is guaranteed to never miss a frame.
+ *
+ */
+
+xine_video_port_t *xine_new_framegrab_video_port (xine_t *self) XINE_PROTECTED;
+
+typedef struct {
+
+  int64_t  vpts;       /* timestamp 1/90000 sec for a/v sync */
+  int64_t  duration;
+  int      width, height;
+  int      colorspace; /* XINE_IMGFMT_* */
+  double   aspect_ratio;
+
+  int      pos_stream; /* bytes from stream start */
+  int      pos_time;   /* milliseconds */
+
+  uint8_t *data;
+  void    *xine_frame; /* used internally by xine engine */
+  
+  int      frame_number; /* frame number (may be unknown) */
+} xine_video_frame_t;
+
+int xine_get_next_video_frame (xine_video_port_t *port,
+			       xine_video_frame_t *frame) XINE_PROTECTED;
+
+void xine_free_video_frame (xine_video_port_t *port, xine_video_frame_t *frame) XINE_PROTECTED;
+
+xine_audio_port_t *xine_new_framegrab_audio_port (xine_t *self) XINE_PROTECTED;
+
+typedef struct {
+
+  int64_t  vpts;       /* timestamp 1/90000 sec for a/v sync */
+  int      num_samples;
+  int      sample_rate;
+  int      num_channels;
+  int      bits_per_sample; /* per channel */
+
+  off_t    pos_stream; /* bytes from stream start */
+  int      pos_time;   /* milliseconds */
+
+  uint8_t *data;
+  void    *xine_frame; /* used internally by xine engine */
+} xine_audio_frame_t;
+
+int xine_get_next_audio_frame (xine_audio_port_t *port,
+			       xine_audio_frame_t *frame) XINE_PROTECTED;
+
+void xine_free_audio_frame (xine_audio_port_t *port, xine_audio_frame_t *frame) XINE_PROTECTED;
+
+  /*
+   * maybe future aproach:
+   */
+
+int xine_get_video_frame (xine_stream_t *stream,
+			  int timestamp, /* msec */
+			  int *width, int *height,
+			  int *ratio_code, 
+			  int *duration, /* msec */
+			  int *format,
+			  uint8_t *img) XINE_PROTECTED XINE_DEPRECATED;
+
+/* TODO: xine_get_audio_frame */
+
+#endif
+
+
+/*********************************************************************
+ * post plugin handling                                              *
+ *********************************************************************/
+
+/*
+ * post effect plugin functions
+ *
+ * after the data leaves the decoder it can pass an arbitrary tree
+ * of post plugins allowing for effects to be applied to the video
+ * frames/audio buffers before they reach the output stage
+ */
+
+typedef struct xine_post_s xine_post_t;
+
+struct xine_post_s {
+
+  /* a NULL-terminated array of audio input ports this post plugin
+   * provides; you can hand these to other post plugin's outputs or
+   * pass them to the initialization of streams
+   */
+  xine_audio_port_t **audio_input;
+  
+  /* a NULL-terminated array of video input ports this post plugin
+   * provides; you can hand these to other post plugin's outputs or
+   * pass them to the initialization of streams
+   */
+  xine_video_port_t **video_input;
+  
+  /* the type of the post plugin
+   * one of XINE_POST_TYPE_* can be used here
+   */
+  int type;
+  
+};
+
+/*
+ * initialize a post plugin
+ *
+ * returns xine_post_t* on success, NULL on failure
+ *
+ * Initializes the post plugin with the given name and connects its
+ * outputs to the NULL-terminated arrays of audio and video ports.
+ * Some plugins also care about the number of inputs you request
+ * (e.g. mixer plugins), others simply ignore this number.
+ */
+xine_post_t *xine_post_init(xine_t *xine, const char *name,
+			    int inputs,
+			    xine_audio_port_t **audio_target,
+			    xine_video_port_t **video_target) XINE_PROTECTED;
+
+/* get a list of all available post plugins */
+const char *const *xine_list_post_plugins(xine_t *xine) XINE_PROTECTED;
+
+/* get a list of all post plugins of one type */
+const char *const *xine_list_post_plugins_typed(xine_t *xine, int type) XINE_PROTECTED;
+
+/*
+ * post plugin input/output
+ *
+ * These structures encapsulate inputs/outputs for post plugins
+ * to transfer arbitrary data. Frontends can also provide inputs
+ * and outputs and connect them to post plugins to exchange data
+ * with them.
+ */
+
+typedef struct xine_post_in_s  xine_post_in_t;
+typedef struct xine_post_out_s xine_post_out_t;
+
+struct xine_post_in_s {
+
+  /* the name identifying this input */
+  const char   *name;
+  
+  /* the datatype of this input, use one of XINE_POST_DATA_* here */
+  int           type;
+  
+  /* the data pointer; input is directed to this memory location,
+   * so you simply access the pointer to access the input data */
+  void         *data;
+  
+};
+
+struct xine_post_out_s {
+
+  /* the name identifying this output */
+  const char   *name;
+  
+  /* the datatype of this output, use one of XINE_POST_DATA_* here */
+  int           type;
+  
+  /* the data pointer; output should be directed to this memory location,
+   * so in the easy case you simply write through the pointer */
+  void         *data;
+  
+  /* this function is called, when the output should be redirected
+   * to another input, you sould set the data pointer to direct
+   * any output to this new input;
+   * a special situation is, when this function is called with a NULL
+   * argument: in this case you should disconnect the data pointer
+   * from any output and if necessary to avoid writing to some stray
+   * memory you should make it point to some dummy location,
+   * returns 1 on success, 0 on failure;
+   * if you do not implement rewiring, set this to NULL */
+  int (*rewire) (xine_post_out_t *self, void *data);
+
+};
+
+/* get a list of all inputs of a post plugin */
+const char *const *xine_post_list_inputs(xine_post_t *self) XINE_PROTECTED;
+
+/* get a list of all outputs of a post plugin */
+const char *const *xine_post_list_outputs(xine_post_t *self) XINE_PROTECTED;
+
+/* retrieve one specific input of a post plugin */
+xine_post_in_t *xine_post_input(xine_post_t *self, const char *name) XINE_PROTECTED;
+
+/* retrieve one specific output of a post plugin */
+xine_post_out_t *xine_post_output(xine_post_t *self, const char *name) XINE_PROTECTED;
+
+/*
+ * wire an input to an output
+ * returns 1 on success, 0 on failure
+ */
+int xine_post_wire(xine_post_out_t *source, xine_post_in_t *target) XINE_PROTECTED;
+
+/*
+ * wire a video port to a video output
+ * This can be used to rewire different post plugins to the video output
+ * plugin layer. The ports you hand in at xine_post_init() will already
+ * be wired with the post plugin, so you need this function for
+ * _re_connecting only.
+ *
+ * returns 1 on success, 0 on failure
+ */
+int xine_post_wire_video_port(xine_post_out_t *source, xine_video_port_t *vo) XINE_PROTECTED;
+
+/*
+ * wire an audio port to an audio output
+ * This can be used to rewire different post plugins to the audio output
+ * plugin layer. The ports you hand in at xine_post_init() will already
+ * be wired with the post plugin, so you need this function for
+ * _re_connecting only.
+ *
+ * returns 1 on success, 0 on failure
+ */
+int xine_post_wire_audio_port(xine_post_out_t *source, xine_audio_port_t *ao) XINE_PROTECTED;
+
+/*
+ * Extracts an output for a stream. Use this to rewire the outputs of streams.
+ */
+xine_post_out_t * xine_get_video_source(xine_stream_t *stream) XINE_PROTECTED;
+xine_post_out_t * xine_get_audio_source(xine_stream_t *stream) XINE_PROTECTED;
+
+/*
+ * disposes the post plugin
+ * please make sure that no other post plugin and no stream is
+ * connected to any of this plugin's inputs
+ */
+void xine_post_dispose(xine_t *xine, xine_post_t *self) XINE_PROTECTED;
+
+
+/* post plugin types */
+#define XINE_POST_TYPE_VIDEO_FILTER		0x010000
+#define XINE_POST_TYPE_VIDEO_VISUALIZATION	0x010001
+#define XINE_POST_TYPE_VIDEO_COMPOSE		0x010002
+#define XINE_POST_TYPE_AUDIO_FILTER		0x020000
+#define XINE_POST_TYPE_AUDIO_VISUALIZATION	0x020001
+
+
+/* post plugin data types */
+
+/* video port data
+ * input->data is a xine_video_port_t*
+ * output->data usually is a xine_video_port_t**
+ */
+#define XINE_POST_DATA_VIDEO          0
+
+/* audio port data
+ * input->data is a xine_audio_port_t*
+ * output->data usually is a xine_audio_port_t**
+ */
+#define XINE_POST_DATA_AUDIO          1
+
+/* integer data
+ * input->data is a int*
+ * output->data usually is a int*
+ */
+#define XINE_POST_DATA_INT            3
+
+/* double precision floating point data
+ * input->data is a double*
+ * output->data usually is a double*
+ */
+#define XINE_POST_DATA_DOUBLE         4
+
+/* parameters api (used by frontends)
+ * input->data is xine_post_api_t*  (see below)
+ */
+#define XINE_POST_DATA_PARAMETERS     5
+
+/* defines a single parameter entry. */
+typedef struct {
+  int              type;             /* POST_PARAM_TYPE_xxx             */
+  char            *name;             /* name of this parameter          */
+  int              size;             /* sizeof(parameter)               */
+  int              offset;           /* offset in bytes from struct ptr */
+  char           **enum_values;      /* enumeration (first=0) or NULL   */
+  double           range_min;        /* minimum value                   */
+  double           range_max;        /* maximum value                   */
+  int              readonly;         /* 0 = read/write, 1=read-only     */
+  char            *description;      /* user-friendly description       */
+} xine_post_api_parameter_t;
+
+/* description of parameters struct (params). */
+typedef struct {
+  int struct_size;                       /* sizeof(params)     */
+  xine_post_api_parameter_t *parameter;  /* list of parameters */
+} xine_post_api_descr_t;
+
+typedef struct {
+  /*
+   * method to set all the read/write parameters.
+   * params is a struct * defined by xine_post_api_descr_t
+   */
+  int (*set_parameters) (xine_post_t *self, void *params);
+
+  /*
+   * method to get all parameters.
+   */
+  int (*get_parameters) (xine_post_t *self, void *params);
+
+  /*
+   * method to get params struct definition
+   */
+  xine_post_api_descr_t * (*get_param_descr) (void);
+
+  /*
+   * method to get plugin and parameters help (UTF-8)
+   * the help string must be word wrapped by the frontend.
+   * it might contain \n to mark paragraph breaks.
+   */
+  char * (*get_help) (void);
+} xine_post_api_t;
+
+/* post parameter types */
+#define POST_PARAM_TYPE_LAST       0  /* terminator of parameter list       */
+#define POST_PARAM_TYPE_INT        1  /* integer (or vector of integers)    */
+#define POST_PARAM_TYPE_DOUBLE     2  /* double (or vector of doubles)      */
+#define POST_PARAM_TYPE_CHAR       3  /* char (or vector of chars = string) */
+#define POST_PARAM_TYPE_STRING     4  /* (char *), ASCIIZ                   */
+#define POST_PARAM_TYPE_STRINGLIST 5  /* (char **) list, NULL terminated    */
+#define POST_PARAM_TYPE_BOOL       6  /* integer (0 or 1)                   */
+
+
+/*********************************************************************
+ * information retrieval                                             *
+ *********************************************************************/
+
+/*
+ * xine log functions
+ *
+ * frontends can display xine log output using these functions
+ */
+int    xine_get_log_section_count(xine_t *self) XINE_PROTECTED;
+
+/* return a NULL terminated array of log sections names */
+const char *const *xine_get_log_names(xine_t *self) XINE_PROTECTED;
+
+/* print some log information to <buf> section */
+void   xine_log (xine_t *self, int buf,
+		 const char *format, ...) XINE_FORMAT_PRINTF(3, 4) XINE_PROTECTED;
+void   xine_vlog(xine_t *self, int buf,
+		  const char *format, va_list args) XINE_FORMAT_PRINTF(3, 0) XINE_PROTECTED;
+
+/* get log messages of specified section */
+char *const *xine_get_log (xine_t *self, int buf) XINE_PROTECTED;
+
+/* log callback will be called whenever something is logged */
+typedef void (*xine_log_cb_t) (void *user_data, int section);
+void   xine_register_log_cb (xine_t *self, xine_log_cb_t cb,
+			     void *user_data) XINE_PROTECTED;
+
+/*
+ * error handling / engine status
+ */
+
+/* return last error  */
+int  xine_get_error (xine_stream_t *stream) XINE_PROTECTED;
+
+/* get current xine engine status (constants see below) */
+int  xine_get_status (xine_stream_t *stream) XINE_PROTECTED;
+
+/*
+ * engine status codes
+ */
+#define XINE_STATUS_IDLE                   0 /* no mrl assigned */
+#define XINE_STATUS_STOP                   1
+#define XINE_STATUS_PLAY                   2
+#define XINE_STATUS_QUIT                   3
+
+/*
+ * xine error codes
+ */
+#define XINE_ERROR_NONE                    0
+#define XINE_ERROR_NO_INPUT_PLUGIN         1
+#define XINE_ERROR_NO_DEMUX_PLUGIN         2
+#define XINE_ERROR_DEMUX_FAILED            3
+#define XINE_ERROR_MALFORMED_MRL           4
+#define XINE_ERROR_INPUT_FAILED            5
+
+/*
+ * try to find out audio/spu language of given channel
+ * (use -1 for current channel)
+ *
+ * lang must point to a buffer of at least XINE_LANG_MAX bytes
+ *
+ * returns 1 on success, 0 on failure
+ */
+int xine_get_audio_lang (xine_stream_t *stream, int channel,
+			 char *lang) XINE_PROTECTED;
+int xine_get_spu_lang   (xine_stream_t *stream, int channel,
+			 char *lang) XINE_PROTECTED;
+/*_x_ increasing this number means an incompatible ABI breakage! */
+#define XINE_LANG_MAX                     32
+
+/*
+ * get position / length information
+ *
+ * depending of the nature and system layer of the stream,
+ * some or all of this information may be unavailable or incorrect
+ * (e.g. live network streams may not have a valid length)
+ *
+ * returns 1 on success, 0 on failure (data was not updated,
+ * probably because it's not known yet... try again later)
+ */
+int  xine_get_pos_length (xine_stream_t *stream,
+			  int *pos_stream,  /* 0..65535     */
+			  int *pos_time,    /* milliseconds */
+			  int *length_time) /* milliseconds */
+  XINE_PROTECTED;
+
+/*
+ * get information about the stream such as
+ * video width/height, codecs, audio format, title, author...
+ * strings are UTF-8 encoded.
+ *
+ * constants see below
+ */
+uint32_t    xine_get_stream_info (xine_stream_t *stream, int info) XINE_PROTECTED;
+const char *xine_get_meta_info   (xine_stream_t *stream, int info) XINE_PROTECTED;
+
+/* xine_get_stream_info */
+#define XINE_STREAM_INFO_BITRATE           0
+#define XINE_STREAM_INFO_SEEKABLE          1
+#define XINE_STREAM_INFO_VIDEO_WIDTH       2
+#define XINE_STREAM_INFO_VIDEO_HEIGHT      3
+#define XINE_STREAM_INFO_VIDEO_RATIO       4 /* *10000 */
+#define XINE_STREAM_INFO_VIDEO_CHANNELS    5
+#define XINE_STREAM_INFO_VIDEO_STREAMS     6
+#define XINE_STREAM_INFO_VIDEO_BITRATE     7
+#define XINE_STREAM_INFO_VIDEO_FOURCC      8
+#define XINE_STREAM_INFO_VIDEO_HANDLED     9  /* codec available? */
+#define XINE_STREAM_INFO_FRAME_DURATION    10 /* 1/90000 sec */
+#define XINE_STREAM_INFO_AUDIO_CHANNELS    11
+#define XINE_STREAM_INFO_AUDIO_BITS        12
+#define XINE_STREAM_INFO_AUDIO_SAMPLERATE  13
+#define XINE_STREAM_INFO_AUDIO_BITRATE     14
+#define XINE_STREAM_INFO_AUDIO_FOURCC      15
+#define XINE_STREAM_INFO_AUDIO_HANDLED     16 /* codec available? */
+#define XINE_STREAM_INFO_HAS_CHAPTERS      17
+#define XINE_STREAM_INFO_HAS_VIDEO         18
+#define XINE_STREAM_INFO_HAS_AUDIO         19
+#define XINE_STREAM_INFO_IGNORE_VIDEO      20
+#define XINE_STREAM_INFO_IGNORE_AUDIO      21
+#define XINE_STREAM_INFO_IGNORE_SPU        22
+#define XINE_STREAM_INFO_VIDEO_HAS_STILL   23
+#define XINE_STREAM_INFO_MAX_AUDIO_CHANNEL 24
+#define XINE_STREAM_INFO_MAX_SPU_CHANNEL   25
+#define XINE_STREAM_INFO_AUDIO_MODE        26
+#define XINE_STREAM_INFO_SKIPPED_FRAMES    27 /* for 1000 frames delivered */
+#define XINE_STREAM_INFO_DISCARDED_FRAMES  28 /* for 1000 frames delivered */
+#define XINE_STREAM_INFO_VIDEO_AFD         29
+#define XINE_STREAM_INFO_DVD_TITLE_NUMBER   30
+#define XINE_STREAM_INFO_DVD_TITLE_COUNT    31
+#define XINE_STREAM_INFO_DVD_CHAPTER_NUMBER 32
+#define XINE_STREAM_INFO_DVD_CHAPTER_COUNT  33
+#define XINE_STREAM_INFO_DVD_ANGLE_NUMBER   34
+#define XINE_STREAM_INFO_DVD_ANGLE_COUNT    35
+
+/* possible values for XINE_STREAM_INFO_VIDEO_AFD */
+#define XINE_VIDEO_AFD_NOT_PRESENT         -1
+#define XINE_VIDEO_AFD_RESERVED_0          0
+#define XINE_VIDEO_AFD_RESERVED_1          1
+#define XINE_VIDEO_AFD_BOX_16_9_TOP        2
+#define XINE_VIDEO_AFD_BOX_14_9_TOP        3
+#define XINE_VIDEO_AFD_BOX_GT_16_9_CENTRE  4
+#define XINE_VIDEO_AFD_RESERVED_5          5
+#define XINE_VIDEO_AFD_RESERVED_6          6
+#define XINE_VIDEO_AFD_RESERVED_7          7
+#define XINE_VIDEO_AFD_SAME_AS_FRAME       8
+#define XINE_VIDEO_AFD_4_3_CENTRE          9
+#define XINE_VIDEO_AFD_16_9_CENTRE         10
+#define XINE_VIDEO_AFD_14_9_CENTRE         11
+#define XINE_VIDEO_AFD_RESERVED_12         12
+#define XINE_VIDEO_AFD_4_3_PROTECT_14_9    13
+#define XINE_VIDEO_AFD_16_9_PROTECT_14_9   14
+#define XINE_VIDEO_AFD_16_9_PROTECT_4_3    15
+
+/* xine_get_meta_info */
+#define XINE_META_INFO_TITLE               0
+#define XINE_META_INFO_COMMENT             1
+#define XINE_META_INFO_ARTIST              2
+#define XINE_META_INFO_GENRE               3
+#define XINE_META_INFO_ALBUM               4
+#define XINE_META_INFO_YEAR                5
+#define XINE_META_INFO_VIDEOCODEC          6
+#define XINE_META_INFO_AUDIOCODEC          7
+#define XINE_META_INFO_SYSTEMLAYER         8
+#define XINE_META_INFO_INPUT_PLUGIN        9
+#define XINE_META_INFO_CDINDEX_DISCID      10
+#define XINE_META_INFO_TRACK_NUMBER        11
+#define XINE_META_INFO_COMPOSER            12
+
+
+/*********************************************************************
+ * plugin management / autoplay / mrl browsing                       *
+ *********************************************************************/
+
+/*
+ * note: the pointers to strings or string arrays returned
+ *       by some of these functions are pointers to statically
+ *       alloced internal xine memory chunks.
+ *       they're only valid between xine function calls
+ *       and should never be free()d.
+ */
+
+typedef struct {
+  char      *origin; /* file plugin: path */
+  char      *mrl;    /* <type>://<location> */
+  char      *link;
+  uint32_t   type;   /* see below */
+  off_t      size;   /* size of this source, may be 0 */
+} xine_mrl_t;
+
+/* mrl types */
+#define XINE_MRL_TYPE_unknown        (0 << 0)
+#define XINE_MRL_TYPE_dvd            (1 << 0)
+#define XINE_MRL_TYPE_vcd            (1 << 1)
+#define XINE_MRL_TYPE_net            (1 << 2)
+#define XINE_MRL_TYPE_rtp            (1 << 3)
+#define XINE_MRL_TYPE_stdin          (1 << 4)
+#define XINE_MRL_TYPE_cda            (1 << 5)
+#define XINE_MRL_TYPE_file           (1 << 6)
+#define XINE_MRL_TYPE_file_fifo      (1 << 7)
+#define XINE_MRL_TYPE_file_chardev   (1 << 8)
+#define XINE_MRL_TYPE_file_directory (1 << 9)
+#define XINE_MRL_TYPE_file_blockdev  (1 << 10)
+#define XINE_MRL_TYPE_file_normal    (1 << 11)
+#define XINE_MRL_TYPE_file_symlink   (1 << 12)
+#define XINE_MRL_TYPE_file_sock      (1 << 13)
+#define XINE_MRL_TYPE_file_exec      (1 << 14)
+#define XINE_MRL_TYPE_file_backup    (1 << 15)
+#define XINE_MRL_TYPE_file_hidden    (1 << 16)
+
+/* get a list of browsable input plugin ids */
+const char *const *xine_get_browsable_input_plugin_ids (xine_t *self)  XINE_PROTECTED;
+
+/*
+ * ask input plugin named <plugin_id> to return
+ * a list of available MRLs in domain/directory <start_mrl>.
+ *
+ * <start_mrl> may be NULL indicating the toplevel domain/dir
+ * returns <start_mrl> if <start_mrl> is a valid MRL, not a directory
+ * returns NULL if <start_mrl> is an invalid MRL, not even a directory.
+ */
+xine_mrl_t **xine_get_browse_mrls (xine_t *self,
+				   const char *plugin_id,
+				   const char *start_mrl,
+				   int *num_mrls) XINE_PROTECTED;
+
+/* get a list of plugins that support the autoplay feature */
+const char *const *xine_get_autoplay_input_plugin_ids (xine_t *self) XINE_PROTECTED;
+
+/* get autoplay MRL list from input plugin named <plugin_id> */
+char **xine_get_autoplay_mrls (xine_t *self,
+			       const char *plugin_id,
+			       int *num_mrls) XINE_PROTECTED;
+
+/* get a list of file extensions for file types supported by xine
+ * the list is separated by spaces
+ *
+ * the pointer returned can be free()ed when no longer used */
+char *xine_get_file_extensions (xine_t *self) XINE_PROTECTED;
+
+/* get a list of mime types supported by xine
+ *
+ * the pointer returned can be free()ed when no longer used */
+char *xine_get_mime_types (xine_t *self) XINE_PROTECTED;
+
+/* get the demuxer identifier that handles a given mime type
+ *
+ * the pointer returned can be free()ed when no longer used
+ * returns NULL if no demuxer is available to handle this. */
+char *xine_get_demux_for_mime_type (xine_t *self, const char *mime_type) XINE_PROTECTED;
+
+/* get a description string for a plugin */
+const char *xine_get_input_plugin_description (xine_t *self,
+					       const char *plugin_id) XINE_PROTECTED;
+const char *xine_get_demux_plugin_description (xine_t *self,
+					       const char *plugin_id) XINE_PROTECTED;
+const char *xine_get_spu_plugin_description   (xine_t *self,
+					       const char *plugin_id) XINE_PROTECTED;
+const char *xine_get_audio_plugin_description (xine_t *self,
+					       const char *plugin_id) XINE_PROTECTED;
+const char *xine_get_video_plugin_description (xine_t *self,
+					       const char *plugin_id) XINE_PROTECTED;
+const char *xine_get_audio_driver_plugin_description (xine_t *self,
+					       const char *plugin_id) XINE_PROTECTED;
+const char *xine_get_video_driver_plugin_description (xine_t *self,
+					       const char *plugin_id) XINE_PROTECTED;
+const char *xine_get_post_plugin_description  (xine_t *self,
+					       const char *plugin_id) XINE_PROTECTED;
+
+/* get lists of available audio and video output plugins */
+const char *const *xine_list_audio_output_plugins (xine_t *self) XINE_PROTECTED;
+const char *const *xine_list_video_output_plugins (xine_t *self) XINE_PROTECTED;
+/* typemask is (1ULL << XINE_VISUAL_TYPE_FOO) | ... */
+const char *const *xine_list_video_output_plugins_typed (xine_t *self, uint64_t typemask) XINE_PROTECTED;
+
+/* get list of available demultiplexor plugins */
+const char *const *xine_list_demuxer_plugins(xine_t *self) XINE_PROTECTED;
+
+/* get list of available input plugins */
+const char *const *xine_list_input_plugins(xine_t *self) XINE_PROTECTED;
+
+/* get list of available subpicture plugins */
+const char *const *xine_list_spu_plugins(xine_t *self) XINE_PROTECTED;
+
+/* get list of available audio and video decoder plugins */
+const char *const *xine_list_audio_decoder_plugins(xine_t *self) XINE_PROTECTED;
+const char *const *xine_list_video_decoder_plugins(xine_t *self) XINE_PROTECTED;
+
+/* unload unused plugins */
+void xine_plugins_garbage_collector(xine_t *self) XINE_PROTECTED;
+
+
+/*********************************************************************
+ * visual specific gui <-> xine engine communication                 *
+ *********************************************************************/
+
+#ifndef XINE_DISABLE_DEPRECATED_FEATURES
+/* talk to video output driver - old method */
+int    xine_gui_send_vo_data (xine_stream_t *self,
+			      int type, void *data) XINE_PROTECTED XINE_DEPRECATED;
+#endif
+
+/* new (preferred) method to talk to video driver. */
+int    xine_port_send_gui_data (xine_video_port_t *vo,
+			        int type, void *data) XINE_PROTECTED;
+
+typedef struct {
+
+  /* area of that drawable to be used by video */
+  int      x,y,w,h;
+
+} x11_rectangle_t;
+
+/*
+ * this is the visual data struct any x11 gui
+ * must supply to the xine_open_video_driver call
+ * ("data" parameter)
+ */
+typedef struct {
+
+  /* some information about the display */
+  void             *display; /* Display* */
+  int               screen;
+
+  /* drawable to display the video in/on */
+  unsigned long     d; /* Drawable */
+
+  void             *user_data;
+
+  /*
+   * dest size callback
+   *
+   * this will be called by the video driver to find out
+   * how big the video output area size will be for a
+   * given video size. The ui should _not_ adjust its
+   * video out area, just do some calculations and return
+   * the size. This will be called for every frame, ui
+   * implementation should be fast.
+   * dest_pixel_aspect should be set to the used display pixel aspect.
+   * NOTE: Semantics has changed: video_width and video_height
+   * are no longer pixel aspect corrected. Get the old semantics
+   * in the UI with
+   *   *dest_pixel_aspect = display_pixel_aspect;
+   *   if (video_pixel_aspect >= display_pixel_aspect)
+   *     video_width  = video_width * video_pixel_aspect / display_pixel_aspect + .5;
+   *   else
+   *     video_height = video_height * display_pixel_aspect / video_pixel_aspect + .5;
+   */
+  void (*dest_size_cb) (void *user_data,
+			int video_width, int video_height,
+			double video_pixel_aspect,
+			int *dest_width, int *dest_height,
+			double *dest_pixel_aspect);
+
+  /*
+   * frame output callback
+   *
+   * this will be called by the video driver for every frame
+   * it's about to draw. ui can adapt its size if necessary
+   * here.
+   * note: the ui doesn't have to adjust itself to this
+   * size, this is just to be taken as a hint.
+   * ui must return the actual size of the video output
+   * area and the video output driver will do its best
+   * to adjust the video frames to that size (while
+   * preserving aspect ratio and stuff).
+   *    dest_x, dest_y: offset inside window
+   *    dest_width, dest_height: available drawing space
+   *    dest_pixel_aspect: display pixel aspect
+   *    win_x, win_y: window absolute screen position
+   * NOTE: Semantics has changed: video_width and video_height
+   * are no longer pixel aspect corrected. Get the old semantics
+   * in the UI with
+   *   *dest_pixel_aspect = display_pixel_aspect;
+   *   if (video_pixel_aspect >= display_pixel_aspect)
+   *     video_width  = video_width * video_pixel_aspect / display_pixel_aspect + .5;
+   *   else
+   *     video_height = video_height * display_pixel_aspect / video_pixel_aspect + .5;
+   */
+  void (*frame_output_cb) (void *user_data,
+			   int video_width, int video_height,
+			   double video_pixel_aspect,
+			   int *dest_x, int *dest_y,
+			   int *dest_width, int *dest_height,
+			   double *dest_pixel_aspect,
+			   int *win_x, int *win_y);
+
+  /*
+   * lock display callback
+   *
+   * this callback is called when the video driver
+   * needs access to the x11 display connection
+   *
+   * note: to enable this you MUST use XINE_VISUAL_TYPE_X11_2
+   * note: if display_lock is NULL, the fallback is used
+   * note: fallback for this function is XLockDisplay(display)
+   */
+   void (*lock_display) (void *user_data);
+
+  /*
+   * unlock display callback
+   *
+   * this callback is called when the video driver
+   * doesn't need access to the x11 display connection anymore
+   *
+   * note: to enable this you MUST use XINE_VISUAL_TYPE_X11_2
+   * note: if display_unlock is NULL, the fallback is used
+   * note: fallback for this function is XUnlockDisplay(display)
+   */
+   void (*unlock_display) (void *user_data);
+
+} x11_visual_t;
+
+/*
+ * this is the visual data struct any xcb gui
+ * must supply to the xine_open_video_driver call
+ * ("data" parameter)
+ */
+typedef struct {
+
+  /* some information about the display */
+  void        *connection; /* xcb_connection_t */
+  void        *screen;     /* xcb_screen_t     */
+
+  /* window to display the video in / on */
+  unsigned int window; /* xcb_window_t */
+
+  void        *user_data;
+
+  /*
+   * dest size callback
+   *
+   * this will be called by the video driver to find out
+   * how big the video output area size will be for a
+   * given video size. The ui should _not_ adjust its
+   * video out area, just do some calculations and return
+   * the size. This will be called for every frame, ui
+   * implementation should be fast.
+   * dest_pixel_aspect should be set to the used display pixel aspect.
+   * NOTE: Semantics has changed: video_width and video_height
+   * are no longer pixel aspect corrected. Get the old semantics
+   * in the UI with
+   *   *dest_pixel_aspect = display_pixel_aspect;
+   *   if (video_pixel_aspect >= display_pixel_aspect)
+   *     video_width  = video_width * video_pixel_aspect / display_pixel_aspect + .5;
+   *   else
+   *     video_height = video_height * display_pixel_aspect / video_pixel_aspect + .5;
+   */
+  void (*dest_size_cb) (void *user_data,
+			int video_width, int video_height,
+			double video_pixel_aspect,
+			int *dest_width, int *dest_height,
+			double *dest_pixel_aspect);
+
+  /*
+   * frame output callback
+   *
+   * this will be called by the video driver for every frame
+   * it's about to draw. ui can adapt its size if necessary
+   * here.
+   * note: the ui doesn't have to adjust itself to this
+   * size, this is just to be taken as a hint.
+   * ui must return the actual size of the video output
+   * area and the video output driver will do its best
+   * to adjust the video frames to that size (while
+   * preserving aspect ratio and stuff).
+   *    dest_x, dest_y: offset inside window
+   *    dest_width, dest_height: available drawing space
+   *    dest_pixel_aspect: display pixel aspect
+   *    win_x, win_y: window absolute screen position
+   * NOTE: Semantics has changed: video_width and video_height
+   * are no longer pixel aspect corrected. Get the old semantics
+   * in the UI with
+   *   *dest_pixel_aspect = display_pixel_aspect;
+   *   if (video_pixel_aspect >= display_pixel_aspect)
+   *     video_width  = video_width * video_pixel_aspect / display_pixel_aspect + .5;
+   *   else
+   *     video_height = video_height * display_pixel_aspect / video_pixel_aspect + .5;
+   */
+  void (*frame_output_cb) (void *user_data,
+			   int video_width, int video_height,
+			   double video_pixel_aspect,
+			   int *dest_x, int *dest_y,
+			   int *dest_width, int *dest_height,
+			   double *dest_pixel_aspect,
+			   int *win_x, int *win_y);
+
+} xcb_visual_t;
+
+/**************************************************
+ * XINE_VO_RAW struct definitions
+ *************************************************/
+/*  frame_format definitions */
+#define XINE_VORAW_YV12 1
+#define XINE_VORAW_YUY2 2
+#define XINE_VORAW_RGB 4
+
+/*  maximum number of overlays the raw driver can handle */
+#define XINE_VORAW_MAX_OVL 16
+
+/* raw_overlay_t struct used in raw_overlay_cb callback */
+typedef struct {
+  uint8_t *ovl_rgba;
+  int ovl_w, ovl_h; /* overlay's width and height */
+  int ovl_x, ovl_y; /* overlay's top-left display position */
+} raw_overlay_t;
+
+/* this is the visual data struct any raw gui
+ * must supply to the xine_open_video_driver call
+ * ("data" parameter)
+ */
+typedef struct {
+  void *user_data;
+
+  /* OR'ed frame_format
+   * Unsupported frame formats are converted to rgb.
+   * XINE_VORAW_RGB is always assumed by the driver, even if not set.
+   * So a frontend must at least support rgb.
+   * Be aware that rgb requires more cpu than yuv,
+   * so avoid its usage for video playback.
+   * However, it's useful for single frame capture (e.g. thumbs)
+   */
+  int supported_formats;
+
+  /* raw output callback
+   * this will be called by the video driver for every frame
+   *
+   * If frame_format==XINE_VORAW_YV12, data0 points to frame_width*frame_height Y values
+   *                                   data1 points to (frame_width/2)*(frame_height/2) U values
+   *                                   data2 points to (frame_width/2)*(frame_height/2) V values
+   *
+   * If frame_format==XINE_VORAW_YUY2, data0 points to frame_width*frame_height*2 YU/Y²V values
+   *                                   data1 is NULL
+   *                                   data2 is NULL
+   *
+   * If frame_format==XINE_VORAW_RGB, data0 points to frame_width*frame_height*3 RGB values
+   *                                  data1 is NULL
+   *                                  data2 is NULL
+   */
+  void (*raw_output_cb) (void *user_data, int frame_format,
+                        int frame_width, int frame_height,
+			double frame_aspect,
+			void *data0, void *data1, void *data2);
+
+  /* raw overlay callback
+   * this will be called by the video driver for every new overlay state
+   * overlays_array points to an array of num_ovl raw_overlay_t
+   * Note that num_ovl can be 0, meaning "end of overlay display"
+   * num_ovl is at most XINE_VORAW_MAX_OVL */
+  void (*raw_overlay_cb) (void *user_data, int num_ovl,
+                         raw_overlay_t *overlays_array);
+} raw_visual_t;
+/**********************************************
+ * end of vo_raw defs
+ *********************************************/
+
+/*
+ * this is the visual data struct any fb gui
+ * may supply to the xine_open_video_driver call
+ * ("data" parameter) to get frame_output_cd calls
+ */
+
+typedef struct {
+
+ void (*frame_output_cb) (void *user_data,
+			   int video_width, int video_height,
+			   double video_pixel_aspect,
+			   int *dest_x, int *dest_y,
+			   int *dest_width, int *dest_height,
+			   double *dest_pixel_aspect,
+			   int *win_x, int *win_y);
+
+  void             *user_data;
+
+} fb_visual_t;
+
+#ifdef WIN32
+/*
+ * this is the visual data struct any win32 gui should supply
+ * (pass this to init_video_out_plugin or the xine_load_video_output_plugin
+ * utility function)
+ */
+
+typedef struct {
+
+  HWND      WndHnd;     /* handle of window associated with primary surface */
+  HINSTANCE HInst;      /* handle of windows application instance */
+  RECT      WndRect;    /* rect of window client points translated to screen 
+                         * cooridnates */
+  int       FullScreen; /* is window fullscreen */
+  HBRUSH    Brush;      /* window brush for background color */
+  COLORREF  ColorKey;   /* window brush color key */
+
+} win32_visual_t;
+
+/*
+ * constants for gui_data_exchange's data_type parameter
+ */
+
+#define GUI_WIN32_MOVED_OR_RESIZED	0
+
+#endif /* WIN32 */
+
+/*
+ * "type" constants for xine_port_send_gui_data(...)
+ */
+
+#ifndef XINE_DISABLE_DEPRECATED_FEATURES
+/* xevent *data */
+#define XINE_GUI_SEND_COMPLETION_EVENT       1 /* DEPRECATED */
+#endif
+
+/* Drawable data */
+#define XINE_GUI_SEND_DRAWABLE_CHANGED       2
+
+/* xevent *data */
+#define XINE_GUI_SEND_EXPOSE_EVENT           3
+
+/* x11_rectangle_t *data */
+#define XINE_GUI_SEND_TRANSLATE_GUI_TO_VIDEO 4
+
+/* int data */
+#define XINE_GUI_SEND_VIDEOWIN_VISIBLE	     5
+
+/* *data contains chosen visual, select a new one or change it to NULL
+ * to indicate the visual to use or that no visual will work */
+/* XVisualInfo **data */
+#define XINE_GUI_SEND_SELECT_VISUAL          8
+
+/* Gui is about to destroy drawable */
+#define XINE_GUI_SEND_WILL_DESTROY_DRAWABLE  9
+
+
+/*********************************************************************
+ * xine health check stuff                                           *
+ *********************************************************************/
+
+#define XINE_HEALTH_CHECK_OK            0
+#define XINE_HEALTH_CHECK_FAIL          1
+#define XINE_HEALTH_CHECK_UNSUPPORTED   2
+#define XINE_HEALTH_CHECK_NO_SUCH_CHECK 3
+
+#define CHECK_KERNEL    0
+#define CHECK_MTRR      1
+#define CHECK_CDROM     2
+#define CHECK_DVDROM    3
+#define CHECK_DMA       4
+#define CHECK_X         5
+#define CHECK_XV        6
+
+struct xine_health_check_s {
+  int         status;
+  const char* cdrom_dev;
+  const char* dvd_dev;
+  char*       msg;
+  char*       title;
+  char*       explanation;
+};
+
+typedef struct xine_health_check_s xine_health_check_t;
+xine_health_check_t* xine_health_check(xine_health_check_t*, int check_num) XINE_PROTECTED;
+
+
+/*********************************************************************
+ * configuration system                                              *
+ *********************************************************************/
+
+/*
+ * config entry data types
+ */
+
+#define XINE_CONFIG_TYPE_UNKNOWN 0
+#define XINE_CONFIG_TYPE_RANGE   1
+#define XINE_CONFIG_TYPE_STRING  2
+#define XINE_CONFIG_TYPE_ENUM    3
+#define XINE_CONFIG_TYPE_NUM     4
+#define XINE_CONFIG_TYPE_BOOL    5
+
+/* For the string type (1.1.4 and later). These are stored in num_value. */ 
+#define XINE_CONFIG_STRING_IS_STRING		0
+#define XINE_CONFIG_STRING_IS_FILENAME		1
+#define XINE_CONFIG_STRING_IS_DEVICE_NAME	2
+#define XINE_CONFIG_STRING_IS_DIRECTORY_NAME	3
+
+typedef struct xine_cfg_entry_s xine_cfg_entry_t;
+
+typedef void (*xine_config_cb_t) (void *user_data,
+				  xine_cfg_entry_t *entry);
+struct xine_cfg_entry_s {
+  const char      *key;     /* unique id (example: gui.logo_mrl) */
+
+  int              type;
+
+  /* type unknown */
+  char            *unknown_value;
+
+  /* type string */
+  char            *str_value;
+  char            *str_default;
+#ifndef XINE_DISABLE_DEPRECATED_FEATURES
+  char            *str_sticky;
+#else
+  void            *dummy;
+#endif
+
+  /* common to range, enum, num, bool;
+   * num_value is also used by string to indicate what's required:
+   * plain string, file name, device name, directory name
+   */
+  int              num_value;
+  int              num_default;
+
+  /* type range specific: */
+  int              range_min;
+  int              range_max;
+
+  /* type enum specific: */
+  char           **enum_values;
+
+  /* help info for the user (UTF-8)
+   * the help string must be word wrapped by the frontend.
+   * it might contain \n to mark paragraph breaks.
+   */
+  const char      *description;
+  const char      *help;
+
+  /* user experience level */
+  int              exp_level; /* 0 => beginner,
+			        10 => advanced user,
+			        20 => expert */
+
+  /* callback function and data for live changeable values */
+  /* some config entries will take effect immediately, although they
+   * do not have a callback registered; such values will have some
+   * non-NULL dummy value in callback_data; so if you want to check,
+   * if a config change will require restarting xine, check for
+   * callback_data == NULL */
+  xine_config_cb_t callback;
+  void            *callback_data;
+
+};
+
+const char *xine_config_register_string (xine_t *self,
+					 const char *key,
+					 const char *def_value,
+					 const char *description,
+					 const char *help,
+					 int   exp_level,
+					 xine_config_cb_t changed_cb,
+					 void *cb_data) XINE_PROTECTED;
+
+const char *xine_config_register_filename (xine_t *self,
+					   const char *key,
+					   const char *def_value,
+					   int req_type, /* XINE_CONFIG_STRING_IS_* */
+					   const char *description,
+					   const char *help,
+					   int   exp_level,
+					   xine_config_cb_t changed_cb,
+					   void *cb_data) XINE_PROTECTED;
+
+int   xine_config_register_range  (xine_t *self,
+				   const char *key,
+				   int def_value,
+				   int min, int max,
+				   const char *description,
+				   const char *help,
+				   int   exp_level,
+				   xine_config_cb_t changed_cb,
+				   void *cb_data) XINE_PROTECTED;
+
+int   xine_config_register_enum   (xine_t *self,
+				   const char *key,
+				   int def_value,
+				   char **values,
+				   const char *description,
+				   const char *help,
+				   int   exp_level,
+				   xine_config_cb_t changed_cb,
+				   void *cb_data) XINE_PROTECTED;
+
+int   xine_config_register_num    (xine_t *self,
+				   const char *key,
+				   int def_value,
+				   const char *description,
+				   const char *help,
+				   int   exp_level,
+				   xine_config_cb_t changed_cb,
+				   void *cb_data) XINE_PROTECTED;
+
+int   xine_config_register_bool   (xine_t *self,
+				   const char *key,
+				   int def_value,
+				   const char *description,
+				   const char *help,
+				   int   exp_level,
+				   xine_config_cb_t changed_cb,
+				   void *cb_data) XINE_PROTECTED;
+
+/*
+ * the following functions will copy data from the internal xine_config
+ * data database to the xine_cfg_entry_t *entry you provide
+ *
+ * they return 1 on success, 0 on failure
+ */
+
+/* get first config item */
+int  xine_config_get_first_entry (xine_t *self, xine_cfg_entry_t *entry) XINE_PROTECTED;
+
+/* get next config item (iterate through the items) */
+int  xine_config_get_next_entry (xine_t *self, xine_cfg_entry_t *entry) XINE_PROTECTED;
+
+/* search for a config entry by key */
+int  xine_config_lookup_entry (xine_t *self, const char *key,
+			       xine_cfg_entry_t *entry) XINE_PROTECTED;
+
+/*
+ * update a config entry (which was returned from lookup_entry() )
+ *
+ * xine will make a deep copy of the data in the entry into its internal
+ * config database.
+ */
+void xine_config_update_entry (xine_t *self,
+			       const xine_cfg_entry_t *entry) XINE_PROTECTED;
+
+/*
+ * translation of old configuration entry names
+ */
+typedef struct {
+  const char *old_name, *new_name;
+} xine_config_entry_translation_t;
+
+void xine_config_set_translation_user (const xine_config_entry_translation_t *) XINE_PROTECTED;
+
+/*
+ * load/save config data from/to afile (e.g. $HOME/.xine/config)
+ */
+void xine_config_load  (xine_t *self, const char *cfg_filename) XINE_PROTECTED;
+void xine_config_save  (xine_t *self, const char *cfg_filename) XINE_PROTECTED;
+void xine_config_reset (xine_t *self) XINE_PROTECTED;
+
+
+/*********************************************************************
+ * asynchroneous xine event mechanism                                *
+ *********************************************************************/
+
+/*
+ * to receive events you have to register an event queue with
+ * the xine engine (xine_event_new_queue, see below).
+ *
+ * then you can either
+ * 1) check for incoming events regularly (xine_event_get/wait),
+ *    process them and free them using xine_event_free
+ * 2) use xine_event_create_listener_thread and specify a callback
+ *    which will then be called for each event
+ *
+ * to send events to every module listening you don't need
+ * to register an event queue but simply call xine_event_send.
+ *
+ * front ends should listen for one of MRL_REFERENCE and MRL_REFERENCE_EXT
+ * since both will be sent for compatibility reasons
+ */
+
+/* event types */
+#define XINE_EVENT_UI_PLAYBACK_FINISHED   1 /* frontend can e.g. move on to next playlist entry */
+#define XINE_EVENT_UI_CHANNELS_CHANGED    2 /* inform ui that new channel info is available */
+#define XINE_EVENT_UI_SET_TITLE           3 /* request title display change in ui */
+#define XINE_EVENT_UI_MESSAGE             4 /* message (dialog) for the ui to display */
+#define XINE_EVENT_FRAME_FORMAT_CHANGE    5 /* e.g. aspect ratio change during dvd playback */
+#define XINE_EVENT_AUDIO_LEVEL            6 /* report current audio level (l/r/mute) */
+#define XINE_EVENT_QUIT                   7 /* last event sent when stream is disposed */
+#define XINE_EVENT_PROGRESS               8 /* index creation/network connections */
+#define XINE_EVENT_MRL_REFERENCE          9 /* (deprecated) demuxer->frontend: MRL reference(s) for the real stream */
+#define XINE_EVENT_UI_NUM_BUTTONS        10 /* number of buttons for interactive menus */
+#define XINE_EVENT_SPU_BUTTON            11 /* the mouse pointer enter/leave a button */
+#define XINE_EVENT_DROPPED_FRAMES        12 /* number of dropped frames is too high */
+#define XINE_EVENT_MRL_REFERENCE_EXT     13 /* demuxer->frontend: MRL reference(s) for the real stream */
+#define XINE_EVENT_AUDIO_AMP_LEVEL       14 /* report current audio amp level (l/r/mute) */
+
+
+/* input events coming from frontend */
+#define XINE_EVENT_INPUT_MOUSE_BUTTON   101
+#define XINE_EVENT_INPUT_MOUSE_MOVE     102
+#define XINE_EVENT_INPUT_MENU1          103
+#define XINE_EVENT_INPUT_MENU2          104
+#define XINE_EVENT_INPUT_MENU3          105
+#define XINE_EVENT_INPUT_MENU4          106
+#define XINE_EVENT_INPUT_MENU5          107
+#define XINE_EVENT_INPUT_MENU6          108
+#define XINE_EVENT_INPUT_MENU7          109
+#define XINE_EVENT_INPUT_UP             110
+#define XINE_EVENT_INPUT_DOWN           111
+#define XINE_EVENT_INPUT_LEFT           112
+#define XINE_EVENT_INPUT_RIGHT          113
+#define XINE_EVENT_INPUT_SELECT         114
+#define XINE_EVENT_INPUT_NEXT           115
+#define XINE_EVENT_INPUT_PREVIOUS       116
+#define XINE_EVENT_INPUT_ANGLE_NEXT     117
+#define XINE_EVENT_INPUT_ANGLE_PREVIOUS 118
+#define XINE_EVENT_INPUT_BUTTON_FORCE   119
+#define XINE_EVENT_INPUT_NUMBER_0       120
+#define XINE_EVENT_INPUT_NUMBER_1       121
+#define XINE_EVENT_INPUT_NUMBER_2       122
+#define XINE_EVENT_INPUT_NUMBER_3       123
+#define XINE_EVENT_INPUT_NUMBER_4       124
+#define XINE_EVENT_INPUT_NUMBER_5       125
+#define XINE_EVENT_INPUT_NUMBER_6       126
+#define XINE_EVENT_INPUT_NUMBER_7       127
+#define XINE_EVENT_INPUT_NUMBER_8       128
+#define XINE_EVENT_INPUT_NUMBER_9       129
+#define XINE_EVENT_INPUT_NUMBER_10_ADD  130
+
+/* specific event types */
+#define XINE_EVENT_SET_V4L2             200
+#define XINE_EVENT_PVR_SAVE             201
+#define XINE_EVENT_PVR_REPORT_NAME      202
+#define XINE_EVENT_PVR_REALTIME         203
+#define XINE_EVENT_PVR_PAUSE            204
+#define XINE_EVENT_SET_MPEG_DATA        205
+
+/* VDR specific event types */
+#define XINE_EVENT_VDR_RED              300
+#define XINE_EVENT_VDR_GREEN            301
+#define XINE_EVENT_VDR_YELLOW           302
+#define XINE_EVENT_VDR_BLUE             303
+#define XINE_EVENT_VDR_PLAY             304
+#define XINE_EVENT_VDR_PAUSE            305
+#define XINE_EVENT_VDR_STOP             306
+#define XINE_EVENT_VDR_RECORD           307
+#define XINE_EVENT_VDR_FASTFWD          308
+#define XINE_EVENT_VDR_FASTREW          309
+#define XINE_EVENT_VDR_POWER            310
+#define XINE_EVENT_VDR_CHANNELPLUS      311
+#define XINE_EVENT_VDR_CHANNELMINUS     312
+#define XINE_EVENT_VDR_SCHEDULE         313
+#define XINE_EVENT_VDR_CHANNELS         314
+#define XINE_EVENT_VDR_TIMERS           315
+#define XINE_EVENT_VDR_RECORDINGS       316
+#define XINE_EVENT_VDR_SETUP            317
+#define XINE_EVENT_VDR_COMMANDS         318
+#define XINE_EVENT_VDR_BACK             319
+#define XINE_EVENT_VDR_USER1            320
+#define XINE_EVENT_VDR_USER2            321
+#define XINE_EVENT_VDR_USER3            322
+#define XINE_EVENT_VDR_USER4            323
+#define XINE_EVENT_VDR_USER5            324
+#define XINE_EVENT_VDR_USER6            325
+#define XINE_EVENT_VDR_USER7            326
+#define XINE_EVENT_VDR_USER8            327
+#define XINE_EVENT_VDR_USER9            328
+#define XINE_EVENT_VDR_VOLPLUS          329
+#define XINE_EVENT_VDR_VOLMINUS         330
+#define XINE_EVENT_VDR_MUTE             331
+#define XINE_EVENT_VDR_AUDIO            332
+#define XINE_EVENT_VDR_INFO             333
+#define XINE_EVENT_VDR_CHANNELPREVIOUS  334
+#define XINE_EVENT_VDR_SUBTITLES        335
+/* some space for further keys */
+#define XINE_EVENT_VDR_SETVIDEOWINDOW   350
+#define XINE_EVENT_VDR_FRAMESIZECHANGED 351
+#define XINE_EVENT_VDR_SELECTAUDIO      352
+#define XINE_EVENT_VDR_TRICKSPEEDMODE   353
+#define XINE_EVENT_VDR_PLUGINSTARTED    354
+#define XINE_EVENT_VDR_DISCONTINUITY    355
+
+/* events generated from post plugins */
+#define XINE_EVENT_POST_TVTIME_FILMMODE_CHANGE   400
+
+/*
+ * xine event struct
+ */
+typedef struct {
+  int                              type;   /* event type (constants see above) */
+  xine_stream_t                   *stream; /* stream this event belongs to     */
+
+  void                            *data;   /* contents depending on type */
+  int                              data_length;
+
+  /* you do not have to provide this, it will be filled in by xine_event_send() */
+  struct timeval                   tv;     /* timestamp of event creation */
+} xine_event_t;
+
+/*
+ * input event dynamic data
+ */
+typedef struct {
+  xine_event_t        event;
+  uint8_t             button; /* Generally 1 = left, 2 = mid, 3 = right */
+  uint16_t            x,y;    /* In Image space */
+} xine_input_data_t;
+
+/*
+ * UI event dynamic data - send information to/from UI.
+ */
+typedef struct {
+  int                 num_buttons;
+  int                 str_len;
+  char                str[256]; /* might be longer */
+} xine_ui_data_t;
+
+/*
+ * Send messages to UI. used mostly to report errors.
+ */
+typedef struct {
+  /*
+   * old xine-ui versions expect xine_ui_data_t type.
+   * this struct is added for compatibility.
+   */
+  xine_ui_data_t      compatibility;
+
+  /* See XINE_MSG_xxx for defined types. */
+  int                 type;
+
+  /* defined types are provided with a standard explanation.
+   * note: zero means no explanation.
+   */
+  int                 explanation; /* add to struct address to get a valid (char *) */
+
+  /* parameters are zero terminated strings */
+  int                 num_parameters;
+  int                 parameters;  /* add to struct address to get a valid (char *) */
+
+  /* where messages are stored, will be longer
+   *
+   * this field begins with the message text itself (\0-terminated),
+   * followed by (optional) \0-terminated parameter strings
+   * the end marker is \0 \0
+   */
+  char                messages[1];
+} xine_ui_message_data_t;
+
+
+/*
+ * notify frame format change
+ */
+typedef struct {
+  int                 width;
+  int                 height;
+  /* these are aspect codes as defined in MPEG2, because this
+   * is only used for DVD playback, pan_scan is a boolean flag */
+  int                 aspect;
+  int                 pan_scan;
+} xine_format_change_data_t;
+
+/*
+ * audio level for left/right channel
+ */
+typedef struct {
+  int                 left;
+  int                 right;  /* 0..100 % */
+  int                 mute;
+} xine_audio_level_data_t;
+
+/*
+ * index generation / buffering
+ */
+typedef struct {
+  const char         *description; /* e.g. "connecting..." */
+  int                 percent;
+} xine_progress_data_t;
+
+/*
+ * mrl reference data is sent by demuxers when a reference stream is found.
+ * this stream just contains pointers (urls) to the real data, which are
+ * passed to frontend using this event type. (examples: .asx, .mov and .ram)
+ * 
+ * ideally, frontends should add these mrls to a "hierarchical playlist". 
+ * that is, instead of the original file, the ones provided here should be
+ * played instead. on pratice, just using a simple playlist should work.
+ *
+ * mrl references should be played in the same order they are received, just
+ * after the current stream finishes.
+ * alternative entries may be provided and should be used in case of
+ * failure of the primary stream (the one with alternative=0).
+ *
+ * sample playlist:
+ *   1) http://something/something.ram
+ *     1a) rtsp://something/realsomething1.rm (alternative=0)
+ *     1b) pnm://something/realsomething1.rm (alternative=1)
+ *   2) http://another/another.avi
+ *
+ * 1 and 2 are the original items on this playlist. 1a and 1b were received
+ * by events (they are the mrl references enclosed in 1). 1a is played after 
+ * receiving the finished event from 1. note: 1b is usually ignored, it should
+ * only be used in case 1a fails to open.
+ *
+ * An event listener which accepts XINE_EVENT_MRL_REFERENCE_EXT events
+ * *must* ignore XINE_EVENT_MRL_REFERENCE events.
+ */
+typedef struct {
+  int                 alternative; /* alternative playlist number, usually 0 */
+  char                mrl[1]; /* might (will) be longer */
+} xine_mrl_reference_data_t XINE_DEPRECATED;
+
+typedef struct {
+  int                 alternative; /* as above */
+  uint32_t            start_time, duration; /* milliseconds */
+  uint32_t            spare[20]; /* for future expansion */
+  const char          mrl[1]; /* might (will) be longer */
+/*const char          title[]; ** immediately follows MRL's terminating NUL */
+} xine_mrl_reference_data_ext_t;
+
+/* 
+ * configuration options for video4linux-like input plugins
+ */
+typedef struct {
+  /* input selection */
+  int input;                    /* select active input from card */ 
+  int channel;                  /* channel number */
+  int radio;                    /* ask for a radio channel */
+  uint32_t frequency;           /* frequency divided by 62.5KHz or 62.5 Hz */
+  uint32_t transmission;        /* The transmission standard. */
+
+  /* video parameters */
+  uint32_t framerate_numerator; /* framerate as numerator/denominator */
+  uint32_t framerate_denominator;
+  uint32_t framelines;          /* Total lines per frame including blanking */
+  uint64_t standard_id;         /* One of the V4L2_STD_* values */
+  uint32_t colorstandard;       /* One of the V4L2_COLOR_STD_* values */
+  uint32_t colorsubcarrier;     /* The color subcarrier frequency */
+  int frame_width;              /* scaled frame width */
+  int frame_height;             /* scaled frame height */
+
+  /* let some spare space so we can add new fields without breaking
+   * binary api compatibility. 
+   */
+  uint32_t spare[20];
+
+  /* used by pvr plugin */
+  int32_t session_id;           /* -1 stops pvr recording */
+     
+} xine_set_v4l2_data_t;
+
+/*
+ * configuration options for plugins that can do a kind of mpeg encoding
+ * note: highly experimental api :)
+ */
+typedef struct {
+
+  /* mpeg2 parameters */
+  int bitrate_vbr;              /* 1 = vbr, 0 = cbr */
+  int bitrate_mean;             /* mean (target) bitrate in kbps*/
+  int bitrate_peak;             /* peak (max) bitrate in kbps */
+  int gop_size;                 /* GOP size in frames */
+  int gop_closure;              /* open/closed GOP */
+  int b_frames;                 /* number of B frames to use */
+  int aspect_ratio;             /* XINE_VO_ASPECT_xxx */
+  
+  /* let some spare space so we can add new fields without breaking
+   * binary api compatibility.
+   */
+  uint32_t spare[20];
+
+} xine_set_mpeg_data_t;
+
+typedef struct {
+  int                 direction; /* 0 leave, 1 enter */
+  int32_t             button; /* button number */
+} xine_spu_button_t;
+
+#ifdef XINE_ENABLE_EXPERIMENTAL_FEATURES
+
+/* 
+ * ask pvr to save (ie. do not discard) the current session
+ * see comments on input_pvr.c to understand how it works.
+ */
+typedef struct {
+  /* mode values:
+   * -1 = do nothing, just set the name
+   * 0 = truncate current session and save from now on
+   * 1 = save from last sync point
+   * 2 = save everything on current session
+   */
+  int mode; 
+  int id;
+  char name[256]; /* name for saving, might be longer */
+} xine_pvr_save_data_t;
+
+typedef struct {
+  /* mode values:
+   * 0 = non realtime
+   * 1 = realtime
+   */
+  int mode; 
+} xine_pvr_realtime_t;
+
+typedef struct {
+  /* mode values:
+   * 0 = playing
+   * 1 = paused
+   */
+  int mode;
+} xine_pvr_pause_t;
+
+#endif
+
+/* event XINE_EVENT_DROPPED_FRAMES is generated if libxine detects a
+ * high number of dropped frames (above configured thresholds). it can
+ * be used by the front end to warn about performance problems.
+ */
+typedef struct {
+  /* these values are given for 1000 frames delivered */
+  /* (that is, divide by 10 to get percentages) */
+  int skipped_frames;
+  int skipped_threshold;
+  int discarded_frames;
+  int discarded_threshold;
+} xine_dropped_frames_t;
+
+
+/*
+ * Defined message types for XINE_EVENT_UI_MESSAGE
+ * This is the mechanism to report async errors from engine.
+ *
+ * If frontend knows about the XINE_MSG_xxx type it may safely 
+ * ignore the 'explanation' field and provide its own custom
+ * dialogue to the 'parameters'.
+ *
+ * right column specifies the usual parameters.
+ */
+
+#define XINE_MSG_NO_ERROR		0  /* (messages to UI)   */
+#define XINE_MSG_GENERAL_WARNING	1  /* (warning message)  */
+#define XINE_MSG_UNKNOWN_HOST		2  /* (host name)        */
+#define XINE_MSG_UNKNOWN_DEVICE		3  /* (device name)      */
+#define XINE_MSG_NETWORK_UNREACHABLE	4  /* none               */
+#define XINE_MSG_CONNECTION_REFUSED	5  /* (host name)        */
+#define XINE_MSG_FILE_NOT_FOUND		6  /* (file name or mrl) */
+#define XINE_MSG_READ_ERROR		7  /* (device/file/mrl)  */
+#define XINE_MSG_LIBRARY_LOAD_ERROR	8  /* (library/decoder)  */
+#define XINE_MSG_ENCRYPTED_SOURCE	9  /* none               */
+#define XINE_MSG_SECURITY		10 /* (security message) */
+#define XINE_MSG_AUDIO_OUT_UNAVAILABLE	11 /* none               */
+#define XINE_MSG_PERMISSION_ERROR       12 /* (file name or mrl) */
+#define XINE_MSG_FILE_EMPTY             13 /* file is empty      */
+
+/* opaque xine_event_queue_t */
+typedef struct xine_event_queue_s xine_event_queue_t;
+
+/*
+ * register a new event queue
+ *
+ * you have to receive messages from this queue regularly
+ *
+ * use xine_event_dispose_queue to unregister and free the queue
+ */
+xine_event_queue_t *xine_event_new_queue (xine_stream_t *stream) XINE_PROTECTED;
+void xine_event_dispose_queue (xine_event_queue_t *queue) XINE_PROTECTED;
+
+/*
+ * receive events (poll)
+ *
+ * use xine_event_free on the events received from these calls
+ * when they're no longer needed
+ */
+xine_event_t *xine_event_get  (xine_event_queue_t *queue) XINE_PROTECTED;
+xine_event_t *xine_event_wait (xine_event_queue_t *queue) XINE_PROTECTED;
+void          xine_event_free (xine_event_t *event) XINE_PROTECTED;
+
+/*
+ * receive events (callback)
+ *
+ * a thread is created which will receive all events from
+ * the specified queue, call your callback on each of them
+ * and will then free the event when your callback returns
+ *
+ */
+typedef void (*xine_event_listener_cb_t) (void *user_data,
+					  const xine_event_t *event);
+void xine_event_create_listener_thread (xine_event_queue_t *queue,
+					xine_event_listener_cb_t callback,
+					void *user_data) XINE_PROTECTED;
+
+/*
+ * send an event to all queues
+ *
+ * the event will be copied so you can free or reuse
+ * *event as soon as xine_event_send returns.
+ */
+void xine_event_send (xine_stream_t *stream, const xine_event_t *event) XINE_PROTECTED;
+
+
+/*********************************************************************
+ * OSD (on screen display)                                           *
+ *********************************************************************/
+
+#define XINE_TEXT_PALETTE_SIZE 11
+
+#define XINE_OSD_TEXT1  (0 * XINE_TEXT_PALETTE_SIZE)
+#define XINE_OSD_TEXT2  (1 * XINE_TEXT_PALETTE_SIZE)
+#define XINE_OSD_TEXT3  (2 * XINE_TEXT_PALETTE_SIZE)
+#define XINE_OSD_TEXT4  (3 * XINE_TEXT_PALETTE_SIZE)
+#define XINE_OSD_TEXT5  (4 * XINE_TEXT_PALETTE_SIZE)
+#define XINE_OSD_TEXT6  (5 * XINE_TEXT_PALETTE_SIZE)
+#define XINE_OSD_TEXT7  (6 * XINE_TEXT_PALETTE_SIZE)
+#define XINE_OSD_TEXT8  (7 * XINE_TEXT_PALETTE_SIZE)
+#define XINE_OSD_TEXT9  (8 * XINE_TEXT_PALETTE_SIZE)
+#define XINE_OSD_TEXT10 (9 * XINE_TEXT_PALETTE_SIZE)
+
+/* white text, black border, transparent background  */
+#define XINE_TEXTPALETTE_WHITE_BLACK_TRANSPARENT    0
+/* white text, noborder, transparent background      */
+#define XINE_TEXTPALETTE_WHITE_NONE_TRANSPARENT     1
+/* white text, no border, translucid background      */
+#define XINE_TEXTPALETTE_WHITE_NONE_TRANSLUCID      2
+/* yellow text, black border, transparent background */
+#define XINE_TEXTPALETTE_YELLOW_BLACK_TRANSPARENT   3
+
+#define XINE_OSD_CAP_FREETYPE2 0x0001 /* freetype2 support compiled in     */
+#define XINE_OSD_CAP_UNSCALED  0x0002 /* unscaled overlays supp. by vo drv */
+
+typedef struct xine_osd_s xine_osd_t;
+
+xine_osd_t *xine_osd_new           (xine_stream_t *self, int x, int y,
+				    int width, int height) XINE_PROTECTED;
+uint32_t    xine_osd_get_capabilities (xine_osd_t *self) XINE_PROTECTED;
+void        xine_osd_draw_point    (xine_osd_t *self, int x, int y, int color) XINE_PROTECTED;
+
+void        xine_osd_draw_line     (xine_osd_t *self, int x1, int y1,
+				    int x2, int y2, int color) XINE_PROTECTED;
+void        xine_osd_draw_rect     (xine_osd_t *self, int x1, int y1,
+				    int x2, int y2,
+				    int color, int filled ) XINE_PROTECTED;
+/* x1 and y1 specifies the upper left corner of the text to be rendered */
+void        xine_osd_draw_text     (xine_osd_t *self, int x1, int y1,
+				    const char *text, int color_base) XINE_PROTECTED;
+void        xine_osd_draw_bitmap   (xine_osd_t *self, uint8_t *bitmap,
+				    int x1, int y1, int width, int height,
+				    uint8_t *palette_map) XINE_PROTECTED;
+/* for freetype2 fonts the height is the maximum height for the whole font and not
+ * only for the specified text */
+void        xine_osd_get_text_size (xine_osd_t *self, const char *text,
+				    int *width, int *height) XINE_PROTECTED;
+/* with freetype2 support compiled in, you can also specify a font file
+   as 'fontname' here */
+int         xine_osd_set_font      (xine_osd_t *self, const char *fontname,
+				    int size) XINE_PROTECTED;
+/* 
+ * specifying encoding of texts
+ *   ""   ... means current locale encoding (default)
+ *   NULL ... means latin1
+ */
+void        xine_osd_set_encoding(xine_osd_t *self, const char *encoding) XINE_PROTECTED;
+/* set position were overlay will be blended */
+void        xine_osd_set_position  (xine_osd_t *self, int x, int y) XINE_PROTECTED;
+void        xine_osd_show          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
+void        xine_osd_show_unscaled (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
+void        xine_osd_hide          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
+/* empty drawing area */
+void        xine_osd_clear         (xine_osd_t *self) XINE_PROTECTED;
+/*
+ * set on existing text palette
+ * (-1 to set used specified palette)
+ *
+ * color_base specifies the first color index to use for this text
+ * palette. The OSD palette is then modified starting at this
+ * color index, up to the size of the text palette.
+ *
+ * Use OSD_TEXT1, OSD_TEXT2, ... for some preassigned color indices.
+ *
+ * These palettes are not working well with the true type fonts.
+ * First thing is that these fonts cannot have a border. So you get
+ * the best results by loading a linearly blending palette from the
+ * background (at index 0) to the forground color (at index 10).
+ */
+void        xine_osd_set_text_palette (xine_osd_t *self,
+				       int palette_number,
+				       int color_base ) XINE_PROTECTED;
+/* get palette (color and transparency) */
+void        xine_osd_get_palette   (xine_osd_t *self, uint32_t *color,
+				    uint8_t *trans) XINE_PROTECTED;
+void        xine_osd_set_palette   (xine_osd_t *self,
+				    const uint32_t *const color,
+				    const uint8_t *const trans ) XINE_PROTECTED;
+/*
+ * close osd rendering engine
+ * loaded fonts are unloaded
+ * osd objects are closed
+ */
+void        xine_osd_free          (xine_osd_t *self) XINE_PROTECTED;
+
+
+#ifndef XINE_DISABLE_DEPRECATED_FEATURES
+
+/*********************************************************************
+ * TV-mode API, to make it possible to use nvtvd to view movies      *
+ *********************************************************************/
+
+/* These functions are just dummies to maintain API compatibility.
+ * You should use libnvtvsimple in your frontend instead. */
+
+typedef enum {
+	XINE_TVSYSTEM_PAL = 0,
+	XINE_TVSYSTEM_NTSC
+} xine_tvsystem XINE_DEPRECATED;
+
+/* connect to nvtvd server and save current TV and X settings */
+int xine_tvmode_init (xine_t *self) XINE_PROTECTED XINE_DEPRECATED;
+
+/* Turn tvmode on/off (1/0)*/
+int xine_tvmode_use(xine_t *self, int use_tvmode) XINE_PROTECTED XINE_DEPRECATED;
+
+/* Set which tv system to use: XINE_TVSYSTEM_PAL or XINE_TVSYSTEM_NTSC */
+void xine_tvmode_set_tvsystem(xine_t *self, xine_tvsystem system) XINE_PROTECTED XINE_DEPRECATED;
+
+/* try to change TV state if enabled
+ *   type select 'regular' (0) or 'TV' (1) state
+ *   width frame width the mode should match best or 0 if unknown
+ *   height frame height the mode should match best or 0 if unknown
+ *   fps frame rate the mode should match best or 0 if unknown
+ * returns: finally selected state
+ */
+int xine_tvmode_switch (xine_t *self, int type, int width, int height, double fps) XINE_PROTECTED XINE_DEPRECATED;
+
+/* adapt (maximum) output size to visible area if necessary and return pixel
+ * aspect and real frame rate if available
+ */
+void xine_tvmode_size (xine_t *self, int *width, int *height,
+		       double *pixelratio, double *fps) XINE_PROTECTED XINE_DEPRECATED;
+
+/* restore old TV and X settings and close nvtvd connection */
+void xine_tvmode_exit (xine_t *self) XINE_PROTECTED XINE_DEPRECATED;
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naur xine-lib-1.1.16.1-old/include/xine.h.in.rej xine-lib-1.1.16.1-new/include/xine.h.in.rej
--- xine-lib-1.1.16.1-old/include/xine.h.in.rej	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/include/xine.h.in.rej	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,16 @@
+***************
+*** 1789,1794 ****
+  #define XINE_EVENT_VDR_SELECTAUDIO      352
+  #define XINE_EVENT_VDR_TRICKSPEEDMODE   353
+  #define XINE_EVENT_VDR_PLUGINSTARTED    354
+  
+  /* events generated from post plugins */
+  #define XINE_EVENT_POST_TVTIME_FILMMODE_CHANGE   400
+--- 1791,1797 ----
+  #define XINE_EVENT_VDR_SELECTAUDIO      352
+  #define XINE_EVENT_VDR_TRICKSPEEDMODE   353
+  #define XINE_EVENT_VDR_PLUGINSTARTED    354
++ #define XINE_EVENT_VDR_DISCONTINUITY    355
+  
+  /* events generated from post plugins */
+  #define XINE_EVENT_POST_TVTIME_FILMMODE_CHANGE   400
diff -Naur xine-lib-1.1.16.1-old/README-VDPAU xine-lib-1.1.16.1-new/README-VDPAU
--- xine-lib-1.1.16.1-old/README-VDPAU	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/README-VDPAU	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,70 @@
+xine-vdpau README:
+------------------------------------------------------------------------------
+
+So, you want to give it a try, but wonder which steps are required.
+Ok, so here it is:
+
+0) you need nvidia's driver 180.22 or later.
+
+1) get the sources:
+svn co svn://jusst.de/xine-vdpau
+
+2) compile the sources:
+cd xine-vdpau
+./autogen.sh
+./configure
+make
+make install (as root)
+    **(make sure that no other xine-lib installation will conflict with this one)
+
+3) edit your xine configuration
+nano $HOME/.xine/config (if it does not exist, first run "xine --no-logo" then quit.
+search for "engine.buffers.video_num_frames" and set it to 22
+
+4) running the beast:
+xine -verbose /path/to/a/working/sample
+    ** --verbose will print some usefull things in your console (in case of problems, 
+        the developers will ask you to give this output, at least)
+
+5) update your svn copy quite often
+
+6) don't blame us if it crashes, burn you gpu (unlikely:) or anything else.
+
+
+------------------------------------------------------------------------------
+
+FAQ:
+
+Q:
+  Why my file plays fine with mplayer-vdpau and not with xine-vdpau?
+A:
+  We are not using the nvidia's libavcodec patch.
+  We are writing decoders from scratch.
+  So don't expect them to be as mature as ffmpeg ones. Not yet.
+
+Q:
+  Why mpeg2 doesn't use less cpu than software decoder?
+A:
+  Because at that moment it does a lot of memcpy. This will be fixed soon, but that's not
+  a priority. Stability is our focus.
+
+Q:
+  Is deinterlacing working?
+A:
+  Yes. It's already quite good (doing 50i->50p), but could even be better in the future.
+
+Q:
+  How do i get it working with VDR, Kaffeine, whatever.
+A:
+  Ask VDR, Kaffeine, whatever developers.
+    (Note: for kaffeine you are lucky, i'm going to tell you the tip.
+     Build kaffeine like that: ./configure --without-xcb && make && make install)
+
+Q:
+  How can i contact you?
+A:
+  IRC: #xine-vdpau on freenode
+  MAIL: http://lists.kafic.ba/mailman/listinfo/xine-vdpau
+  Eventually, nvnews.
+
+----------------------------------------------------------------------------
diff -Naur xine-lib-1.1.16.1-old/src/libvdpau/dpb.c xine-lib-1.1.16.1-new/src/libvdpau/dpb.c
--- xine-lib-1.1.16.1-old/src/libvdpau/dpb.c	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/libvdpau/dpb.c	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,379 @@
+/*
+ * Copyright (C) 2008 Julian Scheel
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * dpb.c: Implementing Decoded Picture Buffer
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "dpb.h"
+#include "nal.h"
+#include "video_out.h"
+
+struct decoded_picture* init_decoded_picture(struct nal_unit *src_nal,
+    VdpVideoSurface surface, vo_frame_t *img)
+{
+  struct decoded_picture *pic = calloc(1, sizeof(struct decoded_picture));
+  pic->nal = init_nal_unit();
+  copy_nal_unit(pic->nal, src_nal);
+  pic->top_is_reference = pic->nal->slc->field_pic_flag
+        ? (pic->nal->slc->bottom_field_flag ? 0 : 1) : 1;
+  pic->bottom_is_reference = pic->nal->slc->field_pic_flag
+        ? (pic->nal->slc->bottom_field_flag ? 1 : 0) : 1;
+  pic->surface = surface;
+  pic->img = img;
+
+  return pic;
+}
+
+void free_decoded_picture(struct decoded_picture *pic)
+{
+  pic->img->free(pic->img);
+  free_nal_unit(pic->nal);
+  free(pic);
+}
+
+struct decoded_picture* dpb_get_next_out_picture(struct dpb *dpb)
+{
+  struct decoded_picture *pic = dpb->pictures;
+  struct decoded_picture *outpic = NULL;
+
+  if(dpb->used < MAX_DPB_SIZE)
+    return NULL;
+
+  if (pic != NULL)
+    do {
+      if (pic->delayed_output &&
+          (outpic == NULL ||
+              (pic->nal->top_field_order_cnt <= outpic->nal->top_field_order_cnt &&
+                  pic->nal->bottom_field_order_cnt <= outpic->nal->bottom_field_order_cnt)||
+              (outpic->nal->top_field_order_cnt < 0 && pic->nal->top_field_order_cnt > 0 &&
+                  outpic->nal->bottom_field_order_cnt < 0 && pic->nal->bottom_field_order_cnt > 0)||
+              outpic->nal->nal_unit_type == NAL_SLICE_IDR))
+        outpic = pic;
+    } while ((pic = pic->next) != NULL);
+
+  return outpic;
+}
+
+struct decoded_picture* dpb_get_picture(struct dpb *dpb, uint32_t picnum)
+{
+  struct decoded_picture *pic = dpb->pictures;
+
+  if (pic != NULL)
+    do {
+      if (pic->nal->curr_pic_num == picnum)
+        return pic;
+    } while ((pic = pic->next) != NULL);
+
+  return NULL;
+}
+
+struct decoded_picture* dpb_get_picture_by_ltpn(struct dpb *dpb,
+    uint32_t longterm_picnum)
+{
+  struct decoded_picture *pic = dpb->pictures;
+
+  if (pic != NULL)
+    do {
+      if (pic->nal->long_term_pic_num == longterm_picnum)
+        return pic;
+    } while ((pic = pic->next) != NULL);
+
+  return NULL;
+}
+
+struct decoded_picture* dpb_get_picture_by_ltidx(struct dpb *dpb,
+    uint32_t longterm_idx)
+{
+  struct decoded_picture *pic = dpb->pictures;
+
+  if (pic != NULL)
+    do {
+      if (pic->nal->long_term_frame_idx == longterm_idx)
+        return pic;
+    } while ((pic = pic->next) != NULL);
+
+  return NULL;
+}
+
+int dpb_set_unused_ref_picture_a(struct dpb *dpb, struct decoded_picture *refpic)
+{
+  struct decoded_picture *pic = dpb->pictures;
+    if (pic != NULL)
+      do {
+        if (pic == refpic) {
+          pic->used_for_reference = 0;
+          if(!pic->delayed_output)
+            dpb_remove_picture(dpb, pic);
+          return 0;
+        }
+      } while ((pic = pic->next) != NULL);
+
+    return -1;
+}
+
+int dpb_set_unused_ref_picture(struct dpb *dpb, uint32_t picnum)
+{
+  struct decoded_picture *pic = dpb->pictures;
+  if (pic != NULL)
+    do {
+      if (pic->nal->curr_pic_num == picnum) {
+        pic->used_for_reference = 0;
+        if(!pic->delayed_output)
+          dpb_remove_picture(dpb, pic);
+        return 0;
+      }
+    } while ((pic = pic->next) != NULL);
+
+  return -1;
+}
+
+int dpb_set_unused_ref_picture_byltpn(struct dpb *dpb, uint32_t longterm_picnum)
+{
+  struct decoded_picture *pic = dpb->pictures;
+  if (pic != NULL)
+    do {
+      if (pic->nal->long_term_pic_num == longterm_picnum) {
+        pic->used_for_reference = 0;
+        if(!pic->delayed_output)
+          dpb_remove_picture(dpb, pic);
+        return 0;
+      }
+    } while ((pic = pic->next) != NULL);
+
+  return -1;
+}
+
+int dpb_set_unused_ref_picture_bylidx(struct dpb *dpb, uint32_t longterm_idx)
+{
+  struct decoded_picture *pic = dpb->pictures;
+  if (pic != NULL)
+    do {
+      if (pic->nal->long_term_frame_idx == longterm_idx) {
+        pic->used_for_reference = 0;
+        if(!pic->delayed_output)
+          dpb_remove_picture(dpb, pic);
+        return 0;
+      }
+    } while ((pic = pic->next) != NULL);
+
+  return -1;
+}
+
+int dpb_set_unused_ref_picture_lidx_gt(struct dpb *dpb, uint32_t longterm_idx)
+{
+  struct decoded_picture *pic = dpb->pictures;
+  if (pic != NULL)
+    do {
+      if (pic->nal->long_term_frame_idx >= longterm_idx) {
+        pic->used_for_reference = 0;
+        if(!pic->delayed_output) {
+          struct decoded_picture *next_pic = pic->next;
+          dpb_remove_picture(dpb, pic);
+          pic = next_pic;
+          continue;
+        }
+      }
+    } while ((pic = pic->next) != NULL);
+
+  return -1;
+}
+
+
+int dpb_set_output_picture(struct dpb *dpb, struct decoded_picture *outpic)
+{
+  struct decoded_picture *pic = dpb->pictures;
+  if (pic != NULL)
+    do {
+      if (pic == outpic) {
+        pic->delayed_output = 0;
+        if(!pic->used_for_reference)
+          dpb_remove_picture(dpb, pic);
+        return 0;
+      }
+    } while ((pic = pic->next) != NULL);
+
+  return -1;
+}
+
+int dpb_remove_picture(struct dpb *dpb, struct decoded_picture *rempic)
+{
+  struct decoded_picture *pic = dpb->pictures;
+  struct decoded_picture *last_pic = NULL;
+
+  if (pic != NULL)
+    do {
+      if (pic == rempic) {
+        // FIXME: free the picture....
+
+        if (last_pic != NULL)
+          last_pic->next = pic->next;
+        else
+          dpb->pictures = pic->next;
+        free_decoded_picture(pic);
+        dpb->used--;
+        return 0;
+      }
+
+      last_pic = pic;
+    } while ((pic = pic->next) != NULL);
+
+  return -1;
+}
+
+int dpb_remove_picture_by_picnum(struct dpb *dpb, uint32_t picnum)
+{
+  struct decoded_picture *pic = dpb->pictures;
+  struct decoded_picture *last_pic = NULL;
+
+  if (pic != NULL)
+    do {
+      if (pic->nal->curr_pic_num == picnum) {
+        dpb_remove_picture(dpb, pic);
+      }
+
+      last_pic = pic;
+    } while ((pic = pic->next) != NULL);
+
+  return -1;
+}
+
+int dpb_add_picture(struct dpb *dpb, struct decoded_picture *pic, uint32_t num_ref_frames)
+{
+  int i = 0;
+  struct decoded_picture *last_pic = dpb->pictures;
+
+  pic->next = dpb->pictures;
+  dpb->pictures = pic;
+  dpb->num_ref_frames = num_ref_frames;
+  dpb->used++;
+
+  if(pic != NULL && dpb->used > num_ref_frames) {
+    do {
+      if(pic->used_for_reference) {
+        i++;
+        if(i>num_ref_frames) {
+          pic->used_for_reference = 0;
+          if(pic == dpb->pictures)
+            last_pic = pic->next;
+
+          if(!pic->delayed_output) {
+            dpb_remove_picture(dpb, pic);
+          }
+          pic = last_pic;
+          if(pic == dpb->pictures)
+            continue;
+        }
+        last_pic = pic;
+      }
+    } while (pic != NULL && (pic = pic->next) != NULL);
+  }
+
+  return 0;
+}
+
+int dpb_flush(struct dpb *dpb)
+{
+  struct decoded_picture *pic = dpb->pictures;
+
+  if (pic != NULL)
+    do {
+      struct decoded_picture *next_pic = pic->next;
+      dpb_set_unused_ref_picture_a(dpb, pic);
+      pic = next_pic;
+    } while (pic != NULL);
+
+  //printf("Flushed, used: %d\n", dpb->used);
+
+  return 0;
+}
+
+void dpb_free_all( struct dpb *dpb )
+{
+  struct decoded_picture *pic = dpb->pictures;
+
+  if (pic != NULL)
+    do {
+      struct decoded_picture *next_pic = pic->next;
+      free_decoded_picture(pic);
+      --dpb->used;
+      pic = next_pic;
+    } while (pic != NULL);
+
+  printf("dpb_free_all, used: %d\n", dpb->used);
+  dpb->pictures = NULL;
+}
+
+void dpb_clear_all_pts( struct dpb *dpb )
+{
+  struct decoded_picture *pic = dpb->pictures;
+
+  while (pic != NULL) {
+    pic->img->pts = 0;
+    pic = pic->next;
+  }
+}
+
+int fill_vdpau_reference_list(struct dpb *dpb, VdpReferenceFrameH264 *reflist)
+{
+  struct decoded_picture *pic = dpb->pictures;
+  struct decoded_picture *last_pic = NULL;
+
+  int i = 0;
+  int used_refframes = 0;
+
+  if (pic != NULL)
+    do {
+      if (pic->used_for_reference) {
+        reflist[i].surface = pic->surface;
+        reflist[i].is_long_term = pic->nal->used_for_long_term_ref;
+        if(reflist[i].is_long_term)
+          reflist[i].frame_idx = pic->nal->slc->frame_num; //pic->nal->long_term_frame_idx;
+        else
+          reflist[i].frame_idx = pic->nal->slc->frame_num; //pic->nal->curr_pic_num;
+        reflist[i].top_is_reference = pic->top_is_reference; /*pic->nal->slc->field_pic_flag
+            ? (pic->nal->slc->bottom_field_flag ? 0 : 1) : 1;*/
+        reflist[i].bottom_is_reference = pic->bottom_is_reference; /*pic->nal->slc->field_pic_flag
+            ? (pic->nal->slc->bottom_field_flag ? 1 : 0) : 1;*/
+        reflist[i].field_order_cnt[0] = pic->nal->top_field_order_cnt;
+        reflist[i].field_order_cnt[1] = pic->nal->bottom_field_order_cnt;
+        i++;
+      }
+      last_pic = pic;
+    } while ((pic = pic->next) != NULL && i < 16);
+
+  used_refframes = i;
+
+  // fill all other frames with invalid handles
+  while(i < 16) {
+    reflist[i].bottom_is_reference = VDP_FALSE;
+    reflist[i].top_is_reference = VDP_FALSE;
+    reflist[i].frame_idx = 0;
+    reflist[i].is_long_term = VDP_FALSE;
+    reflist[i].surface = VDP_INVALID_HANDLE;
+    reflist[i].field_order_cnt[0] = 0;
+    reflist[i].field_order_cnt[1] = 0;
+    i++;
+  }
+
+  return used_refframes;
+}
diff -Naur xine-lib-1.1.16.1-old/src/libvdpau/dpb.h xine-lib-1.1.16.1-new/src/libvdpau/dpb.h
--- xine-lib-1.1.16.1-old/src/libvdpau/dpb.h	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/libvdpau/dpb.h	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2008 Julian Scheel
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * dpb.h: Decoder Picture Buffer
+ */
+
+#ifndef DPB_H_
+#define DPB_H_
+
+#define MAX_DPB_SIZE 16
+
+#include "nal.h"
+#include "video_out.h"
+
+struct decoded_picture {
+  VdpVideoSurface surface;
+  vo_frame_t *img; /* this is the image we block, to make sure
+                    * the surface is not double-used */
+  struct nal_unit *nal;
+
+  uint8_t used_for_reference;
+  uint8_t top_is_reference;
+  uint8_t bottom_is_reference;
+
+  uint8_t delayed_output;
+
+  struct decoded_picture *next;
+};
+
+/* Decoded Picture Buffer */
+struct dpb {
+  struct decoded_picture *pictures;
+
+  uint32_t num_ref_frames;
+  uint32_t used;
+};
+
+struct decoded_picture* init_decoded_picture(struct nal_unit *src_nal,
+    VdpVideoSurface surface, vo_frame_t *img);
+void free_decoded_picture(struct decoded_picture *pic);
+
+struct decoded_picture* dpb_get_next_out_picture(struct dpb *dpb);
+
+struct decoded_picture* dpb_get_picture(struct dpb *dpb, uint32_t picnum);
+struct decoded_picture* dpb_get_picture_by_ltpn(struct dpb *dpb, uint32_t longterm_picnum);
+struct decoded_picture* dpb_get_picture_by_ltidx(struct dpb *dpb, uint32_t longterm_idx);
+
+int dpb_set_unused_ref_picture(struct dpb *dpb, uint32_t picnum);
+int dpb_set_unused_ref_picture_a(struct dpb *dpb, struct decoded_picture *refpic);
+int dpb_set_unused_ref_picture_byltpn(struct dpb *dpb, uint32_t longterm_picnum);
+int dpb_set_unused_ref_picture_bylidx(struct dpb *dpb, uint32_t longterm_idx);
+int dpb_set_unused_ref_picture_lidx_gt(struct dpb *dpb, uint32_t longterm_idx);
+
+int dpb_set_output_picture(struct dpb *dpb, struct decoded_picture *outpic);
+
+int dpb_remove_picture(struct dpb *dpb, struct decoded_picture *rempic);
+int dpb_add_picture(struct dpb *dpb, struct decoded_picture *pic, uint32_t num_ref_frames);
+int dpb_flush(struct dpb *dpb);
+void dpb_free_all( struct dpb *dpb );
+void dpb_clear_all_pts( struct dpb *dpb );
+
+int fill_vdpau_reference_list(struct dpb *dpb, VdpReferenceFrameH264 *reflist);
+
+#endif /* DPB_H_ */
diff -Naur xine-lib-1.1.16.1-old/src/libvdpau/h264_parser.c xine-lib-1.1.16.1-new/src/libvdpau/h264_parser.c
--- xine-lib-1.1.16.1-old/src/libvdpau/h264_parser.c	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/libvdpau/h264_parser.c	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,1587 @@
+/*
+ * Copyright (C) 2008 Julian Scheel
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * h264_parser.c: Almost full-features H264 NAL-Parser
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "h264_parser.h"
+#include "nal.h"
+
+/* default scaling_lists according to Table 7-2 */
+uint8_t default_4x4_intra[16] = { 6, 13, 13, 20, 20, 20, 28, 28, 28, 28, 32,
+    32, 32, 37, 37, 42 };
+
+uint8_t default_4x4_inter[16] = { 10, 14, 14, 20, 20, 20, 24, 24, 24, 24, 27,
+    27, 27, 30, 30, 34 };
+
+uint8_t default_8x8_intra[64] = { 6, 10, 10, 13, 11, 13, 16, 16, 16, 16, 18,
+    18, 18, 18, 18, 32, 23, 23, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 27, 27,
+    27, 27, 27, 27, 27, 27, 29, 29, 29, 29, 29, 29, 29, 31, 31, 31, 31, 31, 31,
+    33, 33, 33, 33, 33, 36, 36, 36, 36, 38, 38, 38, 40, 40, 42 };
+
+uint8_t default_8x8_inter[64] = { 9, 13, 13, 15, 13, 15, 17, 17, 17, 17, 19,
+    19, 19, 19, 19, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 24, 24,
+    24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 27, 27, 27, 27, 27, 27,
+    28, 28, 28, 28, 28, 30, 30, 30, 30, 32, 32, 32, 33, 33, 35 };
+
+struct buf_reader
+{
+  uint8_t *buf;
+  uint8_t *cur_pos;
+  int len;
+  int cur_offset;
+};
+
+static inline uint32_t read_bits(struct buf_reader *buf, int len);
+uint32_t read_exp_golomb(struct buf_reader *buf);
+int32_t read_exp_golomb_s(struct buf_reader *buf);
+
+void calculate_pic_order(struct nal_parser *parser);
+void skip_scaling_list(struct buf_reader *buf, int size);
+void parse_scaling_list(struct buf_reader *buf, uint8_t *scaling_list,
+    int length, int index);
+int parse_nal_header(struct buf_reader *buf, struct nal_parser *parser);
+static void sps_scaling_list_fallback(struct seq_parameter_set_rbsp *sps, int i);
+static void pps_scaling_list_fallback(struct seq_parameter_set_rbsp *sps, struct pic_parameter_set_rbsp *pps, int i);
+uint8_t parse_sps(struct buf_reader *buf, struct nal_parser *parser);
+void parse_vui_parameters(struct buf_reader *buf,
+    struct seq_parameter_set_rbsp *sps);
+void parse_hrd_parameters(struct buf_reader *buf, struct hrd_parameters *hrd);
+uint8_t parse_pps(struct buf_reader *buf, struct pic_parameter_set_rbsp *pps,
+    struct seq_parameter_set_rbsp *sps);
+void parse_sei(struct buf_reader *buf, struct nal_parser *parser);
+uint8_t parse_slice_header(struct buf_reader *buf, struct nal_parser *parser);
+void
+    parse_ref_pic_list_reordering(struct buf_reader *buf, struct nal_unit *nal,
+        struct nal_parser *parser);
+void decode_ref_pic_marking(struct nal_unit *nal,
+    uint32_t memory_management_control_operation,
+    uint32_t marking_nr,
+    struct nal_parser *parser);
+void parse_pred_weight_table(struct buf_reader *buf, struct nal_unit *nal);
+void parse_dec_ref_pic_marking(struct buf_reader *buf,
+    struct nal_parser *parser);
+
+/* here goes the parser implementation */
+
+static void decode_nal(uint8_t **ret, int *len_ret, uint8_t *buf, int buf_len)
+{
+  uint8_t *end = &buf[buf_len];
+  uint8_t *pos = malloc(buf_len);
+
+  *ret = pos;
+  while (buf < end) {
+    if (buf < end - 3 && buf[0] == 0x00 && buf[1] == 0x00 && buf[2] == 0x03) {
+
+      *pos++ = 0x00;
+      *pos++ = 0x00;
+
+      buf += 3;
+      continue;
+    }
+    *pos++ = *buf++;
+  }
+
+  *len_ret = pos - *ret;
+}
+
+static inline void dump_bits(uint32_t bits)
+{
+  int i;
+  printf("0b");
+  for(i=0; i < 32; i++)
+    printf("%d", (bits >> (31-i)) & 0x01);
+  printf("\n");
+}
+
+static inline uint32_t bits_read(struct buf_reader *buf)
+{
+  int bits_read = 0;
+  bits_read = (buf->cur_pos - buf->buf)*8;
+  bits_read += (8-buf->cur_offset);
+
+  return bits_read;
+}
+
+static inline uint32_t read_bits(struct buf_reader *buf, int len)
+{
+  static uint32_t i_mask[33] = { 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f,
+      0x7f, 0xff, 0x1ff, 0x3ff, 0x7ff, 0xfff, 0x1fff, 0x3fff, 0x7fff, 0xffff,
+      0x1ffff, 0x3ffff, 0x7ffff, 0xfffff, 0x1fffff, 0x3fffff, 0x7fffff,
+      0xffffff, 0x1ffffff, 0x3ffffff, 0x7ffffff, 0xfffffff, 0x1fffffff,
+      0x3fffffff, 0x7fffffff, 0xffffffff };
+
+  int i_shr;
+  uint32_t bits = 0;
+
+  while (len > 0 && (buf->cur_pos - buf->buf) < buf->len) {
+    if ((i_shr = buf->cur_offset - len) >= 0) {
+      bits |= (*buf->cur_pos >> i_shr) & i_mask[len];
+      buf->cur_offset -= len;
+      if (buf->cur_offset == 0) {
+        buf->cur_pos++;
+        buf->cur_offset = 8;
+      }
+      //dump_bits(bits);
+      return bits;
+    }
+    else {
+      bits |= (*buf->cur_pos & i_mask[buf->cur_offset]) << -i_shr;
+      //dump_bits(bits);
+      len -= buf->cur_offset;
+      buf->cur_pos++;
+      buf->cur_offset = 8;
+    }
+  }
+  return bits;
+}
+
+/* determines if following bits are rtsb_trailing_bits */
+static inline int rbsp_trailing_bits(uint8_t *buf, int buf_len)
+{
+  uint8_t *cur_buf = buf+(buf_len-1);
+  uint8_t cur_val;
+  int parsed_bits = 0;
+  int i;
+
+  while(buf_len > 0) {
+    cur_val = *cur_buf;
+    for(i = 0; i < 9; i++) {
+      if (cur_val&1)
+        return parsed_bits+i;
+      cur_val>>=1;
+    }
+    parsed_bits += 8;
+    cur_buf--;
+  }
+
+  printf("rbsp trailing bits could not be found\n");
+  return 0;
+}
+
+uint32_t read_exp_golomb(struct buf_reader *buf)
+{
+  int leading_zero_bits = 0;
+
+  while (read_bits(buf, 1) == 0 && leading_zero_bits < 32)
+    leading_zero_bits++;
+
+  uint32_t code = (1 << leading_zero_bits) - 1 + read_bits(buf,
+      leading_zero_bits);
+  return code;
+}
+
+int32_t read_exp_golomb_s(struct buf_reader *buf)
+{
+  uint32_t ue = read_exp_golomb(buf);
+  int32_t code = ue & 0x01 ? (ue + 1) / 2 : -(ue / 2);
+  return code;
+}
+
+int parse_nal_header(struct buf_reader *buf, struct nal_parser *parser)
+{
+  if (buf->len < 1)
+    return -1;
+
+  int ret = -1;
+
+  struct nal_unit *nal = parser->current_nal;
+
+  nal->nal_ref_idc = (buf->buf[0] >> 5) & 0x03;
+  nal->nal_unit_type = buf->buf[0] & 0x1f;
+
+  buf->cur_pos = buf->buf + 1;
+  //printf("NAL: %d\n", nal->nal_unit_type);
+
+  struct buf_reader ibuf;
+  ibuf.cur_offset = 8;
+
+  switch (nal->nal_unit_type) {
+    case NAL_SPS:
+      decode_nal(&ibuf.buf, &ibuf.len, buf->cur_pos, buf->len - 1);
+      ibuf.cur_pos = ibuf.buf;
+
+      if (!nal->sps)
+        nal->sps = calloc(1, sizeof(struct seq_parameter_set_rbsp));
+      else
+        memset(nal->sps, 0x00, sizeof(struct seq_parameter_set_rbsp));
+
+      parse_sps(&ibuf, parser);
+      free(ibuf.buf);
+      ret = NAL_SPS;
+      break;
+    case NAL_PPS:
+      if (!nal->pps)
+        nal->pps = calloc(1, sizeof(struct pic_parameter_set_rbsp));
+      else
+        memset(nal->pps, 0x00, sizeof(struct pic_parameter_set_rbsp));
+
+      parse_pps(buf, nal->pps, nal->sps);
+      ret = NAL_PPS;
+      break;
+    case NAL_SLICE:
+    case NAL_PART_A:
+    case NAL_PART_B:
+    case NAL_PART_C:
+    case NAL_SLICE_IDR:
+      if (nal->sps && nal->pps) {
+        if (!nal->slc)
+          nal->slc = calloc(1, sizeof(struct slice_header));
+        else
+          memset(nal->slc, 0x00, sizeof(struct slice_header));
+
+        parse_slice_header(buf, parser);
+        ret = nal->nal_unit_type;
+      }
+      break;
+    case NAL_SEI:
+      memset(&(nal->sei), 0x00, sizeof(struct sei_message));
+      parse_sei(buf, parser);
+      ret = nal->nal_unit_type;
+      break;
+    default:
+      ret = nal->nal_unit_type;
+      break;
+  }
+
+  return ret;
+}
+
+void calculate_pic_order(struct nal_parser *parser)
+{
+  struct nal_unit *nal = parser->current_nal;
+
+  struct seq_parameter_set_rbsp *sps = nal->sps;
+  struct pic_parameter_set_rbsp *pps = nal->pps;
+  struct slice_header *slc = nal->slc;
+  if (!sps || !pps || !slc)
+    return;
+
+  if (nal->nal_unit_type == NAL_SLICE_IDR) {
+    parser->prev_pic_order_cnt_lsb = 0;
+    parser->prev_pic_order_cnt_msb = 0;
+    parser->frame_num_offset = 0;
+  }
+
+  if (sps->pic_order_cnt_type == 0) {
+
+    const int max_poc_lsb = 1 << (sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+
+    if (slc->pic_order_cnt_lsb < parser->prev_pic_order_cnt_lsb
+        && parser->prev_pic_order_cnt_lsb - slc->pic_order_cnt_lsb
+            >= max_poc_lsb / 2)
+      parser->pic_order_cnt_msb = parser->prev_pic_order_cnt_msb + max_poc_lsb;
+    else if (slc->pic_order_cnt_lsb > parser->prev_pic_order_cnt_lsb
+        && parser->prev_pic_order_cnt_lsb - slc->pic_order_cnt_lsb
+            < -max_poc_lsb / 2)
+      parser->pic_order_cnt_msb = parser->prev_pic_order_cnt_msb - max_poc_lsb;
+    else
+      parser->pic_order_cnt_msb = parser->prev_pic_order_cnt_msb;
+
+    if(!slc->field_pic_flag || !slc->bottom_field_flag)
+      nal->top_field_order_cnt = parser->pic_order_cnt_msb + slc->pic_order_cnt_lsb;
+
+    if(!slc->field_pic_flag)
+      nal->bottom_field_order_cnt = nal->top_field_order_cnt + slc->delta_pic_order_cnt_bottom;
+    else
+      nal->bottom_field_order_cnt = parser->pic_order_cnt_msb + slc->pic_order_cnt_lsb;
+
+
+  } else if (sps->pic_order_cnt_type == 2) {
+    uint32_t prev_frame_num = parser->last_nal->slc->frame_num;
+    uint32_t prev_frame_num_offset = parser->frame_num_offset;
+    uint32_t max_frame_num = 1 << (sps->log2_max_frame_num_minus4+4);
+    uint32_t temp_pic_order_cnt = 0;
+
+    if (parser->is_idr)
+      parser->frame_num_offset = 0;
+    else if (prev_frame_num > slc->frame_num)
+      parser->frame_num_offset = prev_frame_num_offset + max_frame_num;
+    else
+      parser->frame_num_offset = prev_frame_num_offset;
+
+    if(parser->is_idr)
+      temp_pic_order_cnt = 0;
+    else if(nal->nal_ref_idc == 0)
+      temp_pic_order_cnt = 2 * (parser->frame_num_offset + slc->frame_num)-1;
+    else
+      temp_pic_order_cnt = 2 * (parser->frame_num_offset + slc->frame_num);
+
+    if(!slc->field_pic_flag)
+      nal->top_field_order_cnt = nal->bottom_field_order_cnt = temp_pic_order_cnt;
+    else if(slc->bottom_field_flag)
+      nal->bottom_field_order_cnt = temp_pic_order_cnt;
+    else
+      nal->top_field_order_cnt = temp_pic_order_cnt;
+
+  } else {
+    printf("FIXME: Unsupported poc_type: %d\n", sps->pic_order_cnt_type);
+  }
+
+}
+
+void skip_scaling_list(struct buf_reader *buf, int size)
+{
+  int i;
+  for (i = 0; i < size; i++) {
+    read_exp_golomb_s(buf);
+  }
+}
+
+void parse_scaling_list(struct buf_reader *buf, uint8_t *scaling_list,
+    int length, int index)
+{
+  int last_scale = 8;
+  int next_scale = 8;
+  int32_t delta_scale;
+  uint8_t use_default_scaling_matrix_flag = 0;
+  int i;
+
+  uint8_t *zigzag = (length==64) ? zigzag_8x8 : zigzag_4x4;
+
+  for (i = 0; i < length; i++) {
+    if (next_scale != 0) {
+      delta_scale = read_exp_golomb_s(buf);
+      next_scale = (last_scale + delta_scale + 256) % 256;
+      if (i == 0 && next_scale == 0) {
+        use_default_scaling_matrix_flag = 1;
+        break;
+      }
+    }
+    scaling_list[zigzag[i]] = last_scale = (next_scale == 0) ? last_scale : next_scale;
+  }
+
+  if (use_default_scaling_matrix_flag) {
+    switch (index) {
+      case 0:
+      case 1:
+      case 2:
+        memcpy(scaling_list, default_4x4_intra, sizeof(default_4x4_intra));
+        break;
+      case 3:
+      case 4:
+      case 5:
+        memcpy(scaling_list, default_4x4_inter, sizeof(default_4x4_inter));
+        break;
+      case 6:
+        memcpy(scaling_list, default_8x8_intra, sizeof(default_8x8_intra));
+        break;
+      case 7:
+        memcpy(scaling_list, default_8x8_inter, sizeof(default_8x8_inter));
+        break;
+    }
+  }
+}
+
+static void sps_scaling_list_fallback(struct seq_parameter_set_rbsp *sps, int i)
+{
+  switch (i) {
+    case 0:
+      memcpy(sps->scaling_lists_4x4[i], default_4x4_intra, sizeof(sps->scaling_lists_4x4[i]));
+      break;
+    case 3:
+      memcpy(sps->scaling_lists_4x4[i], default_4x4_inter, sizeof(sps->scaling_lists_4x4[i]));
+      break;
+    case 1:
+    case 2:
+    case 4:
+    case 5:
+      memcpy(sps->scaling_lists_4x4[i], sps->scaling_lists_4x4[i-1], sizeof(sps->scaling_lists_4x4[i]));
+      break;
+    case 6:
+      memcpy(sps->scaling_lists_8x8[i-6], default_8x8_intra, sizeof(sps->scaling_lists_8x8[i-6]));
+      break;
+    case 7:
+      memcpy(sps->scaling_lists_8x8[i-6], default_8x8_inter, sizeof(sps->scaling_lists_8x8[i-6]));
+      break;
+
+  }
+}
+
+static void pps_scaling_list_fallback(struct seq_parameter_set_rbsp *sps, struct pic_parameter_set_rbsp *pps, int i)
+{
+  switch (i) {
+    case 0:
+    case 3:
+      memcpy(pps->scaling_lists_4x4[i], sps->scaling_lists_4x4[i], sizeof(pps->scaling_lists_4x4[i]));
+      break;
+    case 1:
+    case 2:
+    case 4:
+    case 5:
+      memcpy(pps->scaling_lists_4x4[i], pps->scaling_lists_4x4[i-1], sizeof(sps->scaling_lists_4x4[i]));
+      break;
+    case 6:
+    case 7:
+      memcpy(pps->scaling_lists_8x8[i-6], sps->scaling_lists_8x8[i-6], sizeof(pps->scaling_lists_8x8[i-6]));
+      break;
+
+  }
+}
+
+
+uint8_t parse_sps(struct buf_reader *buf, struct nal_parser *parser)
+{
+  struct seq_parameter_set_rbsp *sps = parser->current_nal->sps;
+  sps->profile_idc = buf->buf[0];
+  sps->constraint_setN_flag = (buf->buf[1] >> 4) & 0x0f;
+  sps->level_idc = buf->buf[2];
+
+  buf->cur_pos = buf->buf + 3;
+  sps->seq_parameter_set_id = read_exp_golomb(buf);
+
+  memset(sps->scaling_lists_4x4, 16, sizeof(sps->scaling_lists_4x4));
+  memset(sps->scaling_lists_8x8, 16, sizeof(sps->scaling_lists_8x8));
+  if (sps->profile_idc == 100 || sps->profile_idc == 110 || sps->profile_idc
+      == 122 || sps->profile_idc == 144) {
+    sps->chroma_format_idc = read_exp_golomb(buf);
+    if (sps->chroma_format_idc == 3) {
+      sps->residual_colour_transform_flag = read_bits(buf, 1);
+    }
+
+    sps->bit_depth_luma_minus8 = read_exp_golomb(buf);
+    sps->bit_depth_chroma_minus8 = read_exp_golomb(buf);
+    sps->qpprime_y_zero_transform_bypass_flag = read_bits(buf, 1);
+    sps->seq_scaling_matrix_present_flag = read_bits(buf, 1);
+    if (sps->seq_scaling_matrix_present_flag) {
+      int i;
+      for (i = 0; i < 8; i++) {
+        sps->seq_scaling_list_present_flag[i] = read_bits(buf, 1);
+
+        if (sps->seq_scaling_list_present_flag[i]) {
+          if (i < 6)
+            parse_scaling_list(buf, sps->scaling_lists_4x4[i], 16, i);
+          else
+            parse_scaling_list(buf, sps->scaling_lists_8x8[i - 6], 64, i);
+        } else {
+          sps_scaling_list_fallback(sps, i);
+        }
+      }
+    }
+  }
+
+  sps->log2_max_frame_num_minus4 = read_exp_golomb(buf);
+
+  sps->pic_order_cnt_type = read_exp_golomb(buf);
+  if (!sps->pic_order_cnt_type)
+    sps->log2_max_pic_order_cnt_lsb_minus4 = read_exp_golomb(buf);
+  else {
+    sps->delta_pic_order_always_zero_flag = read_bits(buf, 1);
+    sps->offset_for_non_ref_pic = read_exp_golomb_s(buf);
+    sps->offset_for_top_to_bottom_field = read_exp_golomb_s(buf);
+    sps->num_ref_frames_in_pic_order_cnt_cycle = read_exp_golomb(buf);
+    int i;
+    for (i = 0; i < sps->num_ref_frames_in_pic_order_cnt_cycle; i++) {
+      sps->offset_for_ref_frame[i] = read_exp_golomb_s(buf);
+    }
+  }
+
+  sps->num_ref_frames = read_exp_golomb(buf);
+  sps->gaps_in_frame_num_value_allowed_flag = read_bits(buf, 1);
+
+  /*sps->pic_width_in_mbs_minus1 = read_exp_golomb(buf);
+   sps->pic_height_in_map_units_minus1 = read_exp_golomb(buf);*/
+  sps->pic_width = 16 * (read_exp_golomb(buf) + 1);
+  sps->pic_height = 16 * (read_exp_golomb(buf) + 1);
+
+  sps->frame_mbs_only_flag = read_bits(buf, 1);
+
+  /* compute the height correctly even for interlaced material */
+  sps->pic_height = (2 - sps->frame_mbs_only_flag) * sps->pic_height;
+  if (sps->pic_height == 1088)
+    sps->pic_height = 1080;
+
+  if (!sps->frame_mbs_only_flag)
+    sps->mb_adaptive_frame_field_flag = read_bits(buf, 1);
+
+  sps->direct_8x8_inference_flag = read_bits(buf, 1);
+  sps->frame_cropping_flag = read_bits(buf, 1);
+  if (sps->frame_cropping_flag) {
+    sps->frame_crop_left_offset = read_exp_golomb(buf);
+    sps->frame_crop_right_offset = read_exp_golomb(buf);
+    sps->frame_crop_top_offset = read_exp_golomb(buf);
+    sps->frame_crop_bottom_offset = read_exp_golomb(buf);
+  }
+  sps->vui_parameters_present_flag = read_bits(buf, 1);
+  if (sps->vui_parameters_present_flag) {
+    parse_vui_parameters(buf, sps);
+    if(sps->vui_parameters.nal_hrd_parameters_present_flag ||
+        sps->vui_parameters.vc1_hrd_parameters_present_flag) {
+      parser->cpb_dpb_delays_present_flag = 1;
+    } else
+      parser->cpb_dpb_delays_present_flag = 0;
+  } else
+    parser->cpb_dpb_delays_present_flag = 0;
+
+  return 0;
+}
+
+void parse_sei(struct buf_reader *buf, struct nal_parser *parser)
+{
+  struct sei_message *sei = &(parser->current_nal->sei);
+  struct seq_parameter_set_rbsp *sps = parser->current_nal->sps;
+  uint8_t tmp;
+
+  sei->payload_type = 0;
+  while((tmp = read_bits(buf, 8)) == 0xff) {
+    sei->payload_type += 255;
+  }
+  sei->last_payload_type_byte = tmp;
+  sei->payload_type += sei->last_payload_type_byte;
+
+  sei->payload_size = 0;
+  while((tmp = read_bits(buf, 8)) == 0xff) {
+    sei->payload_size += 255;
+  }
+  sei->last_payload_size_byte = tmp;
+  sei->payload_size += sei->last_payload_size_byte;
+
+  /* pic_timing */
+  if(sei->payload_type == 1) {
+    if(parser->cpb_dpb_delays_present_flag) {
+      sei->pic_timing.cpb_removal_delay = read_bits(buf, 5);
+      sei->pic_timing.dpb_output_delay = read_bits(buf, 5);
+    }
+
+    if(sps && sps->vui_parameters_present_flag &&
+        sps->vui_parameters.pic_struct_present_flag) {
+      sei->pic_timing.pic_struct = read_bits(buf, 4);
+      switch(sei->pic_timing.pic_struct) {
+        case DISP_FRAME:
+          parser->current_nal->interlaced = 0;
+          parser->current_nal->repeat_pic = 0;
+          break;
+        case DISP_TOP:
+        case DISP_BOTTOM:
+        case DISP_TOP_BOTTOM:
+        case DISP_BOTTOM_TOP:
+          parser->current_nal->interlaced = 1;
+          break;
+        case DISP_TOP_BOTTOM_TOP:
+        case DISP_BOTTOM_TOP_BOTTOM:
+          parser->current_nal->interlaced = 1;
+          parser->current_nal->repeat_pic = 1;
+          break;
+        case DISP_FRAME_DOUBLING:
+          parser->current_nal->interlaced = 0;
+          parser->current_nal->repeat_pic = 2;
+          break;
+        case DISP_FRAME_TRIPLING:
+          parser->current_nal->interlaced = 0;
+          parser->current_nal->repeat_pic = 3;
+      }
+    }
+  }
+}
+
+void parse_vui_parameters(struct buf_reader *buf,
+    struct seq_parameter_set_rbsp *sps)
+{
+  sps->vui_parameters.aspect_ration_info_present_flag = read_bits(buf, 1);
+  if (sps->vui_parameters.aspect_ration_info_present_flag == 1) {
+    sps->vui_parameters.aspect_ratio_idc = read_bits(buf, 8);
+    if (sps->vui_parameters.aspect_ratio_idc == ASPECT_EXTENDED_SAR) {
+      sps->vui_parameters.sar_width = read_bits(buf, 16);
+      sps->vui_parameters.sar_height = read_bits(buf, 16);
+    }
+  }
+
+  sps->vui_parameters.overscan_info_present_flag = read_bits(buf, 1);
+  if (sps->vui_parameters.overscan_info_present_flag) {
+    sps->vui_parameters.overscan_appropriate_flag = read_bits(buf, 1);
+  }
+
+  sps->vui_parameters.video_signal_type_present_flag = read_bits(buf, 1);
+  if (sps->vui_parameters.video_signal_type_present_flag) {
+    sps->vui_parameters.video_format = read_bits(buf, 3);
+    sps->vui_parameters.video_full_range_flag = read_bits(buf, 1);
+    sps->vui_parameters.colour_description_present = read_bits(buf, 1);
+    if (sps->vui_parameters.colour_description_present) {
+      sps->vui_parameters.colour_primaries = read_bits(buf, 8);
+      sps->vui_parameters.transfer_characteristics = read_bits(buf, 8);
+      sps->vui_parameters.matrix_coefficients = read_bits(buf, 8);
+    }
+  }
+
+  sps->vui_parameters.chroma_loc_info_present_flag = read_bits(buf, 1);
+  if (sps->vui_parameters.chroma_loc_info_present_flag) {
+    sps->vui_parameters.chroma_sample_loc_type_top_field = read_exp_golomb(buf);
+    sps->vui_parameters.chroma_sample_loc_type_bottom_field = read_exp_golomb(
+        buf);
+  }
+
+  sps->vui_parameters.timing_info_present_flag = read_bits(buf, 1);
+  if (sps->vui_parameters.timing_info_present_flag) {
+    uint32_t num_units_in_tick = read_bits(buf, 32);
+    uint32_t time_scale = read_bits(buf, 32);
+    sps->vui_parameters.num_units_in_tick = num_units_in_tick;
+    sps->vui_parameters.time_scale = time_scale;
+    sps->vui_parameters.fixed_frame_rate_flag = read_bits(buf, 1);
+  }
+
+  sps->vui_parameters.nal_hrd_parameters_present_flag = read_bits(buf, 1);
+  if (sps->vui_parameters.nal_hrd_parameters_present_flag)
+    parse_hrd_parameters(buf, &sps->vui_parameters.nal_hrd_parameters);
+
+  sps->vui_parameters.vc1_hrd_parameters_present_flag = read_bits(buf, 1);
+  if (sps->vui_parameters.vc1_hrd_parameters_present_flag)
+    parse_hrd_parameters(buf, &sps->vui_parameters.vc1_hrd_parameters);
+
+  if (sps->vui_parameters.nal_hrd_parameters_present_flag
+      || sps->vui_parameters.vc1_hrd_parameters_present_flag)
+    sps->vui_parameters.low_delay_hrd_flag = read_bits(buf, 1);
+
+  sps->vui_parameters.pic_struct_present_flag = read_bits(buf, 1);
+  sps->vui_parameters.bitstream_restriction_flag = read_bits(buf, 1);
+
+  if (sps->vui_parameters.bitstream_restriction_flag) {
+    sps->vui_parameters.motion_vectors_over_pic_boundaries = read_bits(buf, 1);
+    sps->vui_parameters.max_bytes_per_pic_denom = read_exp_golomb(buf);
+    sps->vui_parameters.max_bits_per_mb_denom = read_exp_golomb(buf);
+    sps->vui_parameters.log2_max_mv_length_horizontal = read_exp_golomb(buf);
+    sps->vui_parameters.log2_max_mv_length_vertical = read_exp_golomb(buf);
+    sps->vui_parameters.num_reorder_frames = read_exp_golomb(buf);
+    sps->vui_parameters.max_dec_frame_buffering = read_exp_golomb(buf);
+    printf("Max_dec_frame_buffering: %d\n", sps->vui_parameters.max_dec_frame_buffering);
+  }
+}
+
+void parse_hrd_parameters(struct buf_reader *buf, struct hrd_parameters *hrd)
+{
+  hrd->cpb_cnt_minus1 = read_exp_golomb(buf);
+  hrd->bit_rate_scale = read_bits(buf, 4);
+  hrd->cpb_size_scale = read_bits(buf, 4);
+
+  int i;
+  for (i = 0; i <= hrd->cpb_cnt_minus1; i++) {
+    hrd->bit_rate_value_minus1[i] = read_exp_golomb(buf);
+    hrd->cpb_size_value_minus1[i] = read_exp_golomb(buf);
+    hrd->cbr_flag[i] = read_bits(buf, 1);
+  }
+
+  hrd->initial_cpb_removal_delay_length_minus1 = read_bits(buf, 5);
+  hrd->cpb_removal_delay_length_minus1 = read_bits(buf, 5);
+  hrd->dpb_output_delay_length_minus1 = read_bits(buf, 5);
+  hrd->time_offset_length = read_bits(buf, 5);
+}
+
+uint8_t parse_pps(struct buf_reader *buf, struct pic_parameter_set_rbsp *pps,
+    struct seq_parameter_set_rbsp *sps)
+{
+  pps->pic_parameter_set_id = read_exp_golomb(buf);
+  pps->seq_parameter_set_id = read_exp_golomb(buf);
+  pps->entropy_coding_mode_flag = read_bits(buf, 1);
+  pps->pic_order_present_flag = read_bits(buf, 1);
+
+  pps->num_slice_groups_minus1 = read_exp_golomb(buf);
+  if (pps->num_slice_groups_minus1 > 0) {
+    pps->slice_group_map_type = read_exp_golomb(buf);
+    if (pps->slice_group_map_type == 0) {
+      int i_group;
+      for (i_group = 0; i_group <= pps->num_slice_groups_minus1; i_group++) {
+        if (i_group < 64)
+          pps->run_length_minus1[i_group] = read_exp_golomb(buf);
+        else { // FIXME: skips if more than 64 groups exist
+          fprintf(stderr, "Error: Only 64 slice_groups are supported\n");
+          read_exp_golomb(buf);
+        }
+      }
+    }
+    else if (pps->slice_group_map_type == 3 || pps->slice_group_map_type == 4
+        || pps->slice_group_map_type == 5) {
+      pps->slice_group_change_direction_flag = read_bits(buf, 1);
+      pps->slice_group_change_rate_minus1 = read_exp_golomb(buf);
+    }
+    else if (pps->slice_group_map_type == 6) {
+      pps->pic_size_in_map_units_minus1 = read_exp_golomb(buf);
+      int i_group;
+      for (i_group = 0; i_group <= pps->num_slice_groups_minus1; i_group++) {
+        pps->slice_group_id[i_group] = read_bits(buf, ceil(log(
+            pps->num_slice_groups_minus1 + 1)));
+      }
+    }
+  }
+
+  pps->num_ref_idx_l0_active_minus1 = read_exp_golomb(buf);
+  pps->num_ref_idx_l1_active_minus1 = read_exp_golomb(buf);
+  pps->weighted_pred_flag = read_bits(buf, 1);
+  pps->weighted_bipred_idc = read_bits(buf, 2);
+  pps->pic_init_qp_minus26 = read_exp_golomb_s(buf);
+  pps->pic_init_qs_minus26 = read_exp_golomb_s(buf);
+  pps->chroma_qp_index_offset = read_exp_golomb_s(buf);
+  pps->deblocking_filter_control_present_flag = read_bits(buf, 1);
+  pps->constrained_intra_pred_flag = read_bits(buf, 1);
+  pps->redundant_pic_cnt_present_flag = read_bits(buf, 1);
+
+  int bit_length = (buf->len*8)-rbsp_trailing_bits(buf->buf, buf->len);
+  int bit_read = bits_read(buf);
+
+  memset(pps->scaling_lists_4x4, 16, sizeof(pps->scaling_lists_4x4));
+  memset(pps->scaling_lists_8x8, 16, sizeof(pps->scaling_lists_8x8));
+  if (bit_length-bit_read > 1) {
+    printf("Read transform 8x8\n");
+    pps->transform_8x8_mode_flag = read_bits(buf, 1);
+    pps->pic_scaling_matrix_present_flag = read_bits(buf, 1);
+    if (pps->pic_scaling_matrix_present_flag) {
+      int i;
+      for (i = 0; i < 6 + 2 * pps->transform_8x8_mode_flag; i++) {
+        pps->pic_scaling_list_present_flag[i] = read_bits(buf, 1);
+
+        if (pps->pic_scaling_list_present_flag[i]) {
+          if (i < 6)
+            parse_scaling_list(buf, pps->scaling_lists_4x4[i], 16, i);
+          else
+            parse_scaling_list(buf, pps->scaling_lists_8x8[i - 6], 64, i);
+        } else {
+          pps_scaling_list_fallback(sps, pps, i);
+        }
+      }
+    }
+
+    pps->second_chroma_qp_index_offset = read_exp_golomb_s(buf);
+  }
+
+  if (!pps->pic_scaling_matrix_present_flag && sps != NULL) {
+    //printf("MEMCPY SCALING LIST\n");
+    memcpy(pps->scaling_lists_4x4, sps->scaling_lists_4x4,
+        sizeof(pps->scaling_lists_4x4));
+    memcpy(pps->scaling_lists_8x8, sps->scaling_lists_8x8,
+        sizeof(pps->scaling_lists_8x8));
+  }
+  /*else if (sps == NULL) {
+    printf("sPS MISSING\n");
+  }*/
+
+  return 0;
+}
+
+uint8_t parse_slice_header(struct buf_reader *buf, struct nal_parser *parser)
+{
+  struct nal_unit *nal = parser->current_nal;
+
+  struct seq_parameter_set_rbsp *sps = nal->sps;
+  struct pic_parameter_set_rbsp *pps = nal->pps;
+  struct slice_header *slc = nal->slc;
+  if (!sps || !pps)
+    return -1;
+
+  slc->first_mb_in_slice = read_exp_golomb(buf);
+  /* we do some parsing on the slice type, because the list is doubled */
+  slc->slice_type = slice_type(read_exp_golomb(buf));
+
+  //print_slice_type(slc->slice_type);
+  slc->pic_parameter_set_id = read_exp_golomb(buf);
+  slc->frame_num = read_bits(buf, sps->log2_max_frame_num_minus4 + 4);
+  if (!sps->frame_mbs_only_flag) {
+    slc->field_pic_flag = read_bits(buf, 1);
+    if (slc->field_pic_flag)
+      slc->bottom_field_flag = read_bits(buf, 1);
+    else
+      slc->bottom_field_flag = 0;
+  }
+  else {
+    slc->field_pic_flag = 0;
+    slc->bottom_field_flag = 0;
+  }
+
+  if (slc->field_pic_flag == 0)
+    nal->curr_pic_num = slc->frame_num;
+  else
+    nal->curr_pic_num = 2 * slc->frame_num + 1;
+
+  if (nal->nal_unit_type == NAL_SLICE_IDR)
+    slc->idr_pic_id = read_exp_golomb(buf);
+
+  if (!sps->pic_order_cnt_type) {
+    slc->pic_order_cnt_lsb = read_bits(buf,
+        sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+    if (pps->pic_order_present_flag && !slc->field_pic_flag)
+      slc->delta_pic_order_cnt_bottom = read_exp_golomb_s(buf);
+  }
+  else if (sps->pic_order_cnt_type == 1) {
+    slc->delta_pic_order_cnt[0] = read_exp_golomb_s(buf);
+    if (pps->pic_order_present_flag && !slc->field_pic_flag)
+      slc->delta_pic_order_cnt[1] = read_exp_golomb_s(buf);
+  }
+
+  if (pps->redundant_pic_cnt_present_flag == 1) {
+    slc->redundant_pic_cnt = read_exp_golomb(buf);
+  }
+
+  if (slc->slice_type == SLICE_B)
+    slc->direct_spatial_mv_pred_flag = read_bits(buf, 1);
+
+  if (slc->slice_type == SLICE_P || slc->slice_type == SLICE_SP
+      || slc->slice_type == SLICE_B) {
+    slc->num_ref_idx_active_override_flag = read_bits(buf, 1);
+
+    if (slc->num_ref_idx_active_override_flag == 1) {
+      slc->num_ref_idx_l0_active_minus1 = read_exp_golomb(buf);
+
+      if (slc->slice_type == SLICE_B) {
+        slc->num_ref_idx_l1_active_minus1 = read_exp_golomb(buf);
+      }
+    }
+  }
+
+  /* --- ref_pic_list_reordering --- */
+  parse_ref_pic_list_reordering(buf, nal, parser);
+
+  /* --- pred_weight_table --- */
+  if ((pps->weighted_pred_flag && (slc->slice_type == SLICE_P
+      || slc->slice_type == SLICE_SP)) || (pps->weighted_bipred_idc == 1
+      && slc->slice_type == SLICE_B)) {
+    parse_pred_weight_table(buf, nal);
+  }
+
+  /* --- dec_ref_pic_marking --- */
+  if (nal->nal_ref_idc != 0)
+    parse_dec_ref_pic_marking(buf, parser);
+  else
+    slc->dec_ref_pic_marking_count = 0;
+
+  return 0;
+}
+
+void parse_ref_pic_list_reordering(struct buf_reader *buf, struct nal_unit *nal, struct nal_parser *parser)
+{
+  struct seq_parameter_set_rbsp *sps = nal->sps;
+  struct pic_parameter_set_rbsp *pps = nal->pps;
+  struct slice_header *slc = nal->slc;
+  if (!sps || !pps)
+    return;
+
+  if (slc->slice_type != SLICE_I && slc->slice_type != SLICE_SI) {
+    slc->ref_pic_list_reordering.ref_pic_list_reordering_flag_l0 = read_bits(
+        buf, 1);
+
+    if (slc->ref_pic_list_reordering.ref_pic_list_reordering_flag_l0 == 1) {
+      do {
+        slc->ref_pic_list_reordering.reordering_of_pic_nums_idc
+            = read_exp_golomb(buf);
+
+        if (slc->ref_pic_list_reordering.reordering_of_pic_nums_idc == 0
+            || slc->ref_pic_list_reordering.reordering_of_pic_nums_idc == 1) {
+          slc->ref_pic_list_reordering.abs_diff_pic_num_minus1
+              = read_exp_golomb(buf);
+        }
+        else if (slc->ref_pic_list_reordering.reordering_of_pic_nums_idc == 2) {
+          slc->ref_pic_list_reordering.long_term_pic_num = read_exp_golomb(buf);
+        }
+      } while (slc->ref_pic_list_reordering.reordering_of_pic_nums_idc != 3);
+    }
+  }
+
+  if (slc->slice_type == SLICE_B) {
+    slc->ref_pic_list_reordering.ref_pic_list_reordering_flag_l1 = read_bits(
+        buf, 1);
+
+    if (slc->ref_pic_list_reordering.ref_pic_list_reordering_flag_l1 == 1) {
+      do {
+        slc->ref_pic_list_reordering.reordering_of_pic_nums_idc
+            = read_exp_golomb(buf);
+
+        if (slc->ref_pic_list_reordering.reordering_of_pic_nums_idc == 0
+            || slc->ref_pic_list_reordering.reordering_of_pic_nums_idc == 1) {
+          slc->ref_pic_list_reordering.abs_diff_pic_num_minus1
+              = read_exp_golomb(buf);
+        }
+        else if (slc->ref_pic_list_reordering.reordering_of_pic_nums_idc == 2) {
+          slc->ref_pic_list_reordering.long_term_pic_num = read_exp_golomb(buf);
+        }
+      } while (slc->ref_pic_list_reordering.reordering_of_pic_nums_idc != 3);
+    }
+  }
+}
+
+void parse_pred_weight_table(struct buf_reader *buf, struct nal_unit *nal)
+{
+  struct seq_parameter_set_rbsp *sps = nal->sps;
+  struct pic_parameter_set_rbsp *pps = nal->pps;
+  struct slice_header *slc = nal->slc;
+  if (!sps || !pps)
+    return;
+
+  nal->slc->pred_weight_table.luma_log2_weight_denom = read_exp_golomb(buf);
+
+  if (sps->chroma_format_idc != 0)
+    nal->slc->pred_weight_table.chroma_log2_weight_denom = read_exp_golomb(buf);
+
+  int i;
+  for (i = 0; i <= pps->num_ref_idx_l0_active_minus1; i++) {
+    uint8_t luma_weight_l0_flag = read_bits(buf, 1);
+
+    if (luma_weight_l0_flag == 1) {
+      nal->slc->pred_weight_table.luma_weight_l0[i] = read_exp_golomb_s(buf);
+      nal->slc->pred_weight_table.luma_offset_l0[i] = read_exp_golomb_s(buf);
+    }
+
+    if (sps->chroma_format_idc != 0) {
+      uint8_t chroma_weight_l0_flag = read_bits(buf, 1);
+
+      if (chroma_weight_l0_flag == 1) {
+        int j;
+        for (j = 0; j < 2; j++) {
+          nal->slc->pred_weight_table.chroma_weight_l0[i][j]
+              = read_exp_golomb_s(buf);
+          nal->slc->pred_weight_table.chroma_offset_l0[i][j]
+              = read_exp_golomb_s(buf);
+        }
+      }
+    }
+  }
+
+  if (slc->slice_type == SLICE_B) {
+    for (i = 0; i <= pps->num_ref_idx_l1_active_minus1; i++) {
+      uint8_t luma_weight_l1_flag = read_bits(buf, 1);
+
+      if (luma_weight_l1_flag == 1) {
+        nal->slc->pred_weight_table.luma_weight_l1[i] = read_exp_golomb_s(buf);
+        nal->slc->pred_weight_table.luma_offset_l1[i] = read_exp_golomb_s(buf);
+      }
+
+      if (sps->chroma_format_idc != 0) {
+        uint8_t chroma_weight_l1_flag = read_bits(buf, 1);
+
+        if (chroma_weight_l1_flag == 1) {
+          int j;
+          for (j = 0; j < 2; j++) {
+            nal->slc->pred_weight_table.chroma_weight_l1[i][j]
+                = read_exp_golomb_s(buf);
+            nal->slc->pred_weight_table.chroma_offset_l1[i][j]
+                = read_exp_golomb_s(buf);
+          }
+        }
+      }
+    }
+  }
+}
+
+void decode_ref_pic_marking(struct nal_unit *nal,
+    uint32_t memory_management_control_operation,
+    uint32_t marking_nr,
+    struct nal_parser *parser)
+{
+  struct seq_parameter_set_rbsp *sps = nal->sps;
+  struct pic_parameter_set_rbsp *pps = nal->pps;
+  struct slice_header *slc = nal->slc;
+  struct dpb *dpb = &parser->dpb;
+  if (!sps || !pps || !slc)
+    return;
+
+  if (memory_management_control_operation == 1) {
+    // short-term -> unused for reference
+    uint32_t pic_num_x = nal->curr_pic_num
+        - (slc->dec_ref_pic_marking[marking_nr].difference_of_pic_nums_minus1 + 1);
+    struct decoded_picture* pic = dpb_get_picture(dpb, pic_num_x);
+    if (pic != NULL) {
+      if (pic->nal->slc->field_pic_flag == 0) {
+        printf("Set %d as unused for ref\n", pic_num_x);
+        dpb_set_unused_ref_picture_a(dpb, pic);
+      } else {
+        if(!pic->top_is_reference)
+          dpb_set_unused_ref_picture_a(dpb, pic);
+        else
+          pic->top_is_reference = 0;
+        //printf("FIXME: We might need do delete more from the DPB...\n");
+        // FIXME: some more handling needed here?! See 8.2.5.4.1, p. 120
+      }
+    }
+  }
+  else if (memory_management_control_operation == 2) {
+    // long-term -> unused for reference
+    struct decoded_picture* pic = dpb_get_picture_by_ltpn(dpb,
+        slc->dec_ref_pic_marking[marking_nr].long_term_pic_num);
+    if (pic != NULL) {
+      if (pic->nal->slc->field_pic_flag == 0)
+        dpb_set_unused_ref_picture(dpb,
+            slc->dec_ref_pic_marking[marking_nr].long_term_pic_num);
+      else {
+        dpb_set_unused_ref_picture(dpb,
+            slc->dec_ref_pic_marking[marking_nr].long_term_pic_num);
+        printf("FIXME: We might need do delete more from the DPB...\n");
+      }
+    }
+  }
+  else if (memory_management_control_operation == 3) {
+    // short-term -> long-term, set long-term frame index
+    uint32_t pic_num_x = nal->curr_pic_num
+        - (slc->dec_ref_pic_marking[marking_nr].difference_of_pic_nums_minus1 + 1);
+    struct decoded_picture* pic = dpb_get_picture_by_ltidx(dpb,
+        slc->dec_ref_pic_marking[marking_nr].long_term_pic_num);
+    if (pic != NULL)
+      dpb_set_unused_ref_picture_bylidx(dpb,
+          slc->dec_ref_pic_marking[marking_nr].long_term_frame_idx);
+
+    pic = dpb_get_picture(dpb, pic_num_x);
+    if (pic) {
+      if (pic->nal->slc->field_pic_flag == 0) {
+        pic = dpb_get_picture(dpb, pic_num_x);
+        pic->nal->long_term_frame_idx
+            = slc->dec_ref_pic_marking[marking_nr].long_term_frame_idx;
+      }
+      else
+        printf("FIXME: B Set frame %d to long-term ref\n", pic_num_x);
+    }
+    else {
+      printf("memory_management_control_operation: 3 failed. No such picture.\n");
+    }
+
+  }
+  else if (memory_management_control_operation == 4) {
+    // set max-long-term frame index,
+    // mark all long-term pictures with long-term frame idx
+    // greater max-long-term farme idx as unused for ref
+    if (slc->dec_ref_pic_marking[marking_nr].max_long_term_frame_idx_plus1 == 0)
+      dpb_set_unused_ref_picture_lidx_gt(dpb, 0);
+    else
+      dpb_set_unused_ref_picture_lidx_gt(dpb,
+          slc->dec_ref_pic_marking[marking_nr].max_long_term_frame_idx_plus1 - 1);
+  }
+  else if (memory_management_control_operation == 5) {
+    // mark all ref pics as unused for reference,
+    // set max-long-term frame index = no long-term frame idxs
+    dpb_flush(dpb);
+    parser->prev_pic_order_cnt_lsb = 0;
+    parser->prev_pic_order_cnt_msb = 0;
+  }
+  else if (memory_management_control_operation == 6) {
+    // mark current picture as used for long-term ref,
+    // assing long-term frame idx to it
+    struct decoded_picture* pic = dpb_get_picture_by_ltidx(dpb,
+        slc->dec_ref_pic_marking[marking_nr].long_term_frame_idx);
+    if (pic != NULL)
+      dpb_set_unused_ref_picture_bylidx(dpb,
+          slc->dec_ref_pic_marking[marking_nr].long_term_frame_idx);
+
+    nal->long_term_frame_idx = slc->dec_ref_pic_marking[marking_nr].long_term_frame_idx;
+
+    if (slc->field_pic_flag == 0) {
+      nal->used_for_long_term_ref = 1;
+    }
+    else
+      printf("FIXME: BY Set frame to long-term ref\n");
+  }
+}
+
+void parse_dec_ref_pic_marking(struct buf_reader *buf,
+    struct nal_parser *parser)
+{
+  struct nal_unit *nal = parser->current_nal;
+  struct seq_parameter_set_rbsp *sps = nal->sps;
+  struct pic_parameter_set_rbsp *pps = nal->pps;
+  struct slice_header *slc = nal->slc;
+  if (!sps || !pps)
+    return;
+
+  slc->dec_ref_pic_marking_count = 0;
+  int i = slc->dec_ref_pic_marking_count;
+
+  if (nal->nal_unit_type == NAL_SLICE_IDR) {
+    slc->dec_ref_pic_marking[i].no_output_of_prior_pics_flag = read_bits(buf, 1);
+    slc->dec_ref_pic_marking[i].long_term_reference_flag = read_bits(buf, 1);
+  }
+  else {
+    slc->dec_ref_pic_marking[i].adaptive_ref_pic_marking_mode_flag = read_bits(
+        buf, 1);
+
+    if (slc->dec_ref_pic_marking[i].adaptive_ref_pic_marking_mode_flag) {
+      do {
+        slc->dec_ref_pic_marking[i].memory_management_control_operation
+            = read_exp_golomb(buf);
+
+        if (slc->dec_ref_pic_marking[i].memory_management_control_operation == 1
+            || slc->dec_ref_pic_marking[i].memory_management_control_operation
+                == 3)
+          slc->dec_ref_pic_marking[i].difference_of_pic_nums_minus1
+              = read_exp_golomb(buf);
+
+        if (slc->dec_ref_pic_marking[i].memory_management_control_operation == 2)
+          slc->dec_ref_pic_marking[i].long_term_pic_num = read_exp_golomb(buf);
+
+        if (slc->dec_ref_pic_marking[i].memory_management_control_operation == 3
+            || slc->dec_ref_pic_marking[i].memory_management_control_operation
+                == 6)
+          slc->dec_ref_pic_marking[i].long_term_frame_idx = read_exp_golomb(buf);
+
+        if (slc->dec_ref_pic_marking[i].memory_management_control_operation == 4)
+          slc->dec_ref_pic_marking[i].max_long_term_frame_idx_plus1
+              = read_exp_golomb(buf);
+
+        i++;
+        if(i >= 10) {
+          printf("Error: Not more than 10 MMC operations supported per slice. Dropping some.\n");
+          i = 0;
+        }
+      } while (slc->dec_ref_pic_marking[i-1].memory_management_control_operation
+          != 0);
+    }
+  }
+
+  slc->dec_ref_pic_marking_count = i;
+}
+
+/* ----------------- NAL parser ----------------- */
+
+struct nal_parser* init_parser()
+{
+  struct nal_parser *parser = calloc(1, sizeof(struct nal_parser));
+  parser->nal0 = init_nal_unit();
+  parser->nal1 = init_nal_unit();
+  parser->current_nal = parser->nal0;
+  parser->last_nal = parser->nal1;
+  parser->slice_cnt = 1;
+
+  parser->field = -1;
+
+  /* no idea why we do that. inspired by libavcodec,
+   * as we couldn't figure in the specs....
+   */
+  parser->prev_pic_order_cnt_msb = parser->pic_order_cnt_lsb = 1 << 16;
+
+  return parser;
+}
+
+void free_parser(struct nal_parser *parser)
+{
+  free_nal_unit(parser->nal0);
+  free_nal_unit(parser->nal1);
+  free(parser);
+}
+
+void parse_codec_private(struct nal_parser *parser, uint8_t *inbuf, int inbuf_len)
+{
+  struct buf_reader bufr;
+
+  bufr.buf = inbuf;
+  bufr.cur_pos = inbuf;
+  bufr.cur_offset = 8;
+  bufr.len = inbuf_len;
+
+  struct nal_unit *nal = parser->current_nal;
+  struct nal_unit *nal1 = parser->last_nal;
+
+  if (!nal->sps)
+    nal->sps = calloc(1, sizeof(struct seq_parameter_set_rbsp));
+  else
+    memset(nal->sps, 0x00, sizeof(struct seq_parameter_set_rbsp));
+
+  /* reserved */
+  read_bits(&bufr, 8);
+  nal->sps->profile_idc = read_bits(&bufr, 8);
+  read_bits(&bufr, 8);
+  nal->sps->level_idc = read_bits(&bufr, 8);
+  read_bits(&bufr, 6);
+
+  parser->nal_size_length = read_bits(&bufr, 2) + 1;
+  parser->nal_size_length_buf = calloc(1, parser->nal_size_length);
+  read_bits(&bufr, 3);
+  uint8_t sps_count = read_bits(&bufr, 5);
+
+  inbuf += 6;
+  inbuf_len -= 6;
+  int i;
+  for(i = 0; i < sps_count; i++) {
+    uint16_t sps_size = read_bits(&bufr, 16);
+    inbuf += 2;
+    inbuf_len -= 2;
+    parse_nal(inbuf, sps_size, parser);
+    inbuf += sps_size;
+    inbuf_len -= sps_size;
+  }
+
+  bufr.buf = inbuf;
+  bufr.cur_pos = inbuf;
+  bufr.cur_offset = 8;
+  bufr.len = inbuf_len;
+
+  uint8_t pps_count = read_bits(&bufr, 8);
+  inbuf += 1;
+  for(i = 0; i < pps_count; i++) {
+    uint16_t pps_size = read_bits(&bufr, 16);
+    inbuf += 2;
+    inbuf_len -= 2;
+    parse_nal(inbuf, pps_size, parser);
+    inbuf += pps_size;
+    inbuf_len -= pps_size;
+  }
+
+  copy_nal_unit(nal1, nal);
+  printf("done parsing extradata\n");
+}
+
+
+int parse_frame(struct nal_parser *parser, uint8_t *inbuf, int inbuf_len,
+    uint8_t **ret_buf, uint32_t *ret_len, uint32_t *ret_slice_cnt)
+{
+  int32_t next_nal = 0;
+  int parsed_len = 0;
+  int search_offset = 0;
+  int start_seq_len = 3;
+  uint8_t completed_nal = 0;
+
+  uint8_t *prebuf = parser->prebuf;
+
+  if(parser->nal_size_length > 0)
+    start_seq_len = 4-parser->have_nal_size_length_buf;
+
+  if(parser->last_nal_res == 1 && parser->current_nal &&
+      parser->current_nal->slc) {
+    int i;
+    for(i = 0; i < parser->current_nal->slc->dec_ref_pic_marking_count; i++) {
+      decode_ref_pic_marking(
+          parser->current_nal,
+          parser->current_nal->slc->dec_ref_pic_marking[i].memory_management_control_operation,
+          i,
+          parser);
+    }
+  }
+
+  while ((next_nal = seek_for_nal(inbuf+search_offset, inbuf_len-parsed_len-search_offset, parser)) >= 0) {
+    next_nal += search_offset;
+    if(parser->nal_size_length > 0)
+        start_seq_len = 4-parser->have_nal_size_length_buf;
+
+    if(parser->incomplete_nal || completed_nal || next_nal == 0 ||
+        parser->nal_size_length) {
+
+      if (parser->prebuf_len + next_nal > MAX_FRAME_SIZE) {
+        printf("buf underrun!!\n");
+        *ret_len = 0;
+        *ret_buf = NULL;
+        return parsed_len;
+      }
+
+      xine_fast_memcpy(parser->prebuf + parser->prebuf_len, inbuf, next_nal);
+      parser->prebuf_len += next_nal;
+      parser->incomplete_nal = 0;
+
+      parsed_len += next_nal;
+      inbuf += next_nal;
+
+      parser->last_nal_res = parse_nal(prebuf+start_seq_len, parser->prebuf_len-start_seq_len, parser);
+      if (parser->last_nal_res == 1 && parser->buf_len > 0) {
+
+        //printf("Frame complete: %d bytes\n", parser->buf_len);
+        *ret_len = parser->buf_len;
+        *ret_buf = malloc(*ret_len);
+        xine_fast_memcpy(*ret_buf, parser->buf, *ret_len);
+        *ret_slice_cnt = parser->slice_cnt;
+
+        parser->slice_cnt = 1;
+        parser->buf_len = 0;
+
+        /* this is a SLICE, keep it in the buffer */
+        //printf("slice %d size: %d\n", parser->slice_cnt-1, parser->prebuf_len);
+        if(parser->nal_size_length > 0) {
+          uint8_t start_seq[3] = { 0x00, 0x00, 0x01 };
+          xine_fast_memcpy(parser->buf, start_seq, 3);
+          parser->buf_len += 3;
+        }
+
+        int offset = 0;
+        if(parser->nal_size_length > 0)
+          offset = start_seq_len;
+        xine_fast_memcpy(parser->buf+parser->buf_len, prebuf+offset, parser->prebuf_len-offset);
+        parser->buf_len += parser->prebuf_len-offset;
+        parser->prebuf_len = 0;
+        parser->incomplete_nal = 0;
+
+        if (parser->last_nal->nal_ref_idc) {
+          if (parser->last_nal->slc != NULL)
+            parser->prev_pic_order_cnt_lsb
+                = parser->last_nal->slc->pic_order_cnt_lsb;
+          parser->prev_pic_order_cnt_msb = parser->pic_order_cnt_msb;
+        }
+        return parsed_len;
+      }
+
+      if (parser->last_nal_res != 2) {
+        if (parser->buf_len + parser->prebuf_len > MAX_FRAME_SIZE) {
+          printf("buf underrun 1!!\n");
+          parser->buf_len = 0;
+          *ret_len = 0;
+          *ret_buf = NULL;
+          return parsed_len;
+        }
+
+        //printf("slice %d size: %d\n", parser->slice_cnt-1, parser->prebuf_len);
+        /* this is a SLICE, keep it in the buffer */
+        if(parser->nal_size_length > 0) {
+          uint8_t start_seq[3] = { 0x00, 0x00, 0x01 };
+          xine_fast_memcpy(parser->buf + parser->buf_len, start_seq, 3);
+          parser->buf_len += 3;
+        }
+
+        int offset = 0;
+        if(parser->nal_size_length > 0)
+          offset = start_seq_len;
+
+        xine_fast_memcpy(parser->buf + parser->buf_len, prebuf+offset, parser->prebuf_len-offset);
+        parser->buf_len += (parser->prebuf_len-offset);
+      }
+
+      parser->prebuf_len = 0;
+      completed_nal = 1;
+
+    } else {
+      /* most likely we are at the beginning of the stream here
+       * which starts not with a nal-boundardy but with some garbage
+       * -> throw it away
+       */
+      parsed_len += next_nal;
+      inbuf += next_nal;
+    }
+
+    if(!parser->nal_size_length)
+      search_offset = start_seq_len;
+  }
+
+  /* if inbuf does not end with the start of a new nal
+   * copy the left data into prebuf
+   */
+  if(parsed_len < inbuf_len) {
+    if (inbuf_len-parsed_len + parser->prebuf_len > MAX_FRAME_SIZE) {
+      printf("buf underrun 0!!\n");
+      parser->prebuf_len = 0;
+      *ret_len = 0;
+      *ret_buf = NULL;
+      return parsed_len;
+    }
+    parser->incomplete_nal = 1;
+    xine_fast_memcpy(parser->prebuf + parser->prebuf_len, inbuf, inbuf_len-parsed_len);
+    parser->prebuf_len += inbuf_len-parsed_len;
+    parsed_len += inbuf_len-parsed_len;
+    inbuf += inbuf_len-parsed_len;
+
+    /* now check if prebuf contains a second slice header
+     * this might happen if the nal start sequence is split
+     * over the buf-boundary - if this is the case we
+     */
+    if(!parser->nal_size_length && parsed_len > 2 &&
+        (next_nal = seek_for_nal(prebuf+start_seq_len, parser->prebuf_len, parser)) >= 0) {
+      inbuf -= parser->prebuf_len-next_nal-start_seq_len;
+      parsed_len -= parser->prebuf_len-next_nal-start_seq_len;
+      parser->prebuf_len = next_nal+start_seq_len;
+    }
+  }
+
+  *ret_len = 0;
+  *ret_buf = NULL;
+  return parsed_len;
+}
+
+int parse_nal(uint8_t *buf, int buf_len, struct nal_parser *parser)
+{
+  struct buf_reader bufr;
+
+  bufr.buf = buf;
+  bufr.cur_pos = buf;
+  bufr.cur_offset = 8;
+  bufr.len = buf_len;
+
+  struct nal_unit *nal = parser->current_nal;
+  struct nal_unit *last_nal = parser->last_nal;
+
+  int res = parse_nal_header(&bufr, parser);
+  if (res == NAL_SLICE_IDR) {
+    parser->is_idr = 1;
+  }
+
+  calculate_pic_order(parser);
+
+  if (res >= NAL_SLICE && res <= NAL_SLICE_IDR) {
+    // now detect if it's a new frame!
+    int ret = 0;
+    uint8_t reason = 0;
+    if (nal->slc->field_pic_flag == 1)
+      parser->field = nal->slc->bottom_field_flag;
+    else {
+      parser->have_top = 1;
+      parser->field = -1;
+    }
+
+    if (nal->slc->field_pic_flag == 1 && nal->slc->bottom_field_flag == 0)
+      parser->have_top = 1;
+
+    parser->slice = 1;
+
+    if (nal->slc == NULL || last_nal->slc == NULL) {
+      ret = 1;
+      reason++;
+    }
+    if (nal->slc && last_nal->slc && (nal->slc->frame_num
+        != last_nal->slc->frame_num)) {
+      ret = 1;
+      reason++;
+    }
+    if (nal->slc && last_nal->slc && (nal->slc->pic_parameter_set_id
+        != last_nal->slc->pic_parameter_set_id)) {
+      ret = 1;
+      reason++;
+    }
+    if (nal->slc && last_nal->slc && (nal->slc->field_pic_flag
+        != last_nal->slc->field_pic_flag)) {
+      ret = 1;
+      reason++;
+    }
+    if (nal->slc && last_nal->slc && nal->slc->bottom_field_flag
+        != last_nal->slc->bottom_field_flag) {
+      ret = 1;
+      reason++;
+    }
+    if (nal->nal_ref_idc != last_nal->nal_ref_idc && (nal->nal_ref_idc == 0
+        || last_nal->nal_ref_idc == 0)) {
+      ret = 1;
+      reason++;
+    }
+    if (nal->sps && nal->slc && last_nal->slc && (nal->sps->pic_order_cnt_type
+        == 0 && last_nal->sps->pic_order_cnt_type == 0
+        && (nal->slc->pic_order_cnt_lsb != last_nal->slc->pic_order_cnt_lsb
+            || nal->slc->delta_pic_order_cnt_bottom
+                != last_nal->slc->delta_pic_order_cnt_bottom))) {
+      ret = 1;
+      reason++;
+      /*printf("C: Reason: %d, %d, %d\n", res, nal->slc->pic_order_cnt_lsb,
+          last_nal->slc->pic_order_cnt_lsb);*/
+    }
+    if (nal->slc && last_nal->slc && (nal->sps->pic_order_cnt_type == 1
+        && last_nal->sps->pic_order_cnt_type == 1
+        && (nal->slc->delta_pic_order_cnt[0]
+            != last_nal->slc->delta_pic_order_cnt[0]
+            || nal->slc->delta_pic_order_cnt[1]
+                != last_nal->slc->delta_pic_order_cnt[1]))) {
+      ret = 1;
+      reason++;
+    }
+    if (nal->nal_unit_type != last_nal->nal_unit_type && (nal->nal_unit_type
+        == 5 || last_nal->nal_unit_type == 5)) {
+      ret = 1;
+      reason++;
+    }
+    if (nal->slc && last_nal->slc && (nal->nal_unit_type == 5
+        && last_nal->nal_unit_type == 5 && nal->slc->idr_pic_id
+        != last_nal->slc->idr_pic_id)) {
+      ret = 1;
+      reason++;
+    }
+
+    if (parser->current_nal == parser->nal0) {
+      parser->current_nal = parser->nal1;
+      parser->last_nal = parser->nal0;
+    }
+    else {
+      parser->current_nal = parser->nal0;
+      parser->last_nal = parser->nal1;
+    }
+
+    if(!parser->current_nal->sps && parser->last_nal->sps) {
+      parser->current_nal->sps = malloc(sizeof(struct seq_parameter_set_rbsp));
+      xine_fast_memcpy(parser->current_nal->sps, parser->last_nal->sps, sizeof(struct seq_parameter_set_rbsp));
+    }
+
+    if(!parser->current_nal->pps && parser->last_nal->pps) {
+      parser->current_nal->pps = malloc(sizeof(struct pic_parameter_set_rbsp));
+      xine_fast_memcpy(parser->current_nal->pps, parser->last_nal->pps, sizeof(struct pic_parameter_set_rbsp));
+    }
+
+    /* increase the slice_cnt until a new frame is detected */
+    if (!ret)
+      parser->slice_cnt++;
+
+    return ret;
+  }
+  else if (res == NAL_PPS || res == NAL_SPS) {
+    return 2;
+  }
+  else if (res >= NAL_SEI) {
+    return 2;
+  }
+
+  return 0;
+}
+
+int seek_for_nal(uint8_t *buf, int buf_len, struct nal_parser *parser)
+{
+  if(parser->nal_size_length > 0) {
+    if(buf_len <= 0 ||
+        (buf_len < parser->nal_size_length &&
+        (parser->next_nal_position == 0 ||
+            parser->next_nal_position > buf_len))) {
+      /* if we have less than nal_size_length bytes
+       * left in the buffer we need to store them, so
+       * that the next length calculation will be correct
+       */
+      if(!parser->next_nal_position) {
+        memcpy(parser->nal_size_length_buf, buf, buf_len);
+        parser->have_nal_size_length_buf = buf_len;
+      }
+      return -1;
+    }
+
+    uint32_t next_nal = parser->next_nal_position;
+    if(!next_nal) {
+      if(parser->have_nal_size_length_buf > 0) {
+        memcpy(parser->nal_size_length_buf+parser->have_nal_size_length_buf, buf, parser->nal_size_length-parser->have_nal_size_length_buf);
+
+        struct buf_reader bufr;
+
+        bufr.buf = parser->nal_size_length_buf;
+        bufr.cur_pos = parser->nal_size_length_buf;
+        bufr.cur_offset = 8;
+        bufr.len = parser->nal_size_length;
+
+        next_nal = read_bits(&bufr, parser->nal_size_length*8)+4-parser->have_nal_size_length_buf;
+
+        parser->have_nal_size_length_buf = 0;
+      } else {
+        struct buf_reader bufr;
+
+        bufr.buf = buf;
+        bufr.cur_pos = buf;
+        bufr.cur_offset = 8;
+        bufr.len = buf_len;
+
+        next_nal = read_bits(&bufr, parser->nal_size_length*8)+4;
+      }
+    }
+
+    if(next_nal > buf_len) {
+      parser->next_nal_position = next_nal-buf_len;
+      return -1;
+    } else
+      parser->next_nal_position = 0;
+
+    return next_nal;
+  }
+
+  int i;
+  for (i = 0; i < buf_len - 2; i++) {
+    if (buf[i] == 0x00 && buf[i + 1] == 0x00 && buf[i + 2] == 0x01) {
+      //printf("found nal at: %d\n", i);
+      return i;
+    }
+  }
+
+  return -1;
+}
diff -Naur xine-lib-1.1.16.1-old/src/libvdpau/h264_parser.h xine-lib-1.1.16.1-new/src/libvdpau/h264_parser.h
--- xine-lib-1.1.16.1-old/src/libvdpau/h264_parser.h	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/libvdpau/h264_parser.h	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2008 Julian Scheel
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * h264_parser.h: Almost full-features H264 NAL-Parser
+ */
+
+#ifndef NAL_PARSER_H_
+#define NAL_PARSER_H_
+
+#include <stdlib.h>
+
+#include "xine_internal.h"
+#include "nal.h"
+#include "dpb.h"
+
+#define MAX_FRAME_SIZE  1024*1024
+
+struct nal_parser {
+    uint8_t buf[MAX_FRAME_SIZE];
+    uint32_t buf_len;
+
+    /* prebuf is used to store the currently
+     * processed nal unit */
+    uint8_t prebuf[MAX_FRAME_SIZE];
+    uint32_t prebuf_len;
+    uint32_t next_nal_position;
+    uint8_t incomplete_nal;
+
+    uint8_t found_sps;
+    uint8_t found_pps;
+    uint8_t last_nal_res;
+
+    uint8_t is_idr;
+
+    int field; /* 0=top, 1=bottom, -1=both */
+    int slice;
+    int slice_cnt;
+
+    uint8_t have_top;
+    uint8_t have_frame;
+
+    uint8_t nal_size_length;
+    uint32_t next_nal_size;
+    uint8_t *nal_size_length_buf;
+    uint8_t have_nal_size_length_buf;
+
+    struct nal_unit *nal0;
+    struct nal_unit *nal1;
+    struct nal_unit *current_nal;
+    struct nal_unit *last_nal;
+
+    uint8_t cpb_dpb_delays_present_flag;
+
+    uint32_t pic_order_cnt_lsb;
+    uint32_t pic_order_cnt_msb;
+    uint32_t prev_pic_order_cnt_lsb;
+    uint32_t prev_pic_order_cnt_msb;
+    uint32_t frame_num_offset;
+
+    /* this is dpb used for reference frame
+     * heading to vdpau + unordered frames
+     */
+    struct dpb dpb;
+};
+
+int parse_nal(uint8_t *buf, int buf_len, struct nal_parser *parser);
+
+int seek_for_nal(uint8_t *buf, int buf_len, struct nal_parser *parser);
+
+struct nal_parser* init_parser();
+void free_parser(struct nal_parser *parser);
+int parse_frame(struct nal_parser *parser, uint8_t *inbuf, int inbuf_len,
+                uint8_t **ret_buf, uint32_t *ret_len, uint32_t *ret_slice_cnt);
+
+void parse_codec_private(struct nal_parser *parser, uint8_t *inbuf, int inbuf_len);
+
+#endif
diff -Naur xine-lib-1.1.16.1-old/src/libvdpau/Makefile.am xine-lib-1.1.16.1-new/src/libvdpau/Makefile.am
--- xine-lib-1.1.16.1-old/src/libvdpau/Makefile.am	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/libvdpau/Makefile.am	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,22 @@
+include $(top_srcdir)/misc/Makefile.common
+
+AM_CFLAGS = $(VISIBILITY_FLAG)
+AM_LDFLAGS = $(xineplug_ldflags)
+
+if HAVE_VDPAU
+vdpau_h264_module = xineplug_decode_vdpau_h264.la
+VDPAU_CFLAGS = -D_ISOC99_SOURCE
+
+vdpau_mpeg12_module = xineplug_decode_vdpau_mpeg12.la
+endif
+
+xineplug_LTLIBRARIES = $(vdpau_h264_module) $(vdpau_mpeg12_module)
+
+xineplug_decode_vdpau_h264_la_SOURCES = nal.c dpb.c h264_parser.c vdpau_h264.c
+xineplug_decode_vdpau_h264_la_CFLAGS = $(AM_CFLAGS) $(VDPAU_CFLAGS)
+xineplug_decode_vdpau_h264_la_LIBADD = $(XINE_LIB) $(DYNAMIC_LD_LIBS) -lm
+
+xineplug_decode_vdpau_mpeg12_la_SOURCES = vdpau_mpeg12.c
+xineplug_decode_vdpau_mpeg12_la_CFLAGS = $(AM_CFLAGS)
+xineplug_decode_vdpau_mpeg12_la_LIBADD = $(XINE_LIB) $(DYNAMIC_LD_LIBS)
+
diff -Naur xine-lib-1.1.16.1-old/src/libvdpau/nal.c xine-lib-1.1.16.1-new/src/libvdpau/nal.c
--- xine-lib-1.1.16.1-old/src/libvdpau/nal.c	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/libvdpau/nal.c	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2008 Julian Scheel
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * nal.c: nal-structure utility functions
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "nal.h"
+#include "xine_internal.h"
+
+struct nal_unit* init_nal_unit()
+{
+  struct nal_unit *nal = calloc(1, sizeof(struct nal_unit));
+
+  /*nal->sps = calloc(1, sizeof(struct seq_parameter_set_rbsp));
+  nal->pps = calloc(1, sizeof(struct pic_parameter_set_rbsp));
+  nal->slc = calloc(1, sizeof(struct slice_header));*/
+
+  return nal;
+}
+
+void free_nal_unit(struct nal_unit *nal)
+{
+  if(!nal)
+    return;
+
+  free(nal->sps);
+  free(nal->pps);
+  free(nal->slc);
+  free(nal);
+}
+
+void copy_nal_unit(struct nal_unit *dest, struct nal_unit *src)
+{
+  /* size without pps, sps and slc units: */
+  int size = sizeof(struct nal_unit) - sizeof(struct seq_parameter_set_rbsp*)
+      - sizeof(struct pic_parameter_set_rbsp*) - sizeof(struct slice_header*);
+
+  xine_fast_memcpy(dest, src, size);
+
+  if(!dest->sps)
+    dest->sps = calloc(1, sizeof(struct seq_parameter_set_rbsp));
+
+  if(!dest->pps)
+    dest->pps = calloc(1, sizeof(struct pic_parameter_set_rbsp));
+
+  if(!dest->slc)
+    dest->slc = calloc(1, sizeof(struct slice_header));
+
+  if(src->sps)
+    xine_fast_memcpy(dest->sps, src->sps, sizeof(struct seq_parameter_set_rbsp));
+  if(src->pps)
+    xine_fast_memcpy(dest->pps, src->pps, sizeof(struct pic_parameter_set_rbsp));
+  if(src->slc)
+    xine_fast_memcpy(dest->slc, src->slc, sizeof(struct slice_header));
+}
diff -Naur xine-lib-1.1.16.1-old/src/libvdpau/nal.h xine-lib-1.1.16.1-new/src/libvdpau/nal.h
--- xine-lib-1.1.16.1-old/src/libvdpau/nal.h	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/libvdpau/nal.h	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,464 @@
+/*
+ * Copyright (C) 2008 Julian Scheel
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * nal.h: H264 NAL structures
+ */
+
+#ifndef NAL_H_
+#define NAL_H_
+#include <stdint.h>
+#include <vdpau/vdpau.h>
+
+enum nal_unit_types
+{
+  NAL_UNSPECIFIED = 0,
+  NAL_SLICE,
+  NAL_PART_A,
+  NAL_PART_B,
+  NAL_PART_C,
+  NAL_SLICE_IDR,
+  NAL_SEI,
+  NAL_SPS,
+  NAL_PPS,
+  NAL_AU_DELIMITER,
+  NAL_END_OF_SEQUENCE,
+  NAL_END_OF_STREAM,
+  NAL_FILLER_DATA,
+  NAL_SPS_EXT
+};
+
+enum pic_struct {
+  DISP_FRAME = 0,
+  DISP_TOP,
+  DISP_BOTTOM,
+  DISP_TOP_BOTTOM,
+  DISP_BOTTOM_TOP,
+  DISP_TOP_BOTTOM_TOP,
+  DISP_TOP_TOP_BOTTOM,
+  DISP_BOTTOM_TOP_BOTTOM,
+  DISP_FRAME_DOUBLING,
+  DISP_FRAME_TRIPLING
+};
+
+/* slice types repeat from 5-9, we
+ * need a helper function for comparison
+ */
+enum slice_types
+{
+  SLICE_P = 0, SLICE_B, SLICE_I, SLICE_SP, SLICE_SI
+};
+
+enum aspect_ratio
+{
+  ASPECT_UNSPECIFIED = 0,
+  ASPECT_1_1,
+  ASPECT_12_11,
+  ASPECT_10_11,
+  ASPECT_16_11,
+  ASPECT_40_33,
+  ASPECT_24_11,
+  ASPECT_20_11,
+  ASPECT_32_11,
+  ASPECT_80_33,
+  ASPECT_18_11,
+  ASPECT_15_11,
+  ASPECT_64_33,
+  ASPECT_160_99,
+  ASPECT_4_3,
+  ASPECT_3_2,
+  ASPECT_2_1,
+  ASPECT_RESERVED,
+  ASPECT_EXTENDED_SAR=255
+};
+
+static const uint8_t zigzag_4x4[16] = {
+  0+0*4, 1+0*4, 0+1*4, 0+2*4,
+  1+1*4, 2+0*4, 3+0*4, 2+1*4,
+  1+2*4, 0+3*4, 1+3*4, 2+2*4,
+  3+1*4, 3+2*4, 2+3*4, 3+3*4,
+};
+
+static const uint8_t zigzag_8x8[64] = {
+  0+0*8, 1+0*8, 0+1*8, 0+2*8,
+  1+1*8, 2+0*8, 3+0*8, 2+1*8,
+  1+2*8, 0+3*8, 0+4*8, 1+3*8,
+  2+2*8, 3+1*8, 4+0*8, 5+0*8,
+  4+1*8, 3+2*8, 2+3*8, 1+4*8,
+  0+5*8, 0+6*8, 1+5*8, 2+4*8,
+  3+3*8, 4+2*8, 5+1*8, 6+0*8,
+  7+0*8, 6+1*8, 5+2*8, 4+3*8,
+  3+4*8, 2+5*8, 1+6*8, 0+7*8,
+  1+7*8, 2+6*8, 3+5*8, 4+4*8,
+  5+3*8, 6+2*8, 7+1*8, 7+2*8,
+  6+3*8, 5+4*8, 4+5*8, 3+6*8,
+  2+7*8, 3+7*8, 4+6*8, 5+5*8,
+  6+4*8, 7+3*8, 7+4*8, 6+5*8,
+  5+6*8, 4+7*8, 5+7*8, 6+6*8,
+  7+5*8, 7+6*8, 6+7*8, 7+7*8,
+};
+
+static inline uint32_t slice_type(uint32_t slice_type)
+{
+  return (slice_type < 10 ? slice_type % 5 : slice_type);
+}
+
+static inline void print_slice_type(uint32_t slice_type)
+{
+  switch(slice_type) {
+    case SLICE_P:
+      printf("SLICE_P\n");
+      break;
+    case SLICE_B:
+      printf("SLICE_B\n");
+      break;
+    case SLICE_I:
+      printf("SLICE_I\n");
+      break;
+    case SLICE_SP:
+      printf("SLICE_SP\n");
+      break;
+    case SLICE_SI:
+      printf("SLICE_SI\n");
+      break;
+    default:
+      printf("Unknown SLICE\n");
+  }
+}
+
+struct hrd_parameters
+{
+  uint32_t cpb_cnt_minus1;
+  uint8_t bit_rate_scale;
+  uint8_t cpb_size_scale;
+
+  uint32_t bit_rate_value_minus1[32];
+  uint32_t cpb_size_value_minus1[32];
+  uint8_t cbr_flag[32];
+
+  uint8_t initial_cpb_removal_delay_length_minus1;
+  uint8_t cpb_removal_delay_length_minus1;
+  uint8_t dpb_output_delay_length_minus1;
+  uint8_t time_offset_length;
+};
+
+struct seq_parameter_set_rbsp
+{
+  uint8_t profile_idc; // 0xff
+  uint8_t constraint_setN_flag; // 0x0f
+  uint8_t level_idc; // 0xff
+  uint32_t seq_parameter_set_id;
+  uint32_t chroma_format_idc;
+  uint8_t residual_colour_transform_flag; // 0x01
+  uint32_t bit_depth_luma_minus8;
+  uint32_t bit_depth_chroma_minus8;
+  uint8_t qpprime_y_zero_transform_bypass_flag;
+  uint8_t seq_scaling_matrix_present_flag;
+
+  /* if(seq_scaling_matrix_present_flag) */
+  uint8_t seq_scaling_list_present_flag[8];
+
+  uint8_t scaling_lists_4x4[6][16];
+  uint8_t scaling_lists_8x8[2][64];
+  /* endif */
+
+  uint32_t log2_max_frame_num_minus4;
+  uint32_t pic_order_cnt_type;
+  // if pic_order_cnt_type==0
+  uint32_t log2_max_pic_order_cnt_lsb_minus4;
+  // else
+  uint8_t delta_pic_order_always_zero_flag;
+  int32_t offset_for_non_ref_pic;
+  int32_t offset_for_top_to_bottom_field;
+  uint8_t num_ref_frames_in_pic_order_cnt_cycle;
+  int32_t offset_for_ref_frame[256];
+  // TODO: some more ignored here
+  uint32_t num_ref_frames;
+  uint8_t gaps_in_frame_num_value_allowed_flag;
+  /*uint32_t    pic_width_in_mbs_minus1;
+   uint32_t    pic_height_in_map_units_minus1;*/
+  uint32_t pic_width;
+  uint32_t pic_height;
+  uint8_t frame_mbs_only_flag;
+  uint8_t mb_adaptive_frame_field_flag;
+  uint8_t direct_8x8_inference_flag;
+  uint8_t frame_cropping_flag;
+  uint32_t frame_crop_left_offset;
+  uint32_t frame_crop_right_offset;
+  uint32_t frame_crop_top_offset;
+  uint32_t frame_crop_bottom_offset;
+  uint8_t vui_parameters_present_flag;
+
+  /* vui_parameters */
+  struct
+  {
+    uint8_t aspect_ration_info_present_flag;
+
+    /* aspect_ration_info_present_flag == 1 */
+    uint8_t aspect_ratio_idc;
+    uint16_t sar_width;
+    uint16_t sar_height;
+
+    uint8_t overscan_info_present_flag;
+    /* overscan_info_present_flag == 1 */
+    uint8_t overscan_appropriate_flag;
+
+    uint8_t video_signal_type_present_flag;
+    /* video_signal_type_present_flag == 1 */
+    uint8_t video_format;
+    uint8_t video_full_range_flag;
+    uint8_t colour_description_present;
+    /* colour_description_present == 1 */
+    uint8_t colour_primaries;
+    uint8_t transfer_characteristics;
+    uint8_t matrix_coefficients;
+
+    uint8_t chroma_loc_info_present_flag;
+    /* chroma_loc_info_present_flag == 1 */
+    uint8_t chroma_sample_loc_type_top_field;
+    uint8_t chroma_sample_loc_type_bottom_field;
+
+    uint8_t timing_info_present_flag;
+    /* timing_info_present_flag == 1 */
+    uint32_t num_units_in_tick;
+    uint32_t time_scale;
+    uint8_t fixed_frame_rate_flag;
+
+    uint8_t nal_hrd_parameters_present_flag;
+    struct hrd_parameters nal_hrd_parameters;
+
+    uint8_t vc1_hrd_parameters_present_flag;
+    struct hrd_parameters vc1_hrd_parameters;
+
+    uint8_t low_delay_hrd_flag;
+
+    uint8_t pic_struct_present_flag;
+    uint8_t bitstream_restriction_flag;
+
+    /* bitstream_restriction_flag == 1 */
+    uint8_t motion_vectors_over_pic_boundaries;
+    uint32_t max_bytes_per_pic_denom;
+    uint32_t max_bits_per_mb_denom;
+    uint32_t log2_max_mv_length_horizontal;
+    uint32_t log2_max_mv_length_vertical;
+    uint32_t num_reorder_frames;
+    uint32_t max_dec_frame_buffering;
+  } vui_parameters;
+
+};
+
+struct pic_parameter_set_rbsp
+{
+  uint32_t pic_parameter_set_id;
+  uint32_t seq_parameter_set_id;
+  uint8_t entropy_coding_mode_flag;
+  uint8_t pic_order_present_flag;
+
+  uint32_t num_slice_groups_minus1;
+
+  /* num_slice_groups_minus1 > 0 */
+  uint32_t slice_group_map_type;
+
+  /* slice_group_map_type == 1 */
+  uint32_t run_length_minus1[64];
+
+  /* slice_group_map_type == 2 */
+  uint32_t top_left[64];
+  uint32_t bottom_right[64];
+
+  /* slice_group_map_type == 3,4,5 */
+  uint8_t slice_group_change_direction_flag;
+  uint32_t slice_group_change_rate_minus1;
+
+  /* slice_group_map_type == 6 */
+  uint32_t pic_size_in_map_units_minus1;
+  uint8_t slice_group_id[64];
+
+  uint32_t num_ref_idx_l0_active_minus1;
+  uint32_t num_ref_idx_l1_active_minus1;
+  uint8_t weighted_pred_flag;
+  uint8_t weighted_bipred_idc;
+  int32_t pic_init_qp_minus26;
+  int32_t pic_init_qs_minus26;
+  int32_t chroma_qp_index_offset;
+  uint8_t deblocking_filter_control_present_flag;
+  uint8_t constrained_intra_pred_flag;
+  uint8_t redundant_pic_cnt_present_flag;
+
+  /* if(more_rbsp_data) */
+  uint8_t transform_8x8_mode_flag;
+  uint8_t pic_scaling_matrix_present_flag;
+
+  /* if(pic_scaling_matrix_present_flag) */
+  uint8_t pic_scaling_list_present_flag[8];
+
+  uint8_t scaling_lists_4x4[6][16];
+  uint8_t scaling_lists_8x8[2][64];
+
+  int32_t second_chroma_qp_index_offset;
+};
+
+/*struct clock_timestamp {
+  uint8_t ct_type;
+  uint8_t nuit_fiel_based_flag;
+  uint8_t counting_type;
+  uint8_t full_timestamp_flag;
+  uint8_t discontinuity_flag;
+  uint8_t cnt_dropped_flag;
+  uint8_t n_frames
+};*/
+
+/* sei contains several additional info, we do
+ * only care for pic_timing, to handle display
+ * reordering
+ */
+struct sei_message
+{
+  uint32_t payload_type;
+  uint8_t last_payload_type_byte;
+  uint32_t payload_size;
+  uint8_t last_payload_size_byte;
+
+  struct
+  {
+    /* cpb_dpb_delays_present_flag == 1 */
+    uint8_t cpb_removal_delay;
+    uint8_t dpb_output_delay;
+
+    uint8_t pic_struct;
+    //uint8_t clock_timestamp_flag[3];
+  } pic_timing;
+};
+
+struct slice_header
+{
+  uint32_t first_mb_in_slice;
+  uint32_t slice_type;
+  uint32_t pic_parameter_set_id;
+  uint32_t frame_num;
+  uint8_t field_pic_flag;
+  uint8_t bottom_field_flag;
+  uint32_t idr_pic_id;
+
+  /* sps->pic_order_cnt_type == 0 */
+  uint32_t pic_order_cnt_lsb;
+  int32_t delta_pic_order_cnt_bottom;
+  /* sps->pic_order_cnt_type == 1 && !sps->delta_pic_order_always_zero_flag */
+  int32_t delta_pic_order_cnt[2];
+
+  /* pps->redundant_pic_cnt_present_flag == 1 */
+  int32_t redundant_pic_cnt;
+
+  /* slice_type == B */
+  uint8_t direct_spatial_mv_pred_flag;
+
+  /* slice_type == P, SP, B */
+  uint8_t num_ref_idx_active_override_flag;
+  /* num_ref_idx_active_override_flag == 1 */
+  uint32_t num_ref_idx_l0_active_minus1;
+  /* slice type == B */
+  uint32_t num_ref_idx_l1_active_minus1;
+
+  /* ref_pic_list_reordering */
+  struct
+  {
+    /* slice_type != I && slice_type != SI */
+    uint8_t ref_pic_list_reordering_flag_l0;
+
+    /* slice_type == B */
+    uint8_t ref_pic_list_reordering_flag_l1;
+
+    /* ref_pic_list_reordering_flag_l0 == 1 */
+    uint32_t reordering_of_pic_nums_idc;
+
+    /* reordering_of_pic_nums_idc == 0, 1 */
+    uint32_t abs_diff_pic_num_minus1;
+
+    /* reordering_of_pic_nums_idc == 2) */
+    uint32_t long_term_pic_num;
+  } ref_pic_list_reordering;
+
+  /* pred_weight_table */
+  struct
+  {
+    uint32_t luma_log2_weight_denom;
+
+    /* chroma_format_idc != 0 */
+    uint32_t chroma_log2_weight_denom;
+
+    int32_t luma_weight_l0[32];
+    int32_t luma_offset_l0[32];
+
+    int32_t chroma_weight_l0[32][2];
+    int32_t chroma_offset_l0[32][2];
+
+    int32_t luma_weight_l1[32];
+    int32_t luma_offset_l1[32];
+
+    int32_t chroma_weight_l1[32][2];
+    int32_t chroma_offset_l1[32][2];
+  } pred_weight_table;
+
+  /* def_rec_pic_marking */
+  struct
+  {
+
+    /* nal_unit_type == NAL_SLICE_IDR */
+    uint8_t no_output_of_prior_pics_flag;
+    uint8_t long_term_reference_flag;
+
+    /* else */
+    uint8_t adaptive_ref_pic_marking_mode_flag;
+    uint32_t memory_management_control_operation;
+
+    uint32_t difference_of_pic_nums_minus1;
+    uint32_t long_term_pic_num;
+    uint32_t long_term_frame_idx;
+    uint32_t max_long_term_frame_idx_plus1;
+  } dec_ref_pic_marking[10];
+  uint32_t dec_ref_pic_marking_count;
+};
+
+struct nal_unit
+{
+  uint8_t nal_ref_idc; // 0x03
+  uint8_t nal_unit_type; // 0x1f
+
+  uint32_t curr_pic_num;
+  uint8_t used_for_long_term_ref;
+  uint32_t long_term_pic_num;
+  uint32_t long_term_frame_idx;
+
+  int32_t top_field_order_cnt;
+  int32_t bottom_field_order_cnt;
+
+  uint8_t interlaced;
+  uint8_t repeat_pic;
+
+  struct sei_message sei;
+
+  struct seq_parameter_set_rbsp *sps;
+  struct pic_parameter_set_rbsp *pps;
+  struct slice_header *slc;
+};
+
+struct nal_unit* init_nal_unit();
+void free_nal_unit(struct nal_unit *nal);
+void copy_nal_unit(struct nal_unit *dest, struct nal_unit *src);
+
+#endif /* NAL_H_ */
diff -Naur xine-lib-1.1.16.1-old/src/libvdpau/vdpau_h264.c xine-lib-1.1.16.1-new/src/libvdpau/vdpau_h264.c
--- xine-lib-1.1.16.1-old/src/libvdpau/vdpau_h264.c	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/libvdpau/vdpau_h264.c	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,827 @@
+/*
+ * Copyright (C) 2008 Julian Scheel
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * vdpau_h264.c: H264 Video Decoder utilizing nvidia VDPAU engine
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <vdpau/vdpau.h>
+
+#include "xine_internal.h"
+#include "video_out.h"
+#include "buffer.h"
+#include "xineutils.h"
+#include "bswap.h"
+#include "accel_vdpau.h"
+#include "h264_parser.h"
+#include "dpb.h"
+
+#define VIDEOBUFSIZE 128*1024
+
+typedef struct {
+  video_decoder_class_t   decoder_class;
+} vdpau_h264_class_t;
+
+typedef struct vdpau_h264_decoder_s {
+  video_decoder_t   video_decoder;  /* parent video decoder structure */
+
+  vdpau_h264_class_t *class;
+  xine_stream_t    *stream;
+
+  /* these are traditional variables in a video decoder object */
+  uint64_t          video_step;  /* frame duration in pts units */
+
+  int               width;       /* the width of a video frame */
+  int               height;      /* the height of a video frame */
+  double            ratio;       /* the width to height ratio */
+
+
+  struct nal_parser *nal_parser;  /* h264 nal parser. extracts stream data for vdpau */
+  uint8_t           wait_for_bottom_field;
+  struct decoded_picture *last_ref_pic;
+  uint32_t          last_top_field_order_cnt;
+
+  int               have_frame_boundary_marks;
+  int               wait_for_frame_start;
+
+  VdpDecoder        decoder;
+  int               decoder_started;
+
+  VdpDecoderProfile profile;
+  vdpau_accel_t     *vdpau_accel;
+
+  xine_t            *xine;
+
+  int64_t           curr_pts;
+  int64_t           next_pts;
+
+  vo_frame_t        *last_img;
+  vo_frame_t        *dangling_img;
+
+  uint8_t           *codec_private;
+  uint32_t          codec_private_len;
+
+  int               vdp_runtime_nr;
+
+} vdpau_h264_decoder_t;
+
+static void vdpau_h264_reset (video_decoder_t *this_gen);
+
+/**************************************************************************
+ * vdpau_h264 specific decode functions
+ *************************************************************************/
+
+/**************************************************************************
+ * xine video plugin functions
+ *************************************************************************/
+
+
+static inline void dump_pictureinfo_h264(VdpPictureInfoH264 *pic)
+{
+  printf("C: slice_count: %d\n", pic->slice_count);
+  printf("C: field_order_cnt[0]: %d\n", pic->field_order_cnt[0]);
+  printf("C: field_order_cnt[1]: %d\n", pic->field_order_cnt[1]);
+  printf("C: is_reference: %d\n", pic->is_reference);
+  printf("C: frame_num: %d\n", pic->frame_num);
+  printf("C: field_pic_flag: %d\n", pic->field_pic_flag);
+  printf("C: bottom_field_flag: %d\n", pic->bottom_field_flag);
+  printf("C: num_ref_frames: %d\n", pic->num_ref_frames);
+  printf("C: mb_adaptive_frame_field_flag: %d\n", pic->mb_adaptive_frame_field_flag);
+  printf("C: constrained_intra_pred_flag: %d\n", pic->constrained_intra_pred_flag);
+  printf("C: weighted_pred_flag: %d\n", pic->weighted_pred_flag);
+  printf("C: weighted_bipred_idc: %d\n", pic->weighted_bipred_idc);
+  printf("C: frame_mbs_only_flag: %d\n", pic->frame_mbs_only_flag);
+  printf("C: transform_8x8_mode_flag: %d\n", pic->transform_8x8_mode_flag);
+  printf("C: chroma_qp_index_offset: %d\n", pic->chroma_qp_index_offset);
+  printf("C: second_chroma_qp_index_offset: %d\n", pic->second_chroma_qp_index_offset);
+  printf("C: pic_init_qp_minus26: %d\n", pic->pic_init_qp_minus26);
+  printf("C: num_ref_idx_l0_active_minus1: %d\n", pic->num_ref_idx_l0_active_minus1);
+  printf("C: num_ref_idx_l1_active_minus1: %d\n", pic->num_ref_idx_l1_active_minus1);
+  printf("C: log2_max_frame_num_minus4: %d\n", pic->log2_max_frame_num_minus4);
+  printf("C: pic_order_cnt_type: %d\n", pic->pic_order_cnt_type);
+  printf("C: log2_max_pic_order_cnt_lsb_minus4: %d\n", pic->log2_max_pic_order_cnt_lsb_minus4);
+  printf("C: delta_pic_order_always_zero_flag: %d\n", pic->delta_pic_order_always_zero_flag);
+  printf("C: direct_8x8_inference_flag: %d\n", pic->direct_8x8_inference_flag);
+  printf("C: entropy_coding_mode_flag: %d\n", pic->entropy_coding_mode_flag);
+  printf("C: pic_order_present_flag: %d\n", pic->pic_order_present_flag);
+  printf("C: deblocking_filter_control_present_flag: %d\n", pic->deblocking_filter_control_present_flag);
+  printf("C: redundant_pic_cnt_present_flag: %d\n", pic->redundant_pic_cnt_present_flag);
+
+  int i, j;
+  for(i = 0; i < 6; i++) {
+    printf("C: scalint_list4x4[%d]:\nC:", i);
+    for(j = 0; j < 16; j++) {
+      printf(" [%d]", pic->scaling_lists_4x4[i][j]);
+      if(j%8 == 0)
+        printf("\nC:");
+    }
+    printf("C: \n");
+  }
+  for(i = 0; i < 2; i++) {
+    printf("C: scalint_list8x8[%d]:\nC:", i);
+    for(j = 0; j < 64; j++) {
+      printf(" [%d] ", pic->scaling_lists_8x8[i][j]);
+      if(j%8 == 0)
+        printf("\nC:");
+    }
+    printf("C: \n");
+  }
+
+  //int i;
+  for(i = 0; i < 16; i++) {
+    if(pic->referenceFrames[i].surface != VDP_INVALID_HANDLE) {
+    printf("C: -------------------\n");
+      printf("C: Reference Frame %d:\n", i);
+    printf("C: frame_idx: %d\n", pic->referenceFrames[i].frame_idx);
+    printf("C: field_order_cnt[0]: %d\n", pic->referenceFrames[i].field_order_cnt[0]);
+    printf("C: field_order_cnt[1]: %d\n", pic->referenceFrames[i].field_order_cnt[0]);
+    printf("C: is_long_term: %d\n", pic->referenceFrames[i].is_long_term);
+    printf("C: top_is_reference: %d\n", pic->referenceFrames[i].top_is_reference);
+    printf("C: bottom_is_reference: %d\n", pic->referenceFrames[i].bottom_is_reference);
+    }
+  }
+  printf("C: ---------------------------------------------------------------\n");
+  /*memcpy(pic.scaling_lists_4x4, pps->scaling_lists_4x4, 6*16);
+  memcpy(pic.scaling_lists_8x8, pps->scaling_lists_8x8, 2*64);
+  memcpy(pic.referenceFrames, this->reference_frames, sizeof(this->reference_frames));*/
+
+}
+
+static void set_ratio(video_decoder_t *this_gen)
+{
+  vdpau_h264_decoder_t *this = (vdpau_h264_decoder_t *)this_gen;
+
+  this->ratio = (double)this->width / (double)this->height;
+  if(this->nal_parser->current_nal->sps->vui_parameters.aspect_ration_info_present_flag) {
+    switch(this->nal_parser->current_nal->sps->vui_parameters.aspect_ratio_idc) {
+      case ASPECT_1_1:
+        this->ratio = 1 * this->ratio;
+        break;
+      case ASPECT_12_11:
+        this->ratio *= 12.0/11.0;
+        break;
+      case ASPECT_10_11:
+        this->ratio *= 10.0/11.0;
+        break;
+      case ASPECT_16_11:
+        this->ratio *= 16.0/11.0;
+        break;
+      case ASPECT_40_33:
+        this->ratio *= 40.0/33.0;
+        break;
+      case ASPECT_24_11:
+        this->ratio *= 24.0/11.0;
+        break;
+      case ASPECT_20_11:
+        this->ratio *= 20.0/11.0;
+        break;
+      case ASPECT_32_11:
+        this->ratio *= 32.0/11.0;
+        break;
+      case ASPECT_80_33:
+        this->ratio *= 80.0/33.0;
+        break;
+      case ASPECT_18_11:
+        this->ratio *= 18.0/11.0;
+        break;
+      case ASPECT_15_11:
+        this->ratio *= 15.0/11.0;
+        break;
+      case ASPECT_64_33:
+        this->ratio *= 64.0/33.0;
+        break;
+      case ASPECT_160_99:
+        this->ratio *= 160.0/99.0;
+        break;
+      case ASPECT_4_3:
+        this->ratio *= 4.0/3.0;
+        break;
+      case ASPECT_3_2:
+        this->ratio *= 3.0/2.0;
+        break;
+      case ASPECT_2_1:
+        this->ratio *= 2.0/1.0;
+        break;
+      case ASPECT_EXTENDED_SAR:
+        this->ratio *=
+          (double)this->nal_parser->current_nal->sps->vui_parameters.sar_width/
+          (double)this->nal_parser->current_nal->sps->vui_parameters.sar_height;
+        break;
+    }
+  }
+}
+
+static void fill_vdpau_pictureinfo_h264(video_decoder_t *this_gen, uint32_t slice_count, VdpPictureInfoH264 *pic)
+{
+  vdpau_h264_decoder_t *this = (vdpau_h264_decoder_t *)this_gen;
+
+  struct pic_parameter_set_rbsp *pps = this->nal_parser->current_nal->pps;
+  struct seq_parameter_set_rbsp *sps = this->nal_parser->current_nal->sps;
+  struct slice_header *slc = this->nal_parser->current_nal->slc;
+
+  pic->slice_count = slice_count;
+  pic->field_order_cnt[0] = this->nal_parser->current_nal->top_field_order_cnt;
+  pic->field_order_cnt[1] = this->nal_parser->current_nal->bottom_field_order_cnt;
+  pic->is_reference =
+    (this->nal_parser->current_nal->nal_ref_idc != 0) ? VDP_TRUE : VDP_FALSE;
+  pic->frame_num = slc->frame_num;
+  pic->field_pic_flag = slc->field_pic_flag;
+  pic->bottom_field_flag = slc->bottom_field_flag;
+  //pic->num_ref_frames = sps->num_ref_frames;
+  pic->mb_adaptive_frame_field_flag = sps->mb_adaptive_frame_field_flag;
+  pic->constrained_intra_pred_flag = pps->constrained_intra_pred_flag;
+  pic->weighted_pred_flag = pps->weighted_pred_flag;
+  pic->weighted_bipred_idc = pps->weighted_bipred_idc;
+  pic->frame_mbs_only_flag = sps->frame_mbs_only_flag;
+  pic->transform_8x8_mode_flag = pps->transform_8x8_mode_flag;
+  pic->chroma_qp_index_offset = pps->chroma_qp_index_offset;
+  pic->second_chroma_qp_index_offset = pps->second_chroma_qp_index_offset;
+  pic->pic_init_qp_minus26 = pps->pic_init_qp_minus26;
+  pic->num_ref_idx_l0_active_minus1 = pps->num_ref_idx_l0_active_minus1;
+  pic->num_ref_idx_l1_active_minus1 = pps->num_ref_idx_l1_active_minus1;
+  pic->log2_max_frame_num_minus4 = sps->log2_max_frame_num_minus4;
+  pic->pic_order_cnt_type = sps->pic_order_cnt_type;
+  pic->log2_max_pic_order_cnt_lsb_minus4 = sps->log2_max_pic_order_cnt_lsb_minus4;
+  pic->delta_pic_order_always_zero_flag = sps->delta_pic_order_always_zero_flag;
+  pic->direct_8x8_inference_flag = sps->direct_8x8_inference_flag;
+  pic->entropy_coding_mode_flag = pps->entropy_coding_mode_flag;
+  pic->pic_order_present_flag = pps->pic_order_present_flag;
+  pic->deblocking_filter_control_present_flag = pps->deblocking_filter_control_present_flag;
+  pic->redundant_pic_cnt_present_flag = pps->redundant_pic_cnt_present_flag;
+
+  memcpy(pic->scaling_lists_4x4, pps->scaling_lists_4x4, sizeof(pic->scaling_lists_4x4));
+  memcpy(pic->scaling_lists_8x8, pps->scaling_lists_8x8, sizeof(pic->scaling_lists_8x8));
+
+  /* set num_ref_frames to the number of actually available reference frames,
+   * if this is not set generation 3 decoders will fail. */
+  pic->num_ref_frames = fill_vdpau_reference_list(&(this->nal_parser->dpb), pic->referenceFrames);
+
+}
+
+static int vdpau_decoder_init(video_decoder_t *this_gen)
+{
+  vdpau_h264_decoder_t *this = (vdpau_h264_decoder_t *)this_gen;
+  vo_frame_t *img;
+
+  this->curr_pts = this->next_pts;
+  this->next_pts = 0;
+
+  if(this->width == 0) {
+    this->width = this->nal_parser->current_nal->sps->pic_width;
+    this->height = this->nal_parser->current_nal->sps->pic_height;
+  }
+
+  set_ratio(this_gen);
+
+  _x_stream_info_set( this->stream, XINE_STREAM_INFO_VIDEO_WIDTH, this->width );
+  _x_stream_info_set( this->stream, XINE_STREAM_INFO_VIDEO_HEIGHT, this->height );
+  _x_stream_info_set( this->stream, XINE_STREAM_INFO_VIDEO_RATIO, ((double)10000*this->ratio) );
+  _x_stream_info_set( this->stream, XINE_STREAM_INFO_FRAME_DURATION, this->video_step );
+  _x_meta_info_set_utf8( this->stream, XINE_META_INFO_VIDEOCODEC, "H264/AVC (vdpau)" );
+  xine_event_t event;
+  xine_format_change_data_t data;
+  event.type = XINE_EVENT_FRAME_FORMAT_CHANGE;
+  event.stream = this->stream;
+  event.data = &data;
+  event.data_length = sizeof(data);
+  data.width = this->width;
+  data.height = this->height;
+  data.aspect = this->ratio;
+  xine_event_send( this->stream, &event );
+
+  switch(this->nal_parser->current_nal->sps->profile_idc) {
+    case 100:
+      this->profile = VDP_DECODER_PROFILE_H264_HIGH;
+      break;
+    case 77:
+      this->profile = VDP_DECODER_PROFILE_H264_MAIN;
+      break;
+    case 66:
+    default:
+      // nvidia's VDPAU doesn't support BASELINE. But most (every?) streams marked BASELINE do not use BASELINE specifics,
+      // so, just force MAIN.
+      //this->profile = VDP_DECODER_PROFILE_H264_BASELINE;
+      this->profile = VDP_DECODER_PROFILE_H264_MAIN;
+      break;
+  }
+
+  // Level 4.1 limits:
+  int ref_frames = 0;
+  if(this->nal_parser->current_nal->sps->num_ref_frames) {
+    ref_frames = this->nal_parser->current_nal->sps->num_ref_frames;
+  } else {
+    uint32_t round_width = (this->width + 15) & ~15;
+    uint32_t round_height = (this->height + 15) & ~15;
+    uint32_t surf_size = (round_width * round_height * 3) / 2;
+    ref_frames = (12 * 1024 * 1024) / surf_size;
+  }
+
+  if (ref_frames > 16) {
+      ref_frames = 16;
+  }
+
+  printf("Allocate %d reference frames\n", ref_frames);
+  /* get the vdpau context from vo */
+  //(this->stream->video_out->open) (this->stream->video_out, this->stream);
+  img = this->stream->video_out->get_frame (this->stream->video_out,
+                                    this->width, this->height,
+                                    this->ratio,
+                                    XINE_IMGFMT_VDPAU, VO_BOTH_FIELDS);
+
+  img->duration = this->video_step;
+  img->pts = this->curr_pts;
+
+  this->vdpau_accel = (vdpau_accel_t*)img->accel_data;
+
+  /*VdpBool is_supported;
+  uint32_t max_level, max_references, max_width, max_height;*/
+  if(this->vdpau_accel->vdp_runtime_nr > 0) {
+   xprintf(this->xine, XINE_VERBOSITY_LOG,
+       "Create decoder: vdp_device: %d, profile: %d, res: %dx%d\n",
+       this->vdpau_accel->vdp_device, this->profile, this->width, this->height);
+
+   VdpStatus status = this->vdpau_accel->vdp_decoder_create(this->vdpau_accel->vdp_device,
+       this->profile, this->width, this->height, 16, &this->decoder);
+
+   if(status != VDP_STATUS_OK) {
+     xprintf(this->xine, XINE_VERBOSITY_LOG, "vdpau_h264: ERROR: VdpDecoderCreate returned status != OK (%s)\n", this->vdpau_accel->vdp_get_error_string(status));
+     return 0;
+   }
+  }
+  this->last_img = img;
+  this->dangling_img = img;
+
+  return 1;
+}
+
+static int vdpau_decoder_render(video_decoder_t *this_gen, VdpBitstreamBuffer *vdp_buffer, uint32_t slice_count)
+{
+  vdpau_h264_decoder_t *this = (vdpau_h264_decoder_t *)this_gen;
+  vo_frame_t *img = this->last_img;
+
+  if(this->nal_parser->current_nal->nal_unit_type == NAL_SLICE_IDR) {
+    dpb_flush(&(this->nal_parser->dpb));
+  }
+
+  VdpPictureInfoH264 pic;
+
+  fill_vdpau_pictureinfo_h264(this_gen, slice_count, &pic);
+
+  //printf("next decode: %d, %d\n", pic.field_order_cnt[0], pic.field_order_cnt[1]);
+
+  if(!this->decoder_started && !pic.is_reference)
+    return 0;
+
+  this->decoder_started = 1;
+
+  struct seq_parameter_set_rbsp *sps = this->nal_parser->current_nal->sps;
+  struct slice_header *slc = this->nal_parser->current_nal->slc;
+
+  if(sps->vui_parameters_present_flag &&
+      sps->vui_parameters.timing_info_present_flag &&
+      this->video_step == 0) {
+    this->video_step = 2*90000/(1/((double)sps->vui_parameters.num_units_in_tick/(double)sps->vui_parameters.time_scale));
+  }
+
+  /* flush the DPB if this frame was an IDR */
+  //printf("is_idr: %d\n", this->nal_parser->is_idr);
+  this->nal_parser->is_idr = 0;
+
+  /* go and decode a frame */
+
+  //dump_pictureinfo_h264(&pic);
+
+  /*int i;
+  printf("Decode data: \n");
+  for(i = 0; i < ((vdp_buffer->bitstream_bytes < 20) ? vdp_buffer->bitstream_bytes : 20); i++) {
+    printf("%02x ", ((uint8_t*)vdp_buffer->bitstream)[i]);
+    if((i+1) % 10 == 0)
+      printf("\n");
+  }
+  printf("\n...\n");
+  for(i = vdp_buffer->bitstream_bytes - 20; i < vdp_buffer->bitstream_bytes; i++) {
+    printf("%02x ", ((uint8_t*)vdp_buffer->bitstream)[i]);
+    if((i+1) % 10 == 0)
+      printf("\n");
+  }*/
+
+
+  if(img == NULL) {
+    img = this->stream->video_out->get_frame (this->stream->video_out,
+                                              this->width, this->height,
+                                              this->ratio,
+                                              XINE_IMGFMT_VDPAU, VO_BOTH_FIELDS);
+    this->vdpau_accel = (vdpau_accel_t*)img->accel_data;
+
+    img->duration  = this->video_step;
+    img->pts       = this->curr_pts;
+
+    this->dangling_img = img;
+  }
+
+  if(this->vdp_runtime_nr != *(this->vdpau_accel->current_vdp_runtime_nr)) {
+    printf("VDPAU was preempted. Reinitialise the decoder.\n");
+    this->decoder = VDP_INVALID_HANDLE;
+    vdpau_h264_reset(this_gen);
+    this->vdp_runtime_nr = this->vdpau_accel->vdp_runtime_nr;
+    this->last_img = NULL;
+    return 0;
+  }
+
+  VdpVideoSurface surface = this->vdpau_accel->surface;
+
+  //printf("Decode: NUM: %d, REF: %d, BYTES: %d, PTS: %lld\n", pic.frame_num, pic.is_reference, vdp_buffer.bitstream_bytes, this->curr_pts);
+  VdpStatus status = this->vdpau_accel->vdp_decoder_render(this->decoder,
+      surface, (VdpPictureInfo*)&pic, 1, vdp_buffer);
+
+  /* only free the actual data, as the start seq is only
+   * locally allocated anyway. */
+  if(((uint8_t*)vdp_buffer->bitstream) != NULL) {
+    free((uint8_t*)vdp_buffer->bitstream);
+  }
+
+  this->curr_pts = this->next_pts;
+  this->next_pts = 0;
+
+  if(status != VDP_STATUS_OK)
+  {
+    xprintf(this->xine, XINE_VERBOSITY_LOG, "vdpau_h264: Decoder failure: %s\n",  this->vdpau_accel->vdp_get_error_string(status));
+    img->free(img);
+    img = this->last_img = this->dangling_img = NULL;
+  }
+  else {
+    img->bad_frame = 0;
+
+    if((sps->vui_parameters_present_flag &&
+        sps->vui_parameters.pic_struct_present_flag &&
+        !this->nal_parser->current_nal->interlaced) ||
+        (!pic.field_pic_flag && !pic.mb_adaptive_frame_field_flag))
+      img->progressive_frame = 1;
+    else
+      img->progressive_frame = 0;
+
+    if(!img->progressive_frame && this->nal_parser->current_nal->repeat_pic)
+      img->repeat_first_field = 1;
+    //else if(img->progressive_frame && this->nal_parser->current_nal->repeat_pic)
+    //  img->duration *= this->nal_parser->current_nal->repeat_pic;
+
+    struct decoded_picture *decoded_pic = NULL;
+    if(pic.is_reference) {
+      if(!slc->field_pic_flag || !this->wait_for_bottom_field) {
+        decoded_pic = init_decoded_picture(this->nal_parser->current_nal, surface, img);
+        this->last_ref_pic = decoded_pic;
+        decoded_pic->used_for_reference = 1;
+        dpb_add_picture(&(this->nal_parser->dpb), decoded_pic, sps->num_ref_frames);
+        this->dangling_img = NULL;
+      } else if(slc->field_pic_flag && this->wait_for_bottom_field) {
+        if(this->last_ref_pic) {
+          decoded_pic = this->last_ref_pic;
+          //copy_nal_unit(decoded_pic->nal, this->nal_parser->current_nal);
+          decoded_pic->nal->bottom_field_order_cnt = this->nal_parser->current_nal->bottom_field_order_cnt;
+          this->last_ref_pic->bottom_is_reference = 1;
+        }
+      }
+    }
+
+    if(!slc->field_pic_flag ||
+        (slc->field_pic_flag && slc->bottom_field_flag && this->wait_for_bottom_field)) {
+      if(!decoded_pic) {
+        decoded_pic = init_decoded_picture(this->nal_parser->current_nal, surface, img);
+        decoded_pic->delayed_output = 1;
+        dpb_add_picture(&(this->nal_parser->dpb), decoded_pic, sps->num_ref_frames);
+        this->dangling_img = NULL;
+        if(decoded_pic->nal->slc->bottom_field_flag)
+          decoded_pic->nal->top_field_order_cnt = this->last_top_field_order_cnt;
+      } else
+        decoded_pic->delayed_output = 1;
+
+      if(this->wait_for_bottom_field && slc->bottom_field_flag)
+        decoded_pic->nal->bottom_field_order_cnt = this->nal_parser->current_nal->bottom_field_order_cnt;
+
+      this->last_img = img = NULL;
+
+      /* now retrieve the next output frame */
+      if ((decoded_pic = dpb_get_next_out_picture(&(this->nal_parser->dpb))) != NULL) {
+        decoded_pic->img->top_field_first = (decoded_pic->nal->top_field_order_cnt <= decoded_pic->nal->bottom_field_order_cnt);
+        //printf("draw pts: %lld\n", decoded_pic->img->pts);
+        decoded_pic->img->draw(decoded_pic->img, this->stream);
+        dpb_set_output_picture(&(this->nal_parser->dpb), decoded_pic);
+      }
+
+      this->wait_for_bottom_field = 0;
+
+    } else if(slc->field_pic_flag && !slc->bottom_field_flag) {
+      // don't draw yet, second field is missing.
+      this->last_top_field_order_cnt = this->nal_parser->current_nal->top_field_order_cnt;
+      this->wait_for_bottom_field = 1;
+      this->last_img = img;
+    }
+  }
+
+  return 1;
+}
+
+/*
+ * This function receives a buffer of data from the demuxer layer and
+ * figures out how to handle it based on its header flags.
+ */
+static void vdpau_h264_decode_data (video_decoder_t *this_gen,
+  buf_element_t *buf) {
+
+  vdpau_h264_decoder_t *this = (vdpau_h264_decoder_t *) this_gen;
+
+  VdpBitstreamBuffer vdp_buffer;
+  vdp_buffer.struct_version = VDP_BITSTREAM_BUFFER_VERSION;
+
+  /* a video decoder does not care about this flag (?) */
+  if (buf->decoder_flags & BUF_FLAG_PREVIEW)
+    return;
+
+  if(buf->decoder_flags & BUF_FLAG_FRAME_START || buf->decoder_flags & BUF_FLAG_FRAME_END)
+    this->have_frame_boundary_marks = 1;
+
+  if (buf->decoder_flags & BUF_FLAG_FRAMERATE) {
+    this->video_step = buf->decoder_info[0];
+    _x_stream_info_set(this->stream, XINE_STREAM_INFO_FRAME_DURATION, this->video_step);
+  }
+
+  if (buf->decoder_flags & BUF_FLAG_STDHEADER) { /* need to initialize */
+    this->have_frame_boundary_marks = 0;
+
+    xine_bmiheader *bih = (xine_bmiheader*)buf->content;
+    this->width                         = bih->biWidth;
+    this->height                        = bih->biHeight;
+
+    uint8_t *codec_private = buf->content + sizeof(xine_bmiheader);
+    uint32_t codec_private_len = bih->biSize - sizeof(xine_bmiheader);
+    this->codec_private_len = codec_private_len;
+    this->codec_private = malloc(codec_private_len);
+    memcpy(this->codec_private, codec_private, codec_private_len);
+
+    if(codec_private_len > 0) {
+      parse_codec_private(this->nal_parser, codec_private, codec_private_len);
+    }
+  } else if (buf->decoder_flags & BUF_FLAG_SPECIAL) {
+    this->have_frame_boundary_marks = 0;
+
+    if(buf->decoder_info[1] == BUF_SPECIAL_DECODER_CONFIG) {
+      uint8_t *codec_private = buf->decoder_info_ptr[2];
+      uint32_t codec_private_len = buf->decoder_info[2];
+      this->codec_private_len = codec_private_len;
+      this->codec_private = malloc(codec_private_len);
+      memcpy(this->codec_private, codec_private, codec_private_len);
+
+      if(codec_private_len > 0) {
+        parse_codec_private(this->nal_parser, codec_private, codec_private_len);
+      }
+    } else if (buf->decoder_info[1] == BUF_SPECIAL_PALETTE) {
+      printf("SPECIAL PALETTE is not yet handled\n");
+    } else
+      printf("UNKNOWN SPECIAL HEADER\n");
+
+  } else {
+    /* parse the first nal packages to retrieve profile type */
+    int len = 0;
+    uint32_t slice_count;
+
+    while(len < buf->size && !(this->wait_for_frame_start && !(buf->decoder_flags & BUF_FLAG_FRAME_START))) {
+      this->wait_for_frame_start = 0;
+      len += parse_frame(this->nal_parser, buf->content + len, buf->size - len,
+          (void*)&vdp_buffer.bitstream, &vdp_buffer.bitstream_bytes, &slice_count);
+
+      if(this->decoder == VDP_INVALID_HANDLE &&
+          this->nal_parser->current_nal->sps != NULL &&
+          this->nal_parser->current_nal->sps->pic_width > 0 &&
+          this->nal_parser->current_nal->sps->pic_height > 0) {
+
+        vdpau_decoder_init(this_gen);
+      }
+
+      if(this->decoder != VDP_INVALID_HANDLE &&
+          vdp_buffer.bitstream_bytes > 0 &&
+          this->nal_parser->current_nal->slc != NULL &&
+          this->nal_parser->current_nal->pps != NULL) {
+        vdpau_decoder_render(this_gen, &vdp_buffer, slice_count);
+      }
+    }
+
+    if(buf->pts != 0 && buf->pts != this->next_pts) {
+      //printf("next pts: %lld\n", buf->pts);
+      this->next_pts = buf->pts;
+    }
+  }
+
+  if(buf->decoder_flags & BUF_FLAG_FRAME_END)
+    this->wait_for_frame_start = 0;
+}
+
+/*
+ * This function is called when xine needs to flush the system.
+ */
+static void vdpau_h264_flush (video_decoder_t *this_gen) {
+}
+
+/*
+ * This function resets the video decoder.
+ */
+static void vdpau_h264_reset (video_decoder_t *this_gen) {
+  vdpau_h264_decoder_t *this = (vdpau_h264_decoder_t *) this_gen;
+
+  printf("vdpau_h264_reset\n");
+
+  dpb_free_all( &(this->nal_parser->dpb) );
+
+  if (this->decoder != VDP_INVALID_HANDLE) {
+    this->vdpau_accel->vdp_decoder_destroy( this->decoder );
+    this->decoder = VDP_INVALID_HANDLE;
+  }
+
+  free_parser(this->nal_parser);
+  this->nal_parser = init_parser();
+  if(this->codec_private_len > 0) {
+    parse_codec_private(this->nal_parser, this->codec_private, this->codec_private_len);
+
+    /* if the stream does not contain frame boundary marks we
+     * have to hope that the next nal will start with the next
+     * incoming buf... seems to work, though...
+     */
+    this->wait_for_frame_start = this->have_frame_boundary_marks;
+  }
+
+  this->wait_for_bottom_field = 0;
+  this->video_step = 0;
+  this->curr_pts = 0;
+  this->next_pts = 0;
+
+  if (this->dangling_img) {
+    this->dangling_img->free(this->dangling_img);
+    this->dangling_img = NULL;
+  }
+}
+
+/*
+ * The decoder should forget any stored pts values here.
+ */
+static void vdpau_h264_discontinuity (video_decoder_t *this_gen) {
+  vdpau_h264_decoder_t *this = (vdpau_h264_decoder_t *) this_gen;
+
+  this->curr_pts = 0;
+  this->next_pts = 0;
+  dpb_clear_all_pts(&this->nal_parser->dpb);
+}
+
+/*
+ * This function frees the video decoder instance allocated to the decoder.
+ */
+static void vdpau_h264_dispose (video_decoder_t *this_gen) {
+
+  vdpau_h264_decoder_t *this = (vdpau_h264_decoder_t *) this_gen;
+
+  if (this->dangling_img) {
+    this->dangling_img->free(this->dangling_img);
+    this->dangling_img = NULL;
+  }
+
+
+  dpb_free_all( &(this->nal_parser->dpb) );
+
+  if (this->decoder != VDP_INVALID_HANDLE) {
+    this->vdpau_accel->vdp_decoder_destroy( this->decoder );
+    this->decoder = VDP_INVALID_HANDLE;
+  }
+
+  this->stream->video_out->close( this->stream->video_out, this->stream );
+
+  free_parser (this->nal_parser);
+  free (this_gen);
+}
+
+/*
+ * This function allocates, initializes, and returns a private video
+ * decoder structure.
+ */
+static video_decoder_t *open_plugin (video_decoder_class_t *class_gen, xine_stream_t *stream) {
+
+  vdpau_h264_decoder_t  *this ;
+
+  /* the videoout must be vdpau-capable to support this decoder */
+  if ( !(stream->video_driver->get_capabilities(stream->video_driver) & VO_CAP_VDPAU_H264) )
+	  return NULL;
+
+  this = (vdpau_h264_decoder_t *) calloc(1, sizeof(vdpau_h264_decoder_t));
+
+  this->video_decoder.decode_data         = vdpau_h264_decode_data;
+  this->video_decoder.flush               = vdpau_h264_flush;
+  this->video_decoder.reset               = vdpau_h264_reset;
+  this->video_decoder.discontinuity       = vdpau_h264_discontinuity;
+  this->video_decoder.dispose             = vdpau_h264_dispose;
+
+  this->stream                            = stream;
+  this->xine                              = stream->xine;
+  this->class                             = (vdpau_h264_class_t *) class_gen;
+
+  this->decoder                           = VDP_INVALID_HANDLE;
+  this->vdp_runtime_nr                    = 1;
+
+  this->nal_parser = init_parser();
+
+  (this->stream->video_out->open) (this->stream->video_out, this->stream);
+
+  return &this->video_decoder;
+}
+
+/*
+ * This function returns a brief string that describes (usually with the
+ * decoder's most basic name) the video decoder plugin.
+ */
+static char *get_identifier (video_decoder_class_t *this) {
+  return "vdpau_h264";
+}
+
+/*
+ * This function returns a slightly longer string describing the video
+ * decoder plugin.
+ */
+static char *get_description (video_decoder_class_t *this) {
+  return "vdpau_h264: h264 decoder plugin using VDPAU hardware decoding.\n"
+	  "Must be used along with video_out_vdpau.";
+}
+
+/*
+ * This function frees the video decoder class and any other memory that was
+ * allocated.
+ */
+static void dispose_class (video_decoder_class_t *this) {
+  free (this);
+}
+
+/*
+ * This function allocates a private video decoder class and initializes
+ * the class's member functions.
+ */
+static void *init_plugin (xine_t *xine, void *data) {
+
+  vdpau_h264_class_t *this;
+
+  this = (vdpau_h264_class_t *) calloc(1, sizeof(vdpau_h264_class_t));
+
+  this->decoder_class.open_plugin     = open_plugin;
+  this->decoder_class.get_identifier  = get_identifier;
+  this->decoder_class.get_description = get_description;
+  this->decoder_class.dispose         = dispose_class;
+
+  return this;
+}
+
+/*
+ * This is a list of all of the internal xine video buffer types that
+ * this decoder is able to handle. Check src/xine-engine/buffer.h for a
+ * list of valid buffer types (and add a new one if the one you need does
+ * not exist). Terminate the list with a 0.
+ */
+static const uint32_t video_types[] = {
+  /* BUF_VIDEO_FOOVIDEO, */
+  BUF_VIDEO_H264,
+  0
+};
+
+/*
+ * This data structure combines the list of supported xine buffer types and
+ * the priority that the plugin should be given with respect to other
+ * plugins that handle the same buffer type. A plugin with priority (n+1)
+ * will be used instead of a plugin with priority (n).
+ */
+static const decoder_info_t dec_info_video = {
+  video_types,         /* supported types */
+  7                    /* priority        */
+};
+
+/*
+ * The plugin catalog entry. This is the only information that this plugin
+ * will export to the public.
+ */
+const plugin_info_t xine_plugin_info[] EXPORTED = {
+  /* { type, API, "name", version, special_info, init_function } */
+  { PLUGIN_VIDEO_DECODER, 18, "vdpau_h264", XINE_VERSION_CODE, &dec_info_video, init_plugin },
+  { PLUGIN_NONE, 0, "", 0, NULL, NULL }
+};
diff -Naur xine-lib-1.1.16.1-old/src/libvdpau/vdpau_mpeg12.c xine-lib-1.1.16.1-new/src/libvdpau/vdpau_mpeg12.c
--- xine-lib-1.1.16.1-old/src/libvdpau/vdpau_mpeg12.c	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/libvdpau/vdpau_mpeg12.c	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,973 @@
+/*
+ * Copyright (C) 2008 Christophe Thommeret <hftom@free.fr>
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * vdpau_mpeg12.c, a mpeg1/2 video stream parser using VDPAU hardware decoder
+ *
+ */
+
+//#define LOG
+#define LOG_MODULE "vdpau_mpeg12"
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "xine_internal.h"
+#include "video_out.h"
+#include "buffer.h"
+#include "xineutils.h"
+#include "accel_vdpau.h"
+
+#include <vdpau/vdpau.h>
+
+
+
+#define sequence_header_code    0xb3
+#define sequence_error_code     0xb4
+#define sequence_end_code       0xb7
+#define group_start_code        0xb8
+#define extension_start_code    0xb5
+#define user_data_start_code    0xb2
+#define picture_start_code      0x00
+#define begin_slice_start_code  0x01
+#define end_slice_start_code    0xaf
+
+#define sequence_ext_sc         1
+#define quant_matrix_ext_sc     3
+#define picture_coding_ext_sc   8
+#define sequence_display_ext_sc 2
+
+#define I_FRAME   1
+#define P_FRAME   2
+#define B_FRAME   3
+
+#define PICTURE_TOP     1
+#define PICTURE_BOTTOM  2
+#define PICTURE_FRAME   3
+
+#define WANT_HEADER 1
+#define WANT_EXT    2
+#define WANT_SLICE  3
+
+
+
+/* default intra quant matrix, in zig-zag order */
+static const uint8_t default_intra_quantizer_matrix[64] = {
+    8,
+    16, 16,
+    19, 16, 19,
+    22, 22, 22, 22,
+    22, 22, 26, 24, 26,
+    27, 27, 27, 26, 26, 26,
+    26, 27, 27, 27, 29, 29, 29,
+    34, 34, 34, 29, 29, 29, 27, 27,
+    29, 29, 32, 32, 34, 34, 37,
+    38, 37, 35, 35, 34, 35,
+    38, 38, 40, 40, 40,
+    48, 48, 46, 46,
+    56, 56, 58,
+    69, 69,
+    83
+};
+
+uint8_t mpeg2_scan_norm[64] = {
+    /* Zig-Zag scan pattern */
+     0, 1, 8,16, 9, 2, 3,10,
+    17,24,32,25,18,11, 4, 5,
+    12,19,26,33,40,48,41,34,
+    27,20,13, 6, 7,14,21,28,
+    35,42,49,56,57,50,43,36,
+    29,22,15,23,30,37,44,51,
+    58,59,52,45,38,31,39,46,
+    53,60,61,54,47,55,62,63
+};
+
+
+
+typedef struct {
+  VdpPictureInfoMPEG1Or2  vdp_infos; /* first field, also used for frame */
+  VdpPictureInfoMPEG1Or2  vdp_infos2; /* second field */
+  int                     slices_count, slices_count2;
+  uint8_t                 *slices;
+  int                     slices_size;
+  int                     slices_pos, slices_pos_top;
+
+  int                     progressive_frame;
+  int                     state;
+} picture_t;
+
+
+
+typedef struct {
+  uint32_t    coded_width;
+  uint32_t    coded_height;
+
+  uint64_t    video_step; /* frame duration in pts units */
+  double      ratio;
+  VdpDecoderProfile profile;
+  int         chroma;
+
+  int         have_header;
+
+  uint8_t     *buf; /* accumulate data */
+  int         bufseek;
+  uint32_t    bufsize;
+  uint32_t    bufpos;
+  int         start;
+
+  picture_t   picture;
+  vo_frame_t  *forward_ref;
+  vo_frame_t  *backward_ref;
+
+  int64_t    seq_pts;
+	int64_t    cur_pts;
+
+  vdpau_accel_t *accel_vdpau;
+
+  int         vdp_runtime_nr;
+
+} sequence_t;
+
+
+
+typedef struct {
+  video_decoder_class_t   decoder_class;
+} vdpau_mpeg12_class_t;
+
+
+
+typedef struct vdpau_mpeg12_decoder_s {
+  video_decoder_t         video_decoder;  /* parent video decoder structure */
+
+  vdpau_mpeg12_class_t    *class;
+  xine_stream_t           *stream;
+
+  sequence_t              sequence;
+
+  VdpDecoder              decoder;
+  VdpDecoderProfile       decoder_profile;
+  uint32_t                decoder_width;
+  uint32_t                decoder_height;
+
+} vdpau_mpeg12_decoder_t;
+
+
+
+static void reset_picture( picture_t *pic )
+{
+  lprintf( "reset_picture\n" );
+  pic->vdp_infos.picture_structure = 0;
+  pic->vdp_infos2.intra_dc_precision = pic->vdp_infos.intra_dc_precision = 0;
+  pic->vdp_infos2.frame_pred_frame_dct = pic->vdp_infos.frame_pred_frame_dct = 1;
+  pic->vdp_infos2.concealment_motion_vectors = pic->vdp_infos.concealment_motion_vectors = 0;
+  pic->vdp_infos2.intra_vlc_format = pic->vdp_infos.intra_vlc_format = 0;
+  pic->vdp_infos2.alternate_scan = pic->vdp_infos.alternate_scan = 0;
+  pic->vdp_infos2.q_scale_type = pic->vdp_infos.q_scale_type = 0;
+  pic->vdp_infos2.top_field_first = pic->vdp_infos.top_field_first = 0;
+  pic->slices_count = 0;
+  pic->slices_count2 = 0;
+  pic->slices_pos = 0;
+  pic->slices_pos_top = 0;
+  pic->state = WANT_HEADER;
+}
+
+
+
+static void init_picture( picture_t *pic )
+{
+  pic->slices_size = 2048;
+  pic->slices = (uint8_t*)malloc(pic->slices_size);
+  reset_picture( pic );
+}
+
+
+
+static void reset_sequence( sequence_t *sequence )
+{
+  lprintf( "reset_sequence\n" );
+  sequence->have_header = 0;
+  sequence->bufpos = 0;
+  sequence->bufseek = 0;
+  sequence->start = -1;
+	sequence->seq_pts = sequence->cur_pts = 0;
+  sequence->profile = VDP_DECODER_PROFILE_MPEG1;
+  sequence->chroma = 0;
+	//sequence->ratio = 1.0;
+	sequence->video_step = 3600;
+  if ( sequence->forward_ref )
+    sequence->forward_ref->free( sequence->forward_ref );
+  sequence->forward_ref = NULL;
+  if ( sequence->backward_ref )
+    sequence->backward_ref->free( sequence->backward_ref );
+  sequence->backward_ref = NULL;
+}
+
+
+
+static uint32_t get_bits( uint8_t *b, int offbits, int nbits )
+{
+  int i, nbytes;
+  uint32_t ret = 0;
+  uint8_t *buf;
+
+  buf = b+(offbits/8);
+  offbits %=8;
+  nbytes = (offbits+nbits)/8;
+  if ( ((offbits+nbits)%8)>0 )
+    nbytes++;
+  for ( i=0; i<nbytes; i++ )
+    ret += buf[i]<<((nbytes-i-1)*8);
+  i = (4-nbytes)*8+offbits;
+  ret = ((ret<<i)>>i)>>((nbytes*8)-nbits-offbits);
+
+  return ret;
+}
+
+
+
+static void sequence_header( vdpau_mpeg12_decoder_t *this_gen, uint8_t *buf, int len )
+{
+  sequence_t *sequence = (sequence_t*)&this_gen->sequence;
+
+  int i, j, off=0;
+	if ( sequence->cur_pts ) {
+		sequence->seq_pts = sequence->cur_pts;
+	}
+  sequence->coded_width = get_bits( buf,0,12 );
+  lprintf( "coded_width: %d\n", get_bits( buf,0,12 ) );
+  sequence->coded_height = get_bits( buf,12,12 );
+  lprintf( "coded_height: %d\n", get_bits( buf,12,12 ) );
+  switch ( get_bits( buf+3,0,4 ) ) {
+    case 1: sequence->ratio = 1.0; break;
+    case 2: sequence->ratio = 4.0/3.0; break;
+    case 3: sequence->ratio = 16.0/9.0; break;
+    case 4: sequence->ratio = 2.21; break;
+    default: sequence->ratio = (double)sequence->coded_width/(double)sequence->coded_height;
+  }
+  lprintf( "ratio: %d\n", get_bits( buf+3,0,4 ) );
+  switch ( get_bits( buf+3,4,4 ) ) {
+    case 1: sequence->video_step = 3913; break; /* 23.976.. */
+    case 2: sequence->video_step = 3750; break; /* 24 */
+    case 3: sequence->video_step = 3600; break; /* 25 */
+    case 4: sequence->video_step = 3003; break; /* 29.97.. */
+    case 5: sequence->video_step = 3000; break; /* 30 */
+    case 6: sequence->video_step = 1800; break; /* 50 */
+    case 7: sequence->video_step = 1525; break; /* 59.94.. */
+    case 8: sequence->video_step = 1509; break; /* 60 */
+  }
+  lprintf( "frame_rate: %d\n", get_bits( buf+3,4,4 ) );
+  lprintf( "bit_rate_value: %d\n", get_bits( buf+4,0,18 ) );
+  lprintf( "marker_bit: %d\n", get_bits( buf+6,2,1 ) );
+  lprintf( "vbv_buffer_size_value: %d\n", get_bits( buf+6,3,10 ) );
+  lprintf( "constrained_parameters_flag: %d\n", get_bits( buf+7,5,1 ) );
+  i = get_bits( buf+7,6,1 );
+  lprintf( "load_intra_quantizer_matrix: %d\n", i );
+  if ( i ) {
+    for ( j=0; j<64; ++j ) {
+      sequence->picture.vdp_infos2.intra_quantizer_matrix[mpeg2_scan_norm[j]] = sequence->picture.vdp_infos.intra_quantizer_matrix[mpeg2_scan_norm[j]] = get_bits( buf+7+j,7,8 );
+    }
+    off = 64;
+  }
+  else {
+    for ( j=0; j<64; ++j ) {
+      sequence->picture.vdp_infos2.intra_quantizer_matrix[mpeg2_scan_norm[j]] = sequence->picture.vdp_infos.intra_quantizer_matrix[mpeg2_scan_norm[j]] = default_intra_quantizer_matrix[j];
+    }
+  }
+
+  i = get_bits( buf+7+off,7,1 );
+  lprintf( "load_non_intra_quantizer_matrix: %d\n", i );
+  if ( i ) {
+    for ( j=0; j<64; ++j ) {
+      sequence->picture.vdp_infos2.non_intra_quantizer_matrix[mpeg2_scan_norm[j]] = sequence->picture.vdp_infos.non_intra_quantizer_matrix[mpeg2_scan_norm[j]] = get_bits( buf+8+off+j,0,8 );
+    }
+  }
+  else {
+    memset( sequence->picture.vdp_infos.non_intra_quantizer_matrix, 16, 64 );
+    memset( sequence->picture.vdp_infos2.non_intra_quantizer_matrix, 16, 64 );
+  }
+
+  if ( !sequence->have_header ) {
+    sequence->have_header = 1;
+    _x_stream_info_set( this_gen->stream, XINE_STREAM_INFO_VIDEO_WIDTH, sequence->coded_width );
+    _x_stream_info_set( this_gen->stream, XINE_STREAM_INFO_VIDEO_HEIGHT, sequence->coded_height );
+    _x_stream_info_set( this_gen->stream, XINE_STREAM_INFO_VIDEO_RATIO, ((double)10000*sequence->ratio) );
+    _x_stream_info_set( this_gen->stream, XINE_STREAM_INFO_FRAME_DURATION, sequence->video_step );
+    _x_meta_info_set_utf8( this_gen->stream, XINE_META_INFO_VIDEOCODEC, "MPEG1/2 (vdpau)" );
+    xine_event_t event;
+    xine_format_change_data_t data;
+    event.type = XINE_EVENT_FRAME_FORMAT_CHANGE;
+    event.stream = this_gen->stream;
+    event.data = &data;
+    event.data_length = sizeof(data);
+    data.width = sequence->coded_width;
+    data.height = sequence->coded_height;
+    data.aspect = sequence->ratio;
+    xine_event_send( this_gen->stream, &event );
+  }
+}
+
+
+
+static void picture_header( sequence_t *sequence, uint8_t *buf, int len )
+{
+  if ( sequence->picture.state!=WANT_HEADER )
+    return;
+
+  if ( sequence->profile==VDP_DECODER_PROFILE_MPEG1 )
+    sequence->picture.vdp_infos.picture_structure = PICTURE_FRAME;
+
+  VdpPictureInfoMPEG1Or2 *infos = &sequence->picture.vdp_infos;
+
+  if ( sequence->picture.vdp_infos.picture_structure && sequence->picture.slices_count2 )
+      reset_picture( &sequence->picture );
+
+  if ( sequence->picture.vdp_infos.picture_structure==PICTURE_FRAME ) {
+    reset_picture( &sequence->picture );
+  }
+  else if ( sequence->picture.vdp_infos.picture_structure ) {
+    infos = &sequence->picture.vdp_infos2;
+  }
+
+  lprintf( "temporal_reference: %d\n", get_bits( buf,0,10 ) );
+  infos->picture_coding_type = get_bits( buf,10,3 );
+  lprintf( "picture_coding_type: %d\n", get_bits( buf,10,3 ) );
+  infos->forward_reference = VDP_INVALID_HANDLE;
+  infos->backward_reference = VDP_INVALID_HANDLE;
+  if ( infos->picture_coding_type > I_FRAME ) {
+    infos->full_pel_forward_vector = get_bits( buf+2,13,1 );
+    infos->f_code[0][0] = infos->f_code[0][1] = get_bits( buf+2,14,3 );
+    if ( infos->picture_coding_type==B_FRAME ) {
+      infos->full_pel_backward_vector = get_bits( buf+2,17,1 );
+      infos->f_code[1][0] = infos->f_code[1][1] = get_bits( buf+2,18,3 );
+    }
+  }
+  else {
+    infos->full_pel_forward_vector = 0;
+    infos->full_pel_backward_vector = 0;
+  }
+  if ( sequence->profile==VDP_DECODER_PROFILE_MPEG1 )
+    sequence->picture.state = WANT_SLICE;
+  else
+    sequence->picture.state = WANT_EXT;
+}
+
+
+
+static void sequence_extension( sequence_t *sequence, uint8_t *buf, int len )
+{
+  lprintf( "extension_start_code_identifier: %d\n", get_bits( buf,0,4 ) );
+  switch ( get_bits( buf,5,3 ) ) {
+    case 5: sequence->profile = VDP_DECODER_PROFILE_MPEG2_SIMPLE; break;
+    default: sequence->profile = VDP_DECODER_PROFILE_MPEG2_MAIN;
+  }
+  lprintf( "profile_and_level_indication: %d\n", get_bits( buf,4,8 ) );
+  lprintf( "progressive_sequence: %d\n", get_bits( buf,12,1 ) );
+  if ( get_bits( buf,13,2 )==2 )
+    sequence->chroma = VO_CHROMA_422;
+  lprintf( "chroma_format: %d\n", get_bits( buf,13,2 ) );
+  lprintf( "horizontal_size_extension: %d\n", get_bits( buf,15,2 ) );
+  lprintf( "vertical_size_extension: %d\n", get_bits( buf,17,2 ) );
+  lprintf( "bit_rate_extension: %d\n", get_bits( buf,19,12 ) );
+  lprintf( "marker_bit: %d\n", get_bits( buf,31,1 ) );
+  lprintf( "vbv_buffer_size_extension: %d\n", get_bits( buf+4,0,8 ) );
+  lprintf( "low_delay: %d\n", get_bits( buf+5,0,1 ) );
+  lprintf( "frame_rate_extension_n: %d\n", get_bits( buf+5,1,2 ) );
+  lprintf( "frame_rate_extension_d: %d\n", get_bits( buf+5,3,5 ) );
+}
+
+
+
+static void picture_coding_extension( sequence_t *sequence, uint8_t *buf, int len )
+{
+  if ( sequence->picture.state!=WANT_EXT )
+    return;
+
+  VdpPictureInfoMPEG1Or2 *infos = &sequence->picture.vdp_infos;
+  if ( infos->picture_structure && infos->picture_structure!=PICTURE_FRAME )
+    infos = &sequence->picture.vdp_infos2;
+
+  infos->f_code[0][0] = get_bits( buf,4,4 );
+  infos->f_code[0][1] = get_bits( buf,8,4 );
+  infos->f_code[1][0] = get_bits( buf,12,4 );
+  infos->f_code[1][1] = get_bits( buf,16,4 );
+  lprintf( "extension_start_code_identifier: %d\n", get_bits( buf,0,4 ) );
+  lprintf( "f_code_0_0: %d\n", get_bits( buf,4,4 ) );
+  lprintf( "f_code_0_1: %d\n", get_bits( buf,8,4 ) );
+  lprintf( "f_code_1_0: %d\n", get_bits( buf,12,4 ) );
+  lprintf( "f_code_1_1: %d\n", get_bits( buf,16,4 ) );
+  infos->intra_dc_precision = get_bits( buf,20,2 );
+  lprintf( "intra_dc_precision: %d\n", get_bits( buf,20,2 ) );
+  infos->picture_structure = get_bits( buf,22,2 );
+  lprintf( "picture_structure: %d\n", get_bits( buf,22,2 ) );
+  infos->top_field_first = get_bits( buf,24,1 );
+  lprintf( "top_field_first: %d\n", get_bits( buf,24,1 ) );
+  infos->frame_pred_frame_dct = get_bits( buf,25,1 );
+  lprintf( "frame_pred_frame_dct: %d\n", get_bits( buf,25,1 ) );
+  infos->concealment_motion_vectors = get_bits( buf,26,1 );
+  lprintf( "concealment_motion_vectors: %d\n", get_bits( buf,26,1 ) );
+  infos->q_scale_type = get_bits( buf,27,1 );
+  lprintf( "q_scale_type: %d\n", get_bits( buf,27,1 ) );
+  infos->intra_vlc_format = get_bits( buf,28,1 );
+  lprintf( "intra_vlc_format: %d\n", get_bits( buf,28,1 ) );
+  infos->alternate_scan = get_bits( buf,29,1 );
+  lprintf( "alternate_scan: %d\n", get_bits( buf,29,1 ) );
+  lprintf( "repeat_first_field: %d\n", get_bits( buf,30,1 ) );
+  lprintf( "chroma_420_type: %d\n", get_bits( buf,31,1 ) );
+  sequence->picture.progressive_frame = get_bits( buf,32,1 );
+  lprintf( "progressive_frame: %d\n", get_bits( buf,32,1 ) );
+  sequence->picture.state = WANT_SLICE;
+}
+
+
+
+static void quant_matrix_extension( sequence_t *sequence, uint8_t *buf, int len )
+{
+  int i, j, off=0;
+
+  i = get_bits( buf,4,1 );
+  lprintf( "load_intra_quantizer_matrix: %d\n", i );
+  if ( i ) {
+    for ( j=0; j<64; ++j ) {
+      sequence->picture.vdp_infos2.intra_quantizer_matrix[mpeg2_scan_norm[j]] = sequence->picture.vdp_infos.intra_quantizer_matrix[mpeg2_scan_norm[j]] = get_bits( buf+j,5,8 );
+    }
+    off = 64;
+  }
+  else {
+    for ( j=0; j<64; ++j ) {
+      sequence->picture.vdp_infos2.intra_quantizer_matrix[mpeg2_scan_norm[j]] = sequence->picture.vdp_infos.intra_quantizer_matrix[mpeg2_scan_norm[j]] = default_intra_quantizer_matrix[j];
+    }
+  }
+
+  i = get_bits( buf+off,5,1 );
+  lprintf( "load_non_intra_quantizer_matrix: %d\n", i );
+  if ( i ) {
+    for ( j=0; j<64; ++j ) {
+      sequence->picture.vdp_infos2.non_intra_quantizer_matrix[mpeg2_scan_norm[j]] = sequence->picture.vdp_infos.non_intra_quantizer_matrix[mpeg2_scan_norm[j]] = get_bits( buf+off+j,6,8 );
+    }
+  }
+  else {
+    memset( sequence->picture.vdp_infos.non_intra_quantizer_matrix, 16, 64 );
+    memset( sequence->picture.vdp_infos2.non_intra_quantizer_matrix, 16, 64 );
+  }
+}
+
+
+
+static void copy_slice( sequence_t *sequence, uint8_t *buf, int len )
+{
+  int size = sequence->picture.slices_pos+len;
+  if ( sequence->picture.slices_size < size ) {
+    sequence->picture.slices_size = size+1024;
+    sequence->picture.slices = realloc( sequence->picture.slices, sequence->picture.slices_size );
+  }
+  xine_fast_memcpy( sequence->picture.slices+sequence->picture.slices_pos, buf, len );
+  sequence->picture.slices_pos += len;
+  if ( sequence->picture.slices_pos_top )
+    sequence->picture.slices_count2++;
+  else
+    sequence->picture.slices_count++;
+}
+
+
+
+static int parse_code( vdpau_mpeg12_decoder_t *this_gen, uint8_t *buf, int len )
+{
+  sequence_t *sequence = (sequence_t*)&this_gen->sequence;
+
+  if ( !sequence->have_header && buf[3]!=sequence_header_code )
+    return 0;
+
+  if ( (buf[3] >= begin_slice_start_code) && (buf[3] <= end_slice_start_code) ) {
+    lprintf( " ----------- slice_start_code\n" );
+    if ( sequence->picture.state==WANT_SLICE )
+      copy_slice( sequence, buf, len );
+    return 0;
+  }
+  else if ( sequence->picture.state==WANT_SLICE && sequence->picture.slices_count ) {
+    if ( !sequence->picture.slices_count2 ) {
+      sequence->picture.slices_pos_top = sequence->picture.slices_pos;
+    }
+    /* no more slices, decode */
+    return 1;
+  }
+
+  switch ( buf[3] ) {
+    case sequence_header_code:
+      lprintf( " ----------- sequence_header_code\n" );
+      sequence_header( this_gen, buf+4, len-4 );
+      break;
+    case extension_start_code: {
+      switch ( get_bits( buf+4,0,4 ) ) {
+        case sequence_ext_sc:
+          lprintf( " ----------- sequence_extension_start_code\n" );
+          sequence_extension( sequence, buf+4, len-4 );
+          break;
+        case quant_matrix_ext_sc:
+          lprintf( " ----------- quant_matrix_extension_start_code\n" );
+          quant_matrix_extension( sequence, buf+4, len-4 );
+          break;
+        case picture_coding_ext_sc:
+          lprintf( " ----------- picture_coding_extension_start_code\n" );
+          picture_coding_extension( sequence, buf+4, len-4 );
+          break;
+        case sequence_display_ext_sc:
+          lprintf( " ----------- sequence_display_extension_start_code\n" );
+          //sequence_display_extension( sequence, buf+4, len-4 );
+          break;
+      }
+      break;
+      }
+    case user_data_start_code:
+      lprintf( " ----------- user_data_start_code\n" );
+      break;
+    case group_start_code:
+      lprintf( " ----------- group_start_code\n" );
+      break;
+    case picture_start_code:
+      lprintf( " ----------- picture_start_code\n" );
+      //slice_count = 0;
+      picture_header( sequence, buf+4, len-4 );
+      break;
+    case sequence_error_code:
+      lprintf( " ----------- sequence_error_code\n" );
+      break;
+    case sequence_end_code:
+      lprintf( " ----------- sequence_end_code\n" );
+      break;
+  }
+  return 0;
+}
+
+
+
+static void decode_render( vdpau_mpeg12_decoder_t *vd, vdpau_accel_t *accel )
+{
+  sequence_t *seq = (sequence_t*)&vd->sequence;
+  picture_t *pic = (picture_t*)&seq->picture;
+
+  pic->vdp_infos.slice_count = pic->slices_count;
+  pic->vdp_infos2.slice_count = pic->slices_count2;
+
+  VdpStatus st;
+  if ( vd->decoder==VDP_INVALID_HANDLE || vd->decoder_profile!=seq->profile || vd->decoder_width!=seq->coded_width || vd->decoder_height!=seq->coded_height ) {
+    if ( vd->decoder!=VDP_INVALID_HANDLE ) {
+      accel->vdp_decoder_destroy( vd->decoder );
+      vd->decoder = VDP_INVALID_HANDLE;
+    }
+    st = accel->vdp_decoder_create( accel->vdp_device, seq->profile, seq->coded_width, seq->coded_height, 2, &vd->decoder);
+    if ( st!=VDP_STATUS_OK )
+      lprintf( "failed to create decoder !! %s\n", accel->vdp_get_error_string( st ) );
+    else {
+      vd->decoder_profile = seq->profile;
+      vd->decoder_width = seq->coded_width;
+      vd->decoder_height = seq->coded_height;
+      seq->vdp_runtime_nr = accel->vdp_runtime_nr;
+    }
+  }
+
+  VdpBitstreamBuffer vbit;
+  vbit.struct_version = VDP_BITSTREAM_BUFFER_VERSION;
+  vbit.bitstream = pic->slices;
+  vbit.bitstream_bytes = (pic->vdp_infos.picture_structure==PICTURE_FRAME)? pic->slices_pos : pic->slices_pos_top;
+  st = accel->vdp_decoder_render( vd->decoder, accel->surface, (VdpPictureInfo*)&pic->vdp_infos, 1, &vbit );
+  if ( st!=VDP_STATUS_OK )
+    lprintf( "decoder failed : %d!! %s\n", st, accel->vdp_get_error_string( st ) );
+  else {
+    lprintf( "DECODER SUCCESS : frame_type:%d, slices=%d, slices_bytes=%d, current=%d, forwref:%d, backref:%d, pts:%lld\n",
+              pic->vdp_infos.picture_coding_type, pic->vdp_infos.slice_count, vbit.bitstream_bytes, accel->surface, pic->vdp_infos.forward_reference, pic->vdp_infos.backward_reference, seq->seq_pts );
+    VdpPictureInfoMPEG1Or2 *info = &pic->vdp_infos;
+    lprintf("%d %d %d %d %d %d %d %d %d %d %d %d %d\n", info->intra_dc_precision, info->frame_pred_frame_dct, info->concealment_motion_vectors, info->intra_vlc_format, info->alternate_scan, info->q_scale_type, info->top_field_first, info->full_pel_forward_vector, info->full_pel_backward_vector, info->f_code[0][0], info->f_code[0][1], info->f_code[1][0], info->f_code[1][1] );
+  }
+
+  if ( pic->vdp_infos.picture_structure != PICTURE_FRAME ) {
+    pic->vdp_infos2.backward_reference = VDP_INVALID_HANDLE;
+    pic->vdp_infos2.forward_reference = VDP_INVALID_HANDLE;
+    if ( pic->vdp_infos2.picture_coding_type==P_FRAME ) {
+      pic->vdp_infos2.backward_reference = VDP_INVALID_HANDLE;
+      if ( pic->vdp_infos.picture_coding_type==I_FRAME )
+        pic->vdp_infos2.forward_reference = accel->surface;
+      else
+        pic->vdp_infos2.forward_reference = pic->vdp_infos.forward_reference;
+    }
+    else if ( pic->vdp_infos.picture_coding_type==B_FRAME ) {
+      pic->vdp_infos2.forward_reference = pic->vdp_infos.forward_reference;
+      pic->vdp_infos2.backward_reference = pic->vdp_infos.backward_reference;
+    }
+    vbit.struct_version = VDP_BITSTREAM_BUFFER_VERSION;
+    vbit.bitstream = pic->slices+pic->slices_pos_top;
+    vbit.bitstream_bytes = pic->slices_pos-pic->slices_pos_top;
+    st = accel->vdp_decoder_render( vd->decoder, accel->surface, (VdpPictureInfo*)&pic->vdp_infos2, 1, &vbit );
+    if ( st!=VDP_STATUS_OK )
+      lprintf( "decoder failed : %d!! %s\n", st, accel->vdp_get_error_string( st ) );
+    else
+      lprintf( "DECODER SUCCESS : frame_type:%d, slices=%d, current=%d, forwref:%d, backref:%d, pts:%lld\n",
+                pic->vdp_infos2.picture_coding_type, pic->vdp_infos2.slice_count, accel->surface, pic->vdp_infos2.forward_reference, pic->vdp_infos2.backward_reference, seq->seq_pts );
+  }
+
+  //printf( "vdpau_meg12:  forwref:%d, backref:%d\n", seq->forward_ref, seq->backward_ref );
+}
+
+
+
+static void decode_picture( vdpau_mpeg12_decoder_t *vd )
+{
+  sequence_t *seq = (sequence_t*)&vd->sequence;
+  picture_t *pic = (picture_t*)&seq->picture;
+  vdpau_accel_t *ref_accel;
+
+  pic->state = WANT_HEADER;
+
+  if ( seq->profile == VDP_DECODER_PROFILE_MPEG1 )
+    pic->vdp_infos.picture_structure=PICTURE_FRAME;
+
+  if ( pic->vdp_infos.picture_structure!=PICTURE_FRAME && !pic->slices_count2 ) {
+    /* waiting second field */
+    lprintf("********************* no slices_count2 **********************\n");
+    return;
+  }
+
+  if ( pic->vdp_infos.picture_coding_type==P_FRAME ) {
+    if ( seq->backward_ref ) {
+      ref_accel = (vdpau_accel_t*)seq->backward_ref->accel_data;
+      pic->vdp_infos.forward_reference = ref_accel->surface;
+    }
+    else
+      return;
+  }
+  else if ( pic->vdp_infos.picture_coding_type==B_FRAME ) {
+    if ( seq->forward_ref ) {
+      ref_accel = (vdpau_accel_t*)seq->forward_ref->accel_data;
+      pic->vdp_infos.forward_reference = ref_accel->surface;
+    }
+    else
+      return;
+    if ( seq->backward_ref ) {
+      ref_accel = (vdpau_accel_t*)seq->backward_ref->accel_data;
+      pic->vdp_infos.backward_reference = ref_accel->surface;
+    }
+    else
+      return;
+  }
+
+  //printf("vdpau_mpeg12: get image ..\n");
+  vo_frame_t *img = vd->stream->video_out->get_frame( vd->stream->video_out, seq->coded_width, seq->coded_height,
+                                                      seq->ratio, XINE_IMGFMT_VDPAU, VO_BOTH_FIELDS|seq->chroma );
+  vdpau_accel_t *accel = (vdpau_accel_t*)img->accel_data;
+  if ( !seq->accel_vdpau )
+    seq->accel_vdpau = accel;
+
+  if( seq->vdp_runtime_nr != *(seq->accel_vdpau->current_vdp_runtime_nr) ) {
+    seq->accel_vdpau = accel;
+    if ( seq->forward_ref )
+      seq->forward_ref->free( seq->forward_ref );
+    seq->forward_ref = NULL;
+    if ( seq->backward_ref )
+      seq->backward_ref->free( seq->backward_ref );
+    seq->backward_ref = NULL;
+    vd->decoder = VDP_INVALID_HANDLE;
+  }
+  img->drawn = 0;
+  //printf("vdpau_mpeg12: .. got image %d\n", img);
+
+  decode_render( vd, accel );
+
+  img->bad_frame = 0;
+  img->duration = seq->video_step;
+  if ( pic->vdp_infos.top_field_first || pic->vdp_infos.picture_structure==PICTURE_FRAME )
+    img->top_field_first = 1;
+  else
+    img->top_field_first = 0;
+
+  // progressive_frame is unreliable with most mpeg2 streams //img->progressive_frame = pic->progressive_frame;
+
+  if ( pic->vdp_infos.picture_coding_type!=B_FRAME ) {
+    if ( pic->vdp_infos.picture_coding_type==I_FRAME && !seq->backward_ref ) {
+      img->pts = 0;
+      img->draw( img, vd->stream );
+      ++img->drawn;
+    }
+    if ( seq->forward_ref ) {
+      seq->forward_ref->drawn = 0;
+      seq->forward_ref->free( seq->forward_ref );
+      //printf("vdpau_mpeg12: freed image %d\n", seq->forward_ref );
+    }
+    seq->forward_ref = seq->backward_ref;
+    if ( seq->forward_ref && !seq->forward_ref->drawn ) {
+      seq->forward_ref->pts = seq->seq_pts;
+      seq->forward_ref->draw( seq->forward_ref, vd->stream );
+      //printf( "vdpau_mpeg12: drawn reference image with pts=%lld\n", seq->forward_ref->pts );
+    }
+    seq->backward_ref = img;
+  }
+  else {
+    img->pts = seq->seq_pts;
+    img->draw( img, vd->stream );
+    //printf( "vdpau_mpeg12: drawn image with pts=%lld\n", img->pts );
+    img->free( img );
+    //printf("vdpau_mpeg12: freed B image %d\n", img );
+  }
+
+  seq->seq_pts +=seq->video_step;
+}
+
+
+
+/*
+ * This function receives a buffer of data from the demuxer layer and
+ * figures out how to handle it based on its header flags.
+ */
+static void vdpau_mpeg12_decode_data (video_decoder_t *this_gen, buf_element_t *buf)
+{
+  vdpau_mpeg12_decoder_t *this = (vdpau_mpeg12_decoder_t *) this_gen;
+  sequence_t *seq = (sequence_t*)&this->sequence;
+
+  /* a video decoder does not care about this flag (?) */
+  if (buf->decoder_flags & BUF_FLAG_PREVIEW) {
+    return;
+  }
+
+  if (buf->decoder_flags & BUF_FLAG_FRAMERATE) {
+    //this->video_step = buf->decoder_info[0];
+    //_x_stream_info_set(this->stream, XINE_STREAM_INFO_FRAME_DURATION, this->video_step);
+  }
+
+  if ( !buf->size )
+    return;
+
+  seq->cur_pts = buf->pts;
+  //printf("vdpau_mpeg12_decode_data: new pts : %lld\n", buf->pts );
+
+  int size = seq->bufpos+buf->size;
+  if ( seq->bufsize < size ) {
+    seq->bufsize = size+1024;
+    seq->buf = realloc( seq->buf, seq->bufsize );
+    //printf("sequence buffer realloced = %d\n", seq->bufsize );
+  }
+  xine_fast_memcpy( seq->buf+seq->bufpos, buf->content, buf->size );
+  seq->bufpos += buf->size;
+
+  while ( seq->bufseek <= seq->bufpos-4 ) {
+    uint8_t *buf = seq->buf+seq->bufseek;
+    if ( buf[0]==0 && buf[1]==0 && buf[2]==1 ) {
+      if ( seq->start<0 ) {
+        seq->start = seq->bufseek;
+      }
+      else {
+        if ( parse_code( this, seq->buf+seq->start, seq->bufseek-seq->start ) ) {
+          decode_picture( this );
+          parse_code( this, seq->buf+seq->start, seq->bufseek-seq->start );
+        }
+        uint8_t *tmp = (uint8_t*)malloc(seq->bufsize);
+        xine_fast_memcpy( tmp, seq->buf+seq->bufseek, seq->bufpos-seq->bufseek );
+        seq->bufpos -= seq->bufseek;
+        seq->start = -1;
+        seq->bufseek = -1;
+        free( seq->buf );
+        seq->buf = tmp;
+      }
+    }
+    ++seq->bufseek;
+  }
+
+  /* still image detection -- don't wait for further data if buffer ends in sequence end code */
+  if (seq->start >= 0 && seq->buf[seq->start + 3] == sequence_end_code) {
+    if (parse_code(this, seq->buf+seq->start, 4)) {
+      decode_picture(this);
+      parse_code(this, seq->buf+seq->start, 4);
+    }
+    seq->start = -1;
+  }
+}
+
+/*
+ * This function is called when xine needs to flush the system.
+ */
+static void vdpau_mpeg12_flush (video_decoder_t *this_gen) {
+  vdpau_mpeg12_decoder_t *this = (vdpau_mpeg12_decoder_t *) this_gen;
+
+  printf( "vdpau_mpeg12: vdpau_mpeg12_flush\n" );
+// incorrect: see libmpeg2, mpeg2_flush()
+//  reset_sequence( &this->sequence );
+}
+
+/*
+ * This function resets the video decoder.
+ */
+static void vdpau_mpeg12_reset (video_decoder_t *this_gen) {
+  vdpau_mpeg12_decoder_t *this = (vdpau_mpeg12_decoder_t *) this_gen;
+
+  printf( "vdpau_mpeg12: vdpau_mpeg12_reset\n" );
+  reset_sequence( &this->sequence );
+
+  //this->size = 0;
+}
+
+/*
+ * The decoder should forget any stored pts values here.
+ */
+static void vdpau_mpeg12_discontinuity (video_decoder_t *this_gen) {
+  vdpau_mpeg12_decoder_t *this = (vdpau_mpeg12_decoder_t *) this_gen;
+
+  printf( "vdpau_mpeg12: vdpau_mpeg12_discontinuity\n" );
+  reset_sequence( &this->sequence );
+
+}
+
+/*
+ * This function frees the video decoder instance allocated to the decoder.
+ */
+static void vdpau_mpeg12_dispose (video_decoder_t *this_gen) {
+
+  vdpau_mpeg12_decoder_t *this = (vdpau_mpeg12_decoder_t *) this_gen;
+
+  printf( "vdpau_mpeg12: vdpau_mpeg12_dispose\n" );
+
+  if ( this->decoder!=VDP_INVALID_HANDLE && this->sequence.accel_vdpau ) {
+      this->sequence.accel_vdpau->vdp_decoder_destroy( this->decoder );
+      this->decoder = VDP_INVALID_HANDLE;
+    }
+
+  reset_sequence( &this->sequence );
+
+  this->stream->video_out->close( this->stream->video_out, this->stream );
+
+  free( this->sequence.picture.slices );
+  free( this->sequence.buf );
+  free( this_gen );
+}
+
+/*
+ * This function allocates, initializes, and returns a private video
+ * decoder structure.
+ */
+static video_decoder_t *open_plugin (video_decoder_class_t *class_gen, xine_stream_t *stream) {
+
+  vdpau_mpeg12_decoder_t  *this ;
+
+  /* the videoout must be vdpau-capable to support this decoder */
+  if ( !(stream->video_driver->get_capabilities(stream->video_driver) & VO_CAP_VDPAU_MPEG12) )
+    return NULL;
+
+  printf( "vdpau_mpeg12: open_plugin\n" );
+
+  this = (vdpau_mpeg12_decoder_t *) calloc(1, sizeof(vdpau_mpeg12_decoder_t));
+
+  this->video_decoder.decode_data         = vdpau_mpeg12_decode_data;
+  this->video_decoder.flush               = vdpau_mpeg12_flush;
+  this->video_decoder.reset               = vdpau_mpeg12_reset;
+  this->video_decoder.discontinuity       = vdpau_mpeg12_discontinuity;
+  this->video_decoder.dispose             = vdpau_mpeg12_dispose;
+
+  this->stream                            = stream;
+  this->class                             = (vdpau_mpeg12_class_t *) class_gen;
+
+  this->sequence.bufsize = 1024;
+  this->sequence.buf = (uint8_t*)malloc(this->sequence.bufsize);
+  this->sequence.forward_ref = 0;
+  this->sequence.backward_ref = 0;
+  this->sequence.vdp_runtime_nr = 1;
+  reset_sequence( &this->sequence );
+
+  init_picture( &this->sequence.picture );
+
+  this->decoder = VDP_INVALID_HANDLE;
+  this->sequence.accel_vdpau = NULL;
+
+  (stream->video_out->open)(stream->video_out, stream);
+
+  return &this->video_decoder;
+}
+
+/*
+ * This function returns a brief string that describes (usually with the
+ * decoder's most basic name) the video decoder plugin.
+ */
+static char *get_identifier (video_decoder_class_t *this) {
+  return "vdpau_mpeg12";
+}
+
+/*
+ * This function returns a slightly longer string describing the video
+ * decoder plugin.
+ */
+static char *get_description (video_decoder_class_t *this) {
+  return "vdpau_mpeg12: mpeg1/2 decoder plugin using VDPAU hardware decoding.\n"
+    "Must be used along with video_out_vdpau.";
+}
+
+/*
+ * This function frees the video decoder class and any other memory that was
+ * allocated.
+ */
+static void dispose_class (video_decoder_class_t *this) {
+  free (this);
+}
+
+/*
+ * This function allocates a private video decoder class and initializes
+ * the class's member functions.
+ */
+static void *init_plugin (xine_t *xine, void *data) {
+
+  vdpau_mpeg12_class_t *this;
+
+  this = (vdpau_mpeg12_class_t *) calloc(1, sizeof(vdpau_mpeg12_class_t));
+
+  this->decoder_class.open_plugin     = open_plugin;
+  this->decoder_class.get_identifier  = get_identifier;
+  this->decoder_class.get_description = get_description;
+  this->decoder_class.dispose         = dispose_class;
+
+  return this;
+}
+
+/*
+ * This is a list of all of the internal xine video buffer types that
+ * this decoder is able to handle. Check src/xine-engine/buffer.h for a
+ * list of valid buffer types (and add a new one if the one you need does
+ * not exist). Terminate the list with a 0.
+ */
+static const uint32_t video_types[] = {
+  BUF_VIDEO_MPEG,
+  0
+};
+
+/*
+ * This data structure combines the list of supported xine buffer types and
+ * the priority that the plugin should be given with respect to other
+ * plugins that handle the same buffer type. A plugin with priority (n+1)
+ * will be used instead of a plugin with priority (n).
+ */
+static const decoder_info_t dec_info_video = {
+  video_types,         /* supported types */
+  8                    /* priority        */
+};
+
+/*
+ * The plugin catalog entry. This is the only information that this plugin
+ * will export to the public.
+ */
+const plugin_info_t xine_plugin_info[] EXPORTED = {
+  /* { type, API, "name", version, special_info, init_function } */
+  { PLUGIN_VIDEO_DECODER, 18, "vdpau_mpeg12", XINE_VERSION_CODE, &dec_info_video, init_plugin },
+  { PLUGIN_NONE, 0, "", 0, NULL, NULL }
+};
diff -Naur xine-lib-1.1.16.1-old/src/Makefile.am xine-lib-1.1.16.1-new/src/Makefile.am
--- xine-lib-1.1.16.1-old/src/Makefile.am	2008-12-01 11:58:03.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/Makefile.am	2009-01-19 18:50:51.000000000 -0800
@@ -25,5 +25,6 @@
 	libreal \
 	libfaad \
         libmusepack \
+    libvdpau \
 	post \
 	combined
diff -Naur xine-lib-1.1.16.1-old/src/video_out/Makefile.am xine-lib-1.1.16.1-new/src/video_out/Makefile.am
--- xine-lib-1.1.16.1-old/src/video_out/Makefile.am	2009-01-10 17:25:34.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/video_out/Makefile.am	2009-01-19 18:50:51.000000000 -0800
@@ -36,6 +36,10 @@
 endif
 endif
 
+if HAVE_VDPAU
+vdpau_module = xineplug_vo_out_vdpau.la
+endif
+
 if HAVE_XCB
 XCBOSD = xcbosd.c
 if HAVE_XCBSHM
@@ -100,9 +104,14 @@
 		  $(xxmc_module) \
 		  $(xcbshm_module) \
 		  $(xcbxv_module) \
+      $(vdpau_module) \
                   xineplug_vo_out_raw.la \
                   xineplug_vo_out_none.la
 
+xineplug_vo_out_vdpau_la_SOURCES = yuv2rgb.c yuv2rgb_mmx.c yuv2rgb_mlib.c video_out_vdpau.c
+xineplug_vo_out_vdpau_la_LIBADD = $(XINE_LIB) $(MLIB_LIBS) $(PTHREAD_LIBS) $(X_LIBS) $(LTLIBINTL) -lvdpau
+xineplug_vo_out_vdpau_la_CFLAGS = $(VISIBILITY_FLAG) $(MLIB_CFLAGS) $(X_CFLAGS)
+
 xineplug_vo_out_xcbshm_la_SOURCES = yuv2rgb.c yuv2rgb_mmx.c yuv2rgb_mlib.c video_out_xcbshm.c $(XCBOSD)
 xineplug_vo_out_xcbshm_la_LIBADD = $(XINE_LIB) $(MLIB_LIBS) $(PTHREAD_LIBS) $(XCB_LIBS) $(XCBSHM_LIBS) $(LTLIBINTL)
 xineplug_vo_out_xcbshm_la_CFLAGS = $(VISIBILITY_FLAG) $(MLIB_CFLAGS) $(XCB_CFLAGS) $(XCBSHM_CFLAGS)
diff -Naur xine-lib-1.1.16.1-old/src/video_out/video_out_raw.c xine-lib-1.1.16.1-new/src/video_out/video_out_raw.c
--- xine-lib-1.1.16.1-old/src/video_out/video_out_raw.c	2009-01-10 17:25:34.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/video_out/video_out_raw.c	2009-01-19 18:50:51.000000000 -0800
@@ -278,9 +278,13 @@
 
   frame->yuv2rgb->dispose (frame->yuv2rgb);
 
+  if ( frame->chunk[0] )
   free (frame->chunk[0]);
+  if ( frame->chunk[1] )
   free (frame->chunk[1]);
+  if ( frame->chunk[2] )
   free (frame->chunk[2]);
+  if ( frame->chunk[3] )
   free (frame->chunk[3]);
   free (frame);
 }
@@ -297,6 +301,9 @@
   if (!frame)
     return NULL;
 
+  frame->chunk[0] = frame->chunk[1] = frame->chunk[2] = frame->chunk[3] = NULL;
+  frame->width = frame->height = frame->format = frame->flags = 0;
+
   pthread_mutex_init (&frame->vo_frame.mutex, NULL);
 
   /*
@@ -330,13 +337,16 @@
       || (frame->flags  != flags)) {
 /*     lprintf ("updating frame to %d x %d (ratio=%g, format=%08x)\n", width, height, ratio, format); */
 
-    flags &= VO_BOTH_FIELDS;
-
     /* (re-) allocate render space */
+    if ( frame->chunk[0] )
     free (frame->chunk[0]);
+    if ( frame->chunk[1] )
     free (frame->chunk[1]);
+    if ( frame->chunk[2] )
     free (frame->chunk[2]);
+    if ( frame->chunk[3] )
     free (frame->chunk[3]);
+    frame->chunk[0] = frame->chunk[1] = frame->chunk[2] = frame->chunk[3] = NULL;   
 
     if (format == XINE_IMGFMT_YV12) {
       frame->vo_frame.pitches[0] = 8*((width + 7) / 8);
@@ -355,7 +365,7 @@
 				       (void **) &frame->chunk[3]);
 
     /* set up colorspace converter */
-    switch (flags) {
+    switch (flags & VO_BOTH_FIELDS) {
     case VO_TOP_FIELD:
     case VO_BOTTOM_FIELD:
       frame->yuv2rgb->configure (frame->yuv2rgb,
@@ -382,6 +392,7 @@
     frame->width = width;
     frame->height = height;
     frame->format = format;
+    frame->flags = flags;
 
     raw_frame_field ((vo_frame_t *)frame, flags);
   }
diff -Naur xine-lib-1.1.16.1-old/src/video_out/video_out_vdpau.c xine-lib-1.1.16.1-new/src/video_out/video_out_vdpau.c
--- xine-lib-1.1.16.1-old/src/video_out/video_out_vdpau.c	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/video_out/video_out_vdpau.c	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,2033 @@
+/*
+ * Copyright (C) 2008 Christophe Thommeret <hftom@free.fr>
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ *
+ * video_out_vdpau.c, a video output plugin using VDPAU (Video Decode and Presentation Api for Unix)
+ *
+ *
+ */
+
+/* #define LOG */
+#define LOG_MODULE "video_out_vdpau"
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <math.h>
+#include <errno.h>
+#include <ctype.h>
+#include <pthread.h>
+
+#include "xine.h"
+#include "video_out.h"
+#include "vo_scale.h"
+#include "xine_internal.h"
+#include "yuv2rgb.h"
+#include "xineutils.h"
+
+#include <vdpau/vdpau_x11.h>
+#include "accel_vdpau.h"
+
+#define NUM_FRAMES_BACK 1
+
+
+
+const char *vdpau_deinterlace_methods[] = {
+  "bob",
+  "temporal",
+  "temporal_spatial",
+  NULL
+};
+
+
+
+VdpOutputSurfaceRenderBlendState blend = { VDP_OUTPUT_SURFACE_RENDER_BLEND_STATE_VERSION,
+          VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE ,
+          VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
+          VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE,
+          VDP_OUTPUT_SURFACE_RENDER_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
+          VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_ADD,
+          VDP_OUTPUT_SURFACE_RENDER_BLEND_EQUATION_ADD };
+
+
+
+VdpDevice vdp_device;
+VdpPresentationQueue vdp_queue;
+VdpPresentationQueueTarget vdp_queue_target;
+
+VdpGetProcAddress *vdp_get_proc_address;
+
+VdpGetApiVersion *vdp_get_api_version;
+VdpGetInformationString *vdp_get_information_string;
+VdpGetErrorString *vdp_get_error_string;
+
+VdpVideoSurfaceQueryGetPutBitsYCbCrCapabilities *vdp_video_surface_query_get_put_bits_ycbcr_capabilities;
+VdpVideoSurfaceCreate *vdp_video_surface_create;
+VdpVideoSurfaceDestroy *vdp_video_surface_destroy;
+VdpVideoSurfacePutBitsYCbCr *vdp_video_surface_putbits_ycbcr;
+VdpVideoSurfaceGetBitsYCbCr *vdp_video_surface_getbits_ycbcr;
+
+VdpOutputSurfaceCreate *vdp_output_surface_create;
+VdpOutputSurfaceDestroy *vdp_output_surface_destroy;
+VdpOutputSurfaceRenderBitmapSurface *vdp_output_surface_render_bitmap_surface;
+VdpOutputSurfacePutBitsNative *vdp_output_surface_put_bits;
+
+VdpVideoMixerCreate *vdp_video_mixer_create;
+VdpVideoMixerDestroy *vdp_video_mixer_destroy;
+VdpVideoMixerRender *vdp_video_mixer_render;
+VdpVideoMixerSetAttributeValues *vdp_video_mixer_set_attribute_values;
+VdpVideoMixerSetFeatureEnables *vdp_video_mixer_set_feature_enables;
+VdpVideoMixerGetFeatureEnables *vdp_video_mixer_get_feature_enables;
+
+VdpGenerateCSCMatrix *vdp_generate_csc_matrix;
+
+VdpPresentationQueueTargetCreateX11 *vdp_queue_target_create_x11;
+VdpPresentationQueueTargetDestroy *vdp_queue_target_destroy;
+VdpPresentationQueueCreate *vdp_queue_create;
+VdpPresentationQueueDestroy *vdp_queue_destroy;
+VdpPresentationQueueDisplay *vdp_queue_display;
+VdpPresentationQueueBlockUntilSurfaceIdle *vdp_queue_block;
+VdpPresentationQueueSetBackgroundColor *vdp_queue_set_background_color;
+VdpPresentationQueueGetTime *vdp_queue_get_time;
+
+VdpBitmapSurfacePutBitsNative *vdp_bitmap_put_bits;
+VdpBitmapSurfaceCreate  *vdp_bitmap_create;
+VdpBitmapSurfaceDestroy *vdp_bitmap_destroy;
+
+VdpDecoderQueryCapabilities *vdp_decoder_query_capabilities;
+VdpDecoderCreate *vdp_decoder_create;
+VdpDecoderDestroy *vdp_decoder_destroy;
+VdpDecoderRender *vdp_decoder_render;
+
+VdpPreemptionCallbackRegister *vdp_preemption_callback_register;
+static void vdp_preemption_callback( VdpDevice device, void *context );
+static void vdpau_reinit( vo_driver_t *this_gen );
+
+static VdpVideoSurfaceCreate *orig_vdp_video_surface_create;
+static VdpVideoSurfaceDestroy *orig_vdp_video_surface_destroy;
+
+static VdpDecoderCreate *orig_vdp_decoder_create;
+static VdpDecoderDestroy *orig_vdp_decoder_destroy;
+static VdpDecoderRender *orig_vdp_decoder_render;
+
+static Display *guarded_display;
+
+static VdpStatus guarded_vdp_video_surface_create(VdpDevice device, VdpChromaType chroma_type, uint32_t width, uint32_t height,VdpVideoSurface *surface)
+{
+  VdpStatus r;
+  XLockDisplay(guarded_display);
+  r = orig_vdp_video_surface_create(device, chroma_type, width, height, surface);
+  XUnlockDisplay(guarded_display);
+  return r;
+}
+
+static VdpStatus guarded_vdp_video_surface_destroy(VdpVideoSurface surface)
+{
+  VdpStatus r;
+//  XLockDisplay(guarded_display);
+  r = orig_vdp_video_surface_destroy(surface);
+//  XUnlockDisplay(guarded_display);
+  return r;
+}
+
+static VdpStatus guarded_vdp_decoder_create(VdpDevice device, VdpDecoderProfile profile, uint32_t width, uint32_t height, uint32_t max_references, VdpDecoder *decoder)
+{
+  VdpStatus r;
+  XLockDisplay(guarded_display);
+  r = orig_vdp_decoder_create(device, profile, width, height, max_references, decoder);
+  XUnlockDisplay(guarded_display);
+  return r;
+}
+
+static VdpStatus guarded_vdp_decoder_destroy(VdpDecoder decoder)
+{
+  VdpStatus r;
+  XLockDisplay(guarded_display);
+  r = orig_vdp_decoder_destroy(decoder);
+  XUnlockDisplay(guarded_display);
+  return r;
+}
+
+static VdpStatus guarded_vdp_decoder_render(VdpDecoder decoder, VdpVideoSurface target, VdpPictureInfo const *picture_info, uint32_t bitstream_buffer_count, VdpBitstreamBuffer const *bitstream_buffers)
+{
+  VdpStatus r;
+  XLockDisplay(guarded_display);
+  r = orig_vdp_decoder_render(decoder, target, picture_info, bitstream_buffer_count, bitstream_buffers);
+  XUnlockDisplay(guarded_display);
+  return r;
+}
+
+
+
+typedef struct {
+  VdpBitmapSurface ovl_bitmap;
+  uint32_t  bitmap_width, bitmap_height;
+  int ovl_w, ovl_h; /* overlay's width and height */
+  int ovl_x, ovl_y; /* overlay's top-left display position */
+  int unscaled;
+} vdpau_overlay_t;
+
+
+typedef struct {
+  vo_frame_t         vo_frame;
+
+  int                width, height, format, flags;
+  double             ratio;
+  uint8_t           *chunk[3]; /* mem alloc by xmalloc_aligned           */
+
+  vdpau_accel_t     vdpau_accel_data;
+} vdpau_frame_t;
+
+
+typedef struct {
+
+  vo_driver_t        vo_driver;
+  vo_scale_t         sc;
+
+  Display           *display;
+  int                screen;
+  Drawable           drawable;
+
+  config_values_t   *config;
+
+  int ovl_changed;
+  vdpau_overlay_t     overlays[XINE_VORAW_MAX_OVL];
+  yuv2rgb_factory_t   *yuv2rgb_factory;
+  yuv2rgb_t           *ovl_yuv2rgb;
+  VdpOutputSurface    overlay_output;
+  uint32_t            overlay_output_width;
+  uint32_t            overlay_output_height;
+  int                 has_overlay;
+
+  VdpOutputSurface    overlay_unscaled;
+  uint32_t            overlay_unscaled_width;
+  uint32_t            overlay_unscaled_height;
+  int                 has_unscaled;
+
+  VdpOutputSurface    argb_overlay;
+  uint32_t            argb_overlay_width;
+  uint32_t            argb_overlay_height;
+  int                 has_argb_overlay;
+  int                 argb_osd_x;
+  int                 argb_osd_y;
+  int                 argb_osd_w;
+  int                 argb_osd_h;
+
+  VdpVideoSurface      soft_surface;
+  uint32_t             soft_surface_width;
+  uint32_t             soft_surface_height;
+  int                  soft_surface_format;
+
+  VdpOutputSurface     output_surface[2];
+  uint8_t              current_output_surface;
+  uint32_t             output_surface_width[2];
+  uint32_t             output_surface_height[2];
+  uint8_t              init_queue;
+
+  VdpVideoMixer        video_mixer;
+  VdpChromaType        video_mixer_chroma;
+  uint32_t             video_mixer_width;
+  uint32_t             video_mixer_height;
+
+  VdpColor             back_color;
+
+  vdpau_frame_t        *back_frame[ NUM_FRAMES_BACK ];
+
+  uint32_t          capabilities;
+  xine_t            *xine;
+
+  int               hue;
+  int               saturation;
+  int               brightness;
+  int               contrast;
+  int               sharpness;
+  int               noise;
+  int               deinterlace;
+  int               deinterlace_method;
+  int               enable_inverse_telecine;
+  int               honor_progressive;
+
+  int               vdp_runtime_nr;
+  int               reinit_needed;
+
+  int               allocated_surfaces;
+  int		            zoom_x;
+  int		            zoom_y;
+} vdpau_driver_t;
+
+
+typedef struct {
+  video_driver_class_t driver_class;
+  xine_t              *xine;
+} vdpau_class_t;
+
+
+
+static void vdpau_overlay_clut_yuv2rgb(vdpau_driver_t  *this, vo_overlay_t *overlay, vdpau_frame_t *frame)
+{
+  int i;
+  clut_t* clut = (clut_t*) overlay->color;
+
+  if (!overlay->rgb_clut) {
+    for ( i=0; i<sizeof(overlay->color)/sizeof(overlay->color[0]); i++ ) {
+      *((uint32_t *)&clut[i]) = this->ovl_yuv2rgb->yuv2rgb_single_pixel_fun(this->ovl_yuv2rgb, clut[i].y, clut[i].cb, clut[i].cr);
+    }
+    overlay->rgb_clut++;
+  }
+  if (!overlay->hili_rgb_clut) {
+    clut = (clut_t*) overlay->hili_color;
+    for ( i=0; i<sizeof(overlay->color)/sizeof(overlay->color[0]); i++) {
+      *((uint32_t *)&clut[i]) = this->ovl_yuv2rgb->yuv2rgb_single_pixel_fun(this->ovl_yuv2rgb, clut[i].y, clut[i].cb, clut[i].cr);
+    }
+    overlay->hili_rgb_clut++;
+  }
+}
+
+
+
+static int vdpau_process_argb_ovl( vdpau_driver_t *this_gen, vo_frame_t *frame_gen, vo_overlay_t *overlay )
+{
+  vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
+
+  if(overlay->argb_layer == NULL)
+    return 0;
+
+  pthread_mutex_lock(&overlay->argb_layer->mutex);
+
+  if (overlay->argb_layer->buffer != NULL) {
+    int extent_width = overlay->extent_width;
+    int extent_height = overlay->extent_height;
+    if (extent_width <= 0 || extent_height <= 0) {
+      extent_width  = frame_gen->width;
+      extent_height = frame_gen->height;
+    }
+
+    if (extent_width > 0 && extent_height > 0) {
+      if ( (this->argb_overlay_width != extent_width ) || (this->argb_overlay_height != extent_height) || (this->argb_overlay == VDP_INVALID_HANDLE) ) {
+        if (this->argb_overlay != VDP_INVALID_HANDLE) {
+          vdp_output_surface_destroy( this->argb_overlay );
+        }
+        VdpStatus st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, extent_width, extent_height, &this->argb_overlay );
+        if ( st != VDP_STATUS_OK ) {
+          printf( "vdpau_process_argb_ovl: vdp_output_surface_create failed : %s\n", vdp_get_error_string(st) );
+        }
+        this->argb_overlay_width  = extent_width;
+        this->argb_overlay_height = extent_height;
+
+        /* set stored osd location to extent as any smaller osd requires to clear the surface first */
+        this->argb_osd_x = 0;
+        this->argb_osd_y = 0;
+        this->argb_osd_w = extent_width;
+        this->argb_osd_h = extent_height;
+      }
+
+      /* wipe surface if osd layout changed */
+      if (overlay->x != this->argb_osd_x || overlay->y != this->argb_osd_y || overlay->width != this->argb_osd_w || overlay->height != this->argb_osd_h) {
+        this->argb_osd_x = overlay->x;
+        this->argb_osd_y = overlay->y;
+        this->argb_osd_w = overlay->width;
+        this->argb_osd_h = overlay->height;
+
+        uint32_t *zeros = calloc(4 * extent_width, extent_height);
+        if (zeros) {
+          uint32_t pitch = extent_width * 4;
+          VdpRect dest = { 0, 0, extent_width, extent_height };
+          VdpStatus st = vdp_output_surface_put_bits( this->argb_overlay, (void*)&(zeros), &pitch, &dest );
+          if ( st != VDP_STATUS_OK )
+            printf( "vdpau_process_argb_ovl: vdp_output_surface_put_bits_native failed : %s\n", vdp_get_error_string(st) );
+          free(zeros);
+        }
+      }
+
+      /* set destination area according to dirty area of argb layer and reset dirty area */
+      uint32_t pitch = overlay->width * 4;
+      uint32_t *buffer_start = overlay->argb_layer->buffer + overlay->argb_layer->y1 * overlay->width + overlay->argb_layer->x1;
+      VdpRect dest = { overlay->x + overlay->argb_layer->x1, overlay->y + overlay->argb_layer->y1, overlay->x + overlay->argb_layer->x2, overlay->y + overlay->argb_layer->y2 };
+      overlay->argb_layer->x1 = overlay->width;
+      overlay->argb_layer->y1 = overlay->height;
+      overlay->argb_layer->x2 = 0;
+      overlay->argb_layer->y2 = 0;
+
+      VdpStatus st = vdp_output_surface_put_bits( this->argb_overlay, (void*)&(buffer_start), &pitch, &dest );
+      if ( st != VDP_STATUS_OK ) {
+        printf( "vdpau_process_argb_ovl: vdp_output_surface_put_bits_native failed : %s\n", vdp_get_error_string(st) );
+      } else
+        this->has_argb_overlay = 1;
+    }
+  }
+
+  pthread_mutex_unlock(&overlay->argb_layer->mutex);
+
+  return 1;
+}
+
+
+
+static int vdpau_process_ovl( vdpau_driver_t *this_gen, vo_overlay_t *overlay )
+{
+  vdpau_overlay_t *ovl = &this_gen->overlays[this_gen->ovl_changed-1];
+
+  if ( overlay->width<=0 || overlay->height<=0 )
+    return 0;
+
+  if ( (ovl->bitmap_width < overlay->width ) || (ovl->bitmap_height < overlay->height) || (ovl->ovl_bitmap == VDP_INVALID_HANDLE) ) {
+    if (ovl->ovl_bitmap != VDP_INVALID_HANDLE) {
+      vdp_bitmap_destroy( ovl->ovl_bitmap );
+    }
+    VdpStatus st = vdp_bitmap_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, overlay->width, overlay->height, 0, &ovl->ovl_bitmap );
+    if ( st != VDP_STATUS_OK ) {
+      printf( "vdpau_process_ovl: vdp_bitmap_create failed : %s\n", vdp_get_error_string(st) );
+    }
+    ovl->bitmap_width = overlay->width;
+    ovl->bitmap_height = overlay->height;
+  }
+  ovl->ovl_w = overlay->width;
+  ovl->ovl_h = overlay->height;
+  ovl->ovl_x = overlay->x;
+  ovl->ovl_y = overlay->y;
+  ovl->unscaled = overlay->unscaled;
+  uint32_t *buf = (uint32_t*)malloc(ovl->ovl_w*ovl->ovl_h*4);
+  if ( !buf )
+    return 0;
+
+  int num_rle = overlay->num_rle;
+  rle_elem_t *rle = overlay->rle;
+  uint32_t *rgba = buf;
+  uint32_t red, green, blue, alpha;
+  clut_t *low_colors = (clut_t*)overlay->color;
+  clut_t *hili_colors = (clut_t*)overlay->hili_color;
+  uint8_t *low_trans = overlay->trans;
+  uint8_t *hili_trans = overlay->hili_trans;
+  clut_t *colors;
+  uint8_t *trans;
+  int rlelen = 0;
+  uint8_t clr = 0;
+  int i, pos=0, x, y;
+
+  while ( num_rle>0 ) {
+    x = pos%ovl->ovl_w;
+    y = pos/ovl->ovl_w;
+    if ( (x>=overlay->hili_left && x<=overlay->hili_right) && (y>=overlay->hili_top && y<=overlay->hili_bottom) ) {
+      colors = hili_colors;
+      trans = hili_trans;
+    }
+    else {
+      colors = low_colors;
+      trans = low_trans;
+    }
+    rlelen = rle->len;
+    clr = rle->color;
+    for ( i=0; i<rlelen; ++i ) {
+      red = colors[clr].y; /* red */
+      green = colors[clr].cr; /* green */
+      blue = colors[clr].cb; /* blue */
+      alpha = trans[clr]*255/15;
+      *rgba = (alpha<<24) | (red<<16) | (green<<8) | blue;
+      rgba++;
+      ++pos;
+    }
+    ++rle;
+    --num_rle;
+  }
+  uint32_t pitch = ovl->ovl_w*4;
+  VdpRect dest = { 0, 0, ovl->ovl_w, ovl->ovl_h };
+  VdpStatus st = vdp_bitmap_put_bits( ovl->ovl_bitmap, &buf, &pitch, &dest);
+  if ( st != VDP_STATUS_OK ) {
+    printf( "vdpau_process_ovl: vdp_bitmap_put_bits failed : %s\n", vdp_get_error_string(st) );
+  }
+  free(buf);
+  return 1;
+}
+
+
+
+static void vdpau_overlay_begin (vo_driver_t *this_gen, vo_frame_t *frame_gen, int changed)
+{
+  vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
+
+  if ( !changed )
+    return;
+
+  this->has_overlay = this->has_unscaled = 0;
+  this->has_argb_overlay = 0;
+  ++this->ovl_changed;
+}
+
+
+
+static void vdpau_overlay_blend (vo_driver_t *this_gen, vo_frame_t *frame_gen, vo_overlay_t *overlay)
+{
+  vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
+  vdpau_frame_t *frame = (vdpau_frame_t *) frame_gen;
+
+  if ( !this->ovl_changed || this->ovl_changed>XINE_VORAW_MAX_OVL )
+    return;
+
+  if (overlay->rle) {
+    if (!overlay->rgb_clut || !overlay->hili_rgb_clut)
+      vdpau_overlay_clut_yuv2rgb (this, overlay, frame);
+    if ( vdpau_process_ovl( this, overlay ) )
+      ++this->ovl_changed;
+  }
+
+  if(overlay->argb_layer)
+    vdpau_process_argb_ovl( this, frame_gen, overlay );
+}
+
+
+
+static void vdpau_overlay_end (vo_driver_t *this_gen, vo_frame_t *frame)
+{
+  vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
+  int i;
+  VdpStatus st;
+
+  if ( !this->ovl_changed )
+    return;
+
+  if ( !(this->ovl_changed-1) ) {
+    this->ovl_changed = 0;
+    this->has_overlay = 0;
+    this->has_unscaled = 0;
+    return;
+  }
+
+  int w=0, h=0;
+  for ( i=0; i<this->ovl_changed-1; ++i ) {
+    if ( this->overlays[i].unscaled )
+      continue;
+    if ( w < (this->overlays[i].ovl_x+this->overlays[i].ovl_w) )
+      w = this->overlays[i].ovl_x+this->overlays[i].ovl_w;
+    if ( h < (this->overlays[i].ovl_y+this->overlays[i].ovl_h) )
+      h = this->overlays[i].ovl_y+this->overlays[i].ovl_h;
+  }
+
+  int out_w = (w>frame->width) ? w : frame->width;
+  int out_h = (h>frame->height) ? h : frame->height;
+
+  if ( (this->overlay_output_width!=out_w || this->overlay_output_height!=out_h) && this->overlay_output != VDP_INVALID_HANDLE ) {
+    st = vdp_output_surface_destroy( this->overlay_output );
+    if ( st != VDP_STATUS_OK ) {
+      printf( "vdpau_overlay_end: vdp_output_surface_destroy failed : %s\n", vdp_get_error_string(st) );
+    }
+    this->overlay_output = VDP_INVALID_HANDLE;
+  }
+
+  this->overlay_output_width = out_w;
+  this->overlay_output_height = out_h;
+
+  w = 64; h = 64;
+  for ( i=0; i<this->ovl_changed-1; ++i ) {
+    if ( !this->overlays[i].unscaled )
+      continue;
+    if ( w < (this->overlays[i].ovl_x+this->overlays[i].ovl_w) )
+      w = this->overlays[i].ovl_x+this->overlays[i].ovl_w;
+    if ( h < (this->overlays[i].ovl_y+this->overlays[i].ovl_h) )
+      h = this->overlays[i].ovl_y+this->overlays[i].ovl_h;
+  }
+
+  if ( (this->overlay_unscaled_width!=w || this->overlay_unscaled_height!=h) && this->overlay_unscaled != VDP_INVALID_HANDLE ) {
+    st = vdp_output_surface_destroy( this->overlay_unscaled );
+    if ( st != VDP_STATUS_OK ) {
+      printf( "vdpau_overlay_end: vdp_output_surface_destroy failed : %s\n", vdp_get_error_string(st) );
+    }
+    this->overlay_unscaled = VDP_INVALID_HANDLE;
+  }
+
+  this->overlay_unscaled_width = w;
+  this->overlay_unscaled_height = h;
+
+  if ( this->overlay_unscaled == VDP_INVALID_HANDLE ) {
+    st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->overlay_unscaled_width, this->overlay_unscaled_height, &this->overlay_unscaled );
+    if ( st != VDP_STATUS_OK )
+      printf( "vdpau_overlay_end: vdp_output_surface_create failed : %s\n", vdp_get_error_string(st) );
+  }
+
+  if ( this->overlay_output == VDP_INVALID_HANDLE ) {
+    st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->overlay_output_width, this->overlay_output_height, &this->overlay_output );
+    if ( st != VDP_STATUS_OK )
+      printf( "vdpau_overlay_end: vdp_output_surface_create failed : %s\n", vdp_get_error_string(st) );
+  }
+
+  w = (this->overlay_unscaled_width>this->overlay_output_width) ? this->overlay_unscaled_width : this->overlay_output_width;
+  h = (this->overlay_unscaled_height>this->overlay_output_height) ? this->overlay_unscaled_height : this->overlay_output_height;
+
+  uint32_t *buf = (uint32_t*)malloc(w*h*4);
+  uint32_t pitch = w*4;
+  memset( buf, 0, w*h*4 );
+  VdpRect clear = { 0, 0, this->overlay_output_width, this->overlay_output_height };
+  st = vdp_output_surface_put_bits( this->overlay_output, &buf, &pitch, &clear );
+  if ( st != VDP_STATUS_OK ) {
+    printf( "vdpau_overlay_end: vdp_output_surface_put_bits (clear) failed : %s\n", vdp_get_error_string(st) );
+  }
+  clear.x1 = this->overlay_unscaled_width; clear.y1 = this->overlay_unscaled_height;
+  st = vdp_output_surface_put_bits( this->overlay_unscaled, &buf, &pitch, &clear );
+  if ( st != VDP_STATUS_OK ) {
+    printf( "vdpau_overlay_end: vdp_output_surface_put_bits (clear) failed : %s\n", vdp_get_error_string(st) );
+  }
+  free(buf);
+
+  VdpOutputSurface *surface;
+  for ( i=0; i<this->ovl_changed-1; ++i ) {
+    VdpRect dest = { this->overlays[i].ovl_x, this->overlays[i].ovl_y, this->overlays[i].ovl_x+this->overlays[i].ovl_w, this->overlays[i].ovl_y+this->overlays[i].ovl_h };
+    VdpRect src = { 0, 0, this->overlays[i].ovl_w, this->overlays[i].ovl_h };
+    surface = (this->overlays[i].unscaled) ? &this->overlay_unscaled : &this->overlay_output;
+    st = vdp_output_surface_render_bitmap_surface( *surface, &dest, this->overlays[i].ovl_bitmap, &src, 0, &blend, 0 );
+    if ( st != VDP_STATUS_OK ) {
+      printf( "vdpau_overlay_end: vdp_output_surface_render_bitmap_surface failed : %s\n", vdp_get_error_string(st) );
+    }
+  }
+  this->has_overlay = 1;
+  this->ovl_changed = 0;
+}
+
+
+
+static void vdpau_frame_proc_slice (vo_frame_t *vo_img, uint8_t **src)
+{
+  vdpau_frame_t  *frame = (vdpau_frame_t *) vo_img ;
+
+  vo_img->proc_called = 1;
+}
+
+
+
+static void vdpau_frame_field (vo_frame_t *vo_img, int which_field)
+{
+}
+
+
+
+static void vdpau_frame_dispose (vo_frame_t *vo_img)
+{
+  vdpau_frame_t  *frame = (vdpau_frame_t *) vo_img ;
+
+  if ( frame->chunk[0] )
+    free (frame->chunk[0]);
+  if ( frame->chunk[1] )
+    free (frame->chunk[1]);
+  if ( frame->chunk[2] )
+    free (frame->chunk[2]);
+  if ( frame->vdpau_accel_data.surface != VDP_INVALID_HANDLE )
+    vdp_video_surface_destroy( frame->vdpau_accel_data.surface );
+  free (frame);
+}
+
+
+
+static vo_frame_t *vdpau_alloc_frame (vo_driver_t *this_gen)
+{
+  vdpau_frame_t  *frame;
+  vdpau_driver_t *this = (vdpau_driver_t *) this_gen;
+
+  printf( "vo_vdpau: vdpau_alloc_frame\n" );
+
+  frame = (vdpau_frame_t *) calloc(1, sizeof(vdpau_frame_t));
+
+  if (!frame)
+    return NULL;
+
+  frame->chunk[0] = frame->chunk[1] = frame->chunk[2] = NULL;
+  frame->width = frame->height = frame->format = frame->flags = 0;
+
+  frame->vo_frame.accel_data = &frame->vdpau_accel_data;
+
+  pthread_mutex_init (&frame->vo_frame.mutex, NULL);
+
+  /*
+   * supply required functions/fields
+   */
+  frame->vo_frame.proc_duplicate_frame_data = NULL;
+  frame->vo_frame.proc_slice = vdpau_frame_proc_slice;
+  frame->vo_frame.proc_frame = NULL;
+  frame->vo_frame.field      = vdpau_frame_field;
+  frame->vo_frame.dispose    = vdpau_frame_dispose;
+  frame->vo_frame.driver     = this_gen;
+
+  frame->vdpau_accel_data.vdp_device = vdp_device;
+  frame->vdpau_accel_data.surface = VDP_INVALID_HANDLE;
+  frame->vdpau_accel_data.chroma = VDP_CHROMA_TYPE_420;
+  frame->vdpau_accel_data.vdp_decoder_create = vdp_decoder_create;
+  frame->vdpau_accel_data.vdp_decoder_destroy = vdp_decoder_destroy;
+  frame->vdpau_accel_data.vdp_decoder_render = vdp_decoder_render;
+  frame->vdpau_accel_data.vdp_get_error_string = vdp_get_error_string;
+  frame->vdpau_accel_data.vdp_runtime_nr = this->vdp_runtime_nr;
+  frame->vdpau_accel_data.current_vdp_runtime_nr = &this->vdp_runtime_nr;
+
+  return (vo_frame_t *) frame;
+}
+
+
+
+static void vdpau_provide_standard_frame_data (vo_frame_t *this_gen, xine_current_frame_data_t *data)
+{
+  vdpau_frame_t *this = (vdpau_frame_t *)this_gen;
+  VdpStatus st;
+  VdpYCbCrFormat format;
+
+  if (this->vo_frame.format != XINE_IMGFMT_VDPAU) {
+    fprintf(stderr, "vdpau_provide_standard_frame_data: unexpected frame format 0x%08x!\n", this->vo_frame.format);
+    return;
+  }
+
+  if (!(this->flags & VO_CHROMA_422)) {
+    data->format = XINE_IMGFMT_YV12;
+    data->img_size = this->vo_frame.width * this->vo_frame.height
+                   + ((this->vo_frame.width + 1) / 2) * ((this->vo_frame.height + 1) / 2)
+                   + ((this->vo_frame.width + 1) / 2) * ((this->vo_frame.height + 1) / 2);
+    if (data->img) {
+      this->vo_frame.pitches[0] = 8*((this->vo_frame.width + 7) / 8);
+      this->vo_frame.pitches[1] = 8*((this->vo_frame.width + 15) / 16);
+      this->vo_frame.pitches[2] = 8*((this->vo_frame.width + 15) / 16);
+      this->vo_frame.base[0] = xine_xmalloc_aligned(16, this->vo_frame.pitches[0] * this->vo_frame.height, (void **)&this->chunk[0]);
+      this->vo_frame.base[1] = xine_xmalloc_aligned(16, this->vo_frame.pitches[1] * ((this->vo_frame.height+1)/2), (void **)&this->chunk[1]);
+      this->vo_frame.base[2] = xine_xmalloc_aligned(16, this->vo_frame.pitches[2] * ((this->vo_frame.height+1)/2), (void **)&this->chunk[2]);
+      format = VDP_YCBCR_FORMAT_YV12;
+    }
+  } else {
+    data->format = XINE_IMGFMT_YUY2;
+    data->img_size = this->vo_frame.width * this->vo_frame.height
+                   + ((this->vo_frame.width + 1) / 2) * this->vo_frame.height
+                   + ((this->vo_frame.width + 1) / 2) * this->vo_frame.height;
+    if (data->img) {
+      this->vo_frame.pitches[0] = 8*((this->vo_frame.width + 3) / 4);
+      this->vo_frame.base[0] = xine_xmalloc_aligned(16, this->vo_frame.pitches[0] * this->vo_frame.height, (void **)&this->chunk[0]);
+      format = VDP_YCBCR_FORMAT_YUYV;
+    }
+  }
+
+  if (data->img) {
+    st = vdp_video_surface_getbits_ycbcr(this->vdpau_accel_data.surface, format, this->vo_frame.base, this->vo_frame.pitches);
+    if (st != VDP_STATUS_OK)
+      printf("vo_vdpau: failed to get surface bits !! %s\n", vdp_get_error_string(st));
+
+    if (format == VDP_YCBCR_FORMAT_YV12) {
+      yv12_to_yv12(
+       /* Y */
+        this->vo_frame.base[0], this->vo_frame.pitches[0],
+        data->img, this->vo_frame.width,
+       /* U */
+        this->vo_frame.base[2], this->vo_frame.pitches[2],
+        data->img+this->vo_frame.width*this->vo_frame.height, this->vo_frame.width/2,
+       /* V */
+        this->vo_frame.base[1], this->vo_frame.pitches[1],
+        data->img+this->vo_frame.width*this->vo_frame.height+this->vo_frame.width*this->vo_frame.height/4, this->vo_frame.width/2,
+       /* width x height */
+        this->vo_frame.width, this->vo_frame.height);
+    } else {
+      yuy2_to_yuy2(
+       /* src */
+        this->vo_frame.base[0], this->vo_frame.pitches[0],
+       /* dst */
+        data->img, this->vo_frame.width*2,
+       /* width x height */
+        this->vo_frame.width, this->vo_frame.height);
+    }
+
+    if (this->chunk[0])
+      free(this->chunk[0]);
+    if (this->chunk[1])
+      free(this->chunk[1]);
+    if (this->chunk[2])
+      free(this->chunk[2]);
+    this->chunk[0] = this->chunk[1] = this->chunk[2] = NULL;
+  }
+}
+
+static void vdpau_duplicate_frame_data (vo_frame_t *this_gen, vo_frame_t *original)
+{
+  vdpau_frame_t *this = (vdpau_frame_t *)this_gen;
+  vdpau_frame_t *orig = (vdpau_frame_t *)original;
+  VdpStatus st;
+  VdpYCbCrFormat format;
+
+  if (orig->vo_frame.format != XINE_IMGFMT_VDPAU) {
+    fprintf(stderr, "vdpau_duplicate_frame_data: unexpected frame format 0x%08x!\n", orig->vo_frame.format);
+    return;
+  }
+
+  if (!(orig->flags & VO_CHROMA_422)) {
+    this->vo_frame.pitches[0] = 8*((orig->vo_frame.width + 7) / 8);
+    this->vo_frame.pitches[1] = 8*((orig->vo_frame.width + 15) / 16);
+    this->vo_frame.pitches[2] = 8*((orig->vo_frame.width + 15) / 16);
+    this->vo_frame.base[0] = xine_xmalloc_aligned(16, this->vo_frame.pitches[0] * orig->vo_frame.height, (void **)&this->chunk[0]);
+    this->vo_frame.base[1] = xine_xmalloc_aligned(16, this->vo_frame.pitches[1] * ((orig->vo_frame.height+1)/2), (void **)&this->chunk[1]);
+    this->vo_frame.base[2] = xine_xmalloc_aligned(16, this->vo_frame.pitches[2] * ((orig->vo_frame.height+1)/2), (void **)&this->chunk[2]);
+    format = VDP_YCBCR_FORMAT_YV12;
+  } else {
+    this->vo_frame.pitches[0] = 8*((orig->vo_frame.width + 3) / 4);
+    this->vo_frame.base[0] = xine_xmalloc_aligned(16, this->vo_frame.pitches[0] * orig->vo_frame.height, (void **)&this->chunk[0]);
+    format = VDP_YCBCR_FORMAT_YUYV;
+  }
+
+  st = vdp_video_surface_getbits_ycbcr(orig->vdpau_accel_data.surface, format, this->vo_frame.base, this->vo_frame.pitches);
+  if (st != VDP_STATUS_OK)
+    printf("vo_vdpau: failed to get surface bits !! %s\n", vdp_get_error_string(st));
+
+  st = vdp_video_surface_putbits_ycbcr(this->vdpau_accel_data.surface, format, this->vo_frame.base, this->vo_frame.pitches);
+  if (st != VDP_STATUS_OK)
+    printf("vo_vdpau: failed to put surface bits !! %s\n", vdp_get_error_string(st));
+
+  if (this->chunk[0])
+    free(this->chunk[0]);
+  if (this->chunk[1])
+    free(this->chunk[1]);
+  if (this->chunk[2])
+    free(this->chunk[2]);
+  this->chunk[0] = this->chunk[1] = this->chunk[2] = NULL;
+}
+
+
+
+static void vdpau_update_frame_format (vo_driver_t *this_gen, vo_frame_t *frame_gen,
+      uint32_t width, uint32_t height, double ratio, int format, int flags)
+{
+  vdpau_driver_t *this = (vdpau_driver_t *) this_gen;
+  vdpau_frame_t   *frame = (vdpau_frame_t *) frame_gen;
+
+  VdpChromaType chroma = (flags & VO_CHROMA_422) ? VDP_CHROMA_TYPE_422 : VDP_CHROMA_TYPE_420;
+
+  /* Check frame size and format and reallocate if necessary */
+  if ( (frame->width != width) || (frame->height != height) || (frame->format != format) || (frame->format==XINE_IMGFMT_VDPAU && frame->vdpau_accel_data.chroma!=chroma) ||
+        (frame->vdpau_accel_data.vdp_runtime_nr != this->vdp_runtime_nr)) {
+    //printf("vo_vdpau: updating frame to %d x %d (ratio=%g, format=%08X)\n", width, height, ratio, format);
+
+    /* (re-) allocate render space */
+    if ( frame->chunk[0] )
+      free (frame->chunk[0]);
+    if ( frame->chunk[1] )
+      free (frame->chunk[1]);
+    if ( frame->chunk[2] )
+      free (frame->chunk[2]);
+    frame->chunk[0] = frame->chunk[1] = frame->chunk[2] = NULL;
+
+    if (format == XINE_IMGFMT_YV12) {
+      frame->vo_frame.pitches[0] = 8*((width + 7) / 8);
+      frame->vo_frame.pitches[1] = 8*((width + 15) / 16);
+      frame->vo_frame.pitches[2] = 8*((width + 15) / 16);
+      frame->vo_frame.base[0] = xine_xmalloc_aligned (16, frame->vo_frame.pitches[0] * height,  (void **) &frame->chunk[0]);
+      frame->vo_frame.base[1] = xine_xmalloc_aligned (16, frame->vo_frame.pitches[1] * ((height+1)/2), (void **) &frame->chunk[1]);
+      frame->vo_frame.base[2] = xine_xmalloc_aligned (16, frame->vo_frame.pitches[2] * ((height+1)/2), (void **) &frame->chunk[2]);
+    } else if (format == XINE_IMGFMT_YUY2){
+      frame->vo_frame.pitches[0] = 8*((width + 3) / 4);
+      frame->vo_frame.base[0] = xine_xmalloc_aligned (16, frame->vo_frame.pitches[0] * height, (void **) &frame->chunk[0]);
+      frame->chunk[1] = NULL;
+      frame->chunk[2] = NULL;
+    }
+
+    if ( frame->vdpau_accel_data.vdp_runtime_nr != this->vdp_runtime_nr ) {
+      frame->vdpau_accel_data.surface = VDP_INVALID_HANDLE;
+      frame->vdpau_accel_data.vdp_runtime_nr = this->vdp_runtime_nr;
+      frame->vdpau_accel_data.vdp_device = vdp_device;
+      frame->vo_frame.proc_duplicate_frame_data = NULL;
+      frame->vo_frame.proc_provide_standard_frame_data = NULL;
+    }
+
+    if ( frame->vdpau_accel_data.surface != VDP_INVALID_HANDLE  ) {
+      if ( (frame->width != width) || (frame->height != height) || (format != XINE_IMGFMT_VDPAU) || frame->vdpau_accel_data.chroma != chroma ) {
+        printf("vo_vdpau: update_frame - destroy surface\n");
+        vdp_video_surface_destroy( frame->vdpau_accel_data.surface );
+        frame->vdpau_accel_data.surface = VDP_INVALID_HANDLE;
+        --this->allocated_surfaces;
+        frame->vo_frame.proc_duplicate_frame_data = NULL;
+        frame->vo_frame.proc_provide_standard_frame_data = NULL;
+      }
+    }
+
+    if ( (format == XINE_IMGFMT_VDPAU) && (frame->vdpau_accel_data.surface == VDP_INVALID_HANDLE) ) {
+      VdpStatus st = vdp_video_surface_create( vdp_device, chroma, width, height, &frame->vdpau_accel_data.surface );
+      if ( st!=VDP_STATUS_OK )
+        printf( "vo_vdpau: failed to create surface !! %s\n", vdp_get_error_string( st ) );
+      else {
+        frame->vdpau_accel_data.chroma = chroma;
+        ++this->allocated_surfaces;
+        frame->vo_frame.proc_duplicate_frame_data = vdpau_duplicate_frame_data;
+        frame->vo_frame.proc_provide_standard_frame_data = vdpau_provide_standard_frame_data;
+      }
+    }
+
+    frame->width = width;
+    frame->height = height;
+    frame->format = format;
+    frame->flags = flags;
+
+    vdpau_frame_field ((vo_frame_t *)frame, flags);
+  }
+
+  //printf("vo_vdpau: allocated_surfaces=%d\n", this->allocated_surfaces );
+
+  frame->ratio = ratio;
+  frame->vo_frame.future_frame = NULL;
+}
+
+
+
+static int vdpau_redraw_needed (vo_driver_t *this_gen)
+{
+  vdpau_driver_t  *this = (vdpau_driver_t *) this_gen;
+
+  _x_vo_scale_compute_ideal_size( &this->sc );
+  if ( _x_vo_scale_redraw_needed( &this->sc ) ) {
+    _x_vo_scale_compute_output_size( &this->sc );
+    return 1;
+  }
+  return 0;
+}
+
+
+
+static void vdpau_release_back_frames( vo_driver_t *this_gen )
+{
+  vdpau_driver_t  *this  = (vdpau_driver_t *) this_gen;
+  int i;
+
+  for ( i=0; i<NUM_FRAMES_BACK; ++i ) {
+    if ( this->back_frame[ i ])
+      this->back_frame[ i ]->vo_frame.free( &this->back_frame[ i ]->vo_frame );
+    this->back_frame[ i ] = NULL;
+  }
+}
+
+
+
+static void vdpau_backup_frame( vo_driver_t *this_gen, vo_frame_t *frame_gen )
+{
+  vdpau_driver_t  *this  = (vdpau_driver_t *) this_gen;
+  vdpau_frame_t   *frame = (vdpau_frame_t *) frame_gen;
+
+  int i;
+  if ( this->back_frame[NUM_FRAMES_BACK-1]) {
+    this->back_frame[NUM_FRAMES_BACK-1]->vo_frame.free (&this->back_frame[NUM_FRAMES_BACK-1]->vo_frame);
+  }
+  for ( i=NUM_FRAMES_BACK-1; i>0; i-- )
+    this->back_frame[i] = this->back_frame[i-1];
+  this->back_frame[0] = frame;
+}
+
+
+
+static void vdpau_set_deinterlace( vo_driver_t *this_gen )
+{
+  vdpau_driver_t  *this  = (vdpau_driver_t *) this_gen;
+
+  VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL, VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL };
+  VdpBool feature_enables[2];
+  if ( this->deinterlace ) {
+    if ( this->video_mixer_width<800 )
+      feature_enables[0] = feature_enables[1] = 1;
+    else {
+      switch ( this->deinterlace_method ) {
+        case 0: feature_enables[0] = feature_enables[1] = 0; break; /* bob */
+        case 1: feature_enables[0] = 1; feature_enables[1] = 0; break; /* temporal */
+        case 2: feature_enables[0] = feature_enables[1] = 1; break; /* temporal_spatial */
+      }
+    }
+  }
+  else
+    feature_enables[0] = feature_enables[1] = 0;
+
+  vdp_video_mixer_set_feature_enables( this->video_mixer, 2, features, feature_enables );
+  vdp_video_mixer_get_feature_enables( this->video_mixer, 2, features, feature_enables );
+  printf("vo_vdpau: enabled features: temporal=%d, temporal_spatial=%d\n", feature_enables[0], feature_enables[1] );
+}
+
+
+
+static void vdpau_set_inverse_telecine( vo_driver_t *this_gen )
+{
+  vdpau_driver_t  *this  = (vdpau_driver_t *) this_gen;
+
+  VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_INVERSE_TELECINE };
+  VdpBool feature_enables[1];
+  if ( this->deinterlace && this->enable_inverse_telecine )
+    feature_enables[0] = 1;
+  else
+    feature_enables[0] = 0;
+
+  vdp_video_mixer_set_feature_enables( this->video_mixer, 1, features, feature_enables );
+  vdp_video_mixer_get_feature_enables( this->video_mixer, 1, features, feature_enables );
+  printf("vo_vdpau: enabled features: inverse_telecine=%d\n", feature_enables[0] );
+}
+
+
+
+static void vdpau_update_deinterlace_method( void *this_gen, xine_cfg_entry_t *entry )
+{
+  vdpau_driver_t  *this  = (vdpau_driver_t *) this_gen;
+
+  this->deinterlace_method = entry->num_value;
+  printf( "vo_vdpau: deinterlace_method=%d\n", this->deinterlace_method );
+  vdpau_set_deinterlace( (vo_driver_t*)this_gen );
+}
+
+
+
+static void vdpau_update_enable_inverse_telecine( void *this_gen, xine_cfg_entry_t *entry )
+{
+  vdpau_driver_t  *this  = (vdpau_driver_t *) this_gen;
+
+  this->enable_inverse_telecine = entry->num_value;
+  printf( "vo_vdpau: enable inverse_telecine=%d\n", this->enable_inverse_telecine );
+  vdpau_set_inverse_telecine( (vo_driver_t*)this_gen );
+}
+
+
+
+static void vdpau_honor_progressive_flag( void *this_gen, xine_cfg_entry_t *entry )
+{
+  vdpau_driver_t  *this  = (vdpau_driver_t *) this_gen;
+
+  this->honor_progressive = entry->num_value;
+}
+
+
+
+static void vdpau_update_noise( vdpau_driver_t *this_gen )
+{
+  float value = this_gen->noise/100.0;
+  if ( value==0 ) {
+    VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION };
+    VdpBool feature_enables[] = { 0 };
+    vdp_video_mixer_set_feature_enables( this_gen->video_mixer, 1, features, feature_enables );
+    printf( "vo_vdpau: disable noise reduction.\n" );
+    return;
+  }
+  else {
+    VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION };
+    VdpBool feature_enables[] = { 1 };
+    vdp_video_mixer_set_feature_enables( this_gen->video_mixer, 1, features, feature_enables );
+    printf( "vo_vdpau: enable noise reduction.\n" );
+  }
+
+  VdpVideoMixerAttribute attributes [] = { VDP_VIDEO_MIXER_ATTRIBUTE_NOISE_REDUCTION_LEVEL };
+  void* attribute_values[] = { &value };
+  VdpStatus st = vdp_video_mixer_set_attribute_values( this_gen->video_mixer, 1, attributes, attribute_values );
+  if ( st != VDP_STATUS_OK )
+    printf( "vo_vdpau: error, can't set noise reduction level !!\n" );
+}
+
+
+
+static void vdpau_update_sharpness( vdpau_driver_t *this_gen )
+{
+  float value = this_gen->sharpness/100.0;
+  if ( value==0 ) {
+    VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_SHARPNESS  };
+    VdpBool feature_enables[] = { 0 };
+    vdp_video_mixer_set_feature_enables( this_gen->video_mixer, 1, features, feature_enables );
+    printf( "vo_vdpau: disable sharpness.\n" );
+    return;
+  }
+  else {
+    VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_SHARPNESS  };
+    VdpBool feature_enables[] = { 1 };
+    vdp_video_mixer_set_feature_enables( this_gen->video_mixer, 1, features, feature_enables );
+    printf( "vo_vdpau: enable sharpness.\n" );
+  }
+
+  VdpVideoMixerAttribute attributes [] = { VDP_VIDEO_MIXER_ATTRIBUTE_SHARPNESS_LEVEL };
+  void* attribute_values[] = { &value };
+  VdpStatus st = vdp_video_mixer_set_attribute_values( this_gen->video_mixer, 1, attributes, attribute_values );
+  if ( st != VDP_STATUS_OK )
+    printf( "vo_vdpau: error, can't set sharpness level !!\n" );
+}
+
+
+
+static void vdpau_update_csc( vdpau_driver_t *this_gen )
+{
+  float hue = this_gen->hue/100.0;
+  float saturation = this_gen->saturation/100.0;
+  float contrast = this_gen->contrast/100.0;
+  float brightness = this_gen->brightness/100.0;
+
+  printf( "vo_vdpau: vdpau_update_csc: hue=%f, saturation=%f, contrast=%f, brightness=%f\n", hue, saturation, contrast, brightness );
+
+  VdpCSCMatrix matrix;
+  VdpProcamp procamp = { VDP_PROCAMP_VERSION, brightness, contrast, saturation, hue };
+
+  VdpStatus st = vdp_generate_csc_matrix( &procamp, VDP_COLOR_STANDARD_ITUR_BT_601, &matrix );
+  if ( st != VDP_STATUS_OK ) {
+    printf( "vo_vdpau: error, can't generate csc matrix !!\n" );
+    return;
+  }
+  VdpVideoMixerAttribute attributes [] = { VDP_VIDEO_MIXER_ATTRIBUTE_CSC_MATRIX };
+  void* attribute_values[] = { &matrix };
+  st = vdp_video_mixer_set_attribute_values( this_gen->video_mixer, 1, attributes, attribute_values );
+  if ( st != VDP_STATUS_OK )
+    printf( "vo_vdpau: error, can't set csc matrix !!\n" );
+}
+
+
+
+static void vdpau_display_frame (vo_driver_t *this_gen, vo_frame_t *frame_gen)
+{
+  vdpau_driver_t  *this  = (vdpau_driver_t *) this_gen;
+  vdpau_frame_t   *frame = (vdpau_frame_t *) frame_gen;
+  VdpStatus st;
+  VdpVideoSurface surface;
+  VdpChromaType chroma = this->video_mixer_chroma;
+  uint32_t mix_w = this->video_mixer_width;
+  uint32_t mix_h = this->video_mixer_height;
+  VdpTime stream_speed;
+
+  if(this->reinit_needed)
+    vdpau_reinit(this_gen);
+
+  if ( (frame->width != this->sc.delivered_width) || (frame->height != this->sc.delivered_height) || (frame->ratio != this->sc.delivered_ratio) ) {
+    this->sc.force_redraw = 1;    /* trigger re-calc of output size */
+  }
+
+  this->sc.delivered_height = frame->height;
+  this->sc.delivered_width  = frame->width;
+  this->sc.delivered_ratio  = frame->ratio;
+  this->sc.crop_left        = frame->vo_frame.crop_left;
+  this->sc.crop_right       = frame->vo_frame.crop_right;
+  this->sc.crop_top         = frame->vo_frame.crop_top;
+  this->sc.crop_bottom      = frame->vo_frame.crop_bottom;
+
+  vdpau_redraw_needed( this_gen );
+
+  if ( (frame->format == XINE_IMGFMT_YV12) || (frame->format == XINE_IMGFMT_YUY2) ) {
+    //printf( "vo_vdpau: got a yuv image -------------\n" );
+    chroma = ( frame->format==XINE_IMGFMT_YV12 )? VDP_CHROMA_TYPE_420 : VDP_CHROMA_TYPE_422;
+    if ( (frame->width > this->soft_surface_width) || (frame->height > this->soft_surface_height) || (frame->format != this->soft_surface_format) ) {
+      printf( "vo_vdpau: soft_surface size update\n" );
+      /* recreate surface to match frame changes */
+      this->soft_surface_width = frame->width;
+      this->soft_surface_height = frame->height;
+      this->soft_surface_format = frame->format;
+      vdp_video_surface_destroy( this->soft_surface );
+      vdp_video_surface_create( vdp_device, chroma, this->soft_surface_width, this->soft_surface_height, &this->soft_surface );
+    }
+    /* FIXME: have to swap U and V planes to get correct colors !! */
+    uint32_t pitches[] = { frame->vo_frame.pitches[0], frame->vo_frame.pitches[2], frame->vo_frame.pitches[1] };
+    void* data[] = { frame->vo_frame.base[0], frame->vo_frame.base[2], frame->vo_frame.base[1] };
+    if ( frame->format==XINE_IMGFMT_YV12 ) {
+      st = vdp_video_surface_putbits_ycbcr( this->soft_surface, VDP_YCBCR_FORMAT_YV12, &data, pitches );
+      if ( st != VDP_STATUS_OK )
+        printf( "vo_vdpau: vdp_video_surface_putbits_ycbcr YV12 error : %s\n", vdp_get_error_string( st ) );
+    }
+    else {
+      st = vdp_video_surface_putbits_ycbcr( this->soft_surface, VDP_YCBCR_FORMAT_YUYV, &data, pitches );
+      if ( st != VDP_STATUS_OK )
+        printf( "vo_vdpau: vdp_video_surface_putbits_ycbcr YUY2 error : %s\n", vdp_get_error_string( st ) );
+    }
+    surface = this->soft_surface;
+    mix_w = this->soft_surface_width;
+    mix_h = this->soft_surface_height;
+  }
+  else if (frame->format == XINE_IMGFMT_VDPAU) {
+    //printf( "vo_vdpau: got a vdpau image -------------\n" );
+    surface = frame->vdpau_accel_data.surface;
+    mix_w = frame->width;
+    mix_h = frame->height;
+    chroma = (frame->vo_frame.flags & VO_CHROMA_422) ? VDP_CHROMA_TYPE_422 : VDP_CHROMA_TYPE_420;
+  }
+  else {
+    /* unknown format */
+    printf( "vo_vdpau: got an unknown image -------------\n" );
+    frame->vo_frame.free( &frame->vo_frame );
+    return;
+  }
+
+  if ( (mix_w != this->video_mixer_width) || (mix_h != this->video_mixer_height) || (chroma != this->video_mixer_chroma) ) {
+    vdpau_release_back_frames( this_gen ); /* empty past frames array */
+    printf("vo_vdpau: recreate mixer to match frames: width=%d, height=%d, chroma=%d\n", mix_w, mix_h, chroma);
+    vdp_video_mixer_destroy( this->video_mixer );
+    VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION, VDP_VIDEO_MIXER_FEATURE_SHARPNESS,
+          VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL, VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL };
+    VdpVideoMixerParameter params[] = { VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH, VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT,
+          VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE, VDP_VIDEO_MIXER_PARAMETER_LAYERS };
+    int num_layers = 3;
+    void const *param_values[] = { &mix_w, &mix_h, &chroma, &num_layers };
+    vdp_video_mixer_create( vdp_device, 4, features, 4, params, param_values, &this->video_mixer );
+    this->video_mixer_chroma = chroma;
+    this->video_mixer_width = mix_w;
+    this->video_mixer_height = mix_h;
+    vdpau_set_deinterlace( this_gen );
+    vdpau_set_inverse_telecine( this_gen );
+    vdpau_update_noise( this );
+    vdpau_update_sharpness( this );
+    vdpau_update_csc( this );
+  }
+
+  if ( (this->sc.gui_width > this->output_surface_width[this->current_output_surface]) || (this->sc.gui_height > this->output_surface_height[this->current_output_surface]) ) {
+    /* recreate output surface to match window size */
+    printf( "vo_vdpau: output_surface size update\n" );
+    this->output_surface_width[this->current_output_surface] = this->sc.gui_width;
+    this->output_surface_height[this->current_output_surface] = this->sc.gui_height;
+
+    vdp_output_surface_destroy( this->output_surface[this->current_output_surface] );
+    vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->output_surface_width[this->current_output_surface], this->output_surface_height[this->current_output_surface], &this->output_surface[this->current_output_surface] );
+  }
+
+  VdpRect vid_source = { this->sc.displayed_xoffset, this->sc.displayed_yoffset, this->sc.displayed_width+this->sc.displayed_xoffset, this->sc.displayed_height+this->sc.displayed_yoffset };
+  VdpRect out_dest = { 0, 0, this->sc.gui_width, this->sc.gui_height };
+  VdpRect vid_dest = { this->sc.output_xoffset, this->sc.output_yoffset, this->sc.output_xoffset+this->sc.output_width, this->sc.output_yoffset+this->sc.output_height };
+
+  //printf( "vid_src = %d %d %d %d - out_dest = %d %d %d %d - vid_dest = %d %d %d %d\n",
+          //vid_source.x0, vid_source.y0, vid_source.x1, vid_source.y1, out_dest.x0, out_dest.y0, out_dest.x1, out_dest.y1, vid_dest.x0, vid_dest.y0, vid_dest.x1, vid_dest.y1 );
+
+  /* prepare field delay calculation to not run into a deadlock while display locked */
+  stream_speed = frame->vo_frame.stream ? xine_get_param(frame->vo_frame.stream, XINE_PARAM_FINE_SPEED) : 0;
+  if (stream_speed != 0) {
+    int vo_bufs_in_fifo = 0;
+    _x_query_buffer_usage(frame->vo_frame.stream, NULL, NULL, &vo_bufs_in_fifo, NULL);
+    //fprintf(stderr, "vo_bufs: %d\n", vo_bufs_in_fifo);
+    if (vo_bufs_in_fifo <= 0)
+      stream_speed = 0; /* still image -> no delay */
+  }
+
+  VdpTime last_time;
+
+  if ( this->init_queue>1 )
+    vdp_queue_block( vdp_queue, this->output_surface[this->current_output_surface], &last_time );
+
+  XLockDisplay( this->display );
+
+  uint32_t layer_count;
+  VdpLayer layer[3];
+  VdpRect layersrc, unscaledsrc;
+  if ( this->has_overlay ) {
+    //printf("vdpau_display_frame: overlay should be visible !\n");
+    layer_count = 2;
+    layersrc.x0 = 0; layersrc.y0 = 0; layersrc.x1 = this->overlay_output_width; layersrc.y1 = this->overlay_output_height;
+    layer[0].struct_version = VDP_LAYER_VERSION; layer[0].source_surface = this->overlay_output; layer[0].source_rect = &layersrc; layer[0].destination_rect = &vid_dest;
+    unscaledsrc.x0 = 0; unscaledsrc.y0 = 0; unscaledsrc.x1 = this->overlay_unscaled_width; unscaledsrc.y1 = this->overlay_unscaled_height;
+    layer[1].struct_version = VDP_LAYER_VERSION; layer[1].source_surface = this->overlay_unscaled; layer[1].source_rect = &unscaledsrc; layer[1].destination_rect = &unscaledsrc;
+    //printf( "layersrc = %d %d %d %d \n", layersrc.x0, layersrc.y0, layersrc.x1, layersrc.y1 );
+  }
+  else {
+    layer_count = 0;
+  }
+
+  VdpRect argb_rect = {0, 0, this->argb_overlay_width, this->argb_overlay_height };
+  if( this->has_argb_overlay ) {
+    layer_count++;
+    layer[layer_count-1].destination_rect = &vid_dest;
+    layer[layer_count-1].source_rect = &argb_rect;
+    layer[layer_count-1].source_surface = this->argb_overlay;
+    layer[layer_count-1].struct_version = VDP_LAYER_VERSION;
+  }
+
+  int non_progressive = (this->honor_progressive && !frame->vo_frame.progressive_frame) || !this->honor_progressive;
+  if ( frame->vo_frame.duration>2500 && this->deinterlace && non_progressive && frame->format==XINE_IMGFMT_VDPAU ) {
+    VdpTime current_time = 0;
+    VdpVideoSurface past[2];
+    VdpVideoSurface future[1];
+    VdpVideoMixerPictureStructure picture_structure;
+
+    past[1] = past[0] = (this->back_frame[0] && (this->back_frame[0]->format==XINE_IMGFMT_VDPAU)) ? this->back_frame[0]->vdpau_accel_data.surface : VDP_INVALID_HANDLE;
+    future[0] = surface;
+    picture_structure = ( frame->vo_frame.top_field_first ) ? VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD : VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD;
+
+    st = vdp_video_mixer_render( this->video_mixer, VDP_INVALID_HANDLE, 0, picture_structure,
+                               2, past, surface, 1, future, &vid_source, this->output_surface[this->current_output_surface], &out_dest, &vid_dest, layer_count, layer_count?layer:NULL );
+    if ( st != VDP_STATUS_OK )
+      printf( "vo_vdpau: vdp_video_mixer_render error : %s\n", vdp_get_error_string( st ) );
+    //else
+      //printf( "vo_vdpau: vdp_video_mixer_render: top_field, past1=%d, past0=%d, current=%d, future=%d\n", past[1], past[0], surface, future[0] );
+
+    vdp_queue_get_time( vdp_queue, &current_time );
+    vdp_queue_display( vdp_queue, this->output_surface[this->current_output_surface], 0, 0, current_time );
+    if ( this->init_queue<2 ) ++this->init_queue;
+    this->current_output_surface ^= 1;
+    if ( this->init_queue>1 ) {
+      XUnlockDisplay(this->display);
+      vdp_queue_block( vdp_queue, this->output_surface[this->current_output_surface], &last_time );
+      XLockDisplay(this->display);
+    }
+
+    if ( (this->sc.gui_width > this->output_surface_width[this->current_output_surface]) || (this->sc.gui_height > this->output_surface_height[this->current_output_surface]) ) {
+      /* recreate output surface to match window size */
+      printf( "vo_vdpau: output_surface size update\n" );
+      this->output_surface_width[this->current_output_surface] = this->sc.gui_width;
+      this->output_surface_height[this->current_output_surface] = this->sc.gui_height;
+
+      vdp_output_surface_destroy( this->output_surface[this->current_output_surface] );
+      vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->output_surface_width[this->current_output_surface], this->output_surface_height[this->current_output_surface], &this->output_surface[this->current_output_surface] );
+    }
+
+    past[0] = surface;
+    if ( frame->vo_frame.future_frame!=NULL )
+      future[0] = ((vdpau_frame_t*)(frame->vo_frame.future_frame))->vdpau_accel_data.surface;
+    else
+      future[0] = VDP_INVALID_HANDLE;
+    picture_structure = ( frame->vo_frame.top_field_first ) ? VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD : VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD;
+
+    st = vdp_video_mixer_render( this->video_mixer, VDP_INVALID_HANDLE, 0, picture_structure,
+                               2, past, surface, 1, future, &vid_source, this->output_surface[this->current_output_surface], &out_dest, &vid_dest, layer_count, layer_count?layer:NULL );
+    if ( st != VDP_STATUS_OK )
+      printf( "vo_vdpau: vdp_video_mixer_render error : %s\n", vdp_get_error_string( st ) );
+    //else
+      //printf( "vo_vdpau: vdp_video_mixer_render: bottom_field, past1=%d, past0=%d, current=%d, future=%d\n", past[1], past[0], surface, future[0] );
+
+    /* calculate delay for second field: there should be no delay for still images otherwise, take replay speed into account */
+    if (stream_speed > 0)
+      current_time += frame->vo_frame.duration * 100000ull * XINE_FINE_SPEED_NORMAL / (18 * stream_speed);
+    else
+      current_time = 0; /* immediately i. e. no delay */
+
+    vdp_queue_display( vdp_queue, this->output_surface[this->current_output_surface], 0, 0, current_time );
+    if ( this->init_queue<2 ) ++this->init_queue;
+    this->current_output_surface ^= 1;
+  }
+  else {
+    st = vdp_video_mixer_render( this->video_mixer, VDP_INVALID_HANDLE, 0, VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
+                               0, 0, surface, 0, 0, &vid_source, this->output_surface[this->current_output_surface], &out_dest, &vid_dest, layer_count, layer_count?layer:NULL );
+    if ( st != VDP_STATUS_OK )
+      printf( "vo_vdpau: vdp_video_mixer_render error : %s\n", vdp_get_error_string( st ) );
+
+    vdp_queue_display( vdp_queue, this->output_surface[this->current_output_surface], 0, 0, 0 );
+    if ( this->init_queue<2 ) ++this->init_queue;
+    this->current_output_surface ^= 1;
+  }
+
+  XUnlockDisplay( this->display );
+
+  vdpau_backup_frame( this_gen, frame_gen );
+}
+
+
+
+static int vdpau_get_property (vo_driver_t *this_gen, int property)
+{
+  vdpau_driver_t *this = (vdpau_driver_t*)this_gen;
+
+  switch (property) {
+    case VO_PROP_MAX_NUM_FRAMES:
+      return 30;
+    case VO_PROP_WINDOW_WIDTH:
+      return this->sc.gui_width;
+    case VO_PROP_WINDOW_HEIGHT:
+      return this->sc.gui_height;
+    case VO_PROP_OUTPUT_WIDTH:
+      return this->sc.output_width;
+    case VO_PROP_OUTPUT_HEIGHT:
+      return this->sc.output_height;
+    case VO_PROP_OUTPUT_XOFFSET:
+      return this->sc.output_xoffset;
+    case VO_PROP_OUTPUT_YOFFSET:
+      return this->sc.output_yoffset;
+    case VO_PROP_HUE:
+      return this->hue;
+    case VO_PROP_SATURATION:
+      return this->saturation;
+    case VO_PROP_CONTRAST:
+      return this->contrast;
+    case VO_PROP_BRIGHTNESS:
+      return this->brightness;
+    case VO_PROP_SHARPNESS:
+      return this->sharpness;
+    case VO_PROP_NOISE_REDUCTION:
+      return this->noise;
+    case VO_PROP_ZOOM_X:
+      return this->zoom_x;
+    case VO_PROP_ZOOM_Y:
+      return this->zoom_y;
+    case VO_PROP_ASPECT_RATIO:
+      return this->sc.user_ratio;
+  }
+
+  return -1;
+}
+
+
+
+static int vdpau_set_property (vo_driver_t *this_gen, int property, int value)
+{
+  vdpau_driver_t *this = (vdpau_driver_t*)this_gen;
+
+  printf("vdpau_set_property: property=%d, value=%d\n", property, value );
+
+  switch (property) {
+    case VO_PROP_INTERLACED:
+      this->deinterlace = value;
+      vdpau_set_deinterlace( this_gen );
+      break;
+    case VO_PROP_ZOOM_X:
+      if ((value >= XINE_VO_ZOOM_MIN) && (value <= XINE_VO_ZOOM_MAX)) {
+        this->zoom_x = value;
+        this->sc.zoom_factor_x = (double)value / (double)XINE_VO_ZOOM_STEP;
+        _x_vo_scale_compute_ideal_size( &this->sc );
+        this->sc.force_redraw = 1;    /* trigger re-calc of output size */
+      }
+      break;
+    case VO_PROP_ZOOM_Y:
+      if ((value >= XINE_VO_ZOOM_MIN) && (value <= XINE_VO_ZOOM_MAX)) {
+        this->zoom_y = value;
+        this->sc.zoom_factor_y = (double)value / (double)XINE_VO_ZOOM_STEP;
+        _x_vo_scale_compute_ideal_size( &this->sc );
+        this->sc.force_redraw = 1;    /* trigger re-calc of output size */
+      }
+      break;
+    case VO_PROP_ASPECT_RATIO:
+      if ( value>=XINE_VO_ASPECT_NUM_RATIOS )
+        value = XINE_VO_ASPECT_AUTO;
+      this->sc.user_ratio = value;
+      this->sc.force_redraw = 1;    /* trigger re-calc of output size */
+      break;
+    case VO_PROP_HUE: this->hue = value; vdpau_update_csc( this ); break;
+    case VO_PROP_SATURATION: this->saturation = value; vdpau_update_csc( this ); break;
+    case VO_PROP_CONTRAST: this->contrast = value; vdpau_update_csc( this ); break;
+    case VO_PROP_BRIGHTNESS: this->brightness = value; vdpau_update_csc( this ); break;
+    case VO_PROP_SHARPNESS: this->sharpness = value; vdpau_update_sharpness( this ); break;
+    case VO_PROP_NOISE_REDUCTION: this->noise = value; vdpau_update_noise( this ); break;
+  }
+
+  return value;
+}
+
+
+
+static void vdpau_get_property_min_max (vo_driver_t *this_gen, int property, int *min, int *max)
+{
+  switch ( property ) {
+    case VO_PROP_HUE:
+      *max = 314; *min = -314; break;
+    case VO_PROP_SATURATION:
+      *max = 1000; *min = 0; break;
+    case VO_PROP_CONTRAST:
+      *max = 1000; *min = 0; break;
+    case VO_PROP_BRIGHTNESS:
+      *max = 100; *min = -100; break;
+    case VO_PROP_SHARPNESS:
+      *max = 100; *min = -100; break;
+    case VO_PROP_NOISE_REDUCTION:
+      *max = 100; *min = 0; break;
+    default:
+      *max = 0; *min = 0;
+  }
+}
+
+
+
+static int vdpau_gui_data_exchange (vo_driver_t *this_gen, int data_type, void *data)
+{
+  vdpau_driver_t *this = (vdpau_driver_t*)this_gen;
+
+  switch (data_type) {
+#ifndef XINE_DISABLE_DEPRECATED_FEATURES
+    case XINE_GUI_SEND_COMPLETION_EVENT:
+      break;
+#endif
+
+    case XINE_GUI_SEND_EXPOSE_EVENT: {
+      if ( this->init_queue ) {
+        XLockDisplay( this->display );
+        int previous = this->current_output_surface ^ 1;
+        vdp_queue_display( vdp_queue, this->output_surface[previous], 0, 0, 0 );
+        XUnlockDisplay( this->display );
+      }
+      break;
+    }
+
+    case XINE_GUI_SEND_DRAWABLE_CHANGED: {
+      VdpStatus st;
+      XLockDisplay( this->display );
+      this->drawable = (Drawable) data;
+      vdp_queue_destroy( vdp_queue );
+      vdp_queue_target_destroy( vdp_queue_target );
+      st = vdp_queue_target_create_x11( vdp_device, this->drawable, &vdp_queue_target );
+      if ( st != VDP_STATUS_OK ) {
+        printf( "vo_vdpau: FATAL !! Can't recreate presentation queue target after drawable change !!\n" );
+        XUnlockDisplay( this->display );
+        break;
+      }
+      st = vdp_queue_create( vdp_device, vdp_queue_target, &vdp_queue );
+      if ( st != VDP_STATUS_OK ) {
+        printf( "vo_vdpau: FATAL !! Can't recreate presentation queue after drawable change !!\n" );
+        XUnlockDisplay( this->display );
+        break;
+      }
+      vdp_queue_set_background_color( vdp_queue, &this->back_color );
+      XUnlockDisplay( this->display );
+      this->sc.force_redraw = 1;
+      break;
+    }
+
+    case XINE_GUI_SEND_TRANSLATE_GUI_TO_VIDEO: {
+      int x1, y1, x2, y2;
+      x11_rectangle_t *rect = data;
+
+      _x_vo_scale_translate_gui2video(&this->sc, rect->x, rect->y, &x1, &y1);
+      _x_vo_scale_translate_gui2video(&this->sc, rect->x + rect->w, rect->y + rect->h, &x2, &y2);
+      rect->x = x1;
+      rect->y = y1;
+      rect->w = x2-x1;
+      rect->h = y2-y1;
+      break;
+    }
+
+    default:
+      return -1;
+  }
+
+  return 0;
+}
+
+
+
+static uint32_t vdpau_get_capabilities (vo_driver_t *this_gen)
+{
+  vdpau_driver_t *this = (vdpau_driver_t *) this_gen;
+
+  return this->capabilities;
+}
+
+
+
+static void vdpau_dispose (vo_driver_t *this_gen)
+{
+  vdpau_driver_t *this = (vdpau_driver_t *) this_gen;
+  int i;
+
+  this->ovl_yuv2rgb->dispose(this->ovl_yuv2rgb);
+  this->yuv2rgb_factory->dispose (this->yuv2rgb_factory);
+
+  for ( i=0; i<XINE_VORAW_MAX_OVL; ++i ) {
+    if ( this->overlays[i].ovl_bitmap != VDP_INVALID_HANDLE )
+      vdp_bitmap_destroy( this->overlays[i].ovl_bitmap );
+  }
+
+  if ( this->video_mixer!=VDP_INVALID_HANDLE )
+    vdp_video_mixer_destroy( this->video_mixer );
+  if ( this->overlay_unscaled!=VDP_INVALID_HANDLE )
+    vdp_output_surface_destroy( this->overlay_unscaled );
+  if ( this->overlay_output!=VDP_INVALID_HANDLE )
+    vdp_output_surface_destroy( this->overlay_output );
+  if ( this->output_surface[0]!=VDP_INVALID_HANDLE )
+    vdp_output_surface_destroy( this->output_surface[0] );
+  if ( this->output_surface[1]!=VDP_INVALID_HANDLE )
+    vdp_output_surface_destroy( this->output_surface[1] );
+  if ( this->soft_surface != VDP_INVALID_HANDLE )
+    vdp_video_surface_destroy( this->soft_surface );
+  vdp_queue_destroy( vdp_queue );
+  vdp_queue_target_destroy( vdp_queue_target );
+
+  for ( i=0; i<NUM_FRAMES_BACK; i++ )
+    if ( this->back_frame[i] )
+      this->back_frame[i]->vo_frame.dispose( &this->back_frame[i]->vo_frame );
+
+  free (this);
+}
+
+
+
+static int vdpau_reinit_error( VdpStatus st, const char *msg )
+{
+  if ( st != VDP_STATUS_OK ) {
+    printf( "vo_vdpau: %s : %s\n", msg, vdp_get_error_string( st ) );
+    return 1;
+  }
+  return 0;
+}
+
+
+
+static void vdpau_reinit( vo_driver_t *this_gen )
+{
+  printf("vo_vdpau: VDPAU was pre-empted. Reinit.\n");
+  vdpau_driver_t *this = (vdpau_driver_t *)this_gen;
+
+  XLockDisplay(guarded_display);
+  vdpau_release_back_frames(this_gen);
+
+  VdpStatus st = vdp_device_create_x11( this->display, this->screen, &vdp_device, &vdp_get_proc_address );
+
+  if ( st != VDP_STATUS_OK ) {
+    printf( "vo_vdpau: Can't create vdp device : " );
+    if ( st == VDP_STATUS_NO_IMPLEMENTATION )
+      printf( "No vdpau implementation.\n" );
+    else
+      printf( "unsupported GPU?\n" );
+    return;
+  }
+
+  st = vdp_queue_target_create_x11( vdp_device, this->drawable, &vdp_queue_target );
+  if ( vdpau_reinit_error( st, "Can't create presentation queue target !!" ) )
+    return;
+  st = vdp_queue_create( vdp_device, vdp_queue_target, &vdp_queue );
+  if ( vdpau_reinit_error( st, "Can't create presentation queue !!" ) )
+    return;
+
+
+  VdpChromaType chroma = VDP_CHROMA_TYPE_420;
+  st = orig_vdp_video_surface_create( vdp_device, chroma, this->soft_surface_width, this->soft_surface_height, &this->soft_surface );
+  if ( vdpau_reinit_error( st, "Can't create video surface !!" ) )
+    return;
+
+  this->current_output_surface = 0;
+  this->init_queue = 0;
+  st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->output_surface_width[0], this->output_surface_height[0], &this->output_surface[0] );
+  if ( vdpau_reinit_error( st, "Can't create first output surface !!" ) ) {
+    orig_vdp_video_surface_destroy( this->soft_surface );
+    return;
+  }
+  st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->output_surface_width[0], this->output_surface_height[0], &this->output_surface[1] );
+  if ( vdpau_reinit_error( st, "Can't create second output surface !!" ) ) {
+    orig_vdp_video_surface_destroy( this->soft_surface );
+    vdp_output_surface_destroy( this->output_surface[0] );
+    return;
+  }
+
+  this->video_mixer_chroma = chroma;
+  VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION, VDP_VIDEO_MIXER_FEATURE_SHARPNESS,
+        VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL, VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL };
+  VdpVideoMixerParameter params[] = { VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH, VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT, VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE, VDP_VIDEO_MIXER_PARAMETER_LAYERS };
+  int num_layers = 3;
+  void const *param_values[] = { &this->video_mixer_width, &this->video_mixer_height, &chroma, &num_layers };
+  st = vdp_video_mixer_create( vdp_device, 4, features, 4, params, param_values, &this->video_mixer );
+  if ( vdpau_reinit_error( st, "Can't create video mixer !!" ) ) {
+    orig_vdp_video_surface_destroy( this->soft_surface );
+    vdp_output_surface_destroy( this->output_surface[0] );
+    vdp_output_surface_destroy( this->output_surface[1] );
+    return;
+  }
+
+  vdp_preemption_callback_register(vdp_device, &vdp_preemption_callback, (void*)this);
+
+  XUnlockDisplay(guarded_display);
+  printf("vo_vdpau: Reinit done.\n");
+  this->vdp_runtime_nr++;
+  this->reinit_needed = 0;
+}
+
+
+
+static void vdp_preemption_callback(VdpDevice device, void *context)
+{
+  printf("vo_vdpau: VDPAU preemption callback\n");
+  vdpau_driver_t *this = (vdpau_driver_t *)context;
+  this->reinit_needed = 1;
+}
+
+
+
+static int vdpau_init_error( VdpStatus st, const char *msg, vo_driver_t *driver, int error_string )
+{
+  if ( st != VDP_STATUS_OK ) {
+    if ( error_string )
+      printf( "vo_vdpau: %s : %s\n", msg, vdp_get_error_string( st ) );
+    else
+      printf( "vo_vdpau: %s\n", msg );
+    vdpau_dispose( driver );
+    return 1;
+  }
+  return 0;
+}
+
+
+
+static vo_driver_t *vdpau_open_plugin (video_driver_class_t *class_gen, const void *visual_gen)
+{
+  vdpau_class_t       *class   = (vdpau_class_t *) class_gen;
+  x11_visual_t         *visual  = (x11_visual_t *) visual_gen;
+  vdpau_driver_t      *this;
+  config_values_t      *config  = class->xine->config;
+  int i;
+
+  this = (vdpau_driver_t *) calloc(1, sizeof(vdpau_driver_t));
+
+  if (!this)
+    return NULL;
+
+  guarded_display     = visual->display;
+  this->display       = visual->display;
+  this->screen        = visual->screen;
+  this->drawable      = visual->d;
+
+  _x_vo_scale_init(&this->sc, 1, 0, config);
+  this->sc.frame_output_cb  = visual->frame_output_cb;
+  this->sc.dest_size_cb     = visual->dest_size_cb;
+  this->sc.user_data        = visual->user_data;
+  this->sc.user_ratio       = XINE_VO_ASPECT_AUTO;
+  this->zoom_x              = 100;
+  this->zoom_y              = 100;
+
+  this->xine                    = class->xine;
+  this->config                  = config;
+
+  this->vo_driver.get_capabilities     = vdpau_get_capabilities;
+  this->vo_driver.alloc_frame          = vdpau_alloc_frame;
+  this->vo_driver.update_frame_format  = vdpau_update_frame_format;
+  this->vo_driver.overlay_begin        = vdpau_overlay_begin;
+  this->vo_driver.overlay_blend        = vdpau_overlay_blend;
+  this->vo_driver.overlay_end          = vdpau_overlay_end;
+  this->vo_driver.display_frame        = vdpau_display_frame;
+  this->vo_driver.get_property         = vdpau_get_property;
+  this->vo_driver.set_property         = vdpau_set_property;
+  this->vo_driver.get_property_min_max = vdpau_get_property_min_max;
+  this->vo_driver.gui_data_exchange    = vdpau_gui_data_exchange;
+  this->vo_driver.dispose              = vdpau_dispose;
+  this->vo_driver.redraw_needed        = vdpau_redraw_needed;
+
+  for ( i=0; i<XINE_VORAW_MAX_OVL; ++i ) {
+    this->overlays[i].ovl_w = this->overlays[i].ovl_h = 0;
+    this->overlays[i].bitmap_width = this->overlays[i].bitmap_height = 0;
+    this->overlays[i].ovl_bitmap = VDP_INVALID_HANDLE;
+    this->overlays[i].ovl_x = this->overlays[i].ovl_y = 0;
+  }
+  this->overlay_output = VDP_INVALID_HANDLE;
+  this->overlay_output_width = this->overlay_output_height = 0;
+  this->overlay_unscaled = VDP_INVALID_HANDLE;
+  this->overlay_unscaled_width = this->overlay_unscaled_height = 0;
+  this->ovl_changed = 0;
+  this->has_overlay = 0;
+  this->has_unscaled = 0;
+
+  this->argb_overlay = VDP_INVALID_HANDLE;
+  this->argb_overlay_width = this->argb_overlay_height = 0;
+  this->has_argb_overlay = 0;
+
+  /*  overlay converter */
+  this->yuv2rgb_factory = yuv2rgb_factory_init (MODE_24_BGR, 0, NULL);
+  this->ovl_yuv2rgb = this->yuv2rgb_factory->create_converter( this->yuv2rgb_factory );
+
+  VdpStatus st = vdp_device_create_x11( visual->display, visual->screen, &vdp_device, &vdp_get_proc_address );
+  if ( st != VDP_STATUS_OK ) {
+    printf( "vo_vdpau: Can't create vdp device : " );
+    if ( st == VDP_STATUS_NO_IMPLEMENTATION )
+      printf( "No vdpau implementation.\n" );
+    else
+      printf( "unsupported GPU?\n" );
+    vdpau_dispose( &this->vo_driver );
+    return NULL;
+  }
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_GET_ERROR_STRING , (void*)&vdp_get_error_string );
+  if ( vdpau_init_error( st, "Can't get GET_ERROR_STRING proc address !!", &this->vo_driver, 0 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_GET_API_VERSION , (void*)&vdp_get_api_version );
+  if ( vdpau_init_error( st, "Can't get GET_API_VERSION proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  uint32_t tmp;
+  vdp_get_api_version( &tmp );
+  printf( "vo_vdpau: vdpau API version : %d\n", tmp );
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_GET_INFORMATION_STRING , (void*)&vdp_get_information_string );
+  if ( vdpau_init_error( st, "Can't get GET_INFORMATION_STRING proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  const char *s;
+  st = vdp_get_information_string( &s );
+  printf( "vo_vdpau: vdpau implementation description : %s\n", s );
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_SURFACE_QUERY_GET_PUT_BITS_Y_CB_CR_CAPABILITIES , (void*)&vdp_video_surface_query_get_put_bits_ycbcr_capabilities );
+  if ( vdpau_init_error( st, "Can't get VIDEO_SURFACE_QUERY_GET_PUT_BITS_Y_CB_CR_CAPABILITIES proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  VdpBool ok;
+  st = vdp_video_surface_query_get_put_bits_ycbcr_capabilities( vdp_device, VDP_CHROMA_TYPE_422, VDP_YCBCR_FORMAT_YUYV, &ok );
+  if ( vdpau_init_error( st, "Failed to check vdpau yuy2 capability", &this->vo_driver, 1 ) )
+    return NULL;
+  if ( !ok ) {
+    printf( "vo_vdpau: VideoSurface doesn't support yuy2, sorry.\n");
+    vdpau_dispose( &this->vo_driver );
+    return NULL;
+  }
+  st = vdp_video_surface_query_get_put_bits_ycbcr_capabilities( vdp_device, VDP_CHROMA_TYPE_420, VDP_YCBCR_FORMAT_YV12, &ok );
+  if ( vdpau_init_error( st, "Failed to check vdpau yv12 capability", &this->vo_driver, 1 ) )
+    return NULL;
+  if ( !ok ) {
+    printf( "vo_vdpau: VideoSurface doesn't support yv12, sorry.\n");
+    vdpau_dispose( &this->vo_driver );
+    return NULL;
+  }
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_SURFACE_CREATE , (void*)&orig_vdp_video_surface_create ); vdp_video_surface_create = guarded_vdp_video_surface_create;
+  if ( vdpau_init_error( st, "Can't get VIDEO_SURFACE_CREATE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_SURFACE_DESTROY , (void*)&orig_vdp_video_surface_destroy ); vdp_video_surface_destroy = guarded_vdp_video_surface_destroy;
+  if ( vdpau_init_error( st, "Can't get VIDEO_SURFACE_DESTROY proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_SURFACE_PUT_BITS_Y_CB_CR , (void*)&vdp_video_surface_putbits_ycbcr );
+  if ( vdpau_init_error( st, "Can't get VIDEO_SURFACE_PUT_BITS_Y_CB_CR proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR , (void*)&vdp_video_surface_getbits_ycbcr );
+  if ( vdpau_init_error( st, "Can't get VIDEO_SURFACE_GET_BITS_Y_CB_CR proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_OUTPUT_SURFACE_CREATE , (void*)&vdp_output_surface_create );
+  if ( vdpau_init_error( st, "Can't get OUTPUT_SURFACE_CREATE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_OUTPUT_SURFACE_DESTROY , (void*)&vdp_output_surface_destroy );
+  if ( vdpau_init_error( st, "Can't get OUTPUT_SURFACE_DESTROY proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_OUTPUT_SURFACE_RENDER_BITMAP_SURFACE , (void*)&vdp_output_surface_render_bitmap_surface );
+  if ( vdpau_init_error( st, "Can't get OUTPUT_SURFACE_RENDER_BITMAP_SURFACE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_NATIVE , (void*)&vdp_output_surface_put_bits );
+  if ( vdpau_init_error( st, "Can't get VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_NATIVE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_MIXER_CREATE , (void*)&vdp_video_mixer_create );
+  if ( vdpau_init_error( st, "Can't get VIDEO_MIXER_CREATE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_MIXER_DESTROY , (void*)&vdp_video_mixer_destroy );
+  if ( vdpau_init_error( st, "Can't get VIDEO_MIXER_DESTROY proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_MIXER_RENDER , (void*)&vdp_video_mixer_render );
+  if ( vdpau_init_error( st, "Can't get VIDEO_MIXER_RENDER proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_MIXER_SET_ATTRIBUTE_VALUES , (void*)&vdp_video_mixer_set_attribute_values );
+  if ( vdpau_init_error( st, "Can't get VIDEO_MIXER_SET_ATTRIBUTE_VALUES proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_MIXER_SET_FEATURE_ENABLES , (void*)&vdp_video_mixer_set_feature_enables );
+  if ( vdpau_init_error( st, "Can't get VIDEO_MIXER_SET_FEATURE_ENABLES proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_VIDEO_MIXER_GET_FEATURE_ENABLES , (void*)&vdp_video_mixer_get_feature_enables );
+  if ( vdpau_init_error( st, "Can't get VIDEO_MIXER_GET_FEATURE_ENABLES proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_GENERATE_CSC_MATRIX , (void*)&vdp_generate_csc_matrix );
+  if ( vdpau_init_error( st, "Can't get GENERATE_CSC_MATRIX proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_CREATE_X11 , (void*)&vdp_queue_target_create_x11 );
+  if ( vdpau_init_error( st, "Can't get PRESENTATION_QUEUE_TARGET_CREATE_X11 proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_DESTROY , (void*)&vdp_queue_target_destroy );
+  if ( vdpau_init_error( st, "Can't get PRESENTATION_QUEUE_TARGET_DESTROY proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_PRESENTATION_QUEUE_CREATE , (void*)&vdp_queue_create );
+  if ( vdpau_init_error( st, "Can't get PRESENTATION_QUEUE_CREATE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_PRESENTATION_QUEUE_DESTROY , (void*)&vdp_queue_destroy );
+  if ( vdpau_init_error( st, "Can't get PRESENTATION_QUEUE_DESTROY proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_PRESENTATION_QUEUE_DISPLAY , (void*)&vdp_queue_display );
+  if ( vdpau_init_error( st, "Can't get PRESENTATION_QUEUE_DISPLAY proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_PRESENTATION_QUEUE_BLOCK_UNTIL_SURFACE_IDLE , (void*)&vdp_queue_block );
+  if ( vdpau_init_error( st, "Can't get PRESENTATION_QUEUE_BLOCK_UNTIL_SURFACE_IDLE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_PRESENTATION_QUEUE_SET_BACKGROUND_COLOR , (void*)&vdp_queue_set_background_color );
+  if ( vdpau_init_error( st, "Can't get PRESENTATION_QUEUE_SET_BACKGROUND_COLOR proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_PRESENTATION_QUEUE_GET_TIME , (void*)&vdp_queue_get_time );
+  if ( vdpau_init_error( st, "Can't get PRESENTATION_QUEUE_GET_TIME proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES , (void*)&vdp_decoder_query_capabilities );
+  if ( vdpau_init_error( st, "Can't get DECODER_QUERY_CAPABILITIES proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_DECODER_CREATE , (void*)&orig_vdp_decoder_create ); vdp_decoder_create = guarded_vdp_decoder_create;
+  if ( vdpau_init_error( st, "Can't get DECODER_CREATE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_DECODER_DESTROY , (void*)&orig_vdp_decoder_destroy ); vdp_decoder_destroy = guarded_vdp_decoder_destroy;
+  if ( vdpau_init_error( st, "Can't get DECODER_DESTROY proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_DECODER_RENDER , (void*)&orig_vdp_decoder_render ); vdp_decoder_render = guarded_vdp_decoder_render;
+  if ( vdpau_init_error( st, "Can't get DECODER_RENDER proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_BITMAP_SURFACE_CREATE , (void*)&vdp_bitmap_create );
+  if ( vdpau_init_error( st, "Can't get BITMAP_SURFACE_CREATE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_BITMAP_SURFACE_DESTROY , (void*)&vdp_bitmap_destroy );
+  if ( vdpau_init_error( st, "Can't get BITMAP_SURFACE_DESTROY proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_BITMAP_SURFACE_PUT_BITS_NATIVE , (void*)&vdp_bitmap_put_bits );
+  if ( vdpau_init_error( st, "Can't get BITMAP_SURFACE_PUT_BITS_NATIVE proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_get_proc_address( vdp_device, VDP_FUNC_ID_PREEMPTION_CALLBACK_REGISTER, (void*)&vdp_preemption_callback_register );
+  if ( vdpau_init_error( st, "Can't get PREEMPTION_CALLBACK_REGISTER proc address !!", &this->vo_driver, 1 ) )
+    return NULL;
+
+  st = vdp_preemption_callback_register(vdp_device, &vdp_preemption_callback, (void*)this);
+  if ( vdpau_init_error( st, "Can't register preemption callback !!", &this->vo_driver, 1 ) )
+    return NULL;
+
+  st = vdp_queue_target_create_x11( vdp_device, this->drawable, &vdp_queue_target );
+  if ( vdpau_init_error( st, "Can't create presentation queue target !!", &this->vo_driver, 1 ) )
+    return NULL;
+  st = vdp_queue_create( vdp_device, vdp_queue_target, &vdp_queue );
+  if ( vdpau_init_error( st, "Can't create presentation queue !!", &this->vo_driver, 1 ) )
+    return NULL;
+
+  /* choose almost black as backcolor for color keying */
+  this->back_color.red = 0.02;
+  this->back_color.green = 0.01;
+  this->back_color.blue = 0.03;
+  this->back_color.alpha = 1;
+  vdp_queue_set_background_color( vdp_queue, &this->back_color );
+
+  this->soft_surface_width = 320;
+  this->soft_surface_height = 240;
+  this->soft_surface_format = XINE_IMGFMT_YV12;
+  VdpChromaType chroma = VDP_CHROMA_TYPE_420;
+  st = vdp_video_surface_create( vdp_device, chroma, this->soft_surface_width, this->soft_surface_height, &this->soft_surface );
+  if ( vdpau_init_error( st, "Can't create video surface !!", &this->vo_driver, 1 ) )
+    return NULL;
+
+  this->output_surface_width[0] = this->output_surface_width[1] = 320;
+  this->output_surface_height[0] = this->output_surface_height[1] = 240;
+  this->current_output_surface = 0;
+  this->init_queue = 0;
+  st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->output_surface_width[0], this->output_surface_height[0], &this->output_surface[0] );
+  if ( vdpau_init_error( st, "Can't create first output surface !!", &this->vo_driver, 1 ) ) {
+    vdp_video_surface_destroy( this->soft_surface );
+    return NULL;
+  }
+  st = vdp_output_surface_create( vdp_device, VDP_RGBA_FORMAT_B8G8R8A8, this->output_surface_width[0], this->output_surface_height[0], &this->output_surface[1] );
+  if ( vdpau_init_error( st, "Can't create second output surface !!", &this->vo_driver, 1 ) ) {
+    vdp_video_surface_destroy( this->soft_surface );
+    vdp_output_surface_destroy( this->output_surface[0] );
+    return NULL;
+  }
+
+  this->video_mixer_chroma = chroma;
+  this->video_mixer_width = this->soft_surface_width;
+  this->video_mixer_height = this->soft_surface_height;
+  VdpVideoMixerFeature features[] = { VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION, VDP_VIDEO_MIXER_FEATURE_SHARPNESS,
+        VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL, VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL };
+  VdpVideoMixerParameter params[] = { VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH, VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT, VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE, VDP_VIDEO_MIXER_PARAMETER_LAYERS };
+  int num_layers = 3;
+  void const *param_values[] = { &this->video_mixer_width, &this->video_mixer_height, &chroma, &num_layers };
+  st = vdp_video_mixer_create( vdp_device, 4, features, 4, params, param_values, &this->video_mixer );
+  if ( vdpau_init_error( st, "Can't create video mixer !!", &this->vo_driver, 1 ) ) {
+    vdp_video_surface_destroy( this->soft_surface );
+    vdp_output_surface_destroy( this->output_surface[0] );
+    vdp_output_surface_destroy( this->output_surface[1] );
+    return NULL;
+  }
+
+  this->deinterlace_method = config->register_enum( config, "video.output.vdpau_deinterlace_method", 1,
+         vdpau_deinterlace_methods, _("vdpau: HD deinterlace method"),
+         _("bob\n"
+           "Basic deinterlacing, doing 50i->50p.\n\n"
+           "temporal\n"
+           "Very good, 50i->50p\n\n"
+           "temporal_spatial\n"
+           "The best, but very GPU intensive.\n\n"),
+         10, vdpau_update_deinterlace_method, this );
+
+  this->enable_inverse_telecine = config->register_bool( config, "video.output.vdpau_enable_inverse_telecine", 1,
+      _("vdpau: Try to recreate progressive frames from pulldown material"),
+      _("Enable this to detect bad-flagged progressive content to which\n"
+        "a 2:2 or 3:2 pulldown was applied.\n\n"),
+        10, vdpau_update_enable_inverse_telecine, this );
+
+  this->honor_progressive = config->register_bool( config, "video.output.vdpau_honor_progressive", 0,
+        _("vdpau: disable deinterlacing when progressive_frame flag is set"),
+        _("Set to true if you want to trust the progressive_frame stream's flag.\n"
+          "This flag is not always reliable.\n\n"),
+        10, vdpau_honor_progressive_flag, this );
+
+  /* number of video frames from config - register it with the default value. */
+  int frame_num = config->register_num (config, "engine.buffers.video_num_frames", 15, /* default */
+       _("default number of video frames"),
+       _("The default number of video frames to request "
+         "from xine video out driver. Some drivers will "
+         "override this setting with their own values."),
+      20, NULL, this);
+
+  /* now make sure we have at least 22 frames, to prevent
+   * locks with vdpau_h264 */
+  if(frame_num < 22)
+    config->update_num(config,"engine.buffers.video_num_frames",22);
+
+  this->capabilities = VO_CAP_YV12 | VO_CAP_YUY2 | VO_CAP_CROP | VO_CAP_UNSCALED_OVERLAY | VO_CAP_CUSTOM_EXTENT_OVERLAY | VO_CAP_ARGB_LAYER_OVERLAY;
+  ok = 0;
+  uint32_t mw, mh, ml, mr;
+  st = vdp_decoder_query_capabilities( vdp_device, VDP_DECODER_PROFILE_H264_MAIN, &ok, &ml, &mr, &mw, &mh );
+  if ( st != VDP_STATUS_OK  )
+    printf( "vo_vdpau: getting h264_supported failed! : %s\n", vdp_get_error_string( st ) );
+  else if ( !ok )
+    printf( "vo_vdpau: no support for h264 ! : no ok\n" );
+  else
+    this->capabilities |= VO_CAP_VDPAU_H264;
+
+  st = vdp_decoder_query_capabilities( vdp_device, VDP_DECODER_PROFILE_MPEG2_MAIN, &ok, &ml, &mr, &mw, &mh );
+  if ( st != VDP_STATUS_OK  )
+    printf( "vo_vdpau: getting mpeg12_supported failed! : %s\n", vdp_get_error_string( st ) );
+  else if ( !ok )
+    printf( "vo_vdpau: no support for mpeg1/2 ! : no ok\n" );
+  else
+    this->capabilities |= VO_CAP_VDPAU_MPEG12;
+
+  for ( i=0; i<NUM_FRAMES_BACK; i++)
+    this->back_frame[i] = NULL;
+
+  this->hue = 0;
+  this->saturation = 100;
+  this->contrast = 100;
+  this->brightness = 0;
+  this->sharpness = 0;
+  this->noise = 0;
+  this->deinterlace = 0;
+
+  this->allocated_surfaces = 0;
+
+  this->vdp_runtime_nr = 1;
+
+  return &this->vo_driver;
+}
+
+/*
+ * class functions
+ */
+
+static char* vdpau_get_identifier (video_driver_class_t *this_gen)
+{
+  return "vdpau";
+}
+
+
+
+static char* vdpau_get_description (video_driver_class_t *this_gen)
+{
+  return _("xine video output plugin using VDPAU hardware acceleration");
+}
+
+
+
+static void vdpau_dispose_class (video_driver_class_t *this_gen)
+{
+  vdpau_class_t *this = (vdpau_class_t *) this_gen;
+  free (this);
+}
+
+
+
+static void *vdpau_init_class (xine_t *xine, void *visual_gen)
+{
+  vdpau_class_t *this = (vdpau_class_t *) calloc(1, sizeof(vdpau_class_t));
+
+  this->driver_class.open_plugin     = vdpau_open_plugin;
+  this->driver_class.get_identifier  = vdpau_get_identifier;
+  this->driver_class.get_description = vdpau_get_description;
+  this->driver_class.dispose         = vdpau_dispose_class;
+  this->xine                         = xine;
+
+  return this;
+}
+
+
+
+static const vo_info_t vo_info_vdpau = {
+  11,                    /* priority    */
+  XINE_VISUAL_TYPE_X11  /* visual type */
+};
+
+
+/*
+ * exported plugin catalog entry
+ */
+
+const plugin_info_t xine_plugin_info[] EXPORTED = {
+  /* type, API, "name", version, special_info, init_function */
+  { PLUGIN_VIDEO_OUT, 21, "vdpau", XINE_VERSION_CODE, &vo_info_vdpau, vdpau_init_class },
+  { PLUGIN_NONE, 0, "", 0, NULL, NULL }
+};
diff -Naur xine-lib-1.1.16.1-old/src/video_out/video_out_xv.c xine-lib-1.1.16.1-new/src/video_out/video_out_xv.c
--- xine-lib-1.1.16.1-old/src/video_out/video_out_xv.c	2009-01-10 17:25:34.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/video_out/video_out_xv.c	2009-01-19 18:50:51.000000000 -0800
@@ -912,6 +912,8 @@
 			    int property, int value) {
   xv_driver_t *this = (xv_driver_t *) this_gen;
 
+  printf("xv_set_property: property=%d, value=%d\n", property, value );
+
   if (this->props[property].atom != None) {
 
     /* value is out of bound */
diff -Naur xine-lib-1.1.16.1-old/src/xine-engine/accel_vdpau.h xine-lib-1.1.16.1-new/src/xine-engine/accel_vdpau.h
--- xine-lib-1.1.16.1-old/src/xine-engine/accel_vdpau.h	1969-12-31 16:00:00.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/xine-engine/accel_vdpau.h	2009-01-19 18:50:51.000000000 -0800
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2008 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ * Common acceleration definitions for vdpau
+ *
+ *
+ */
+
+#ifndef HAVE_XINE_ACCEL_VDPAU_H
+#define HAVE_XINE_ACCEL_VDPAU_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <vdpau/vdpau.h>
+
+
+typedef struct {
+
+  VdpDevice vdp_device;
+
+  VdpGetErrorString *vdp_get_error_string;
+  VdpDecoderCreate *vdp_decoder_create;
+  VdpDecoderDestroy *vdp_decoder_destroy;
+  VdpDecoderRender *vdp_decoder_render;
+
+  VdpVideoSurface surface;
+  VdpChromaType chroma;
+
+  int vdp_runtime_nr; /* this is used to keep in sync on preemptions */
+  int *current_vdp_runtime_nr;
+
+} vdpau_accel_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -Naur xine-lib-1.1.16.1-old/src/xine-engine/osd.c xine-lib-1.1.16.1-new/src/xine-engine/osd.c
--- xine-lib-1.1.16.1-old/src/xine-engine/osd.c	2009-01-11 10:15:19.000000000 -0800
+++ xine-lib-1.1.16.1-new/src/xine-engine/osd.c	2009-01-19 18:50:51.000000000 -0800
@@ -157,14 +157,19 @@
   osd->next = this->osds;
   this->osds = osd;
   
+  osd->extent_width = 0;
+  osd->extent_height = 0;
   osd->width = width;
   osd->height = height;
   osd->area = calloc(width, height);
+  osd->area_touched = 0;
   
-  osd->x1 = width;
-  osd->y1 = height;
-  osd->x2 = 0;
-  osd->y2 = 0;
+  osd->x1 = osd->argb_layer.x1 = width;
+  osd->y1 = osd->argb_layer.y1 = height;
+  osd->x2 = osd->argb_layer.x2 = 0;
+  osd->y2 = osd->argb_layer.y2 = 0;
+
+  pthread_mutex_init(&osd->argb_layer.mutex, NULL);
 
   memcpy(osd->color, textpalettes_color[0], sizeof(textpalettes_color[0])); 
   memcpy(osd->trans, textpalettes_trans[0], sizeof(textpalettes_trans[0])); 
@@ -183,6 +188,18 @@
   return osd;
 }
 
+/*
+ * osd extent must be set to achive video resolution independent osds
+ * both sizes must be > 0 to take effect. otherwise, video resolution
+ * will still be used. the extent defines the reference coordinate
+ * system which is matched to the video output area.
+ */
+static void osd_set_extent (osd_object_t *osd, int extent_width, int extent_height) {
+
+  osd->extent_width  = extent_width;
+  osd->extent_height = extent_height;
+}
+
 
 
 /*
@@ -242,12 +259,18 @@
     this->event.object.handle = osd->handle;
 
     memset( this->event.object.overlay, 0, sizeof(*this->event.object.overlay) );
+
+    this->event.object.overlay->argb_layer = &osd->argb_layer;
+
     this->event.object.overlay->unscaled = unscaled;
     this->event.object.overlay->x = osd->display_x + osd->x1;
     this->event.object.overlay->y = osd->display_y + osd->y1;
     this->event.object.overlay->width = osd->x2 - osd->x1;
     this->event.object.overlay->height = osd->y2 - osd->y1;
  
+    this->event.object.overlay->extent_width  = osd->extent_width;
+    this->event.object.overlay->extent_height = osd->extent_height;
+
     this->event.object.overlay->hili_top    = 0;
     this->event.object.overlay->hili_bottom = this->event.object.overlay->height;
     this->event.object.overlay->hili_left   = 0;
@@ -255,6 +278,11 @@
    
     /* there will be at least that many rle objects (one for each row) */
     this->event.object.overlay->num_rle = 0;
+    if (!osd->area_touched) {
+      /* avoid rle encoding when only argb_layer is modified */
+      this->event.object.overlay->data_size = 0;
+      rle_p = this->event.object.overlay->rle = NULL;
+    } else {
     /* We will never need more rle objects than columns in any row
        Rely on lazy page allocation to avoid us actually taking up
        this much RAM */
@@ -302,6 +330,7 @@
     memcpy(this->event.object.overlay->hili_trans, osd->trans, sizeof(osd->trans)); 
     memcpy(this->event.object.overlay->color, osd->color, sizeof(osd->color)); 
     memcpy(this->event.object.overlay->trans, osd->trans, sizeof(osd->trans)); 
+    }
   
     this->event.event_type = OVERLAY_EVENT_SHOW;
     this->event.vpts = vpts;
@@ -385,11 +414,14 @@
 static void osd_clear (osd_object_t *osd) {
   lprintf("osd=%p\n",osd);
 
+  if (osd->area_touched) {
+    osd->area_touched = 0;
   memset(osd->area, 0, osd->width * osd->height);
-  osd->x1 = osd->width;
-  osd->y1 = osd->height;
-  osd->x2 = 0;
-  osd->y2 = 0;
+  }
+  osd->x1 = osd->argb_layer.x1 = osd->width;
+  osd->y1 = osd->argb_layer.y1 = osd->height;
+  osd->x2 = osd->argb_layer.x2 = 0;
+  osd->y2 = osd->argb_layer.y2 = 0;
 }
 
 /*
@@ -411,6 +443,7 @@
   osd->x2 = MAX(osd->x2, (x + 1));
   osd->y1 = MIN(osd->y1, y);
   osd->y2 = MAX(osd->y2, (y + 1));
+  osd->area_touched = 1;
 
   c = osd->area + y * osd->width + x;
   *c = color;
@@ -470,6 +503,7 @@
   osd->x2 = MAX( osd->x2, x2 );
   osd->y1 = MIN( osd->y1, y1 );
   osd->y2 = MAX( osd->y2, y2 );
+  osd->area_touched = 1;
   
   dx = x2 - x1;
   dy = y2 - y1;
@@ -583,6 +617,7 @@
   osd->x2 = MAX( osd->x2, dx );
   osd->y1 = MIN( osd->y1, y );
   osd->y2 = MAX( osd->y2, dy );
+  osd->area_touched = 1;
 
   dx -= x;
   dy -= y;
@@ -1143,6 +1178,7 @@
 
   if( x1 < osd->x1 ) osd->x1 = x1;
   if( y1 < osd->y1 ) osd->y1 = y1;
+  osd->area_touched = 1;
 
   inbuf = text;
   inbytesleft = strlen(text);
@@ -1483,6 +1519,7 @@
       else
         this->osds = osd->next;
 
+      pthread_mutex_destroy(&osd->argb_layer.mutex);
       free( osd );
       break;
     }
@@ -1528,6 +1565,7 @@
   osd->x2 = MAX( osd->x2, x1+width );
   osd->y1 = MIN( osd->y1, y1 );
   osd->y2 = MAX( osd->y2, y1+height );
+  osd->area_touched = 1;
 
   for( y=0; y<height; y++ ) {
     if ( palette_map ) {
@@ -1546,21 +1584,58 @@
   }
 }
 
+static void osd_set_argb_buffer(osd_object_t *osd, uint32_t *argb_buffer,
+    int dirty_x, int dirty_y, int dirty_width, int dirty_height)
+{
+  if (osd->argb_layer.buffer != argb_buffer) {
+    dirty_x = 0;
+    dirty_y = 0;
+    dirty_width = osd->width;
+    dirty_height = osd->height;
+  }
+
+  /* keep osd_object clipping behavior */
+  osd->x1 = MIN( osd->x1, dirty_x );
+  osd->x2 = MAX( osd->x2, dirty_x + dirty_width );
+  osd->y1 = MIN( osd->y1, dirty_y );
+  osd->y2 = MAX( osd->y2, dirty_y + dirty_height );
+
+  pthread_mutex_lock(&osd->argb_layer.mutex);
+
+  /* argb layer update area accumulation */
+  osd->argb_layer.x1 = MIN( osd->argb_layer.x1, dirty_x );
+  osd->argb_layer.x2 = MAX( osd->argb_layer.x2, dirty_x + dirty_width );
+  osd->argb_layer.y1 = MIN( osd->argb_layer.y1, dirty_y );
+  osd->argb_layer.y2 = MAX( osd->argb_layer.y2, dirty_y + dirty_height );
+
+  osd->argb_layer.buffer = argb_buffer;
+
+  pthread_mutex_unlock(&osd->argb_layer.mutex);
+}
+
 static uint32_t osd_get_capabilities (osd_object_t *osd) {
      
   osd_renderer_t *this = osd->renderer;
   uint32_t capabilities = 0;
+  uint32_t vo_capabilities;
 
 #ifdef HAVE_FT2
   capabilities |= XINE_OSD_CAP_FREETYPE2;
 #endif
 
   this->stream->xine->port_ticket->acquire(this->stream->xine->port_ticket, 1);
-  if( this->stream->video_out->get_capabilities(this->stream->video_out) &
-      VO_CAP_UNSCALED_OVERLAY)
-    capabilities |= XINE_OSD_CAP_UNSCALED;
+  vo_capabilities = this->stream->video_out->get_capabilities(this->stream->video_out);
   this->stream->xine->port_ticket->release(this->stream->xine->port_ticket, 1);
  
+  if (vo_capabilities & VO_CAP_UNSCALED_OVERLAY)
+    capabilities |= XINE_OSD_CAP_UNSCALED;
+
+  if (vo_capabilities & VO_CAP_CUSTOM_EXTENT_OVERLAY)
+    capabilities |= XINE_OSD_CAP_CUSTOM_EXTENT;
+
+  if (vo_capabilities & VO_CAP_ARGB_LAYER_OVERLAY)
+    capabilities |= XINE_OSD_CAP_ARGB_LAYER;
+
   return capabilities; 
 }
 
@@ -1621,8 +1696,10 @@
   this->get_text_size      = osd_get_text_size;
   this->close              = osd_renderer_close;
   this->draw_bitmap        = osd_draw_bitmap;
+  this->set_argb_buffer    = osd_set_argb_buffer;
   this->show_unscaled      = osd_show_unscaled;
   this->get_capabilities   = osd_get_capabilities;
+  this->set_extent         = osd_set_extent;
 
   return this;
 }
diff -Naur xine-lib-1.1.16.1-old/src/xine-engine/osd.h xine-lib-1.1.16.1-new/src/xine-engine/osd.h
--- xine-lib-1.1.16.1-old/src/xine-engine/osd.h	2008-06-14 16:15:00.000000000 -0700
+++ xine-lib-1.1.16.1-new/src/xine-engine/osd.h	2009-01-19 18:50:51.000000000 -0800
@@ -47,8 +47,12 @@
 
   int width, height;    /* work area dimentions */
   uint8_t *area;        /* work area */
+  int area_touched;     /* work area was used for painting */
   int display_x,display_y;  /* where to display it in screen */
   
+  /* extent of reference coordinate system */
+  int extent_width, extent_height;
+
   /* clipping box inside work area */
   int x1, y1;
   int x2, y2;
@@ -65,6 +69,13 @@
   
   osd_font_t *font;
   osd_ft2context_t *ft2;
+
+
+  /* this holds an optional ARGB overlay, which
+   * is only be used by supported video_out modules.
+   * right now this is only vdpau */
+  argb_layer_t argb_layer;
+
 };
 
 /* this one is public */
@@ -211,6 +222,28 @@
    */
   uint32_t (*get_capabilities) (osd_object_t *osd);
   
+  /*
+   * define extent of reference coordinate system for video
+   * resolution independent osds. both sizes must be > 0 to
+   * take effect. otherwise, video resolution will be used.
+   */
+  void (*set_extent) (osd_object_t *osd, int extent_width, int extent_height);
+
+  /*
+   * set an argb buffer to be blended into video
+   * the buffer must exactly match the osd dimensions
+   * and stay valid while the osd is on screen. pass
+   * a NULL pointer to safely remove the buffer from
+   * the osd layer. only the dirty area  will be
+   * updated on screen. for convinience the whole
+   * osd object will be considered dirty when setting
+   * a different buffer pointer.
+   * see also XINE_OSD_CAP_ARGB_LAYER
+   */
+  void (*set_argb_buffer) (osd_object_t *osd, uint32_t *argb_buffer,
+                           int dirty_x, int dirty_y, int dirty_width, int dirty_height);
+
+
   /* private stuff */
 
   pthread_mutex_t             osd_mutex;
diff -Naur xine-lib-1.1.16.1-old/src/xine-engine/video_out.c xine-lib-1.1.16.1-new/src/xine-engine/video_out.c
--- xine-lib-1.1.16.1-old/src/xine-engine/video_out.c	2008-06-14 16:15:00.000000000 -0700
+++ xine-lib-1.1.16.1-new/src/xine-engine/video_out.c	2009-01-19 18:50:51.000000000 -0800
@@ -930,8 +930,8 @@
         img->vpts = cur_vpts;
         /* extra info of the backup is thrown away, because it is not up to date */
         _x_extra_info_reset(img->extra_info);
+        img->future_frame = NULL;  
       }
-        
       return img;
 
     } else {
@@ -990,6 +990,13 @@
      * remove frame from display queue and show it
      */
     
+    if ( img ) {
+      if ( img->next )
+        img->future_frame = img->next;
+      else
+        img->future_frame = NULL;
+    }
+    
     img = vo_remove_from_img_buf_queue_int (this->display_img_buf_queue, 1, 0, 0, 0, 0, 0);
     pthread_mutex_unlock(&this->display_img_buf_queue->mutex);
 
@@ -1427,6 +1434,8 @@
     ret = this->crop_bottom;
     break;
   
+  case XINE_PARAM_VO_SHARPNESS:
+  case XINE_PARAM_VO_NOISE_REDUCTION:
   case XINE_PARAM_VO_HUE:
   case XINE_PARAM_VO_SATURATION:
   case XINE_PARAM_VO_CONTRAST:
@@ -1516,6 +1525,8 @@
     ret = this->crop_bottom = value;
     break;
   
+  case XINE_PARAM_VO_SHARPNESS:
+  case XINE_PARAM_VO_NOISE_REDUCTION:
   case XINE_PARAM_VO_HUE:
   case XINE_PARAM_VO_SATURATION:
   case XINE_PARAM_VO_CONTRAST:
diff -Naur xine-lib-1.1.16.1-old/src/xine-engine/video_out.h xine-lib-1.1.16.1-new/src/xine-engine/video_out.h
--- xine-lib-1.1.16.1-old/src/xine-engine/video_out.h	2008-06-14 16:15:00.000000000 -0700
+++ xine-lib-1.1.16.1-new/src/xine-engine/video_out.h	2009-01-19 18:50:51.000000000 -0800
@@ -68,6 +68,14 @@
    * member functions
    */
 
+  /* Provide a copy of the frame's image in an image format already known to xine. data's member */
+  /* have already been intialized to frame's content on entry, so it's usually only necessary to */
+  /* change format and img_size. In case img is set, it will point to a memory block of suitable */
+  /* size (size has been determined by a previous call with img == NULL). img content and img_size */
+  /* must adhere to the specification of _x_get_current_frame_data(). */
+  /* Currently this is needed for all image formats except XINE_IMGFMT_YV12 and XINE_IMGFMT_YUY2. */
+  void (*proc_provide_standard_frame_data) (vo_frame_t *vo_img, xine_current_frame_data_t *data);
+
   /* Duplicate picture data and acceleration specific data of a frame. */
   /* if the image format isn't already known by Xine. Currently this is needed */
   /* For all image formats except XINE_IMGFMT_YV12 and XINE_IMGFMT_YUY2 */
@@ -150,6 +158,9 @@
   /* displacement for overlays */
   int                       overlay_offset_x, overlay_offset_y;
   
+  /* pointer to the next frame in display order, used by some vo deint */
+  struct vo_frame_s         *future_frame;
+
   /* 
    * that part is used only by video_out.c for frame management
    * obs: changing anything here will require recompiling vo drivers
@@ -249,7 +260,9 @@
 #define VO_PROP_OUTPUT_HEIGHT         20 /* read-only */
 #define VO_PROP_OUTPUT_XOFFSET        21 /* read-only */
 #define VO_PROP_OUTPUT_YOFFSET        22 /* read-only */
-#define VO_NUM_PROPERTIES             23
+#define VO_PROP_SHARPNESS             24
+#define VO_PROP_NOISE_REDUCTION       25
+#define VO_NUM_PROPERTIES             26
 
 /* number of colors in the overlay palette. Currently limited to 256
    at most, because some alphablend functions use an 8-bit index into
@@ -271,6 +284,7 @@
 #define VO_PAN_SCAN_FLAG     4
 #define VO_INTERLACED_FLAG   8
 #define VO_NEW_SEQUENCE_FLAG 16 /* set after MPEG2 Sequence Header Code (used by XvMC) */
+#define VO_CHROMA_422        32 /* used by VDPAU, default is chroma_420 */
 
 /* video driver capabilities */
 #define VO_CAP_YV12                   0x00000001 /* driver can handle YUV 4:2:0 pictures */
@@ -280,6 +294,10 @@
 #define VO_CAP_UNSCALED_OVERLAY       0x00000010 /* driver can blend overlay at output resolution */
 #define VO_CAP_CROP                   0x00000020 /* driver can crop */
 #define VO_CAP_XXMC                   0x00000040 /* driver can use extended XvMC */
+#define VO_CAP_VDPAU_H264             0x00000080 /* driver can use VDPAU for H264 */
+#define VO_CAP_VDPAU_MPEG12           0x00000100 /* driver can use VDPAU for mpeg1/2 */
+#define VO_CAP_CUSTOM_EXTENT_OVERLAY  0x01000000 /* driver can blend custom extent overlay to output extent */
+#define VO_CAP_ARGB_LAYER_OVERLAY     0x02000000 /* driver supports true color overlay */
 
 
 /*
@@ -392,6 +410,14 @@
   uint16_t color;
 } rle_elem_t;
 
+typedef struct argb_layer_s {
+  pthread_mutex_t  mutex;
+  uint32_t        *buffer;
+  /* dirty area */
+  int x1, y1;
+  int x2, y2;
+} argb_layer_t;
+
 struct vo_overlay_s {
 
   rle_elem_t       *rle;           /* rle code buffer                  */
@@ -402,6 +428,10 @@
   int               width;         /* width of subpicture area         */
   int               height;        /* height of subpicture area        */
   
+  /* extent of reference coordinate system */
+  int               extent_width;
+  int               extent_height;
+
   uint32_t          color[OVL_PALETTE_SIZE];  /* color lookup table     */
   uint8_t           trans[OVL_PALETTE_SIZE];  /* mixer key table        */
   int               rgb_clut;      /* true if clut was converted to rgb */
@@ -416,6 +446,9 @@
   int               hili_rgb_clut; /* true if clut was converted to rgb */
   
   int               unscaled;      /* true if it should be blended unscaled */
+
+
+  argb_layer_t     *argb_layer;
 };
 
 
diff -Naur xine-lib-1.1.16.1-old/src/xine-engine/xine.c xine-lib-1.1.16.1-new/src/xine-engine/xine.c
--- xine-lib-1.1.16.1-old/src/xine-engine/xine.c	2008-06-25 06:04:09.000000000 -0700
+++ xine-lib-1.1.16.1-new/src/xine-engine/xine.c	2009-01-19 18:50:51.000000000 -0800
@@ -1963,6 +1963,8 @@
 
   stream->xine->port_ticket->acquire(stream->xine->port_ticket, 0);
   frame = stream->video_out->get_last_frame (stream->video_out);
+  if (frame)
+    frame->lock(frame);
   stream->xine->port_ticket->release(stream->xine->port_ticket, 0);
   
   if (!frame) {
@@ -1994,6 +1996,30 @@
 
   switch (frame->format) {
 
+  default:
+    if (frame->proc_provide_standard_frame_data) {
+      uint8_t *img = data->img;
+      size_t img_size = data->img_size;
+      data->img = 0;
+      data->img_size = 0;
+
+      /* ask frame implementation for required img buffer size */
+      frame->proc_provide_standard_frame_data(frame, data);
+      required_size = data->img_size;
+
+      data->img = img;
+      data->img_size = img_size;
+      break;
+    }
+
+    if (!data->img && !(flags & XINE_FRAME_DATA_ALLOCATE_IMG))
+      break; /* not interested in image data */
+
+    xprintf (stream->xine, XINE_VERBOSITY_DEBUG, 
+	     "xine: error, snapshot function not implemented for format 0x%x\n", frame->format);
+    /* fall though and provide "green" YV12 image */
+    data->format = XINE_IMGFMT_YV12;
+
   case XINE_IMGFMT_YV12:
     required_size = frame->width * frame->height
                   + ((frame->width + 1) / 2) * ((frame->height + 1) / 2)
@@ -2006,26 +2032,21 @@
                   + ((frame->width + 1) / 2) * frame->height;
     break;
 
-  default:
-    if (data->img || (flags & XINE_FRAME_DATA_ALLOCATE_IMG)) {
-      xprintf (stream->xine, XINE_VERBOSITY_DEBUG, 
-	       "xine: error, snapshot function not implemented for format 0x%x\n", frame->format);
-      _x_abort ();
-    }
-
-    required_size = 0;
   }
 
   if (flags & XINE_FRAME_DATA_ALLOCATE_IMG) {
     /* return allocated buffer size */
     data->img_size = required_size;
     /* allocate img or fail */
-    if (!(data->img = calloc(1, required_size)))
+    if (!(data->img = calloc(1, required_size))) {
+      frame->free(frame);
       return 0;
+    }
   } else {
     /* fail if supplied buffer is to small */
     if (data->img && !img_size_unknown && data->img_size < required_size) {
       data->img_size = required_size;
+      frame->free(frame);
       return 0;
     }
     /* return used buffer size */
@@ -2061,11 +2082,14 @@
       break;
 
     default:
-      xprintf (stream->xine, XINE_VERBOSITY_DEBUG, 
-	       "xine: error, snapshot function not implemented for format 0x%x\n", frame->format);
-      _x_abort ();
+      if (frame->proc_provide_standard_frame_data)
+        frame->proc_provide_standard_frame_data(frame, data);
+      else if (!(flags & XINE_FRAME_DATA_ALLOCATE_IMG))
+        memset(data->img, 0, data->img_size);
     }
   }
+
+  frame->free(frame);
   return 1;
 }
 
diff -Naur xine-lib-1.1.16.1-old/src/xine-engine/xine_interface.c xine-lib-1.1.16.1-new/src/xine-engine/xine_interface.c
--- xine-lib-1.1.16.1-old/src/xine-engine/xine_interface.c	2008-07-12 15:52:01.000000000 -0700
+++ xine-lib-1.1.16.1-new/src/xine-engine/xine_interface.c	2009-01-19 18:50:51.000000000 -0800
@@ -474,6 +474,8 @@
     stream->xine->verbosity = value;
     break;
 
+  case XINE_PARAM_VO_SHARPNESS:
+  case XINE_PARAM_VO_NOISE_REDUCTION:
   case XINE_PARAM_VO_HUE:
   case XINE_PARAM_VO_SATURATION:
   case XINE_PARAM_VO_CONTRAST:
@@ -635,6 +637,8 @@
     ret = stream->xine->verbosity;
     break;
 
+  case XINE_PARAM_VO_SHARPNESS:
+  case XINE_PARAM_VO_NOISE_REDUCTION:
   case XINE_PARAM_VO_HUE:
   case XINE_PARAM_VO_SATURATION:
   case XINE_PARAM_VO_CONTRAST:
@@ -855,6 +859,16 @@
   this->osd.renderer->draw_bitmap(&this->osd, bitmap, x1, y1, width, height, palette_map);
 }
 
+void xine_osd_set_argb_buffer(xine_osd_t *this, uint32_t *argb_buffer,
+    int dirty_x, int dirty_y, int dirty_width, int dirty_height) {
+  this->osd.renderer->set_argb_buffer(&this->osd, argb_buffer, dirty_x, dirty_y, dirty_width, dirty_height);
+}
+
+void xine_osd_set_extent(xine_osd_t *this, int extent_width, int extent_height) {
+  this->osd.renderer->set_extent(&this->osd, extent_width, extent_height);
+}
+
+
 const char *const *xine_post_list_inputs(xine_post_t *this_gen) {
   post_plugin_t *this = (post_plugin_t *)this_gen;
   return this->input_ids;
