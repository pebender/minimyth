diff -Naur MPlayer-27942.15845-old/codec-cfg.c MPlayer-27942.15845-new/codec-cfg.c
--- MPlayer-27942.15845-old/codec-cfg.c	2008-11-16 16:27:03.000000000 -0800
+++ MPlayer-27942.15845-new/codec-cfg.c	2008-11-16 16:50:05.000000000 -0800
@@ -182,6 +182,16 @@
 		{"IDCT_MPEG2",IMGFMT_XVMC_IDCT_MPEG2},
 		{"MOCO_MPEG2",IMGFMT_XVMC_MOCO_MPEG2},
 
+		{"VDPAU_MPEG1",IMGFMT_VDPAU_MPEG1},
+		{"VDPAU_MPEG2_SIMPLE",IMGFMT_VDPAU_MPEG2_SIMPLE},
+		{"VDPAU_MPEG2_MAIN",IMGFMT_VDPAU_MPEG2_MAIN},
+		{"VDPAU_H264_BASELINE",IMGFMT_VDPAU_H264_BASELINE},
+		{"VDPAU_H264_MAIN",IMGFMT_VDPAU_H264_MAIN},
+		{"VDPAU_H264_HIGH",IMGFMT_VDPAU_H264_HIGH},
+		{"VDPAU_VC1_SIMPLE",IMGFMT_VDPAU_VC1_SIMPLE},
+		{"VDPAU_VC1_MAIN",IMGFMT_VDPAU_VC1_MAIN},
+		{"VDPAU_VC1_ADVANCED",IMGFMT_VDPAU_VC1_ADVANCED},
+
 		{NULL,    0}
 	};
 
diff -Naur MPlayer-27942.15845-old/configure MPlayer-27942.15845-new/configure
--- MPlayer-27942.15845-old/configure	2008-11-16 16:27:03.000000000 -0800
+++ MPlayer-27942.15845-new/configure	2008-11-16 16:50:05.000000000 -0800
@@ -380,6 +380,7 @@
   --enable-xmga            enable mga_vid X11 video output [autodetect]
   --enable-xv              enable Xv video output [autodetect]
   --enable-xvmc            enable XvMC acceleration [disable]
+  --enable-vdpau           enable VDPAU acceleration [disable]
   --enable-vm              enable XF86VidMode support [autodetect]
   --enable-xinerama        enable Xinerama support [autodetect]
   --enable-x11             enable X11 video output [autodetect]
@@ -546,6 +547,7 @@
 _dga2=auto
 _xv=auto
 _xvmc=no  #auto when complete
+_vdpau=auto
 _sdl=auto
 _directx=auto
 _win32waveout=auto
@@ -865,6 +867,8 @@
   --disable-xv)		_xv=no		;;
   --enable-xvmc)        _xvmc=yes       ;;
   --disable-xvmc)       _xvmc=no        ;;
+  --enable-vdpau)       _vdpau=yes      ;;
+  --disable-vdpau)      _vdpau=no       ;;
   --enable-sdl)		_sdl=yes	;;
   --disable-sdl)	_sdl=no		;;
   --enable-directx)     _directx=yes    ;;
@@ -3991,7 +3995,7 @@
   _novomodules="x11 $_novomodules"
   _res_comment="check if the dev(el) packages are installed"
   # disable stuff that depends on X
-  _xv=no ; _xvmc=no ; _xinerama=no ; _vm=no ; _xf86keysym=no
+  _xv=no ; _xvmc=no ; _xinerama=no ; _vm=no ; _xf86keysym=no ; _vdpau=no
 fi
 echores "$_x11"
 
@@ -4104,6 +4108,31 @@
 echores "$_xvmc"
 
 
+echocheck "VDPAU"
+if test "$_vdpau" = auto ; then
+  cat > $TMPC <<EOF
+#include <vdpau/vdpau_x11.h>
+int main(void) {
+  (void)vdp_device_create_x11(0, 0, 0, 0);
+  return 0; }
+EOF
+  _vdpau=no
+  cc_check -lvdpau && _vdpau=yes
+fi
+
+if test "$_vdpau" = yes ; then
+  _def_vdpau='#define HAVE_VDPAU 1'
+  _libs_mplayer="$_libs_mplayer -lvdpau"
+  _vosrc="$_vosrc vo_vdpau.c"
+  _vomodules="vdpau $_vomodules"
+else
+  _def_vdpau='#undef HAVE_VDPAU'
+  _novomodules="vdpau $_novomodules"
+  _libavdecoders=`echo $_libavdecoders | sed -e s/MPEG_VDPAU_DECODER// `
+fi
+echores "$_vdpau"
+
+
 echocheck "Xinerama"
 if test "$_xinerama" = auto ; then
   cat > $TMPC <<EOF
@@ -8429,6 +8458,7 @@
 $_def_xss
 $_def_xv
 $_def_xvmc
+$_def_vdpau
 $_def_xvr100
 $_def_yuv4mpeg
 $_def_zr
diff -Naur MPlayer-27942.15845-old/etc/codecs.conf MPlayer-27942.15845-new/etc/codecs.conf
--- MPlayer-27942.15845-old/etc/codecs.conf	2008-11-16 16:27:02.000000000 -0800
+++ MPlayer-27942.15845-new/etc/codecs.conf	2008-11-16 16:50:05.000000000 -0800
@@ -254,6 +254,34 @@
   out IDCT_MPEG2
   out MOCO_MPEG2
 
+videocodec ffmpeg12vdpau
+  info "FFmpeg MPEG-1/2 (VDPAU)"
+  status working
+  format 0x10000001  ; MPEG-1
+  format 0x10000002  ; MPEG-2
+  fourcc mpg1,mpg2,MPG2
+  fourcc "DVR "
+  fourcc hdv1
+  fourcc hdv2
+  fourcc PIM1        ; Pinnacle hardware-MPEG-1
+  fourcc VCR2
+  fourcc MPEG
+  fourcc hdv3        ; HDV 1080i50
+  fourcc hdv5        ; HDV  720p25
+  fourcc mx5p        ; MPEG IMX 625/50 (50 Mb/s)
+  fourcc MMES,mmes   ; matrox mpeg2 in avi
+  fourcc hdv6,hdv7,hdv8
+  fourcc xdv1,xdv2,xdv3
+  fourcc xdv4,xdv5,xdv6
+  fourcc xdv7,xdv8,xdv9
+  fourcc xdva,xdvb,xdvc
+  fourcc xdvd,xdve,xdvf
+  driver ffmpeg
+  dll "mpegvideo_vdpau"
+  out VDPAU_MPEG1
+  out VDPAU_MPEG2_SIMPLE
+  out VDPAU_MPEG2_MAIN
+
 ; we have only native open source codecs for these:
 
 videocodec ffnuv
@@ -741,6 +769,15 @@
   dll wmv3
   out YV12,I420,IYUV
 
+videocodec ffwmv3vdpau
+  info "FFmpeg WMV3/WMV9 (VDPAU)"
+  status buggy
+  fourcc WMV3,wmv3
+  driver ffmpeg
+  dll wmv3_vdpau
+  out VDPAU_VC1_SIMPLE
+  out VDPAU_VC1_MAIN
+  
 videocodec ffvc1
   info "FFmpeg WVC1"
   status buggy
@@ -750,6 +787,14 @@
   dll vc1
   out YV12,I420,IYUV
 
+videocodec ffvc1vdpau
+  info "FFmpeg WVC1 (VDPAU)"
+  status buggy
+  fourcc WVC1,wvc1
+  driver ffmpeg
+  dll vc1_vdpau
+  out VDPAU_VC1_ADVANCED
+
 videocodec ffh264
   info "FFmpeg H.264"
   status working
@@ -762,6 +807,20 @@
   dll h264
   out YV12,I420,IYUV
 
+videocodec ffh264vdpau
+  info "FFmpeg H.264 (VDPAU)"
+  status working
+  fourcc H264,h264
+  fourcc X264,x264
+  fourcc avc1,AVC1
+  fourcc davc,DAVC
+  format 0x10000005
+  driver ffmpeg
+  dll h264_vdpau
+  out VDPAU_H264_BASELINE
+  out VDPAU_H264_MAIN
+  out VDPAU_H264_HIGH
+
 videocodec ffsvq3
   info "FFmpeg Sorenson Video v3 (SVQ3)"
   status working
diff -Naur MPlayer-27942.15845-old/help/help_mp-en.h MPlayer-27942.15845-new/help/help_mp-en.h
--- MPlayer-27942.15845-old/help/help_mp-en.h	2008-11-16 16:27:01.000000000 -0800
+++ MPlayer-27942.15845-new/help/help_mp-en.h	2008-11-16 16:50:05.000000000 -0800
@@ -1654,15 +1654,18 @@
 
 // libmpcodecs/vd_ffmpeg.c
 #define MSGTR_MPCODECS_XVMCAcceleratedCodec "[VD_FFMPEG] XVMC accelerated codec.\n"
+#define MSGTR_MPCODECS_VDPAUAcceleratedCodec "[VD_FFMPEG] VDPAU accelerated codec.\n"
 #define MSGTR_MPCODECS_ArithmeticMeanOfQP "[VD_FFMPEG] Arithmetic mean of QP: %2.4f, Harmonic mean of QP: %2.4f\n"
 #define MSGTR_MPCODECS_DRIFailure "[VD_FFMPEG] DRI failure.\n"
 #define MSGTR_MPCODECS_CouldntAllocateImageForCodec "[VD_FFMPEG] Couldn't allocate image for codec.\n"
 #define MSGTR_MPCODECS_XVMCAcceleratedMPEG2 "[VD_FFMPEG] XVMC-accelerated MPEG-2.\n"
 #define MSGTR_MPCODECS_TryingPixfmt "[VD_FFMPEG] Trying pixfmt=%d.\n"
 #define MSGTR_MPCODECS_McGetBufferShouldWorkOnlyWithXVMC "[VD_FFMPEG] The mc_get_buffer should work only with XVMC acceleration!!"
+#define MSGTR_MPCODECS_VDPAUGetBufferShouldWorkOnlyWithVDPAU "[VD_FFMPEG] The mc_get_buffer should work only with VDPAU acceleration!!"
 #define MSGTR_MPCODECS_UnexpectedInitVoError "[VD_FFMPEG] Unexpected init_vo error.\n"
 #define MSGTR_MPCODECS_UnrecoverableErrorRenderBuffersNotTaken "[VD_FFMPEG] Unrecoverable error, render buffers not taken.\n"
 #define MSGTR_MPCODECS_OnlyBuffersAllocatedByVoXvmcAllowed "[VD_FFMPEG] Only buffers allocated by vo_xvmc allowed.\n"
+#define MSGTR_MPCODECS_OnlyBuffersAllocatedByVoVdpauAllowed "[VD_FFMPEG] Only buffers allocated by vo_vdpau allowed.\n"
 
 // libmpcodecs/ve_lavc.c
 #define MSGTR_MPCODECS_HighQualityEncodingSelected "[VE_LAVC] High quality encoding selected (non-realtime)!\n"
diff -Naur MPlayer-27942.15845-old/libavcodec/allcodecs.c MPlayer-27942.15845-new/libavcodec/allcodecs.c
--- MPlayer-27942.15845-old/libavcodec/allcodecs.c	2008-11-16 16:27:48.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/allcodecs.c	2008-11-16 16:49:52.000000000 -0800
@@ -98,6 +98,7 @@
     REGISTER_DECODER (H263I, h263i);
     REGISTER_ENCODER (H263P, h263p);
     REGISTER_DECODER (H264, h264);
+    REGISTER_DECODER (H264_VDPAU, h264_vdpau);
     REGISTER_ENCDEC  (HUFFYUV, huffyuv);
     REGISTER_DECODER (IDCIN, idcin);
     REGISTER_DECODER (INDEO2, indeo2);
@@ -114,6 +115,7 @@
     REGISTER_DECODER (MMVIDEO, mmvideo);
     REGISTER_DECODER (MOTIONPIXELS, motionpixels);
     REGISTER_DECODER (MPEG_XVMC, mpeg_xvmc);
+    REGISTER_DECODER (MPEG_VDPAU, mpeg_vdpau);
     REGISTER_ENCDEC  (MPEG1VIDEO, mpeg1video);
     REGISTER_ENCDEC  (MPEG2VIDEO, mpeg2video);
     REGISTER_ENCDEC  (MPEG4, mpeg4);
@@ -162,6 +164,7 @@
     REGISTER_DECODER (ULTI, ulti);
     REGISTER_DECODER (VB, vb);
     REGISTER_DECODER (VC1, vc1);
+    REGISTER_DECODER (VC1_VDPAU, vc1_vdpau);
     REGISTER_DECODER (VCR1, vcr1);
     REGISTER_DECODER (VMDVIDEO, vmdvideo);
     REGISTER_DECODER (VMNC, vmnc);
@@ -174,6 +177,7 @@
     REGISTER_ENCDEC  (WMV1, wmv1);
     REGISTER_ENCDEC  (WMV2, wmv2);
     REGISTER_DECODER (WMV3, wmv3);
+    REGISTER_DECODER (WMV3_VDPAU, wmv3_vdpau);
     REGISTER_DECODER (WNV1, wnv1);
     REGISTER_DECODER (XAN_WC3, xan_wc3);
     REGISTER_DECODER (XL, xl);
diff -Naur MPlayer-27942.15845-old/libavcodec/avcodec.h MPlayer-27942.15845-new/libavcodec/avcodec.h
--- MPlayer-27942.15845-old/libavcodec/avcodec.h	2008-11-16 16:27:48.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/avcodec.h	2008-11-16 16:49:52.000000000 -0800
@@ -190,6 +190,10 @@
     CODEC_ID_MOTIONPIXELS,
     CODEC_ID_TGV,
     CODEC_ID_TGQ,
+    CODEC_ID_MPEGVIDEO_VDPAU,
+    CODEC_ID_H264_VDPAU,
+    CODEC_ID_VC1_VDPAU,
+    CODEC_ID_WMV3_VDPAU,
 
     /* various PCM "codecs" */
     CODEC_ID_PCM_S16LE= 0x10000,
@@ -526,6 +530,8 @@
  * This can be used to prevent truncation of the last audio samples.
  */
 #define CODEC_CAP_SMALL_LAST_FRAME 0x0040
+/* Codec can export data for HW decoding (VDPAU). */
+#define CODEC_CAP_HWACCEL_VDPAU    0x0080
 
 //The following defines may change, don't expect compatibility if you use them.
 #define MB_TYPE_INTRA4x4   0x0001
@@ -1736,6 +1742,13 @@
     int xvmc_acceleration;
 
     /**
+     * VDPAU Acceleration
+     * - encoding: forbidden
+     * - decoding: set by decoder
+     */
+    int vdpau_acceleration;
+
+    /**
      * macroblock decision mode
      * - encoding: Set by user.
      * - decoding: unused
diff -Naur MPlayer-27942.15845-old/libavcodec/h263dec.c MPlayer-27942.15845-new/libavcodec/h263dec.c
--- MPlayer-27942.15845-old/libavcodec/h263dec.c	2008-11-16 16:27:47.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/h263dec.c	2008-11-16 16:49:52.000000000 -0800
@@ -92,6 +92,8 @@
         break;
     case CODEC_ID_VC1:
     case CODEC_ID_WMV3:
+    case CODEC_ID_VC1_VDPAU:
+    case CODEC_ID_WMV3_VDPAU:
         s->h263_msmpeg4 = 1;
         s->h263_pred = 1;
         s->msmpeg4_version=6;
diff -Naur MPlayer-27942.15845-old/libavcodec/h264.c MPlayer-27942.15845-new/libavcodec/h264.c
--- MPlayer-27942.15845-old/libavcodec/h264.c	2008-11-16 16:27:47.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/h264.c	2008-11-16 16:49:52.000000000 -0800
@@ -72,6 +72,10 @@
 static VLC_TYPE run7_vlc_table[96][2];
 static const int run7_vlc_table_size = 96;
 
+extern int VDPAU_h264_set_reference_frames(H264Context *h);
+extern int VDPAU_h264_picture_complete(H264Context *h, const uint8_t *buf, int buf_size);
+extern void VDPAU_h264_set_reference_frames_count(H264Context *h);
+
 static void svq3_luma_dc_dequant_idct_c(DCTELEM *block, int qp);
 static void svq3_add_idct_c(uint8_t *dst, DCTELEM *block, int stride, int qp, int dc);
 static void filter_mb( H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize);
@@ -101,6 +105,16 @@
     {0,2,0,2,7,10,7,10}
 };
 
+static const enum PixelFormat pixfmt_vdpau_h264_baseline_420[] = {
+                                           PIX_FMT_VDPAU_H264_BASELINE,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_h264_main_420[] = {
+                                           PIX_FMT_VDPAU_H264_MAIN,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_h264_high_420[] = {
+                                           PIX_FMT_VDPAU_H264_HIGH,
+                                           PIX_FMT_NONE};
+
 static void fill_caches(H264Context *h, int mb_type, int for_deblock){
     MpegEncContext * const s = &h->s;
     const int mb_xy= h->mb_xy;
@@ -2221,10 +2235,8 @@
     s->quarter_sample = 1;
     s->low_delay= 1;
 
-    if(avctx->codec_id == CODEC_ID_SVQ3)
-        avctx->pix_fmt= PIX_FMT_YUVJ420P;
-    else
-        avctx->pix_fmt= PIX_FMT_YUV420P;
+    // Set in decode_postinit() once initial parsing is complete
+    avctx->pix_fmt = PIX_FMT_NONE;
 
     decode_init_vlc();
 
@@ -2242,10 +2254,43 @@
     return 0;
 }
 
+static int decode_postinit(H264Context *h, SPS *sps){
+    AVCodecContext * const avctx= h->s.avctx;
+
+    if (avctx->pix_fmt != PIX_FMT_NONE){
+        return 0;
+    }
+
+    if (avctx->vdpau_acceleration) {
+        if(h->s.chroma_format >= 2) {
+            return -2;
+        }
+        if (sps->profile_idc == 66) {
+            avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_h264_baseline_420);
+        } else if (sps->profile_idc == 77) {
+            avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_h264_main_420);
+        } else if (sps->profile_idc == 100) {
+            avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_h264_high_420);
+        } else {
+            return -2;
+        }
+    } else if (avctx->codec_id == CODEC_ID_SVQ3) {
+        avctx->pix_fmt= PIX_FMT_YUVJ420P;
+    } else {
+        avctx->pix_fmt= PIX_FMT_YUV420P;
+    }
+
+    return 0;
+}
+
 static int frame_start(H264Context *h){
     MpegEncContext * const s = &h->s;
     int i;
 
+#ifdef HAVE_VDPAU
+    VDPAU_h264_set_reference_frames_count(h);
+#endif
+
     if(MPV_frame_start(s, s->avctx) < 0)
         return -1;
     ff_er_frame_start(s);
@@ -7205,6 +7250,10 @@
                ((const char*[]){"Gray","420","422","444"})[sps->chroma_format_idc]
                );
     }
+
+    if (decode_postinit(h, sps) < 0)
+        return -1;
+
     return 0;
 }
 
@@ -7337,7 +7386,9 @@
     H264Context *hx;
     int i;
 
-    if(context_count == 1) {
+    if(avctx->vdpau_acceleration) {
+        return;
+    } else if(context_count == 1) {
         decode_slice(avctx, &h);
     } else {
         for(i = 1; i < context_count; i++) {
@@ -7660,6 +7711,12 @@
         s->current_picture_ptr->qscale_type= FF_QSCALE_TYPE_H264;
         s->current_picture_ptr->pict_type= s->pict_type;
 
+#ifdef HAVE_VDPAU
+        if (avctx->vdpau_acceleration) {
+            VDPAU_h264_set_reference_frames(h);
+        }
+#endif
+
         if(!s->dropable) {
             execute_ref_pic_marking(h, h->mmco, h->mmco_index);
             h->prev_poc_msb= h->poc_msb;
@@ -7668,6 +7725,12 @@
         h->prev_frame_num_offset= h->frame_num_offset;
         h->prev_frame_num= h->frame_num;
 
+#ifdef HAVE_VDPAU
+        if (avctx->vdpau_acceleration) {
+            VDPAU_h264_picture_complete(h, buf, buf_size);
+        }
+#endif
+
         /*
          * FIXME: Error handling code does not seem to support interlaced
          * when slices span multiple rows
@@ -7680,8 +7743,11 @@
          * past end by one (callers fault) and resync_mb_y != 0
          * causes problems for the first MB line, too.
          */
-        if (!FIELD_PICTURE)
-            ff_er_frame_end(s);
+#ifdef HAVE_VDPAU
+        if (!avctx->vdpau_acceleration)
+#endif
+            if (!FIELD_PICTURE)
+                ff_er_frame_end(s);
 
         MPV_frame_end(s);
 
@@ -8053,4 +8119,35 @@
     .long_name = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"),
 };
 
+#ifdef HAVE_VDPAU
+static av_cold int h264_vdpau_decode_init(AVCodecContext *avctx){
+    if( avctx->thread_count > 1)
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_CODED_ORDER) )
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD) ){
+        dprintf(avctx, "h264.c: VDPAU decoder does not set SLICE_FLAG_ALLOW_FIELD\n");
+    }
+    decode_init(avctx);
+
+    avctx->vdpau_acceleration = 1;
+
+    return 0;
+}
+
+AVCodec h264_vdpau_decoder = {
+    "h264_vdpau",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_H264_VDPAU,
+    sizeof(H264Context),
+    h264_vdpau_decode_init,
+    NULL,
+    decode_end,
+    decode_frame,
+    CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,
+    .flush= flush_dpb,
+    .long_name = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (VDPAU acceleration)"),
+};
+#endif
+
 #include "svq3.c"
diff -Naur MPlayer-27942.15845-old/libavcodec/imgconvert.c MPlayer-27942.15845-new/libavcodec/imgconvert.c
--- MPlayer-27942.15845-old/libavcodec/imgconvert.c	2008-11-16 16:27:48.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/imgconvert.c	2008-11-16 16:49:52.000000000 -0800
@@ -266,6 +266,33 @@
     [PIX_FMT_XVMC_MPEG2_IDCT] = {
         .name = "xvmcidct",
     },
+    [PIX_FMT_VDPAU_MPEG1] = {
+        .name = "vdpau_mpeg1",
+    },
+    [PIX_FMT_VDPAU_MPEG2_SIMPLE] = {
+        .name = "vdpau_mpeg2_simple",
+    },
+    [PIX_FMT_VDPAU_MPEG2_MAIN] = {
+        .name = "vdpau_mpeg2_main",
+    },
+    [PIX_FMT_VDPAU_H264_BASELINE] = {
+        .name = "vdpau_h264_baseline",
+    },
+    [PIX_FMT_VDPAU_H264_MAIN] = {
+        .name = "vdpau_h264_main",
+    },
+    [PIX_FMT_VDPAU_H264_HIGH] = {
+        .name = "vdpau_h264_high",
+    },
+    [PIX_FMT_VDPAU_VC1_SIMPLE] = {
+        .name = "vdpau_vc1_simple",
+    },
+    [PIX_FMT_VDPAU_VC1_MAIN] = {
+        .name = "vdpau_vc1_main",
+    },
+    [PIX_FMT_VDPAU_VC1_ADVANCED] = {
+        .name = "vdpau_vc1_advanced",
+    },
     [PIX_FMT_UYYVYY411] = {
         .name = "uyyvyy411",
         .nb_channels = 1,
diff -Naur MPlayer-27942.15845-old/libavcodec/Makefile MPlayer-27942.15845-new/libavcodec/Makefile
--- MPlayer-27942.15845-old/libavcodec/Makefile	2008-11-16 16:27:47.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/Makefile	2008-11-16 16:49:52.000000000 -0800
@@ -382,6 +382,7 @@
 OBJS-$(HAVE_W32THREADS)                += w32thread.o
 
 OBJS-$(HAVE_XVMC)                      += xvmcvideo.o
+OBJS-$(HAVE_VDPAU)                     += vdpauvideo.o
 
 ifndef CONFIG_SWSCALE
 OBJS += imgresample.o
diff -Naur MPlayer-27942.15845-old/libavcodec/mpeg12.c MPlayer-27942.15845-new/libavcodec/mpeg12.c
--- MPlayer-27942.15845-old/libavcodec/mpeg12.c	2008-11-16 16:27:47.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/mpeg12.c	2008-11-16 16:49:52.000000000 -0800
@@ -68,10 +68,22 @@
 extern void XVMC_pack_pblocks(MpegEncContext *s,int cbp);
 extern void XVMC_init_block(MpegEncContext *s);//set s->block
 
+extern int VDPAU_mpeg_field_start(MpegEncContext *s);
+extern void VDPAU_mpeg_picture_complete(MpegEncContext *s, const uint8_t *buf, int buf_size, int slice_count);
+
 static const enum PixelFormat pixfmt_xvmc_mpg2_420[] = {
                                            PIX_FMT_XVMC_MPEG2_IDCT,
                                            PIX_FMT_XVMC_MPEG2_MC,
                                            PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_mpg1_420[] = {
+                                           PIX_FMT_VDPAU_MPEG1,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_mpg2simple_420[] = {
+                                           PIX_FMT_VDPAU_MPEG2_SIMPLE,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_mpg2main_420[] = {
+                                           PIX_FMT_VDPAU_MPEG2_MAIN,
+                                           PIX_FMT_NONE};
 
 uint8_t ff_mpeg12_static_rl_table_store[2][2][2*MAX_RUN + MAX_LEVEL + 3];
 
@@ -1288,7 +1300,23 @@
             }
         }//MPEG-2
 
-        if(avctx->xvmc_acceleration){
+        if(avctx->vdpau_acceleration){
+            if(s->chroma_format >= 2){
+                return -2;
+            }
+            if(avctx->sub_id == 1){
+                avctx->pix_fmt = avctx->get_format(avctx,pixfmt_vdpau_mpg1_420);
+            }else{
+                if(avctx->profile == 5){
+                    avctx->pix_fmt = avctx->get_format(avctx,pixfmt_vdpau_mpg2simple_420);
+                }else
+                if(avctx->profile == 4){
+                    avctx->pix_fmt = avctx->get_format(avctx,pixfmt_vdpau_mpg2main_420);
+                }else{
+                    return -2;
+                }
+            }
+        }else if(avctx->xvmc_acceleration){
             avctx->pix_fmt = avctx->get_format(avctx,pixfmt_xvmc_mpg2_420);
         }else{
             if(s->chroma_format <  2){
@@ -1646,6 +1674,11 @@
          XVMC_field_start(s,avctx);
 #endif
 
+#ifdef HAVE_VDPAU
+    if(s->avctx->vdpau_acceleration)
+         VDPAU_mpeg_field_start(s);
+#endif
+
     return 0;
 }
 
@@ -1922,7 +1955,10 @@
 
         s->current_picture_ptr->qscale_type= FF_QSCALE_TYPE_MPEG2;
 
-        ff_er_frame_end(s);
+#ifdef HAVE_VDPAU
+        if(!s->avctx->vdpau_acceleration)
+#endif
+            ff_er_frame_end(s);
 
         MPV_frame_end(s);
 
@@ -2069,7 +2105,23 @@
     avctx->has_b_frames= 0; //true?
     s->low_delay= 1;
 
-    if(avctx->xvmc_acceleration){
+    if(avctx->vdpau_acceleration){
+        if(s->chroma_format >= 2){
+            return -2;
+        }
+        if(avctx->sub_id == 1){
+            avctx->pix_fmt = avctx->get_format(avctx,pixfmt_vdpau_mpg1_420);
+        }else{
+            if(avctx->profile == 5){
+                avctx->pix_fmt = avctx->get_format(avctx,pixfmt_vdpau_mpg2simple_420);
+            }else
+            if(avctx->profile == 4){
+                avctx->pix_fmt = avctx->get_format(avctx,pixfmt_vdpau_mpg2main_420);
+            }else{
+                return -2;
+            }
+        }
+    }else if(avctx->xvmc_acceleration){
         avctx->pix_fmt = avctx->get_format(avctx,pixfmt_xvmc_mpg2_420);
     }else{
         avctx->pix_fmt = PIX_FMT_YUV420P;
@@ -2303,6 +2355,14 @@
                     for(i=0; i<s->slice_count; i++)
                         s2->error_count += s2->thread_context[i]->error_count;
                 }
+
+#ifdef HAVE_VDPAU
+                if (avctx->vdpau_acceleration) {
+                    /* Fills mpeg12 picture informations before returing from libavcodec. */
+                    VDPAU_mpeg_picture_complete(s2, buf, buf_size, s->slice_count);
+                }
+#endif
+
                 if (slice_end(avctx, picture)) {
                     if(s2->last_picture_ptr || s2->low_delay) //FIXME merge with the stuff in mpeg_decode_slice
                         *data_size = sizeof(AVPicture);
@@ -2388,6 +2448,11 @@
                     return -1;
                 }
 
+                if (avctx->vdpau_acceleration) {
+                    s->slice_count++;
+                    break;                
+                }
+
                 if(avctx->thread_count > 1){
                     int threshold= (s2->mb_height*s->slice_count + avctx->thread_count/2) / avctx->thread_count;
                     if(threshold <= mb_y){
@@ -2507,3 +2572,36 @@
 };
 
 #endif
+
+#ifdef HAVE_VDPAU
+static av_cold int mpeg_vdpau_decode_init(AVCodecContext *avctx){
+    if( avctx->thread_count > 1)
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_CODED_ORDER) )
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD) ){
+        dprintf(avctx, "mpeg12.c: VDPAU decoder does not set SLICE_FLAG_ALLOW_FIELD\n");
+    }
+    mpeg_decode_init(avctx);
+
+    // Set in mpeg_decode_postinit() once initial parsing is complete
+    avctx->pix_fmt = PIX_FMT_NONE;
+    avctx->vdpau_acceleration = 1;
+
+    return 0;
+}
+
+AVCodec mpeg_vdpau_decoder = {
+    "mpegvideo_vdpau",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_MPEGVIDEO_VDPAU,
+    sizeof(Mpeg1Context),
+    mpeg_vdpau_decode_init,
+    NULL,
+    mpeg_decode_end,
+    mpeg_decode_frame,
+    CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED | CODEC_CAP_HWACCEL_VDPAU | CODEC_CAP_DELAY,
+    .flush= ff_mpeg_flush,
+    .long_name = NULL_IF_CONFIG_SMALL("MPEG-1/2 video (VDPAU acceleration)"),
+};
+#endif
diff -Naur MPlayer-27942.15845-old/libavcodec/mpegvideo.c MPlayer-27942.15845-new/libavcodec/mpegvideo.c
--- MPlayer-27942.15845-old/libavcodec/mpegvideo.c	2008-11-16 16:27:47.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/mpegvideo.c	2008-11-16 16:49:52.000000000 -0800
@@ -58,6 +58,7 @@
 extern void XVMC_field_end(MpegEncContext *s);
 extern void XVMC_decode_mb(MpegEncContext *s);
 
+extern int VDPAU_mpeg_field_start(MpegEncContext *s);
 
 /* enable all paranoid tests for rounding, overflows, etc... */
 //#define PARANOID
@@ -954,6 +955,10 @@
         XVMC_field_end(s);
     }else
 #endif
+#ifdef HAVE_VDPAU
+    if(s->avctx->vdpau_acceleration){
+    }else
+#endif
     if(s->unrestricted_mv && s->current_picture.reference && !s->intra_only && !(s->flags&CODEC_FLAG_EMU_EDGE)) {
             s->dsp.draw_edges(s->current_picture.data[0], s->linesize  , s->h_edge_pos   , s->v_edge_pos   , EDGE_WIDTH  );
             s->dsp.draw_edges(s->current_picture.data[1], s->uvlinesize, s->h_edge_pos>>1, s->v_edge_pos>>1, EDGE_WIDTH/2);
diff -Naur MPlayer-27942.15845-old/libavcodec/utils.c MPlayer-27942.15845-new/libavcodec/utils.c
--- MPlayer-27942.15845-old/libavcodec/utils.c	2008-11-16 16:27:47.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/utils.c	2008-11-16 16:49:52.000000000 -0800
@@ -644,6 +644,7 @@
 {"context", "context model", OFFSET(context_model), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, V|E},
 {"slice_flags", NULL, OFFSET(slice_flags), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX},
 {"xvmc_acceleration", NULL, OFFSET(xvmc_acceleration), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX},
+{"vdpau_acceleration", NULL, OFFSET(vdpau_acceleration), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX},
 {"mbd", "macroblock decision algorithm (high quality mode)", OFFSET(mb_decision), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, V|E, "mbd"},
 {"simple", "use mbcmp (default)", 0, FF_OPT_TYPE_CONST, FF_MB_DECISION_SIMPLE, INT_MIN, INT_MAX, V|E, "mbd"},
 {"bits", "use fewest bits", 0, FF_OPT_TYPE_CONST, FF_MB_DECISION_BITS, INT_MIN, INT_MAX, V|E, "mbd"},
diff -Naur MPlayer-27942.15845-old/libavcodec/vc1.c MPlayer-27942.15845-new/libavcodec/vc1.c
--- MPlayer-27942.15845-old/libavcodec/vc1.c	2008-11-16 16:27:48.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/vc1.c	2008-11-16 16:49:52.000000000 -0800
@@ -41,8 +41,22 @@
 #define MB_INTRA_VLC_BITS 9
 #define DC_VLC_BITS 9
 #define AC_VLC_BITS 9
+
+extern int VDPAU_vc1_decode_picture(MpegEncContext *s, AVCodecContext *avctx, VC1Context *v, const uint8_t *buf, int buf_size);
+
 static const uint16_t table_mb_intra[64][2];
 
+#ifdef HAVE_VDPAU
+static const enum PixelFormat pixfmt_vdpau_vc1_simple_420[] = {
+                                           PIX_FMT_VDPAU_VC1_SIMPLE,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_vc1_main_420[] = {
+                                           PIX_FMT_VDPAU_VC1_MAIN,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_vc1_advanced_420[] = {
+                                           PIX_FMT_VDPAU_VC1_ADVANCED,
+                                           PIX_FMT_NONE};
+#endif
 
 /**
  * Init VC-1 specific tables and VC1Context members
@@ -828,6 +842,29 @@
     }
 }
 
+#ifdef HAVE_VDPAU
+static int decode_postinit(VC1Context *v, AVCodecContext *avctx)
+{
+    if (avctx->pix_fmt != PIX_FMT_NONE){
+        return 0;
+    }
+
+    if (avctx->vdpau_acceleration) { // VC1
+        if (v->profile == 0) {
+            avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_vc1_simple_420);
+        } else if (v->profile == 1) {
+            avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_vc1_main_420);
+        } else if (v->profile == 3) {
+            avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_vc1_advanced_420);
+        } else {
+            return -2;
+        }            
+    } 
+
+    return 0;
+}
+#endif
+
 static int decode_sequence_header_adv(VC1Context *v, GetBitContext *gb);
 
 /**
@@ -1007,8 +1044,24 @@
     if(get_bits1(gb)) { //Display Info - decoding is not affected by it
         int w, h, ar = 0;
         av_log(v->s.avctx, AV_LOG_DEBUG, "Display extended info:\n");
-        v->s.avctx->width  = v->s.width  = w = get_bits(gb, 14) + 1;
-        v->s.avctx->height = v->s.height = h = get_bits(gb, 14) + 1;
+        // FIXME: The w/h parsed here are the *display* width/height, not the
+        // coded width/height. Ideally, we should make the commented
+        // assignments below, but that causes problems:
+        // * The SW decoder in this file experiences errors, because it
+        //   assumes these assigned values are the coded size:
+        //   [vc1 @ 0x86f2130]concealing 150 DC, 150 AC, 150 MV errors
+        // * VDPAU also assumes these are the coded size, since this is the
+        //   only size passed to vo_vdpau.c:config(). This causes errors
+        //   during the decode process.
+        // However, simply removing these assignments is not the complete fix,
+        // because without them, the stream is displayed at its coded size,
+        // not this requested display size. Ideally, setting:
+        // sample_aspect_ratio = (AVRational){w, h}
+        // in the case when ar is not present/set would persuade other modules
+        // to scale to this requested size. However, sample_aspect_ratio
+        // appears to be completely ignored elsewhere.
+        /*v->s.avctx->width  = v->s.width  =*/ w = get_bits(gb, 14) + 1;
+        /*v->s.avctx->height = v->s.height =*/ h = get_bits(gb, 14) + 1;
         av_log(v->s.avctx, AV_LOG_DEBUG, "Display dimensions: %ix%i\n", w, h);
         if(get_bits1(gb))
             ar = get_bits(gb, 4);
@@ -1059,13 +1112,13 @@
 static int decode_entry_point(AVCodecContext *avctx, GetBitContext *gb)
 {
     VC1Context *v = avctx->priv_data;
-    int i, blink, clentry, refdist;
+    int i, blink, clentry;
 
     av_log(avctx, AV_LOG_DEBUG, "Entry point: %08X\n", show_bits_long(gb, 32));
     blink = get_bits1(gb); // broken link
     clentry = get_bits1(gb); // closed entry
     v->panscanflag = get_bits1(gb);
-    refdist = get_bits1(gb); // refdist flag
+    v->refdist_flag = get_bits1(gb);
     v->s.loop_filter = get_bits1(gb);
     v->fastuvmc = get_bits1(gb);
     v->extended_mv = get_bits1(gb);
@@ -1086,20 +1139,22 @@
     }
     if(v->extended_mv)
         v->extended_dmv = get_bits1(gb);
-    if(get_bits1(gb)) {
+    v->range_mapy_flag = get_bits1(gb);
+    if(v->range_mapy_flag) {
         av_log(avctx, AV_LOG_ERROR, "Luma scaling is not supported, expect wrong picture\n");
-        skip_bits(gb, 3); // Y range, ignored for now
+        v->range_mapy = get_bits(gb, 3);
     }
-    if(get_bits1(gb)) {
+    v->range_mapuv_flag = get_bits1(gb);
+    if(v->range_mapuv_flag) {
         av_log(avctx, AV_LOG_ERROR, "Chroma scaling is not supported, expect wrong picture\n");
-        skip_bits(gb, 3); // UV range, ignored for now
+        v->range_mapuv = get_bits(gb, 3);
     }
 
     av_log(avctx, AV_LOG_DEBUG, "Entry point info:\n"
         "BrokenLink=%i, ClosedEntry=%i, PanscanFlag=%i\n"
         "RefDist=%i, Postproc=%i, FastUVMC=%i, ExtMV=%i\n"
         "DQuant=%i, VSTransform=%i, Overlap=%i, Qmode=%i\n",
-        blink, clentry, v->panscanflag, refdist, v->s.loop_filter,
+        blink, clentry, v->panscanflag, v->refdist_flag, v->s.loop_filter,
         v->fastuvmc, v->extended_mv, v->dquant, v->vstransform, v->overlap, v->quantizer_mode);
 
     return 0;
@@ -1399,6 +1454,9 @@
 
     if(v->s.pict_type == FF_I_TYPE || v->s.pict_type == FF_P_TYPE) v->use_ic = 0;
 
+    if(v->postprocflag)
+        v->postproc = get_bits(gb, 2);
+
     switch(v->s.pict_type) {
     case FF_I_TYPE:
     case FF_BI_TYPE:
@@ -3996,7 +4054,7 @@
 
     avctx->coded_width = avctx->width;
     avctx->coded_height = avctx->height;
-    if (avctx->codec_id == CODEC_ID_WMV3)
+    if ((avctx->codec_id == CODEC_ID_WMV3) || (avctx->codec_id == CODEC_ID_WMV3_VDPAU))
     {
         int count = 0;
 
@@ -4111,6 +4169,9 @@
     MpegEncContext *s = &v->s;
     AVFrame *pict = data;
     uint8_t *buf2 = NULL;
+#ifdef HAVE_VDPAU
+    const uint8_t *buf_vdpau = buf;
+#endif
 
     /* no supplementary picture */
     if (buf_size == 0) {
@@ -4132,8 +4193,14 @@
         s->current_picture_ptr= &s->picture[i];
     }
 
+#ifdef HAVE_VDPAU
+    // pxt_fmt calculation for VDPAU.
+    if (decode_postinit(v, avctx) < 0)
+        return -1;
+#endif
+
     //for advanced profile we may need to parse and unescape data
-    if (avctx->codec_id == CODEC_ID_VC1) {
+    if ((avctx->codec_id == CODEC_ID_VC1) || (avctx->codec_id == CODEC_ID_VC1_VDPAU)) {
         int buf_size2 = 0;
         buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
@@ -4148,6 +4215,9 @@
                 if(size <= 0) continue;
                 switch(AV_RB32(start)){
                 case VC1_CODE_FRAME:
+#ifdef HAVE_VDPAU
+                    buf_vdpau = start;
+#endif
                     buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);
                     break;
                 case VC1_CODE_ENTRYPOINT: /* it should be before frame data */
@@ -4233,17 +4303,36 @@
         return -1;
     }
 
+#ifdef HAVE_VDPAU
+    // MPV_frame_start() calls to  get_buffer/videoSurfaces. Now we call
+    // VDPAU_vc1_field_start where picture-parameters are filled.
+    // VDPAU_vc1_picture_complete calls to vdpau_decoder_render.
+
+    if (avctx->vdpau_acceleration) {
+        if (VDPAU_vc1_decode_picture(s, avctx, v, buf_vdpau, (buf + buf_size) - buf_vdpau) < 0) {
+            av_free(buf2);
+            return -1;
+        }
+    }
+#endif
+
     s->me.qpel_put= s->dsp.put_qpel_pixels_tab;
     s->me.qpel_avg= s->dsp.avg_qpel_pixels_tab;
 
-    ff_er_frame_start(s);
+#ifdef HAVE_VDPAU
+    if (!avctx->vdpau_acceleration) {
+#endif
+        ff_er_frame_start(s);
 
-    v->bits = buf_size * 8;
-    vc1_decode_blocks(v);
+        v->bits = buf_size * 8;
+        vc1_decode_blocks(v);
 //av_log(s->avctx, AV_LOG_INFO, "Consumed %i/%i bits\n", get_bits_count(&s->gb), buf_size*8);
 //  if(get_bits_count(&s->gb) > buf_size * 8)
 //      return -1;
-    ff_er_frame_end(s);
+        ff_er_frame_end(s);
+#ifdef HAVE_VDPAU
+    }
+#endif
 
     MPV_frame_end(s);
 
@@ -4317,3 +4406,48 @@
     NULL,
     .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 9"),
 };
+
+#ifdef HAVE_VDPAU
+static av_cold int vc1_vdpau_decode_init(AVCodecContext *avctx){
+    if( avctx->thread_count > 1)
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_CODED_ORDER) )
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD) ){
+        dprintf(avctx, "vc1.c: VDPAU decoder does not set SLICE_FLAG_ALLOW_FIELD\n");
+    }
+    avctx->vdpau_acceleration = 1;
+    vc1_decode_init(avctx);
+    avctx->pix_fmt = PIX_FMT_NONE;
+
+    return 0;
+}
+
+AVCodec wmv3_vdpau_decoder = {
+    "wmv3_vdpau",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_WMV3_VDPAU,
+    sizeof(VC1Context),
+    vc1_vdpau_decode_init,
+    NULL,
+    vc1_decode_end,
+    vc1_decode_frame,
+    CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,
+    NULL,
+    .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 9 VDPAU"),
+};
+
+AVCodec vc1_vdpau_decoder = {
+    "vc1_vdpau",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_VC1_VDPAU,
+    sizeof(VC1Context),
+    vc1_vdpau_decode_init,
+    NULL,
+    vc1_decode_end,
+    vc1_decode_frame,
+    CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,
+    NULL,
+    .long_name = NULL_IF_CONFIG_SMALL("SMPTE VC-1 VDPAU"),
+};
+#endif
diff -Naur MPlayer-27942.15845-old/libavcodec/vc1.h MPlayer-27942.15845-new/libavcodec/vc1.h
--- MPlayer-27942.15845-old/libavcodec/vc1.h	2008-11-16 16:27:48.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/vc1.h	2008-11-16 16:49:52.000000000 -0800
@@ -180,6 +180,7 @@
     int interlace;        ///< Progressive/interlaced (RPTFTM syntax element)
     int tfcntrflag;       ///< TFCNTR present
     int panscanflag;      ///< NUMPANSCANWIN, TOPLEFT{X,Y}, BOTRIGHT{X,Y} present
+    int refdist_flag;     ///<
     int extended_dmv;     ///< Additional extended dmv range at P/B frame-level
     int color_prim;       ///< 8bits, chroma coordinates of the color primaries
     int transfer_char;    ///< 8bits, Opto-electronic transfer characteristics
diff -Naur MPlayer-27942.15845-old/libavcodec/vdpau_render.h MPlayer-27942.15845-new/libavcodec/vdpau_render.h
--- MPlayer-27942.15845-old/libavcodec/vdpau_render.h	1969-12-31 16:00:00.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/vdpau_render.h	2008-11-16 16:49:52.000000000 -0800
@@ -0,0 +1,30 @@
+#ifndef FFMPEG_VDPAU_RENDER_H
+#define FFMPEG_VDPAU_RENDER_H
+
+#include "vdpau/vdpau.h"
+#include "vdpau/vdpau_x11.h"
+
+//the surface is used for render.
+#define MP_VDPAU_STATE_USED_FOR_RENDER 1
+//the surface is needed for reference/prediction, codec manipulates this.
+#define MP_VDPAU_STATE_USED_FOR_REFERENCE 2
+
+#define MP_VDPAU_RENDER_MAGIC 0x1DC8E14B
+
+typedef struct {
+    int  magic;
+
+    VdpVideoSurface surface; //used as rendered surface, never changed.
+
+    int state; // Holds MP_VDPAU_STATE_* values
+
+    union _VdpPictureInfo {
+        VdpPictureInfoMPEG1Or2 mpeg;
+        VdpPictureInfoH264     h264;
+        VdpPictureInfoVC1       vc1;
+    } info;
+
+    VdpBitstreamBuffer bitstreamBuffer;
+} vdpau_render_state_t;
+
+#endif /* FFMPEG_VDPAU_RENDER_H */
diff -Naur MPlayer-27942.15845-old/libavcodec/vdpauvideo.c MPlayer-27942.15845-new/libavcodec/vdpauvideo.c
--- MPlayer-27942.15845-old/libavcodec/vdpauvideo.c	1969-12-31 16:00:00.000000000 -0800
+++ MPlayer-27942.15845-new/libavcodec/vdpauvideo.c	2008-11-16 16:49:52.000000000 -0800
@@ -0,0 +1,346 @@
+#include <limits.h>
+
+//avcodec include
+#include "avcodec.h"
+#include "dsputil.h"
+#include "mpegvideo.h"
+#include "h264.h"
+#include "vc1.h"
+
+#undef NDEBUG
+#include <assert.h>
+
+#include "vdpau_render.h"
+
+#define ARSIZE(_x_) (sizeof(_x_) / sizeof((_x_)[0]))
+
+uint32_t num_reference_surfaces;
+
+int VDPAU_mpeg_field_start(MpegEncContext *s)
+{
+    vdpau_render_state_t * render,* last, * next;
+    int i;
+    
+    render = (vdpau_render_state_t*)s->current_picture.data[2];
+    assert(render != NULL);
+    if (render == NULL) {
+        return -1; //make sure that this is render packet
+    }
+
+    /*  fill VdpPictureInfoMPEG1Or2 struct */
+    render->info.mpeg.picture_structure = s->picture_structure;
+    render->info.mpeg.picture_coding_type = s->pict_type;
+    render->info.mpeg.intra_dc_precision = s->intra_dc_precision;
+    render->info.mpeg.frame_pred_frame_dct = s->frame_pred_frame_dct;
+    render->info.mpeg.concealment_motion_vectors = s->concealment_motion_vectors;
+    render->info.mpeg.intra_vlc_format = s->intra_vlc_format;
+    render->info.mpeg.alternate_scan = s->alternate_scan;
+    render->info.mpeg.q_scale_type = s->q_scale_type;
+    render->info.mpeg.top_field_first = s->top_field_first;
+    render->info.mpeg.full_pel_forward_vector = s->full_pel[0];  // MPEG-1 only.  Set 0 for MPEG-2
+    render->info.mpeg.full_pel_backward_vector = s->full_pel[1]; // MPEG-1 only.  Set 0 for MPEG-2
+    render->info.mpeg.f_code[0][0] = s->mpeg_f_code[0][0];             // For MPEG-1 fill both horiz. & vert.
+    render->info.mpeg.f_code[0][1] = s->mpeg_f_code[0][1];
+    render->info.mpeg.f_code[1][0] = s->mpeg_f_code[1][0];
+    render->info.mpeg.f_code[1][1] = s->mpeg_f_code[1][1];
+    for (i = 0; i < 64; ++i) {
+        render->info.mpeg.intra_quantizer_matrix[i] =  s->intra_matrix[i];
+        render->info.mpeg.non_intra_quantizer_matrix[i] = s->inter_matrix[i];
+    }
+
+    render->info.mpeg.forward_reference = VDP_INVALID_HANDLE;
+    render->info.mpeg.backward_reference = VDP_INVALID_HANDLE;
+
+    switch(s->pict_type){
+    case  FF_I_TYPE:
+        return 0; // no prediction from other frames
+    case  FF_B_TYPE:
+        next = (vdpau_render_state_t*)s->next_picture.data[2];
+        assert(next!=NULL);
+        if (next == NULL) {
+            return -1;
+        }
+        render->info.mpeg.backward_reference = next->surface;
+        // no return here, going to set forward prediction
+    case  FF_P_TYPE:
+        last = (vdpau_render_state_t*)s->last_picture.data[2];
+        if (last == NULL) { // FIXME: Does this test make sense?
+            last = render; // predict second field from the first
+        }
+        render->info.mpeg.forward_reference = last->surface;
+        return 0;
+    }
+
+    return -1;
+}
+
+int VDPAU_mpeg_picture_complete(MpegEncContext *s, const uint8_t *buf, int buf_size, int slice_count)
+{
+    vdpau_render_state_t * render;
+
+    render = (vdpau_render_state_t*)s->current_picture_ptr->data[2];
+    assert(render != NULL);
+    if (render == NULL) {
+        return -1; // make sure that this is render packet
+    }
+
+    render->bitstreamBuffer.struct_version = VDP_BITSTREAM_BUFFER_VERSION;
+    render->bitstreamBuffer.bitstream_bytes = buf_size;
+    render->bitstreamBuffer.bitstream = buf;
+    render->info.mpeg.slice_count = slice_count;
+
+    if (slice_count > 0) {
+        ff_draw_horiz_band(s, 0, s->avctx->height);
+    }
+
+    return 0;
+}
+
+int VDPAU_h264_set_reference_frames(H264Context *h)
+{
+    MpegEncContext * s = &h->s;
+    vdpau_render_state_t * render, * render_ref;
+    VdpReferenceFrameH264 * rf, * rf2;
+    Picture * pic;
+    int i, list;
+
+    render = (vdpau_render_state_t*)s->current_picture_ptr->data[2];
+    assert(render != NULL);
+    if (render == NULL)
+        return -1; //make sure that this is render packet
+
+    rf = &render->info.h264.referenceFrames[0];
+#define H264_RF_COUNT ARSIZE(render->info.h264.referenceFrames)
+
+    for (list = 0; list < 2; ++list) {
+        Picture **lp = list ? h->long_ref : h->short_ref;
+        int ls = list ? h->long_ref_count : h->short_ref_count;
+
+        for (i = 0; i < ls; ++i) {
+            pic = lp[i];
+            if (!pic || !pic->reference) {
+                continue;
+            }
+
+            render_ref = (vdpau_render_state_t*)pic->data[2];
+            assert(render_ref != NULL);
+            if (render_ref == NULL)
+                return -1; //make sure that this is render packet
+
+            rf2 = &render->info.h264.referenceFrames[0];
+            while (rf2 != rf) {
+                if (
+                    (rf2->surface == render_ref->surface)
+                    && (rf2->is_long_term == pic->long_ref)
+                    && (rf2->frame_idx == pic->frame_num)
+                ) {
+                    break;
+                }
+                ++rf2;
+            }
+            if (rf2 != rf) {
+                rf2->top_is_reference |= (pic->reference & PICT_TOP_FIELD) ? VDP_TRUE : VDP_FALSE;
+                rf2->bottom_is_reference |= (pic->reference & PICT_BOTTOM_FIELD) ? VDP_TRUE : VDP_FALSE;
+                continue;
+            }
+
+            if (rf >= &render->info.h264.referenceFrames[H264_RF_COUNT]) {
+                continue;
+            }
+
+            rf->surface = render_ref->surface;
+            rf->is_long_term = pic->long_ref;
+            rf->top_is_reference = (pic->reference & PICT_TOP_FIELD) ? VDP_TRUE : VDP_FALSE;
+            rf->bottom_is_reference = (pic->reference & PICT_BOTTOM_FIELD) ? VDP_TRUE : VDP_FALSE;
+            rf->field_order_cnt[0] = pic->field_poc[0];
+            rf->field_order_cnt[1] = pic->field_poc[1];
+            rf->frame_idx = pic->frame_num;
+
+            ++rf;
+        }
+    }
+
+    for (; rf < &render->info.h264.referenceFrames[H264_RF_COUNT]; ++rf) {
+        rf->surface = VDP_INVALID_HANDLE;
+        rf->is_long_term = 0;
+        rf->top_is_reference = 0;
+        rf->bottom_is_reference = 0;
+        rf->field_order_cnt[0] = 0;
+        rf->field_order_cnt[1] = 0;
+        rf->frame_idx = 0;
+    }
+
+    return 0;
+}
+
+int VDPAU_h264_picture_complete(H264Context *h, const uint8_t *buf, int buf_size)
+{
+    MpegEncContext * s = &h->s;
+    vdpau_render_state_t * render;
+    int i;
+
+    render = (vdpau_render_state_t*)s->current_picture_ptr->data[2];
+    assert(render != NULL);
+    if (render == NULL)
+        return -1; //make sure that this is render packet
+
+    render->info.h264.slice_count = h->slice_num;
+
+    if (render->info.h264.slice_count < 1)
+        return 0;
+
+    for (int i = 0; i < 2; ++i) {
+        int foc = s->current_picture_ptr->field_poc[i];
+        if (foc == INT_MAX) {
+            foc = 0;
+        }
+        render->info.h264.field_order_cnt[i] = foc;
+    }
+
+    render->info.h264.is_reference = s->current_picture_ptr->reference ? VDP_TRUE : VDP_FALSE;
+    render->info.h264.frame_num = h->frame_num;
+    render->info.h264.field_pic_flag = (s->picture_structure != PICT_FRAME) ? 1 : 0;
+    render->info.h264.bottom_field_flag = (s->picture_structure == PICT_BOTTOM_FIELD) ? 1 : 0;
+    render->info.h264.num_ref_frames = h->sps.ref_frame_count;
+    render->info.h264.mb_adaptive_frame_field_flag = h->sps.mb_aff;
+    render->info.h264.constrained_intra_pred_flag = h->pps.constrained_intra_pred;
+    render->info.h264.weighted_pred_flag = h->pps.weighted_pred;
+    render->info.h264.weighted_bipred_idc = h->pps.weighted_bipred_idc;
+    render->info.h264.frame_mbs_only_flag = h->sps.frame_mbs_only_flag;
+    render->info.h264.transform_8x8_mode_flag = h->pps.transform_8x8_mode;
+    render->info.h264.chroma_qp_index_offset = h->pps.chroma_qp_index_offset[0];
+    render->info.h264.second_chroma_qp_index_offset = h->pps.chroma_qp_index_offset[1];
+    render->info.h264.pic_init_qp_minus26 = h->pps.init_qp - 26;
+    render->info.h264.num_ref_idx_l0_active_minus1 = h->pps.ref_count[0] - 1;
+    render->info.h264.num_ref_idx_l1_active_minus1 = h->pps.ref_count[1] - 1;
+    render->info.h264.log2_max_frame_num_minus4 = h->sps.log2_max_frame_num - 4;
+    render->info.h264.pic_order_cnt_type = h->sps.poc_type;
+    render->info.h264.log2_max_pic_order_cnt_lsb_minus4 = h->sps.log2_max_poc_lsb - 4;
+    render->info.h264.delta_pic_order_always_zero_flag = h->sps.delta_pic_order_always_zero_flag;
+    render->info.h264.direct_8x8_inference_flag = h->sps.direct_8x8_inference_flag;
+    render->info.h264.entropy_coding_mode_flag = h->pps.cabac;
+    render->info.h264.pic_order_present_flag = h->pps.pic_order_present;
+    render->info.h264.deblocking_filter_control_present_flag = h->pps.deblocking_filter_parameters_present;
+    render->info.h264.redundant_pic_cnt_present_flag = h->pps.redundant_pic_cnt_present;
+    memcpy(render->info.h264.scaling_lists_4x4, h->pps.scaling_matrix4, sizeof(render->info.h264.scaling_lists_4x4));
+    memcpy(render->info.h264.scaling_lists_8x8, h->pps.scaling_matrix8, sizeof(render->info.h264.scaling_lists_8x8));
+
+    render->bitstreamBuffer.struct_version = VDP_BITSTREAM_BUFFER_VERSION;
+    render->bitstreamBuffer.bitstream_bytes = buf_size;
+    render->bitstreamBuffer.bitstream = buf;
+
+    ff_draw_horiz_band(s, 0, s->avctx->height);
+
+    return 0;
+}
+
+void VDPAU_h264_set_reference_frames_count(H264Context *h)
+{
+    num_reference_surfaces = h->sps.ref_frame_count;
+}
+
+#undef printf
+
+int VDPAU_vc1_decode_picture(MpegEncContext *s, AVCodecContext *avctx, VC1Context *v, const uint8_t *buf, int buf_size)
+{
+   // VC1Context *v = avctx->priv_data;
+    vdpau_render_state_t * render,* last, * next;
+
+    render = (vdpau_render_state_t*)s->current_picture.data[2];
+    assert(render != NULL);
+    if (render == NULL) {
+        return -1; //make sure that this is render packet
+    }
+    memset(&(render->info), 0 , sizeof(VdpPictureInfoVC1));
+    memset(&(render->bitstreamBuffer), 0, sizeof(VdpBitstreamBuffer));
+
+    /*  fill LvPictureInfoVC1 struct */
+    render->info.vc1.frame_coding_mode = v->fcm;
+    render->info.vc1.postprocflag = v->postprocflag;
+    render->info.vc1.pulldown = v->broadcast;
+    render->info.vc1.interlace = v->interlace;
+    render->info.vc1.tfcntrflag = v->tfcntrflag;
+    render->info.vc1.finterpflag = v->finterpflag;
+    render->info.vc1.psf = v->psf;
+    render->info.vc1.dquant = v->dquant;
+    render->info.vc1.panscan_flag = v->panscanflag;
+    render->info.vc1.refdist_flag = v->refdist_flag;
+    render->info.vc1.quantizer = v->quantizer_mode;
+    render->info.vc1.extended_mv = v->extended_mv;
+    render->info.vc1.extended_dmv = v->extended_dmv;
+    render->info.vc1.overlap = v->overlap;
+    render->info.vc1.vstransform = v->vstransform;
+    render->info.vc1.loopfilter = v->s.loop_filter;
+    render->info.vc1.fastuvmc = v->fastuvmc;
+    render->info.vc1.range_mapy_flag = v->range_mapy_flag;
+    render->info.vc1.range_mapy = v->range_mapy;
+    render->info.vc1.range_mapuv_flag = v->range_mapuv_flag;
+    render->info.vc1.range_mapuv = v->range_mapuv;
+    /* Specific to simple/main profile only */
+    render->info.vc1.multires = v->multires;
+    render->info.vc1.syncmarker = v->s.resync_marker;
+    render->info.vc1.rangered = v->rangered;
+    render->info.vc1.maxbframes = v->s.max_b_frames;
+    /* Presently, making these as 0 */
+    render->info.vc1.deblockEnable = 0;
+    render->info.vc1.pquant = 0;
+
+    render->info.vc1.forward_reference = VDP_INVALID_HANDLE;
+    render->info.vc1.backward_reference = VDP_INVALID_HANDLE;
+
+    switch(s->pict_type){
+    case  FF_I_TYPE:
+        render->info.vc1.picture_type = 0;
+        break;
+    case  FF_B_TYPE:
+        if (v->bi_type) {
+            render->info.vc1.picture_type = 4;
+        }
+        else {
+            render->info.vc1.picture_type = 3;
+        }
+        break;
+    case  FF_P_TYPE:
+        render->info.vc1.picture_type = 1;
+        break;
+    case  FF_BI_TYPE:
+        render->info.vc1.picture_type = 4;
+        break;
+    default:
+        return -1;
+    }
+
+    switch(s->pict_type){
+    case  FF_I_TYPE:
+    case  FF_BI_TYPE:
+        break;
+    case  FF_B_TYPE:
+        next = (vdpau_render_state_t*)s->next_picture.data[2];
+        assert(next!=NULL);
+        if (next == NULL) {
+            return -1;
+        }
+        render->info.vc1.backward_reference = next->surface;
+        // no break here, going to set forward prediction
+    case  FF_P_TYPE:
+        last = (vdpau_render_state_t*)s->last_picture.data[2];
+        if (last == NULL) { // FIXME: Does this test make sense?
+            last = render; // predict second field from the first
+        }
+        render->info.vc1.forward_reference = last->surface;
+        break;
+    default:
+        return -1;
+    }
+
+    render->bitstreamBuffer.struct_version = VDP_BITSTREAM_BUFFER_VERSION;
+    render->bitstreamBuffer.bitstream_bytes = buf_size;
+    render->bitstreamBuffer.bitstream = buf;
+    // FIXME: I am not sure about how MPlayer calculates slice number.
+    render->info.vc1.slice_count = 1;
+
+    ff_draw_horiz_band(s, 0, s->avctx->height);  
+
+    return 0;
+}
+
diff -Naur MPlayer-27942.15845-old/libavutil/avutil.h MPlayer-27942.15845-new/libavutil/avutil.h
--- MPlayer-27942.15845-old/libavutil/avutil.h	2008-11-16 16:27:40.000000000 -0800
+++ MPlayer-27942.15845-new/libavutil/avutil.h	2008-11-16 16:49:52.000000000 -0800
@@ -121,6 +121,15 @@
     PIX_FMT_YUV440P,   ///< Planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
     PIX_FMT_YUVJ440P,  ///< Planar YUV 4:4:0 full scale (jpeg)
     PIX_FMT_YUVA420P,  ///< Planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
+    PIX_FMT_VDPAU_MPEG1,        ///< VDPAU acceleration via common packet passing(vdpau_remder.h)
+    PIX_FMT_VDPAU_MPEG2_SIMPLE, ///< VDPAU acceleration via common packet passing(vdpau_remder.h)
+    PIX_FMT_VDPAU_MPEG2_MAIN,   ///< VDPAU acceleration via common packet passing(vdpau_remder.h)
+    PIX_FMT_VDPAU_H264_BASELINE,///< VDPAU acceleration via common packet passing(vdpau_remder.h)
+    PIX_FMT_VDPAU_H264_MAIN,    ///< VDPAU acceleration via common packet passing(vdpau_remder.h)
+    PIX_FMT_VDPAU_H264_HIGH,    ///< VDPAU acceleration via common packet passing(vdpau_remder.h)
+    PIX_FMT_VDPAU_VC1_SIMPLE,   ///< VDPAU acceleration via common packet passing(vdpau_remder.h)
+    PIX_FMT_VDPAU_VC1_MAIN,     ///< VDPAU acceleration via common packet passing(vdpau_remder.h)
+    PIX_FMT_VDPAU_VC1_ADVANCED, ///< VDPAU acceleration via common packet passing(vdpau_remder.h)
     PIX_FMT_NB,        ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
diff -Naur MPlayer-27942.15845-old/libmpcodecs/img_format.c MPlayer-27942.15845-new/libmpcodecs/img_format.c
--- MPlayer-27942.15845-old/libmpcodecs/img_format.c	2008-11-16 16:26:51.000000000 -0800
+++ MPlayer-27942.15845-new/libmpcodecs/img_format.c	2008-11-16 16:50:05.000000000 -0800
@@ -67,6 +67,15 @@
 	case IMGFMT_ZRMJPEGIB: return "Zoran MJPEG bottom field first";
 	case IMGFMT_XVMC_MOCO_MPEG2: return "MPEG1/2 Motion Compensation";
 	case IMGFMT_XVMC_IDCT_MPEG2: return "MPEG1/2 Motion Compensation and IDCT";
+	case IMGFMT_VDPAU_MPEG1: return "MPEG1 VDPAU acceleration";
+	case IMGFMT_VDPAU_MPEG2_SIMPLE: return "MPEG2 SIMPLE VDPAU acceleration";
+	case IMGFMT_VDPAU_MPEG2_MAIN: return "MPEG2 MAIN VDPAU acceleration";
+	case IMGFMT_VDPAU_H264_BASELINE: return "H.264 BASELINE VDPAU acceleration";
+	case IMGFMT_VDPAU_H264_MAIN: return "H.264 MAIN VDPAU acceleration";
+	case IMGFMT_VDPAU_H264_HIGH: return "H.264 HIGH VDPAU acceleration";
+	case IMGFMT_VDPAU_VC1_SIMPLE: return "VC1 SIMPLE VDPAU acceleration";
+	case IMGFMT_VDPAU_VC1_MAIN: return "VC1 MAIN VDPAU acceleration";
+	case IMGFMT_VDPAU_VC1_ADVANCED: return "VC1 ADVANCED VDPAU acceleration";
     }
     snprintf(unknown_format,20,"Unknown 0x%04x",format);
     return unknown_format;
diff -Naur MPlayer-27942.15845-old/libmpcodecs/img_format.h MPlayer-27942.15845-new/libmpcodecs/img_format.h
--- MPlayer-27942.15845-old/libmpcodecs/img_format.h	2008-11-16 16:26:51.000000000 -0800
+++ MPlayer-27942.15845-new/libmpcodecs/img_format.h	2008-11-16 16:50:05.000000000 -0800
@@ -107,6 +107,20 @@
 #define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
 #define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
 
+// VDPAU specific format.
+#define IMGFMT_VDPAU               0x1DC80000
+#define IMGFMT_VDPAU_MASK          0xFFFF0000
+#define IMGFMT_IS_VDPAU(fmt)       (((fmt)&IMGFMT_VDPAU_MASK)==IMGFMT_VDPAU)
+#define IMGFMT_VDPAU_MPEG1         (IMGFMT_VDPAU|0x01)
+#define IMGFMT_VDPAU_MPEG2_SIMPLE  (IMGFMT_VDPAU|0x02)
+#define IMGFMT_VDPAU_MPEG2_MAIN    (IMGFMT_VDPAU|0x03)
+#define IMGFMT_VDPAU_H264_BASELINE (IMGFMT_VDPAU|0x04)
+#define IMGFMT_VDPAU_H264_MAIN     (IMGFMT_VDPAU|0x05)
+#define IMGFMT_VDPAU_H264_HIGH     (IMGFMT_VDPAU|0x06)
+#define IMGFMT_VDPAU_VC1_SIMPLE    (IMGFMT_VDPAU|0x07)
+#define IMGFMT_VDPAU_VC1_MAIN      (IMGFMT_VDPAU|0x08)
+#define IMGFMT_VDPAU_VC1_ADVANCED  (IMGFMT_VDPAU|0x09)
+
 typedef struct {
     void* data;
     int size;
diff -Naur MPlayer-27942.15845-old/libmpcodecs/mp_image.h MPlayer-27942.15845-new/libmpcodecs/mp_image.h
--- MPlayer-27942.15845-old/libmpcodecs/mp_image.h	2008-11-16 16:26:51.000000000 -0800
+++ MPlayer-27942.15845-new/libmpcodecs/mp_image.h	2008-11-16 16:50:05.000000000 -0800
@@ -113,6 +113,10 @@
 	mpi->bpp=0;
 	return;
     }
+    if(IMGFMT_IS_VDPAU(out_fmt)){
+        mpi->bpp=0;
+        return;
+    }
     if(IMGFMT_IS_XVMC(out_fmt)){
 	mpi->bpp=0;
 	return;
diff -Naur MPlayer-27942.15845-old/libmpcodecs/vd_ffmpeg.c MPlayer-27942.15845-new/libmpcodecs/vd_ffmpeg.c
--- MPlayer-27942.15845-old/libmpcodecs/vd_ffmpeg.c	2008-11-16 16:26:51.000000000 -0800
+++ MPlayer-27942.15845-new/libmpcodecs/vd_ffmpeg.c	2008-11-16 16:50:05.000000000 -0800
@@ -30,6 +30,10 @@
 #include "xvmc_render.h"
 #endif
 
+#ifdef HAVE_VDPAU
+#include "vdpau_render.h"
+#endif
+
 int avcodec_initialized=0;
 
 typedef struct {
@@ -69,6 +73,16 @@
                 	int y, int type, int height);
 #endif
 
+#ifdef HAVE_VDPAU
+static enum PixelFormat vdpau_get_format(struct AVCodecContext * avctx,
+                                   const enum PixelFormat * pix_fmt);
+static int vdpau_get_buffer(AVCodecContext *avctx, AVFrame *pic);
+static void vdpau_release_buffer(AVCodecContext *avctx, AVFrame *pic);
+static void vdpau_render_frame(struct AVCodecContext *s,
+                        AVFrame *src, int offset[4],
+                        int y, int type, int height);
+#endif
+
 static int lavc_param_workaround_bugs= FF_BUG_AUTODETECT;
 static int lavc_param_error_resilience=2;
 static int lavc_param_error_concealment=3;
@@ -147,6 +161,36 @@
         case IMGFMT_XVMC_IDCT_MPEG2:
         case IMGFMT_XVMC_MOCO_MPEG2:
             if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_IDCT) return CONTROL_TRUE;
+	    break;
+#endif
+#ifdef HAVE_VDPAU
+        case IMGFMT_VDPAU_MPEG1:
+            if(avctx->pix_fmt==PIX_FMT_VDPAU_MPEG1) return CONTROL_TRUE;
+	    break;
+        case IMGFMT_VDPAU_MPEG2_SIMPLE:
+            if(avctx->pix_fmt==PIX_FMT_VDPAU_MPEG2_SIMPLE) return CONTROL_TRUE;
+	    break;
+        case IMGFMT_VDPAU_MPEG2_MAIN:
+            if(avctx->pix_fmt==PIX_FMT_VDPAU_MPEG2_MAIN) return CONTROL_TRUE;
+	    break;
+        case IMGFMT_VDPAU_H264_BASELINE:
+            if(avctx->pix_fmt==PIX_FMT_VDPAU_H264_BASELINE) return CONTROL_TRUE;
+	    break;
+        case IMGFMT_VDPAU_H264_MAIN:
+            if(avctx->pix_fmt==PIX_FMT_VDPAU_H264_MAIN) return CONTROL_TRUE;
+	    break;
+        case IMGFMT_VDPAU_H264_HIGH:
+            if(avctx->pix_fmt==PIX_FMT_VDPAU_H264_HIGH) return CONTROL_TRUE;
+	    break;
+        case IMGFMT_VDPAU_VC1_SIMPLE:
+            if(avctx->pix_fmt==PIX_FMT_VDPAU_VC1_SIMPLE) return CONTROL_TRUE;
+            break;
+        case IMGFMT_VDPAU_VC1_MAIN:
+            if(avctx->pix_fmt==PIX_FMT_VDPAU_VC1_MAIN) return CONTROL_TRUE;
+            break;
+        case IMGFMT_VDPAU_VC1_ADVANCED:
+            if(avctx->pix_fmt==PIX_FMT_VDPAU_VC1_ADVANCED) return CONTROL_TRUE;
+            break;
 #endif
 	}
         return CONTROL_FALSE;
@@ -250,6 +294,18 @@
     ctx->avctx = avcodec_alloc_context();
     avctx = ctx->avctx;
 
+#ifdef HAVE_VDPAU
+    if(lavc_codec->capabilities & CODEC_CAP_HWACCEL_VDPAU){
+        mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_VDPAUAcceleratedCodec);
+        assert(ctx->do_dr1);
+        avctx->get_format= vdpau_get_format;
+        avctx->get_buffer= vdpau_get_buffer;
+        avctx->release_buffer= vdpau_release_buffer;
+        avctx->draw_horiz_band = vdpau_render_frame;
+        avctx->slice_flags=SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
+    } else
+#endif /* HAVE_VDPAU */
+
 #ifdef HAVE_XVMC
 
 #ifdef CODEC_CAP_HWACCEL
@@ -537,6 +593,17 @@
         case PIX_FMT_XVMC_MPEG2_MC:ctx->best_csp=IMGFMT_XVMC_MOCO_MPEG2;break;
         case PIX_FMT_XVMC_MPEG2_IDCT:ctx->best_csp=IMGFMT_XVMC_IDCT_MPEG2;break;
 #endif
+#ifdef HAVE_VDPAU
+        case PIX_FMT_VDPAU_MPEG1: ctx->best_csp=IMGFMT_VDPAU_MPEG1;break;
+        case PIX_FMT_VDPAU_MPEG2_SIMPLE: ctx->best_csp=IMGFMT_VDPAU_MPEG2_SIMPLE;break;
+        case PIX_FMT_VDPAU_MPEG2_MAIN: ctx->best_csp=IMGFMT_VDPAU_MPEG2_MAIN;break;
+        case PIX_FMT_VDPAU_H264_BASELINE: ctx->best_csp=IMGFMT_VDPAU_H264_BASELINE;break;
+        case PIX_FMT_VDPAU_H264_MAIN: ctx->best_csp=IMGFMT_VDPAU_H264_MAIN;break;
+        case PIX_FMT_VDPAU_H264_HIGH: ctx->best_csp=IMGFMT_VDPAU_H264_HIGH;break;
+        case PIX_FMT_VDPAU_VC1_SIMPLE: ctx->best_csp=IMGFMT_VDPAU_VC1_SIMPLE;break;
+        case PIX_FMT_VDPAU_VC1_MAIN: ctx->best_csp=IMGFMT_VDPAU_VC1_MAIN;break;
+        case PIX_FMT_VDPAU_VC1_ADVANCED: ctx->best_csp=IMGFMT_VDPAU_VC1_ADVANCED;break;
+#endif
 	default:
 	    ctx->best_csp=0;
 	}
@@ -1071,3 +1138,152 @@
 }
 
 #endif // HAVE_XVMC
+
+#ifdef HAVE_VDPAU
+
+static enum PixelFormat vdpau_get_format(struct AVCodecContext * avctx,
+                                    const enum PixelFormat * fmt){
+    sh_video_t * sh = avctx->opaque;
+    int i;
+
+    if(avctx->vdpau_acceleration){
+        vd_ffmpeg_ctx *ctx = sh->context;
+        avctx->get_buffer= vdpau_get_buffer;
+        avctx->release_buffer= vdpau_release_buffer;
+        avctx->draw_horiz_band = vdpau_render_frame;
+        assert(ctx->do_dr1);
+        avctx->slice_flags=SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
+    }
+    for(i=0;fmt[i]!=-1;i++){
+        mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_TryingPixfmt,i);
+        if( init_vo(sh,fmt[i]) >= 0)
+            return fmt[i];
+    }
+    return fmt[0];
+}
+
+static int vdpau_get_buffer(AVCodecContext *avctx, AVFrame *pic){
+    sh_video_t * sh = avctx->opaque;
+    vd_ffmpeg_ctx *ctx = sh->context;
+    mp_image_t* mpi=NULL;
+    vdpau_render_state_t * render;
+    int flags= MP_IMGFLAG_ACCEPT_STRIDE | MP_IMGFLAG_PREFER_ALIGNED_STRIDE|
+               MP_IMGFLAG_DRAW_CALLBACK;
+
+    if(!avctx->vdpau_acceleration){
+        mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_VDPAUGetBufferShouldWorkOnlyWithVDPAU);
+        assert(0);
+        exit(1);
+    }
+
+    assert(avctx->draw_horiz_band == vdpau_render_frame);
+    assert(avctx->release_buffer == vdpau_release_buffer);
+    if( mp_msg_test(MSGT_DECVIDEO,MSGL_DBG5) )
+        mp_msg(MSGT_DECVIDEO, MSGL_DBG5, "vd_ffmpeg::vdpau_get_buffer\n");
+
+    if(init_vo(sh,avctx->pix_fmt) < 0){
+        mp_msg(MSGT_DECVIDEO, MSGL_WARN, MSGTR_MPCODECS_UnexpectedInitVoError);
+        exit(1);
+    }
+
+    if(!pic->reference){
+        ctx->b_count++;
+    }else{
+        ctx->ip_count++;
+        flags|= MP_IMGFLAG_PRESERVE|MP_IMGFLAG_READABLE;
+    }
+
+    mpi= mpcodecs_get_image(sh, MP_IMGTYPE_IPB,flags ,
+                            avctx->width, avctx->height);
+
+    if(mpi==NULL){
+        mp_msg(MSGT_DECVIDEO, MSGL_ERR, MSGTR_MPCODECS_UnrecoverableErrorRenderBuffersNotTaken);
+        assert(0);
+        exit(1);
+    };
+
+    if( (mpi->flags & MP_IMGFLAG_DIRECT) == 0){
+        mp_msg(MSGT_DECVIDEO, MSGL_ERR, MSGTR_MPCODECS_OnlyBuffersAllocatedByVoVdpauAllowed);
+        assert(0);
+        exit(1);
+    }
+
+    pic->data[0]= mpi->planes[0];
+    pic->data[1]= mpi->planes[1];
+    pic->data[2]= mpi->planes[2];
+ 
+    /* Note, some (many) codecs in libavcodec must have stride1==stride2 && no changes between frames
+     * lavc will check that and die with an error message, if its not true
+     */
+    pic->linesize[0]= mpi->stride[0];
+    pic->linesize[1]= mpi->stride[1];
+    pic->linesize[2]= mpi->stride[2];
+
+    pic->opaque = mpi;
+
+    if(pic->reference){
+        //I or P frame
+        pic->age= ctx->ip_age[0];
+
+        ctx->ip_age[0]= ctx->ip_age[1]+1;
+        ctx->ip_age[1]= 1;
+        ctx->b_age++;
+    }else{
+        //B frame
+        pic->age= ctx->b_age;
+
+        ctx->ip_age[0]++;
+        ctx->ip_age[1]++;
+        ctx->b_age=1;
+    }
+
+    pic->type= FF_BUFFER_TYPE_USER;
+
+    render=(vdpau_render_state_t*)mpi->planes[2];
+    if( mp_msg_test(MSGT_DECVIDEO,MSGL_DBG5) )
+        mp_msg(MSGT_DECVIDEO, MSGL_DBG5, "vd_ffmpeg::vdpau_get_buffer (render=%p)\n",render);
+    assert(render != 0);
+    render->state |= MP_VDPAU_STATE_USED_FOR_REFERENCE;
+   return 0;
+}
+
+static void vdpau_release_buffer(AVCodecContext *avctx, AVFrame *pic){
+    mp_image_t* mpi= pic->opaque;
+    sh_video_t * sh = avctx->opaque;
+    vd_ffmpeg_ctx *ctx = sh->context;
+    vdpau_render_state_t * render;
+    int i;
+
+    if(ctx->ip_count <= 2 && ctx->b_count<=1){
+        if(mpi->flags&MP_IMGFLAG_PRESERVE)
+            ctx->ip_count--;
+        else
+            ctx->b_count--;
+    }
+
+    // Mark the surface as not required for prediction
+    render=(vdpau_render_state_t*)pic->data[2];
+    if( mp_msg_test(MSGT_DECVIDEO,MSGL_DBG5) )
+        mp_msg(MSGT_DECVIDEO, MSGL_DBG5, "vd_ffmpeg::vdpau_release_buffer (render=%p)\n",render);
+    assert(render!=NULL);
+    render->state &= ~MP_VDPAU_STATE_USED_FOR_REFERENCE;
+    for(i=0; i<4; i++){
+        pic->data[i]= NULL;
+    }
+}
+
+static void vdpau_render_frame(struct AVCodecContext *s,
+                        AVFrame *src, int offset[4],
+                        int y, int type, int height){
+    int width= s->width;
+    sh_video_t * sh = s->opaque;
+    uint8_t *source[3]= {src->data[0], src->data[1], src->data[2]};
+
+    assert(src->linesize[0]==0 && src->linesize[1]==0 && src->linesize[2]==0);
+    assert(offset[0]==0 && offset[1]==0 && offset[2]==0);
+
+    mpcodecs_draw_slice (sh, source, src->linesize, width, height, 0, y);
+}
+
+#endif
+
diff -Naur MPlayer-27942.15845-old/libvo/video_out.c MPlayer-27942.15845-new/libvo/video_out.c
--- MPlayer-27942.15845-old/libvo/video_out.c	2008-11-16 16:26:56.000000000 -0800
+++ MPlayer-27942.15845-new/libvo/video_out.c	2008-11-16 16:50:05.000000000 -0800
@@ -71,6 +71,7 @@
 extern vo_functions_t video_out_x11;
 extern vo_functions_t video_out_xover;
 extern vo_functions_t video_out_xvmc;
+extern vo_functions_t video_out_vdpau;
 extern vo_functions_t video_out_xv;
 extern vo_functions_t video_out_gl;
 extern vo_functions_t video_out_gl2;
@@ -149,6 +150,9 @@
 #ifdef CONFIG_3DFX
         &video_out_3dfx,
 #endif
+#ifdef HAVE_VDPAU
+        &video_out_vdpau,
+#endif
 #ifdef CONFIG_XV
         &video_out_xv,
 #endif
diff -Naur MPlayer-27942.15845-old/libvo/vo_vdpau.c MPlayer-27942.15845-new/libvo/vo_vdpau.c
--- MPlayer-27942.15845-old/libvo/vo_vdpau.c	1969-12-31 16:00:00.000000000 -0800
+++ MPlayer-27942.15845-new/libvo/vo_vdpau.c	2008-11-16 16:50:05.000000000 -0800
@@ -0,0 +1,1163 @@
+/* vo_vdpau.c, vdpau with X11 interface */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "config.h"
+#include "mp_msg.h"
+#include "help_mp.h"
+#include "video_out.h"
+#include "video_out_internal.h"
+
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <errno.h>
+
+#include "x11_common.h"
+
+#include "vdpau_render.h"
+
+#include "fastmemcpy.h"
+#include "sub.h"
+#include "aspect.h"
+
+#include "subopt-helper.h"
+
+#include "input/input.h"
+
+#ifdef HAVE_NEW_GUI
+#include "gui/interface.h"
+#endif
+
+#include "libavutil/common.h"
+#include <assert.h>
+
+#define TRACE_SURFACES 0
+
+static vo_info_t info = {
+    "VDPAU with X11",
+    "vdpau", 
+    "Rajib Mahapatra <rmahapatra@nvidia.com> and others", 
+    ""
+};
+
+LIBVO_EXTERN(vdpau)
+
+#define ARSIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+/* MACRO for error check */
+#define CHECK_ST \
+  if (vdp_st != VDP_STATUS_OK) { \
+      printf("Error at %s:%d\n", __FILE__, __LINE__); \
+      exit(1); \
+  }
+
+/* Numbers of video and ouput Surfaces */
+#define NUM_OUTPUT_SURFACES                2
+#define NUM_VIDEO_SURFACES_MPEG2           3  // (1 frame being decoded, 2 reference)
+#define NUM_VIDEO_SURFACES_H264            17 // (1 frame being decoded, up to 16 references) 
+#define NUM_VIDEO_SURFACES_VC1             3  // (same as MPEG-2)
+#define NUM_VIDEO_SURFACES_NON_ACCEL_YUV   1  //  surfaces for YV12 etc. 
+#define NUM_VIDEO_SURFACES_NON_ACCEL_RGB   0 // surfaces for RGB or YUV4:4:4
+
+/* Declaration for  all varialbles of win_x11_init_vdpau_procs() and 
+ * win_x11_init_vdpau_flip_queue() function. 
+ */
+VdpDevice           vdp_device;
+VdpGetProcAddress * vdp_get_proc_address;
+
+VdpPresentationQueueTarget vdp_flip_target;
+VdpPresentationQueue       vdp_flip_queue;
+
+VdpDeviceDestroy * vdp_device_destroy;
+VdpVideoSurfaceCreate * vdp_video_surface_create;
+VdpVideoSurfaceDestroy * vdp_video_surface_destroy;
+
+/* May be used in  software filtering/postprocessing options
+ * in MPlayer(./mplayer -vf ..) if we want copy video_surface data to 
+ * sytem memory.
+ */
+VdpVideoSurfacePutBitsYCbCr * vdp_video_surface_put_bits_y_cb_cr;
+VdpVideoSurfacePutBitsYCbCr * vdp_video_surface_get_bits_y_cb_cr;
+
+VdpOutputSurfacePutBitsYCbCr * vdp_output_surface_put_bits_y_cb_cr;
+VdpOutputSurfacePutBitsNative * vdp_output_surface_put_bits_native;
+
+VdpOutputSurfaceCreate * vdp_output_surface_create;
+VdpOutputSurfaceDestroy * vdp_output_surface_destroy;
+
+/* videoMixer puts videoSurface data to displayble ouputSurface. */
+VdpVideoMixerCreate * vdp_video_mixer_create;
+VdpVideoMixerSetFeatureEnables * vdp_video_mixer_set_feature_enables;
+VdpVideoMixerDestroy * vdp_video_mixer_destroy;
+VdpVideoMixerRender * vdp_video_mixer_render;
+
+VdpPresentationQueueTargetDestroy * vdp_presentation_queue_target_destroy;
+VdpPresentationQueueCreate * vdp_presentation_queue_create;
+VdpPresentationQueueDestroy * vdp_presentation_queue_destroy;
+VdpPresentationQueueDisplay * vdp_presentation_queue_display;
+VdpPresentationQueueBlockUntilSurfaceIdle * vdp_presentation_queue_block_until_surface_idle;
+VdpPresentationQueueTargetCreateX11 * vdp_presentation_queue_target_create_x11;
+VdpPresentationQueueQuerySurfaceStatus * vdp_presentation_queue_query_surface_status;
+
+VdpDecoderCreate * vdp_decoder_create;
+VdpDecoderDestroy * vdp_decoder_destroy;
+VdpDecoderRender * vdp_decoder_render;
+
+static VdpVideoSurface *videoSurfaces;
+static VdpOutputSurface outputSurfaces[NUM_OUTPUT_SURFACES];
+static VdpVideoSurface videoSurface;
+static VdpOutputSurface outputSurface;
+
+static VdpDecoder decoder;
+static VdpVideoMixer videoMixer;
+
+static VdpRect outRect;
+static VdpRect outRectVid;
+
+static vdpau_render_state_t * surface_render;
+int surfaceNum;
+static uint32_t vid_width, vid_height;
+static uint32_t image_format;
+static uint32_t num_video_surfaces;
+extern uint32_t num_reference_surfaces;
+
+/* X11 specific */
+static int visible_buf = -1;    // -1 means: no buffer was drawn yet
+
+static int flip_flag;
+
+static int int_pause;
+
+static Window mRoot;
+static uint32_t drwX, drwY, drwBorderWidth, drwDepth;
+static uint32_t max_width = 0, max_height = 0; // zero means: not set
+
+static void calc_drwXY_dWH(uint32_t *drwX, uint32_t *drwY, uint32_t *d_wh, uint32_t *d_ht) {
+  *drwX = *drwY = 0;
+  if (!vo_fs && (*d_wh > vo_screenwidth || *d_ht > vo_screenheight)) {
+    aspect(d_wh, d_ht, A_ZOOM);
+    *d_wh = FFMIN(*d_wh, vo_screenwidth);
+    *d_ht = FFMIN(*d_ht, vo_screenheight);
+    // this case, window is created at (0,0) position.
+    vo_dx = 0; //(vo_screenwidth - *d_wh) / 2;
+    vo_dy = 0; //(vo_screenheight - *d_ht) / 2;
+    *drwX = vo_dx;
+    *drwY = vo_dy;
+    mp_msg(MSGT_VO, MSGL_V, "[vdpau - when (w x h) > (sw x sh)] dx: %d dy: %d dw: %d dh: %d\n",
+           *drwX, *drwY, *d_wh, *d_ht);
+    return ;
+  }
+  if (vo_fs) {
+    aspect(&vo_dwidth, &vo_dheight, A_ZOOM);
+    vo_dwidth = FFMIN(vo_dwidth, vo_screenwidth);
+    vo_dheight = FFMIN(vo_dheight, vo_screenheight);
+    *drwX = (vo_screenwidth - vo_dwidth) / 2;
+    *drwY = (vo_screenheight - vo_dheight) / 2;
+    mp_msg(MSGT_VO, MSGL_V, "[vdpau-fs] dx: %d dy: %d dw: %d dh: %d\n",
+           *drwX, *drwY, vo_dwidth, vo_dheight);
+  } else if (WinID == 0) {
+    *drwX = vo_dx;
+    *drwY = vo_dy;
+  }
+}
+
+/* Initialize Get Proc Address, called from config() */
+static void win_x11_init_vdpau_procs(void)
+{
+    VdpStatus vdp_st;
+
+    // Create Device
+    vdp_st = vdp_device_create_x11(
+        mDisplay, //x_display,
+        mScreen, //x_screen,
+        &vdp_device,
+        &vdp_get_proc_address
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_DEVICE_DESTROY,
+        (void *)&vdp_device_destroy
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_VIDEO_SURFACE_CREATE,
+        (void *)&vdp_video_surface_create
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_VIDEO_SURFACE_DESTROY,
+        (void *)&vdp_video_surface_destroy
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_VIDEO_SURFACE_PUT_BITS_Y_CB_CR,
+        (void *)&vdp_video_surface_put_bits_y_cb_cr
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR,
+        (void *)&vdp_video_surface_get_bits_y_cb_cr
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_Y_CB_CR,
+        (void *)&vdp_output_surface_put_bits_y_cb_cr
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_NATIVE,
+        (void *)&vdp_output_surface_put_bits_native
+    );
+    CHECK_ST
+
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_OUTPUT_SURFACE_CREATE,
+        (void *)&vdp_output_surface_create
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_OUTPUT_SURFACE_DESTROY,
+        (void *)&vdp_output_surface_destroy
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_VIDEO_MIXER_CREATE,
+        (void *)&vdp_video_mixer_create
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_VIDEO_MIXER_SET_FEATURE_ENABLES,
+        (void *)&vdp_video_mixer_set_feature_enables
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_VIDEO_MIXER_DESTROY,
+        (void *)&vdp_video_mixer_destroy
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_VIDEO_MIXER_RENDER,
+        (void *)&vdp_video_mixer_render
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_DESTROY,
+        (void *)&vdp_presentation_queue_target_destroy
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_PRESENTATION_QUEUE_CREATE,
+        (void *)&vdp_presentation_queue_create
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_PRESENTATION_QUEUE_DESTROY,
+        (void *)&vdp_presentation_queue_destroy
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_PRESENTATION_QUEUE_DISPLAY,
+        (void *)&vdp_presentation_queue_display
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_PRESENTATION_QUEUE_BLOCK_UNTIL_SURFACE_IDLE,
+        (void *)&vdp_presentation_queue_block_until_surface_idle
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_CREATE_X11,
+        (void *)&vdp_presentation_queue_target_create_x11
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_DECODER_CREATE,
+        (void *)&vdp_decoder_create
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_DECODER_DESTROY,
+        (void *)&vdp_decoder_destroy
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_DECODER_RENDER,
+        (void *)&vdp_decoder_render
+    );
+    CHECK_ST
+
+    vdp_st = vdp_get_proc_address(
+        vdp_device,
+        VDP_FUNC_ID_PRESENTATION_QUEUE_QUERY_SURFACE_STATUS,
+        (void *)&vdp_presentation_queue_query_surface_status
+    );
+    CHECK_ST
+}
+
+/* Destroy vdpau procs, called from uninit() */
+static VdpStatus win_x11_fini_vdpau_procs(void)
+{
+    VdpStatus vdp_st;
+
+    vdp_st = vdp_device_destroy(
+        vdp_device
+    );
+    CHECK_ST
+
+    return VDP_STATUS_OK;
+}
+
+/* Initialize vdpau_flip_queue, called from config() */
+static void win_x11_init_vdpau_flip_queue(void)
+{   
+    VdpStatus vdp_st;
+
+    vdp_st = vdp_presentation_queue_target_create_x11(
+        vdp_device,
+        vo_window, //x_window,
+        &vdp_flip_target
+    );
+    CHECK_ST
+
+    vdp_st = vdp_presentation_queue_create(
+        vdp_device,
+        vdp_flip_target,
+        &vdp_flip_queue
+    );
+    CHECK_ST
+
+}
+
+/* Destroy vdpau_flip_queue, called from uninit() */
+static VdpStatus win_x11_fini_vdpau_flip_queue(void)
+{  
+    VdpStatus vdp_st;
+    
+    vdp_st = vdp_presentation_queue_destroy(
+        vdp_flip_queue
+    );
+    CHECK_ST
+         
+    vdp_st = vdp_presentation_queue_target_destroy(
+        vdp_flip_target
+    );
+    CHECK_ST
+
+    return VDP_STATUS_OK;
+}
+
+/*
+ * connect to X server, create and map window, Initialize all
+ * VDPAU objects, create differnt surfaces etc.
+ */
+static int config(uint32_t width, uint32_t height, uint32_t d_width,
+                       uint32_t d_height, uint32_t flags, char *title,
+                       uint32_t format)
+{
+    XVisualInfo vinfo;
+    XSetWindowAttributes xswa;
+    XWindowAttributes attribs;
+    unsigned long xswamask;
+    int depth;
+    VdpStatus vdp_st;
+    int i;
+    VdpDecoderProfile vdp_decoder_profile;
+    VdpChromaType vdp_chroma_type;
+
+#ifdef HAVE_XF86VM
+    int vm = 0;
+    unsigned int modeline_width, modeline_height;
+    static uint32_t vm_width;
+    static uint32_t vm_height;
+#endif
+
+    if (vo_config_count)
+    {
+        // FIXME: We should really check for matching parameters here,
+        // and uninit/re-config if they have changed? 
+        return 0;
+    }
+
+    image_format = format;
+
+    // FIXME: Are higher profiles able to decode all lower profile streams?
+    switch (format) {
+    case IMGFMT_VDPAU_MPEG1:
+        vdp_decoder_profile = VDP_DECODER_PROFILE_MPEG1;
+        vdp_chroma_type = VDP_CHROMA_TYPE_420;
+        num_video_surfaces = NUM_VIDEO_SURFACES_MPEG2;
+        break;
+    case IMGFMT_VDPAU_MPEG2_SIMPLE:
+        vdp_decoder_profile = VDP_DECODER_PROFILE_MPEG2_SIMPLE;
+        vdp_chroma_type = VDP_CHROMA_TYPE_420;
+        num_video_surfaces = NUM_VIDEO_SURFACES_MPEG2;
+        break;
+    case IMGFMT_VDPAU_MPEG2_MAIN:
+        vdp_decoder_profile = VDP_DECODER_PROFILE_MPEG2_MAIN;
+        vdp_chroma_type = VDP_CHROMA_TYPE_420;
+        num_video_surfaces = NUM_VIDEO_SURFACES_MPEG2;
+        break;
+    case IMGFMT_VDPAU_H264_BASELINE:
+        vdp_decoder_profile = VDP_DECODER_PROFILE_H264_BASELINE;
+        vdp_chroma_type = VDP_CHROMA_TYPE_420;
+        // Theoretically, "num_reference_surfaces+1" is correct.
+        // However, to work around invalid/corrupt streams,
+        // and/or ffmpeg DPB management issues,
+        // we allocate more than we should need to allow problematic
+        // streams to play.
+        //num_video_surfaces = num_reference_surfaces + 1;
+        num_video_surfaces = NUM_VIDEO_SURFACES_H264;
+        break;
+    case IMGFMT_VDPAU_H264_MAIN:
+        vdp_decoder_profile = VDP_DECODER_PROFILE_H264_MAIN;
+        vdp_chroma_type = VDP_CHROMA_TYPE_420;
+        // Theoretically, "num_reference_surfaces+1" is correct.
+        // However, to work around invalid/corrupt streams,
+        // and/or ffmpeg DPB management issues,
+        // we allocate more than we should need to allow problematic
+        // streams to play.
+        //num_video_surfaces = num_reference_surfaces + 1;
+        num_video_surfaces = NUM_VIDEO_SURFACES_H264;
+        break;
+    case IMGFMT_VDPAU_H264_HIGH:
+        vdp_decoder_profile = VDP_DECODER_PROFILE_H264_HIGH;
+        vdp_chroma_type = VDP_CHROMA_TYPE_420;
+        // Theoretically, "num_reference_surfaces+1" is correct.
+        // However, to work around invalid/corrupt streams,
+        // and/or ffmpeg DPB management issues,
+        // we allocate more than we should need to allow problematic
+        // streams to play.
+        //num_video_surfaces = num_reference_surfaces + 1;
+        num_video_surfaces = NUM_VIDEO_SURFACES_H264;
+        break;
+    case IMGFMT_VDPAU_VC1_SIMPLE:
+        vdp_decoder_profile = VDP_DECODER_PROFILE_VC1_SIMPLE;
+        vdp_chroma_type = VDP_CHROMA_TYPE_420;
+        num_video_surfaces = NUM_VIDEO_SURFACES_VC1;
+        break;
+    case IMGFMT_VDPAU_VC1_MAIN:
+        vdp_decoder_profile = VDP_DECODER_PROFILE_VC1_MAIN;
+        vdp_chroma_type = VDP_CHROMA_TYPE_420;
+        num_video_surfaces = NUM_VIDEO_SURFACES_VC1;
+        break;
+    case IMGFMT_VDPAU_VC1_ADVANCED:
+        vdp_decoder_profile = VDP_DECODER_PROFILE_VC1_ADVANCED;
+        vdp_chroma_type = VDP_CHROMA_TYPE_420;
+        num_video_surfaces = NUM_VIDEO_SURFACES_VC1;
+        break;
+
+    /* Non VDPAU specific formats.
+     * No HW acceleration. VdpDecoder will not be created and 
+     * there will be no call for VdpDecoderRender.
+     */
+    case IMGFMT_YV12:
+        vdp_chroma_type = VDP_CHROMA_TYPE_420;
+        num_video_surfaces = NUM_VIDEO_SURFACES_NON_ACCEL_YUV;
+        break;
+    case IMGFMT_BGRA:
+        // No need for videoSurfaces, directly renders to outputSurface.
+        num_video_surfaces = NUM_VIDEO_SURFACES_NON_ACCEL_RGB;
+        break;
+    default:
+        assert(0);
+        return 1;
+    }
+
+    vo_mouse_autohide = 1;
+    int_pause = 0;
+    visible_buf = -1;
+
+#ifdef HAVE_XF86VM
+    if (flags & VOFLAG_MODESWITCHING)
+        vm = 1;
+#endif
+
+    flip_flag = flags & VOFLAG_FLIPPING;
+
+    calc_drwXY_dWH(&drwX, &drwY, &d_width, &d_height);
+
+#ifdef HAVE_NEW_GUI
+    if (use_gui)
+        guiGetEvent(guiSetShVideo, 0);  // let the GUI to setup/resize our window
+    else
+#endif
+    {
+#ifdef HAVE_XF86VM
+        if (vm)
+        {
+            if ((d_width == 0) && (d_height == 0))
+            {
+                vm_width = width;
+                vm_height = height;
+            } else
+            {
+                vm_width = d_width;
+                vm_height = d_height;
+            }
+            vo_vm_switch(vm_width, vm_height, &modeline_width,
+                         &modeline_height);
+            aspect_save_screenres(modeline_width, modeline_height);
+        } else
+#endif
+        XGetWindowAttributes(mDisplay, DefaultRootWindow(mDisplay),
+                             &attribs);
+        depth = attribs.depth;
+        if (depth != 15 && depth != 16 && depth != 24 && depth != 32)
+            depth = 24;
+        XMatchVisualInfo(mDisplay, mScreen, depth, TrueColor, &vinfo);
+
+        xswa.background_pixel = 0;
+        xswa.border_pixel = 0;
+        xswamask = CWBackPixel | CWBorderPixel;
+
+        if (WinID >= 0)
+        {
+            vo_window = WinID ? ((Window) WinID) : mRootWin;
+            if (WinID)
+            {
+                XUnmapWindow(mDisplay, vo_window);
+                XChangeWindowAttributes(mDisplay, vo_window, xswamask,
+                                        &xswa);
+                vo_x11_selectinput_witherr(mDisplay, vo_window,
+                                           StructureNotifyMask |
+                                           KeyPressMask |
+                                           PropertyChangeMask |
+                                           PointerMotionMask |
+                                           ButtonPressMask |
+                                           ButtonReleaseMask |
+                                           ExposureMask);
+                XMapWindow(mDisplay, vo_window);
+                XGetGeometry(mDisplay, vo_window, &mRoot,
+                             &drwX, &drwY, &vo_dwidth, &vo_dheight,
+                             &drwBorderWidth, &drwDepth);
+                if (vo_dwidth <= 0) vo_dwidth = d_width;
+                if (vo_dheight <= 0) vo_dheight = d_height;
+                aspect_save_prescale(vo_dwidth, vo_dheight);
+            }
+        } else
+        {
+            vo_x11_create_vo_window(&vinfo, vo_dx, vo_dy, d_width, d_height,
+                   flags, CopyFromParent, "x11", title);
+            XChangeWindowAttributes(mDisplay, vo_window, xswamask, &xswa);
+        }
+
+        XSync(mDisplay, False);
+
+#ifdef HAVE_XF86VM
+        if (vm)
+        {
+            /* Grab the mouse pointer in our window */
+            if (vo_grabpointer)
+                XGrabPointer(mDisplay, vo_window, True, 0,
+                             GrabModeAsync, GrabModeAsync,
+                             vo_window, None, CurrentTime);
+            XSetInputFocus(mDisplay, vo_window, RevertToNone, CurrentTime);
+        }
+#endif
+    }
+
+    aspect(&vo_dwidth, &vo_dheight, A_NOZOOM);
+    if ((flags & VOFLAG_FULLSCREEN) && WinID <= 0) vo_fs = 1;
+
+    panscan_calc();
+
+    if (vo_ontop)
+        vo_x11_setlayer(mDisplay, vo_window, vo_ontop);
+  
+    /* -----VDPAU related code here -------- */
+    if (num_video_surfaces) {
+        videoSurfaces = (VdpVideoSurface *)malloc(sizeof(VdpVideoSurface)*num_video_surfaces);
+    } else {
+        videoSurfaces = NULL;
+    }
+ 
+    /* get proc address */ 
+    win_x11_init_vdpau_procs();
+    win_x11_init_vdpau_flip_queue();
+
+    // video width and height 
+    vid_width = width;
+    vid_height = height;
+
+    if (IMGFMT_IS_VDPAU(image_format)) {
+        vdp_st = vdp_decoder_create(
+            vdp_device,
+            vdp_decoder_profile,
+            vid_width,
+            vid_height,
+            &decoder
+        );
+        CHECK_ST
+    }
+
+    // Creation of VideoSurfaces
+    for (i = 0; i < num_video_surfaces; i++) {
+        vdp_st = vdp_video_surface_create(
+            vdp_device,
+            vdp_chroma_type,
+            vid_width,
+            vid_height,
+            &videoSurfaces[i]
+        );
+        CHECK_ST
+#if TRACE_SURFACES
+        printf("VID CREATE: %u\n", videoSurfaces[i]);
+#endif
+    }
+
+    if (num_video_surfaces) {
+        surface_render = malloc(num_video_surfaces*sizeof(vdpau_render_state_t));
+        memset(surface_render,0,num_video_surfaces*sizeof(vdpau_render_state_t));
+
+        for (i = 0; i < num_video_surfaces; i++) {
+            surface_render[i].state = 0; // surfaces are free.
+            surface_render[i].surface = videoSurfaces[i];
+        }
+
+        // Creation of VideoMixer.
+        VdpVideoMixerParameter parameters[] = {
+            VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH,
+            VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT,
+            VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE
+        };
+
+        void const * parameter_values[] = {
+            &vid_width,
+            &vid_height,
+            &vdp_chroma_type
+        };
+
+        vdp_st = vdp_video_mixer_create(
+            vdp_device,
+            0,
+            0,
+            ARSIZE(parameters),
+            parameters,
+            parameter_values,
+            &videoMixer
+        );
+        CHECK_ST
+    } else {
+        surface_render = NULL;
+    }
+
+    // Creation of outputSurfaces
+    for (i = 0; i < NUM_OUTPUT_SURFACES; i++) {
+        vdp_st = vdp_output_surface_create(
+            vdp_device,
+            VDP_RGBA_FORMAT_B8G8R8A8,
+            max_width,
+            max_height,
+            &outputSurfaces[i]
+        );
+        CHECK_ST
+#if TRACE_SURFACES
+        printf("OUT CREATE: %u\n", outputSurfaces[i]);
+#endif
+    }
+
+    surfaceNum = 0;
+    vo_directrendering = 1;
+
+    return 0;
+}
+
+static void check_events(void)
+{
+    int e = vo_x11_check_events(mDisplay);
+
+    if (e & VO_EVENT_RESIZE)
+    {
+        XGetGeometry(mDisplay, vo_window, &mRoot, &drwX, &drwY, &vo_dwidth,
+                     &vo_dheight, &drwBorderWidth, &drwDepth);
+        mp_msg(MSGT_VO, MSGL_V, "[vdpau] dx: %d dy: %d dw: %d dh: %d\n", drwX,
+               drwY, vo_dwidth, vo_dheight);
+
+        calc_drwXY_dWH(&drwX, &drwY, &vo_dwidth, &vo_dheight);
+    }
+
+    if (e & VO_EVENT_EXPOSE || e & VO_EVENT_RESIZE)
+    {
+        outRectVid.x0 = drwX-(vo_panscan_x>>1); //clipX
+        outRectVid.y0 = drwY-(vo_panscan_y>>1); //clipY
+        outRectVid.x1 = vo_dwidth+vo_panscan_x+outRectVid.x0; //clip width
+        outRectVid.y1 = vo_dheight+vo_panscan_y+outRectVid.y0; //clip height
+
+        if (vo_fs) {
+            outRect.x0 = 0;
+            outRect.x1 = vo_screenwidth;
+            outRect.y0 = 0;
+            outRect.y1 = vo_screenheight;
+        } else {
+            outRect = outRectVid;
+        }
+    }
+
+    if ((e & VO_EVENT_EXPOSE || e & VO_EVENT_RESIZE) && int_pause)
+    {
+        /* did we already draw a buffer */
+        if ( visible_buf != -1 )
+        {
+          /* redraw the last visible buffer */
+          VdpStatus vdp_st;
+          vdp_st = vdp_presentation_queue_display(
+              vdp_flip_queue,
+              outputSurface, // outputSurfaces[0 / 1],
+              outRect.x1,
+              outRect.y1,
+              0
+          );
+          CHECK_ST
+        }
+     
+    }
+}
+
+static void draw_osd(void)
+{
+#if TRACE_SURFACES
+    printf("DRAW_OSD\n");
+#endif
+
+   // Not implemented
+}
+
+static void flip_page(void)
+{
+    VdpStatus vdp_st;
+#if TRACE_SURFACES
+    printf("\nFLIP_PAGE VID:%u -> OUT:%u\n", videoSurface, outputSurface);
+#endif
+
+    vdp_st = vdp_presentation_queue_display(
+        vdp_flip_queue,
+        outputSurface,
+        outRect.x1,
+        outRect.y1,
+        0
+    );
+    CHECK_ST
+
+    surfaceNum = surfaceNum ^ 1;
+    visible_buf = 1;
+    return;
+}
+
+static uint32_t start_slice(mp_image_t * mpi)
+{
+    if (!IMGFMT_IS_VDPAU(image_format))
+        mpi->flags &= ~MP_IMGFLAG_DRAW_CALLBACK;
+    return VO_TRUE;
+}
+
+static int draw_slice(uint8_t * image[], int stride[], int w, int h,
+                           int x, int y)
+{
+    VdpStatus vdp_st;
+    vdpau_render_state_t * rndr;
+
+    rndr = (vdpau_render_state_t*)image[2]; // this is a copy of private
+    assert( rndr != NULL );
+    if (rndr == NULL)
+        return VO_ERROR;
+
+#if TRACE_SURFACES
+    printf("\nDRAW_SLICE -> VID:%u\n", rndr->surface);
+#endif
+
+    /* VdpDecoderRender is called with decoding order. Decoded images are store in
+     * videoSurface like rndr->surface. VdpVideoMixerRender put this videoSurface
+     * to outputSurface which is displayable.
+     */
+    vdp_st = vdp_decoder_render(
+        decoder,
+        rndr->surface,
+        (void*)&(rndr->info),
+        1,
+        &(rndr->bitstreamBuffer)
+    );
+    CHECK_ST
+
+    return VO_TRUE;
+}
+
+static int draw_frame(uint8_t * src[])
+{
+#if TRACE_SURFACES
+    printf("DRAW_FRAME\n");
+#endif
+
+    mp_msg(MSGT_VO,MSGL_INFO, MSGTR_LIBVO_XV_DrawFrameCalled);
+    return -1;
+}
+
+static uint32_t draw_image(mp_image_t * mpi)
+{
+    vdpau_render_state_t * rndr;
+    VdpStatus vdp_st;
+    VdpTime dummy;
+    VdpYCbCrFormat vdp_ycbcr_format;
+    VdpRGBAFormat vdp_rgba_format;
+    void *destdata[3];
+
+    // check for VDPAU surface format 
+    if (IMGFMT_IS_VDPAU(image_format)) {   
+        rndr = (vdpau_render_state_t*)mpi->planes[2]; // this is a copy of private
+        assert( rndr != NULL );
+        if (rndr == NULL)
+            return VO_ERROR;
+
+        videoSurface = rndr->surface;
+    }
+
+    // check for non-VDPAU and non RGB/YUV4:4:4 surface formats.
+    switch (image_format) {
+    case IMGFMT_YV12:
+        assert(mpi->num_planes == 3);
+        vdp_ycbcr_format = VDP_YCBCR_FORMAT_YV12;
+        destdata[0] = mpi->planes[0];
+        destdata[1] = mpi->planes[2];
+        destdata[2] = mpi->planes[1];
+        videoSurface = videoSurfaces[0];
+
+        vdp_st = vdp_video_surface_put_bits_y_cb_cr(
+            videoSurface,
+            vdp_ycbcr_format, // YV12
+            destdata,
+            mpi->stride // pitch
+        );
+        CHECK_ST
+        break;
+    default:
+        break;
+    }
+
+    outputSurface = outputSurfaces[surfaceNum];
+    vdp_st = vdp_presentation_queue_block_until_surface_idle(
+        vdp_flip_queue,
+        outputSurface,
+        &dummy
+    );
+    CHECK_ST
+
+    if (!num_video_surfaces) { // RGB surface formats
+        switch (image_format) {
+        case IMGFMT_BGRA:
+            assert(mpi->num_planes == 1);
+            vdp_rgba_format = VDP_RGBA_FORMAT_B8G8R8A8;
+            destdata[0] = mpi->planes[0];
+            break;
+        default:
+            assert(0);
+            return VO_ERROR;
+        }
+        vdp_st = vdp_output_surface_put_bits_native(
+            outputSurface,
+            destdata,
+            mpi->stride, // pitch
+            NULL // or &outRectVid ?? Not sure.
+        );
+        CHECK_ST
+    } else {
+        vdp_st = vdp_video_mixer_render(
+            videoMixer,
+            VDP_INVALID_HANDLE,
+            0,
+            VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
+            0,
+            NULL,
+            videoSurface,
+            0,
+            NULL,
+            NULL,
+            outputSurface,
+            &outRect,
+            &outRectVid,
+            0,
+            NULL
+        );
+        CHECK_ST
+    }
+
+#if TRACE_SURFACES
+    printf("\DRAW IMG:%u\n", videoSurface);
+#endif
+
+    return VO_TRUE;
+}
+
+static vdpau_render_state_t * find_free_surface()
+{
+    int i;
+
+    for (i = 0 ; i < num_video_surfaces; i++)
+    {
+        if (surface_render[i].state != MP_VDPAU_STATE_USED_FOR_REFERENCE) {
+            return &surface_render[i];
+        }
+    }
+
+    return NULL;
+}
+
+static uint32_t get_image(mp_image_t * mpi)
+{
+   vdpau_render_state_t * rndr;
+
+    if (!IMGFMT_IS_VDPAU(image_format)) {
+        return VO_FALSE; // buffer in system memory instead of video memory.
+    }
+
+   rndr = find_free_surface();
+
+   if(rndr == NULL){
+      printf("vo_vdpau: get_image failed\n");
+      return VO_FALSE;
+   }
+
+   mpi->flags |= MP_IMGFLAG_DIRECT;
+   mpi->stride[0] = 0;
+   mpi->stride[1] = 0;
+   mpi->stride[2] = 0;
+
+   /* mpi->plane[0] anf mpi->plane[1] should be NULL.
+    * Presently, I have made it as non-NULL otherwise we have
+    * to check for assert in libavcode and libmpcodecs.
+    *
+    * mpi->plane[2] is used as callback function for ffmpeg and
+    * video renderer i.e vo_vdpau.c
+    */
+   mpi->planes[0] = (char*)rndr;
+   mpi->planes[1] = (char*)rndr;
+   mpi->planes[2] = (char*)rndr;
+
+   rndr->state = 0;
+
+#if TRACE_SURFACES
+    {
+        vdpau_render_state_t * rndr;
+
+        rndr = (vdpau_render_state_t*)mpi->planes[2]; // this is a copy of private
+        assert( rndr != NULL );
+        if (rndr == NULL)
+            return VO_ERROR;
+
+        printf("GET_IMAGE -> VID:%u\n", rndr->surface);
+    }
+#endif
+
+   return VO_TRUE;
+}
+
+static int query_format(uint32_t format)
+{
+    /* Following surface format is supported by VDPAU.
+     * vd.c: mpcodecs_config_vo() queries supported surface
+     * format for VDPAU.
+     * Return flag/value describes driver-capabilities.
+     * (VFCAP_CSP_SUPPORTED | VFCAP_CSP_SUPPORTED_BY_HW | VFCAP_HWSCALE_UP | VFCAP_HWSCALE_DOWN
+     * are basic driver capabilities.)
+     */
+
+    switch (format) {
+    // non-VDPAU specific format. used in non-accelerated video.
+    case IMGFMT_YV12:
+    case IMGFMT_BGRA:
+    // VDPAU specific format. used in accelerated video.
+    case IMGFMT_VDPAU_MPEG1:
+    case IMGFMT_VDPAU_MPEG2_SIMPLE:
+    case IMGFMT_VDPAU_MPEG2_MAIN:
+    case IMGFMT_VDPAU_H264_BASELINE:
+    case IMGFMT_VDPAU_H264_MAIN:
+    case IMGFMT_VDPAU_H264_HIGH:
+    case IMGFMT_VDPAU_VC1_SIMPLE:
+    case IMGFMT_VDPAU_VC1_MAIN:
+    case IMGFMT_VDPAU_VC1_ADVANCED:
+        return VFCAP_CSP_SUPPORTED | VFCAP_CSP_SUPPORTED_BY_HW | VFCAP_HWSCALE_UP | VFCAP_HWSCALE_DOWN;
+    }
+
+    return 0;
+}
+
+static void DestroyVdpauObjects()
+{
+    int i;
+    VdpStatus vdp_st;
+
+    vdp_st = win_x11_fini_vdpau_flip_queue();
+    CHECK_ST
+
+    if (num_video_surfaces) {
+        vdp_st = vdp_video_mixer_destroy(
+            videoMixer
+        );
+        CHECK_ST
+    }
+
+    if (IMGFMT_IS_VDPAU(image_format)) {
+        vdp_st = vdp_decoder_destroy(
+            decoder
+        );
+        CHECK_ST
+    }
+
+    for (i = 0; i < NUM_OUTPUT_SURFACES; i++) {
+        vdp_st = vdp_output_surface_destroy(
+            outputSurfaces[i]
+        );
+        CHECK_ST
+    }
+
+    for (i = 0; i < num_video_surfaces; i++) {
+        vdp_st = vdp_video_surface_destroy(
+            videoSurfaces[i]
+        );
+        CHECK_ST
+    }
+
+    vdp_st = win_x11_fini_vdpau_procs();
+    CHECK_ST
+}
+
+static void uninit(void)
+{
+    if (!vo_config_count)
+        return;
+    visible_buf = -1;
+
+    /* Destroy all vdpau objects */
+    DestroyVdpauObjects();    
+
+    if (videoSurfaces) {
+        free(videoSurfaces);
+        videoSurfaces = NULL;
+    }
+
+    if (surface_render) {
+        free(surface_render);
+        surface_render = NULL;
+    }
+
+#ifdef HAVE_XF86VM
+    vo_vm_close(mDisplay);
+#endif
+    mp_input_rm_event_fd(ConnectionNumber(mDisplay));
+    vo_x11_uninit();
+}
+
+static int preinit(const char *arg)
+{
+    if (arg)
+    {
+        mp_msg(MSGT_VO, MSGL_ERR, "vo_x11: Unknown subdevice: %s\n", arg);
+        return ENOSYS;
+    }
+
+    if (!vo_init())
+        return -1;              // Can't open X11
+
+    max_width = vo_screenwidth;
+    max_height = vo_screenheight;
+
+    return 0;
+}
+
+static int control(uint32_t request, void *data, ...)
+{
+    switch (request)
+    {
+    case VOCTRL_PAUSE:
+        return (int_pause = 1);
+    case VOCTRL_RESUME:
+        return (int_pause = 0);
+    case VOCTRL_QUERY_FORMAT:
+        return query_format(*((uint32_t *)data));
+    case VOCTRL_GET_IMAGE:
+        return get_image(data);
+    case VOCTRL_DRAW_IMAGE:
+        return draw_image(data);
+    case VOCTRL_START_SLICE:
+        return start_slice(data);
+    case VOCTRL_GUISUPPORT:
+        return VO_TRUE;
+    case VOCTRL_FULLSCREEN:
+        vo_x11_fullscreen();
+    case VOCTRL_SET_EQUALIZER:
+        { 
+            va_list ap;
+            int value;
+
+            va_start(ap, data);
+            value = va_arg(ap, int);
+
+            va_end(ap);
+            return vo_x11_set_equalizer(data, value);
+        }
+    case VOCTRL_GET_EQUALIZER:
+        {
+            va_list ap;
+            int *value;
+
+            va_start(ap, data);
+            value = va_arg(ap, int *);
+
+            va_end(ap);
+            return vo_x11_get_equalizer(data, value);
+        }
+    case VOCTRL_ONTOP:
+        vo_x11_ontop();
+        return VO_TRUE;
+    case VOCTRL_UPDATE_SCREENINFO:
+        update_xinerama_info();
+        return VO_TRUE;
+    }
+
+    return VO_NOTIMPL;
+}
diff -Naur MPlayer-27942.15845-old/vdpau_render.h MPlayer-27942.15845-new/vdpau_render.h
--- MPlayer-27942.15845-old/vdpau_render.h	1969-12-31 16:00:00.000000000 -0800
+++ MPlayer-27942.15845-new/vdpau_render.h	2008-11-16 16:50:05.000000000 -0800
@@ -0,0 +1,30 @@
+#ifndef FFMPEG_VDPAU_RENDER_H
+#define FFMPEG_VDPAU_RENDER_H
+
+#include "vdpau/vdpau.h"
+#include "vdpau/vdpau_x11.h"
+
+//the surface is used for render.
+#define MP_VDPAU_STATE_USED_FOR_RENDER 1
+//the surface is needed for reference/prediction, codec manipulates this.
+#define MP_VDPAU_STATE_USED_FOR_REFERENCE 2
+
+#define MP_VDPAU_RENDER_MAGIC 0x1DC8E14B
+
+typedef struct {
+    int  magic;
+
+    VdpVideoSurface surface; //used as rendered surface, never changed.
+
+    int state; // Holds MP_VDPAU_STATE_* values
+
+    union _VdpPictureInfo {
+        VdpPictureInfoMPEG1Or2 mpeg;
+        VdpPictureInfoH264     h264;
+        VdpPictureInfoVC1       vc1;
+    } info;
+
+    VdpBitstreamBuffer bitstreamBuffer;
+} vdpau_render_state_t;
+
+#endif /* FFMPEG_VDPAU_RENDER_H */
