diff -Naur MPlayer-1.0pre8-old/codec-cfg.c MPlayer-1.0pre8-new/codec-cfg.c
--- MPlayer-1.0pre8-old/codec-cfg.c	2006-06-11 11:35:47.000000000 -0700
+++ MPlayer-1.0pre8-new/codec-cfg.c	2006-07-21 11:25:14.000000000 -0700
@@ -178,6 +178,7 @@
 		{"ZRMJPEGIT", IMGFMT_ZRMJPEGIT},
 		{"ZRMJPEGIB", IMGFMT_ZRMJPEGIB},
 
+		{"VLD_MPEG2",IMGFMT_XVMC_VLD_MPEG2},
 		{"IDCT_MPEG2",IMGFMT_XVMC_IDCT_MPEG2},
 		{"MOCO_MPEG2",IMGFMT_XVMC_MOCO_MPEG2},
 
diff -Naur MPlayer-1.0pre8-old/configure MPlayer-1.0pre8-new/configure
--- MPlayer-1.0pre8-old/configure	2006-06-11 11:35:47.000000000 -0700
+++ MPlayer-1.0pre8-new/configure	2006-07-21 11:25:14.000000000 -0700
@@ -422,7 +422,8 @@
   --with-xmmslibdir=DIR    libxmms.so.1 in DIR
   --with-cdparanoiaincdir=DIR  cdparanoia headers in DIR (*)
   --with-cdparanoialibdir=DIR  cdparanoia libraries (libcdda_*) in DIR (*)
-  --with-xvmclib=NAME      name of adapter-specific library (e.g. XvMCNVIDIA)
+  --with-xvmclib=NAME      name of adapter-specific library
+                           (e.g. XvMCNVIDIA/I810XvMC/viaXvMC/viaXvMCPro)
   --with-termcaplib=NAME   name of library with termcap functionality
                            name should be given without leading "lib"
                            checks for "termcap" and "tinfo"
@@ -1540,6 +1541,7 @@
 fi
 
 _prefix="/usr/local"
+_xvmclib=""
 
 # GOTCHA: the variables below defines the default behavior for autodetection
 # and have - unless stated otherwise - at least 2 states : yes no
@@ -3847,34 +3849,88 @@
 echores "$_xv"
 
 
-echocheck "XvMC"
-if test "$_x11" = yes && test "$_xv" = yes && test "$_xvmc" != no ; then
-  _xvmc=no
-  cat > $TMPC <<EOF
-#include <X11/Xlib.h>
+xvmc_check()
+{
+  if test "$_xvmcvld" = yes; then
+    _xvmcinc="vldXvMC.h"
+  else
+    _xvmcinc="XvMClib.h"
+  fi
+
+  echo "#include <X11/Xlib.h>
 #include <X11/extensions/Xvlib.h>
-#include <X11/extensions/XvMClib.h>
+#include <X11/extensions/$_xvmcinc>
 int main(void) { 
   (void) XvMCQueryExtension(0,0,0);
   (void) XvMCCreateContext(0,0,0,0,0,0,0);
-  return 0; }
-EOF
-  for _ld_tmp in $_xvmclib XvMCNVIDIA XvMCW I810XvMC ; do
-    cc_check $_inc_x11 -lXvMC -l$_ld_tmp $_ld_xv $_ld_x11 && _xvmc=yes && _xvmclib="$_ld_tmp" && break
-  done
-fi
-if test "$_xvmc" = yes ; then
+  return 0; }" > $TMPC
+
+  _success=0
+  cc_check $_inc_x11 -lXvMC -l$_xvmclib $_ld_xv $_ld_x11 && _success=1
+  return $_ok
+}
+
+# Note: here we try to determine what xvmc capability is available
+# if the xvmc wrapper is available then we link to that, also we
+# check whether we can include the vld (slice) level xvmc include file
+if test "$_x11" = yes && test "$_xv" = yes && test "$_xvmc" != no ; then
+  _xvmc=no
+
+# No explicit xvmc lib specified so try and find one
+  if test "$_xvmclib" = ""; then
+# Try with the xvmc wrapper+vld first
+    echocheck "XvMC (Wrapper+vld)"
+    _xvmclib="XvMCW"
+    _xvmcvld=yes
+    xvmc_check && _xvmc=yes
+    echores $_xvmc
+
+# Try with the xvmc wrapper
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC (Wrapper)"
+      _xvmcvld=no
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+
+# Try with the nvidia lib
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC (NVIDIA)"
+      _xvmclib="XvMCNVIDIA"
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+  else
+# check for specified xvmc lib
+    echocheck "XvMC vld+("$_xvmclib")"
+    _xvmcvld=yes
+    xvmc_check && _xvmc=yes
+    echores $_xvmc
+
+    if test "$_xvmc" = no ; then
+      echocheck "XvMC ("$_xvmclib")"
+      _xvmcvld=no
+      xvmc_check && _xvmc=yes
+      echores $_xvmc
+    fi
+  fi
+
+  if test "$_xvmc" = yes ; then
   _def_xvmc='#define HAVE_XVMC 1'
   _ld_xvmc="-lXvMC -l$_xvmclib"
   _vosrc="$_vosrc vo_xvmc.c"
   _vomodules="xvmc $_vomodules"
-  _res_comment="using $_xvmclib"
-else
-  _def_xvmc='#undef HAVE_XVMC'
+  else
   _novomodules="xvmc $_novomodules"
-fi
-echores "$_xvmc"
+    _def_xvmc='#undef HAVE_XVMC'
+  fi
 
+  if test "$_xvmcvld" = yes; then
+    _def_xvmc_vld='#define HAVE_XVMC_VLD 1'
+  else
+    _def_xvmc_vld='#undef HAVE_XVMC_VLD'
+  fi
+fi
 
 echocheck "Xinerama"
 if test "$_x11" = yes && test "$_xinerama" != no ; then
@@ -8221,6 +8277,7 @@
 $_def_x11
 $_def_xv
 $_def_xvmc
+$_def_xvmc_vld
 $_def_vm
 $_def_xf86keysym
 $_def_xinerama
diff -Naur MPlayer-1.0pre8-old/etc/codecs.conf MPlayer-1.0pre8-new/etc/codecs.conf
--- MPlayer-1.0pre8-old/etc/codecs.conf	2006-06-11 11:35:46.000000000 -0700
+++ MPlayer-1.0pre8-new/etc/codecs.conf	2006-07-21 11:25:14.000000000 -0700
@@ -124,6 +124,7 @@
   fourcc mx5p        ; MPEG IMX 625/50 (50 Mb/s)
   driver ffmpeg
   dll "mpegvideo_xvmc"
+  out VLD_MPEG2
   out IDCT_MPEG2
   out MOCO_MPEG2
 
diff -Naur MPlayer-1.0pre8-old/help/help_mp-en.h MPlayer-1.0pre8-new/help/help_mp-en.h
--- MPlayer-1.0pre8-old/help/help_mp-en.h	2006-06-11 11:35:45.000000000 -0700
+++ MPlayer-1.0pre8-new/help/help_mp-en.h	2006-07-21 11:25:14.000000000 -0700
@@ -1524,6 +1524,7 @@
 #define MSGTR_MPCODECS_DRIFailure "[VD_FFMPEG] DRI failure.\n"
 #define MSGTR_MPCODECS_CouldntAllocateImageForCodec "[VD_FFMPEG] Couldn't allocate image for codec.\n"
 #define MSGTR_MPCODECS_XVMCAcceleratedMPEG2 "[VD_FFMPEG] XVMC-accelerated MPEG-2.\n"
+#define MSGTR_MPCODECS_XVMCVLDAcceleratedMPEG2 "[VD_FFMPEG] XVMC-VLD-accelerated MPEG-2.\n"
 #define MSGTR_MPCODECS_TryingPixfmt "[VD_FFMPEG] Trying pixfmt=%d.\n"
 #define MSGTR_MPCODECS_McGetBufferShouldWorkOnlyWithXVMC "[VD_FFMPEG] The mc_get_buffer should work only with XVMC acceleration!!"
 #define MSGTR_MPCODECS_UnexpectedInitVoError "[VD_FFMPEG] Unexpected init_vo error.\n"
diff -Naur MPlayer-1.0pre8-old/libavutil/avutil.h MPlayer-1.0pre8-new/libavutil/avutil.h
--- MPlayer-1.0pre8-old/libavutil/avutil.h	2006-06-11 11:35:47.000000000 -0700
+++ MPlayer-1.0pre8-new/libavutil/avutil.h	2006-07-21 11:34:02.000000000 -0700
@@ -70,6 +70,7 @@
     PIX_FMT_UYVY422,   ///< Packed pixel, Cb Y0 Cr Y1
     PIX_FMT_UYVY411,   ///< Packed pixel, Cb Y0 Y1 Cr Y2 Y3
     PIX_FMT_NB,
+    PIX_FMT_XVMC_MPEG2_VLD,
 };
 
 #ifdef __cplusplus
diff -Naur MPlayer-1.0pre8-old/libmpcodecs/img_format.c MPlayer-1.0pre8-new/libmpcodecs/img_format.c
--- MPlayer-1.0pre8-old/libmpcodecs/img_format.c	2006-06-11 11:35:41.000000000 -0700
+++ MPlayer-1.0pre8-new/libmpcodecs/img_format.c	2006-07-21 11:25:14.000000000 -0700
@@ -65,6 +65,7 @@
 	case IMGFMT_ZRMJPEGIB: return("Zoran MJPEG bottom field first");
 	case IMGFMT_XVMC_MOCO_MPEG2: return("MPEG1/2 Motion Compensation");
 	case IMGFMT_XVMC_IDCT_MPEG2: return("MPEG1/2 Motion Compensation and IDCT");
+	case IMGFMT_XVMC_VLD_MPEG2: return("MPEG1/2 Motion Compensation and VLD");
     }
     return("Unknown");
 }
diff -Naur MPlayer-1.0pre8-old/libmpcodecs/img_format.h MPlayer-1.0pre8-new/libmpcodecs/img_format.h
--- MPlayer-1.0pre8-old/libmpcodecs/img_format.h	2006-06-11 11:35:41.000000000 -0700
+++ MPlayer-1.0pre8-new/libmpcodecs/img_format.h	2006-07-21 11:25:14.000000000 -0700
@@ -106,6 +106,7 @@
 //these are chroma420
 #define IMGFMT_XVMC_MOCO_MPEG2 (IMGFMT_XVMC|0x02)
 #define IMGFMT_XVMC_IDCT_MPEG2 (IMGFMT_XVMC|0x82)
+#define IMGFMT_XVMC_VLD_MPEG2 (IMGFMT_XVMC|0x42)
 
 typedef struct {
     void* data;
diff -Naur MPlayer-1.0pre8-old/libmpcodecs/vd_ffmpeg.c MPlayer-1.0pre8-new/libmpcodecs/vd_ffmpeg.c
--- MPlayer-1.0pre8-old/libmpcodecs/vd_ffmpeg.c	2006-06-11 11:35:41.000000000 -0700
+++ MPlayer-1.0pre8-new/libmpcodecs/vd_ffmpeg.c	2006-07-21 11:25:14.000000000 -0700
@@ -10,6 +10,7 @@
 #include "bswap.h"
 
 #include "vd_internal.h"
+#include "libvo/video_out.h"
 
 static vd_info_t info = {
 	"FFmpeg's libavcodec codec family",
@@ -181,6 +182,8 @@
         case IMGFMT_XVMC_IDCT_MPEG2:
         case IMGFMT_XVMC_MOCO_MPEG2:
             if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_IDCT) return CONTROL_TRUE;
+        case IMGFMT_XVMC_VLD_MPEG2:
+            if(avctx->pix_fmt==PIX_FMT_XVMC_MPEG2_VLD) return CONTROL_TRUE;
 #endif
 	}
         return CONTROL_FALSE;
@@ -201,6 +204,9 @@
 #if LIBAVCODEC_BUILD >= 4722
     int lowres_w=0;
 #endif
+#ifdef HAVE_XVMC
+    char *voname = 0;
+#endif
     int do_vis_debug= lavc_param_vismv || (lavc_param_debug&(FF_DEBUG_VIS_MB_TYPE|FF_DEBUG_VIS_QP));
 
     if(!avcodec_inited){
@@ -243,11 +249,23 @@
 
 #ifdef HAVE_XVMC
 
+    // Try and get the name of the selected vo system
+    // so that if its _not_ xvmc we can fail gracefully
+    // and mplayer can fall back to a sw decoder
+    if (sh->video_out) {
+      vo_info_t *voinfo;
+      vo_functions_t * shvoc=sh->video_out;
+      if (shvoc) {
+        voinfo = shvoc->info;
+        if (voinfo) voname=voinfo->short_name;
+      }
+    }
 #ifdef CODEC_CAP_HWACCEL
-    if(lavc_codec->capabilities & CODEC_CAP_HWACCEL){
+    if((lavc_codec->capabilities & CODEC_CAP_HWACCEL) &&
 #else
-    if(lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC){
+    if((lavc_codec->id == CODEC_ID_MPEG2VIDEO_XVMC) &&
 #endif
+        voname && !strcmp(voname,"xvmc") ) {
         mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCAcceleratedCodec);
         assert(ctx->do_dr1);//these are must to!
         assert(ctx->do_slices); //it is (vo_)ffmpeg bug if this fails
@@ -556,6 +574,7 @@
 #ifdef HAVE_XVMC
         case PIX_FMT_XVMC_MPEG2_MC:ctx->best_csp=IMGFMT_XVMC_MOCO_MPEG2;break;
         case PIX_FMT_XVMC_MPEG2_IDCT:ctx->best_csp=IMGFMT_XVMC_IDCT_MPEG2;break;
+        case PIX_FMT_XVMC_MPEG2_VLD:ctx->best_csp=IMGFMT_XVMC_VLD_MPEG2;break;
 #endif
 	default:
 	    ctx->best_csp=0;
@@ -959,7 +978,11 @@
         avctx->get_buffer= mc_get_buffer;
         avctx->release_buffer= mc_release_buffer;
         avctx->draw_horiz_band = mc_render_slice;
+        if (avctx->xvmc_acceleration != 4)
         mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCAcceleratedMPEG2);
+        else
+            mp_msg(MSGT_DECVIDEO, MSGL_INFO, MSGTR_MPCODECS_XVMCVLDAcceleratedMPEG2);
+
         assert(ctx->do_dr1);//these are must to!
         assert(ctx->do_slices); //it is (vo_)ffmpeg bug if this fails
         avctx->flags|= CODEC_FLAG_EMU_EDGE;//do i need that??!!
diff -Naur MPlayer-1.0pre8-old/libvo/vo_xvmc.c MPlayer-1.0pre8-new/libvo/vo_xvmc.c
--- MPlayer-1.0pre8-old/libvo/vo_xvmc.c	2006-06-11 11:35:43.000000000 -0700
+++ MPlayer-1.0pre8-new/libvo/vo_xvmc.c	2006-07-21 11:25:14.000000000 -0700
@@ -24,6 +24,10 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
+
 #include "x11_common.h"
 #include "xvmc_render.h"
 
@@ -44,13 +48,16 @@
 
 
 #define UNUSED(x) ((void)(x))
-
+extern unsigned int video_format; 
 
 static int benchmark;
 static int use_sleep;
 static int first_frame;//draw colorkey on first frame
 static int use_queue;
 static int xv_port_request = 0;
+static int use_deint_bob; /* non-zero if we're doing bob de-interlacing */
+static int use_deint_one; /* non-zero if we're doing one field de-interlacing */
+static int use_tv_clip;   /* non-zero if we're clipping the top couple of lines */
 
 static int image_width,image_height;
 static uint32_t  drwX,drwY;
@@ -113,7 +120,7 @@
   "XVideo Motion Compensation",
   "xvmc",
   "Ivan Kalvachev <iive@users.sf.net>",
-  ""
+  "Ivor Hewitt <ivor@ivor.org> - VIA VLD support"
 };
 
 LIBVO_EXTERN(xvmc);
@@ -186,7 +193,23 @@
 }
 //end of vo_xv shm/xvimage code
 
+int hasVLDAcceleration()
+{
+#ifdef HAVE_XVMC_VLD
+    return XVMC_VLD == (surface_info.mc_type & XVMC_VLD);
+#else
+    return 0;
+#endif
+}            
+
 static int xvmc_check_surface_format(uint32_t format, XvMCSurfaceInfo * surf_info){
+#ifdef HAVE_XVMC_VLD
+    if (format == IMGFMT_XVMC_VLD_MPEG2 ){
+        if( surf_info->mc_type != (XVMC_VLD|XVMC_MPEG_2) ) return -1;
+        if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
+        return 0;
+    }
+#endif
    if ( format == IMGFMT_XVMC_IDCT_MPEG2 ){ 
       if( surf_info->mc_type != (XVMC_IDCT|XVMC_MPEG_2) ) return -1;
       if( surf_info->chroma_format != XVMC_CHROMA_FORMAT_420 ) return -1;
@@ -363,9 +386,17 @@
   {  "benchmark", OPT_ARG_BOOL, &benchmark,       NULL },
   {  "sleep",     OPT_ARG_BOOL, &use_sleep,       NULL },
   {  "queue",     OPT_ARG_BOOL, &use_queue,       NULL },
+  {  "deint-bob", OPT_ARG_BOOL, &use_deint_bob,   NULL },
+  {  "deint-one", OPT_ARG_BOOL, &use_deint_one,   NULL },
+  {  "tv-clip",   OPT_ARG_BOOL, &use_tv_clip,   NULL },  
   {  NULL }
 };
 
+   // If the video is not MPEG1 or MPEG2, we can't decode it, so
+   // fail cleanly to allow mplayer to fallback to another vo system
+   if (video_format != 0x10000001 && video_format != 0x10000002) return -1;
+
+
    //Obtain display handler
    if (!vo_init()) return -1;//vo_xv
 
@@ -400,6 +431,9 @@
    benchmark = 0; //disable PutImageto allow faster display than screen refresh
    use_sleep = 0;
    use_queue = 0;
+   use_deint_bob = 0;
+   use_deint_one = 0;
+   use_tv_clip = 0;
 
    /* parse suboptions */
    if ( subopt_parse( arg, subopts ) != 0 )
@@ -471,6 +505,8 @@
    if(surface_info.chroma_format == XVMC_CHROMA_FORMAT_444)
       blocks_per_macroblock = 12;
 
+if (!hasVLDAcceleration())
+{
    rez = XvMCCreateBlocks(mDisplay,&ctx,numblocks*blocks_per_macroblock,&data_blocks);
    if( rez != Success ){
       XvMCDestroyContext(mDisplay,&ctx);
@@ -486,6 +522,8 @@
    }
    printf("vo_xvmc: mv_blocks allocated\n");
 
+}
+
    if(surface_render==NULL)
       surface_render=malloc(MAX_SURFACES*sizeof(xvmc_render_state_t));//easy mem debug
    memset(surface_render,0,MAX_SURFACES*sizeof(xvmc_render_state_t));
@@ -504,6 +542,11 @@
       surface_render[i].chroma_format = surface_info.chroma_format;
       surface_render[i].unsigned_intra = (surface_info.flags & XVMC_INTRA_UNSIGNED) == XVMC_INTRA_UNSIGNED;
       surface_render[i].p_surface = &surface_array[i];
+
+      surface_render[i].state = 0;
+      surface_render[i].disp = mDisplay;
+      surface_render[i].ctx = &ctx;
+
       if( mp_msg_test(MSGT_VO,MSGL_DBG4) )
           printf("vo_xvmc: surface[%d] = %p .rndr=%p\n",i,&surface_array[i], &surface_render[i]);
    }
@@ -580,8 +623,10 @@
          printf("vo_xvmc: OSD support by additional frontend rendering\n");
          break;
       case BACKEND_SUBPICTURE:
-         printf("vo_xvmc: OSD support by beckend rendering (fast)\n");
-         printf("vo_xvmc: Pleace send feedback to configrm that it work,otherwise send bugreport!\n");
+         printf("vo_xvmc: OSD support by backend rendering "
+		"(fast, but untested with mplayer.)\n");
+         printf("vo_xvmc: Pleace send feedback to confirm that OSD works.\n"
+		"Otherwise, please send a bugreport!\n");
          break;
    }
 
@@ -1011,8 +1056,9 @@
 }
 
 static void put_xvmc_image(xvmc_render_state_t * p_render_surface, int draw_ck){
-int rez;
+int rez,field;
 int clipX,clipY,clipW,clipH;
+int srcY=0,srcH=image_height;
 
    if(p_render_surface == NULL)
       return;
@@ -1028,11 +1074,51 @@
    if(benchmark)
       return;
 
+   if (use_tv_clip) {
+    /*
+     Clip top few lines off to get rid of annoying flicker
+     when using bob de-interlacing on TV sourced video.
+    */
+     srcY+=4;
+     srcH-=4;
+   }
+   
+   if (use_deint_bob || use_deint_one) {
+  /*
+   Passing  XVMC_TOP_FIELD then XVMC_BOTTOM_FIELD turns on
+   bob de-interlacing in the unichrome driver. Just passing
+   XVMC_TOP_FIELD through just does 1 field de-interlacing.
+  */
+     field=p_render_surface->flags ? XVMC_TOP_FIELD : XVMC_BOTTOM_FIELD;
+   }
+   else field=XVMC_FRAME_PICTURE; /* no de-interlacing */
+      
    rez = XvMCPutSurface(mDisplay, p_render_surface->p_surface, 
                         vo_window,
-                        0, 0, image_width, image_height,
+                        0, srcY, image_width, srcH,
                         clipX, clipY, clipW, clipH,
-                        3);//p_render_surface_to_show->display_flags);
+                        field);
+
+   if (use_deint_bob && rez == Success) {
+ /*
+   Pause before we do the next putsurface - I guess this is to
+   allow the hardware to complete whatever it needs to do before
+   we hit it with more data, and cause something to spin on a lock
+   Adding this reduces CPU usage from about 20% to 10% on a 1GHz CPU.
+   Xine actually does this:
+     unsigned  ms_per_field = 500 * frame->vo_frame.duration / 90000 - 2;
+   I can't see how to get frame duration in mplayer, so we use an
+   abitrary pause of 10ms - seems to work ok.
+ */
+     usleep(10*1000);
+     rez = XvMCPutSurface(mDisplay, p_render_surface->p_surface, 
+                          vo_window,
+                          0,srcY,image_width,srcH,
+                          clipX, clipY, clipW, clipH,
+                          (field & XVMC_TOP_FIELD) ? XVMC_BOTTOM_FIELD : XVMC_TOP_FIELD);
+   }
+   
+
    if(rez != Success){
       printf("vo_xvmc: PutSurface failer, critical error %d!\n",rez);
       assert(0);
@@ -1136,9 +1222,11 @@
 
    if( number_of_surfaces ){
 
+      if (!hasVLDAcceleration())
+      {
       XvMCDestroyMacroBlocks(mDisplay,&mv_blocks);
       XvMCDestroyBlocks(mDisplay,&data_blocks);
-
+      }
       for(i=0; i<number_of_surfaces; i++)
       {
          XvMCHideSurface(mDisplay,&surface_array[i]);//it doesn't hurt, I hope
@@ -1172,7 +1260,13 @@
 static void uninit(void){
    if( mp_msg_test(MSGT_VO,MSGL_DBG4) ) {
       printf("vo_xvmc: uninit called\n"); }
-   xvmc_free();
+   //
+   // This function can be called as part of a signal handler, and
+   // calling xvmc_free() thus may result in a deadlock.
+   // Don't do it this way. 
+   // The xvmc subsystem should take care of this anyway.
+   //
+   // xvmc_free();
  //from vo_xv
 #ifdef HAVE_XF86VM
    vo_vm_close(mDisplay);
@@ -1216,6 +1310,17 @@
    assert( rndr != NULL );
    assert( rndr->magic == MP_XVMC_RENDER_MAGIC );
 
+   if (hasVLDAcceleration())
+   {
+        rez = XvMCPutSlice2(mDisplay,&ctx,(char*)rndr->slice_data,
+                            rndr->slice_datalen,
+                            rndr->slice_code);
+        if (rez)
+           printf("vo_xxmc::slice Error %d\n",rez);
+
+   }
+   else
+   {
    rez = XvMCRenderSurface(mDisplay,&ctx,rndr->picture_structure,
              		   rndr->p_surface,
                            rndr->p_past_surface,
@@ -1227,7 +1332,7 @@
    if(rez != Success)
    {
    int i;
-      printf("vo_xvmc::slice: RenderSirface returned %d\n",rez);
+      printf("vo_xvmc::slice: RenderSurface returned %d\n",rez);
 
       printf("vo_xvmc::slice: pict=%d,flags=%x,start_blocks=%d,num_blocks=%d\n",
              rndr->picture_structure,rndr->flags,rndr->start_mv_blocks_num,
@@ -1255,6 +1360,7 @@
    rez = XvMCFlushSurface(mDisplay, rndr->p_surface);
    assert(rez==Success);
 
+}
 //   rndr->start_mv_blocks_num += rndr->filled_mv_blocks_num;
    rndr->start_mv_blocks_num = 0;
    rndr->filled_mv_blocks_num = 0;
@@ -1347,8 +1453,16 @@
 
 // these are shared!! so watch out
 // do call RenderSurface before overwriting
+if (!hasVLDAcceleration())
+{
    mpi->planes[0] = (char*)data_blocks.blocks;   
    mpi->planes[1] = (char*)mv_blocks.macro_blocks;
+}
+else
+{
+   mpi->planes[0] = 1;
+   mpi->planes[1] = 0;
+}
    mpi->priv =
    mpi->planes[2] = (char*)rndr;
 
diff -Naur MPlayer-1.0pre8-old/Makefile MPlayer-1.0pre8-new/Makefile
--- MPlayer-1.0pre8-old/Makefile	2006-06-11 11:35:47.000000000 -0700
+++ MPlayer-1.0pre8-new/Makefile	2006-07-21 11:25:14.000000000 -0700
@@ -205,7 +205,9 @@
 ifeq ($(TREMOR),yes)
 PARTS += tremor
 endif
-
+ifeq ($(HAVE_XVMC_ACCEL),yes)
+CODEC_LIBS += $(X_LIB)
+endif
 ALL_PRG = $(PRG)
 ifeq ($(MENCODER),yes)
 ALL_PRG += $(PRG_MENCODER)
diff -Naur MPlayer-1.0pre8-old/mplayer.c MPlayer-1.0pre8-new/mplayer.c
--- MPlayer-1.0pre8-old/mplayer.c	2006-06-11 11:35:47.000000000 -0700
+++ MPlayer-1.0pre8-new/mplayer.c	2006-07-21 11:25:14.000000000 -0700
@@ -92,6 +92,8 @@
 extern int verbose;
 int quiet=0;
 
+unsigned int video_format=0;
+
 #ifdef WIN32
 char * proc_priority=NULL;
 #endif
@@ -3375,6 +3377,11 @@
 
 vo_config_count=0;
 //if((video_out->preinit(vo_subdevice))!=0){
+
+// let the video driver know what format the video is in so it can
+// reject it if it wants - lets vo_xvmc fail if ffmpeg12mc codec not used
+video_format=sh_video->format; 
+
 if(!(video_out=init_best_video_out(video_driver_list))){
     mp_msg(MSGT_CPLAYER,MSGL_FATAL,MSGTR_ErrorInitializingVODevice);
     goto goto_next_file; // exit_player(MSGTR_Exit_error);
diff -Naur MPlayer-1.0pre8-old/vidix/drivers/radeon_vid.c MPlayer-1.0pre8-new/vidix/drivers/radeon_vid.c
--- MPlayer-1.0pre8-old/vidix/drivers/radeon_vid.c	2006-06-11 11:35:43.000000000 -0700
+++ MPlayer-1.0pre8-new/vidix/drivers/radeon_vid.c	2006-07-21 11:25:14.000000000 -0700
@@ -905,7 +905,7 @@
  DEVICE_ATI_RADEON_R300_AF,
  DEVICE_ATI_RADEON_RV350_AP,
  DEVICE_ATI_RADEON_RV350_AR,
- DEVICE_ATI_RADEON_RV350_BK,
+// DEVICE_ATI_RADEON_RV350_BK,
  DEVICE_ATI_RADEON_R350_AH,
  DEVICE_ATI_RADEON_R350_AI,
  DEVICE_ATI_RADEON_R350_NH,
diff -Naur MPlayer-1.0pre8-old/xvmc_render.h MPlayer-1.0pre8-new/xvmc_render.h
--- MPlayer-1.0pre8-old/xvmc_render.h	2006-06-11 11:35:47.000000000 -0700
+++ MPlayer-1.0pre8-new/xvmc_render.h	2006-07-21 11:25:14.000000000 -0700
@@ -5,6 +5,9 @@
 #include <X11/extensions/Xvlib.h>
 #include <X11/extensions/XvMClib.h>
 
+#ifdef HAVE_XVMC_VLD
+#include <X11/extensions/vldXvMC.h>
+#endif
 
 //the surface should be shown, video driver manipulate this
 #define MP_XVMC_STATE_DISPLAY_PENDING 1
@@ -27,7 +30,20 @@
   int idct;//does we use IDCT acceleration?
   int chroma_format;//420,422,444
   int unsigned_intra;//+-128 for intra pictures after clip
+
+#ifdef HAVE_XVMC_VLD
+  int reserved1[3];
+  // These are for the XVMC VLD slice interface
+  int pict_type; //this is for skipping frames
+  int   slice_code; 
+  int   slice_datalen;
+  unsigned char *slice_data;
+  Display *disp;
+  XvMCContext *ctx;
+#else
   int reserved1[12];//future extenstions (e.g. gmc,qpel)
+#endif
+  
   void * p_osd_target_surface_render;//pointer to the surface where subpicture is rendered
   XvMCSurface* p_surface;//pointer to rendered surface, never changed
 
@@ -47,4 +63,6 @@
   
   int next_free_data_block_num;//used in add_mv_block, pointer to next free block
 
+
+
 } xvmc_render_state_t;
